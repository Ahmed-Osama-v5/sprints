
FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000078e6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000aa  00800060  000078e6  0000797a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006eb  0080010a  0080010a  00007a24  2**0
                  ALLOC
  3 .debug_aranges 00000720  00000000  00000000  00007a24  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000e6a  00000000  00000000  00008144  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000055f8  00000000  00000000  00008fae  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001384  00000000  00000000  0000e5a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000078be  00000000  00000000  0000f92a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000c00  00000000  00000000  000171e8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000259d  00000000  00000000  00017de8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_macinfo 00061db1  00000000  00000000  0001a385  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000690  00000000  00000000  0007c136  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 a6 32 	jmp	0x654c	; 0x654c <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 e7 09 	jmp	0x13ce	; 0x13ce <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 6b 32 	jmp	0x64d6	; 0x64d6 <__vector_9>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 31 32 	jmp	0x6462	; 0x6462 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 52 2e 	jmp	0x5ca4	; 0x5ca4 <__vector_13>
      38:	0c 94 ec 2d 	jmp	0x5bd8	; 0x5bd8 <__vector_14>
      3c:	0c 94 1f 2e 	jmp	0x5c3e	; 0x5c3e <__vector_15>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 ee       	ldi	r30, 0xE6	; 230
      68:	f8 e7       	ldi	r31, 0x78	; 120
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	aa 30       	cpi	r26, 0x0A	; 10
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	aa e0       	ldi	r26, 0x0A	; 10
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 3f       	cpi	r26, 0xF5	; 245
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 f7 3b 	call	0x77ee	; 0x77ee <main>
      8a:	0c 94 71 3c 	jmp	0x78e2	; 0x78e2 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <SOS_Timer_OV_cbk>:
 *Description: This function excute the Interrupt service routine for timer 0 overflow .
 *check for gu8_MS_Counter and gu16_SysTickCounter overflow issues
 */

static void SOS_Timer_OV_cbk(void)
{
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
	static uint8 gu8_MS_Counter = SOS_UNINTIALIZED;
	gu8_MS_Counter++;
      9a:	80 91 0a 01 	lds	r24, 0x010A
      9e:	8f 5f       	subi	r24, 0xFF	; 255
      a0:	80 93 0a 01 	sts	0x010A, r24
	if (gu8_MS_Counter == str_SOS_Init_Cfg.Sos_Sys_Tick)
      a4:	90 91 bc 00 	lds	r25, 0x00BC
      a8:	80 91 0a 01 	lds	r24, 0x010A
      ac:	98 17       	cp	r25, r24
      ae:	71 f4       	brne	.+28     	; 0xcc <SOS_Timer_OV_cbk+0x3a>
	{
		gu8_MS_Counter = SOS_UNINTIALIZED;
      b0:	10 92 0a 01 	sts	0x010A, r1
		gu8_Flag = TRUE;
      b4:	81 e0       	ldi	r24, 0x01	; 1
      b6:	80 93 0b 01 	sts	0x010B, r24
		gu16_SysTickCounter++;
      ba:	80 91 0e 01 	lds	r24, 0x010E
      be:	90 91 0f 01 	lds	r25, 0x010F
      c2:	01 96       	adiw	r24, 0x01	; 1
      c4:	90 93 0f 01 	sts	0x010F, r25
      c8:	80 93 0e 01 	sts	0x010E, r24
	}
}
      cc:	cf 91       	pop	r28
      ce:	df 91       	pop	r29
      d0:	08 95       	ret

000000d2 <SOS_Init>:
/* Return: The error status of the function.													*/
/* Description: Initiates the module.															*/
/************************************************************************************************/

SOS_ERROR_STATUS SOS_Init(void)
{
      d2:	df 93       	push	r29
      d4:	cf 93       	push	r28
      d6:	cd b7       	in	r28, 0x3d	; 61
      d8:	de b7       	in	r29, 0x3e	; 62
      da:	28 97       	sbiw	r28, 0x08	; 8
      dc:	0f b6       	in	r0, 0x3f	; 63
      de:	f8 94       	cli
      e0:	de bf       	out	0x3e, r29	; 62
      e2:	0f be       	out	0x3f, r0	; 63
      e4:	cd bf       	out	0x3d, r28	; 61
	uint8 u8_counter;
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = SOS_BASE_ERROR + ERR_SUCCESS;
      e6:	8c e9       	ldi	r24, 0x9C	; 156
      e8:	89 83       	std	Y+1, r24	; 0x01
	/*
	 * timer intialization
	 */
	Timer_cfg_s timeMS =
	{ str_SOS_Init_Cfg.Timer_CH_NO, TIMER_MODE, TIMER_PRESCALER_64,
	TIMER_INTERRUPT_MODE, SOS_Timer_OV_cbk };
      ea:	80 91 bb 00 	lds	r24, 0x00BB
      ee:	8b 83       	std	Y+3, r24	; 0x03
      f0:	1c 82       	std	Y+4, r1	; 0x04
      f2:	84 e0       	ldi	r24, 0x04	; 4
      f4:	8d 83       	std	Y+5, r24	; 0x05
      f6:	81 e0       	ldi	r24, 0x01	; 1
      f8:	8e 83       	std	Y+6, r24	; 0x06
      fa:	89 e4       	ldi	r24, 0x49	; 73
      fc:	90 e0       	ldi	r25, 0x00	; 0
      fe:	98 87       	std	Y+8, r25	; 0x08
     100:	8f 83       	std	Y+7, r24	; 0x07
	s8_ErrorStatus = Timer_Init(&timeMS);
     102:	ce 01       	movw	r24, r28
     104:	03 96       	adiw	r24, 0x03	; 3
     106:	0e 94 85 2e 	call	0x5d0a	; 0x5d0a <Timer_Init>
     10a:	89 83       	std	Y+1, r24	; 0x01

	if (s8_ErrorStatus == TIMER_BASE_ERROR + ERR_SUCCESS)
     10c:	89 81       	ldd	r24, Y+1	; 0x01
     10e:	82 3e       	cpi	r24, 0xE2	; 226
     110:	09 f0       	breq	.+2      	; 0x114 <SOS_Init+0x42>
     112:	40 c0       	rjmp	.+128    	; 0x194 <SOS_Init+0xc2>
	{
		/*
		 * global variables intialization
		 */
		gu8_Flag = SOS_UNINTIALIZED;
     114:	10 92 0b 01 	sts	0x010B, r1
		gu8_MaxPriority = SOS_UNINTIALIZED;
     118:	10 92 0c 01 	sts	0x010C, r1
		gu16_SysTickCounter = SOS_UNINTIALIZED;
     11c:	10 92 0f 01 	sts	0x010F, r1
     120:	10 92 0e 01 	sts	0x010E, r1
		gu8_SOS_Status = SOS_INTIALIZED;
     124:	81 e0       	ldi	r24, 0x01	; 1
     126:	80 93 0d 01 	sts	0x010D, r24
		/*
		 * initialize task list
		 */
		for (u8_counter = SOS_UNINTIALIZED; u8_counter < SOS_MAX_TASK_NUM;
     12a:	1a 82       	std	Y+2, r1	; 0x02
     12c:	2f c0       	rjmp	.+94     	; 0x18c <SOS_Init+0xba>
				u8_counter++)
		{
			gastr_SOS_TaskList[u8_counter].Status = TASK_DELETED;
     12e:	8a 81       	ldd	r24, Y+2	; 0x02
     130:	28 2f       	mov	r18, r24
     132:	30 e0       	ldi	r19, 0x00	; 0
     134:	c9 01       	movw	r24, r18
     136:	88 0f       	add	r24, r24
     138:	99 1f       	adc	r25, r25
     13a:	88 0f       	add	r24, r24
     13c:	99 1f       	adc	r25, r25
     13e:	82 0f       	add	r24, r18
     140:	93 1f       	adc	r25, r19
     142:	fc 01       	movw	r30, r24
     144:	e0 5f       	subi	r30, 0xF0	; 240
     146:	fe 4f       	sbci	r31, 0xFE	; 254
     148:	10 82       	st	Z, r1
			gastr_SOS_TaskList[u8_counter].Delay = SOS_UNINTIALIZED;
     14a:	8a 81       	ldd	r24, Y+2	; 0x02
     14c:	28 2f       	mov	r18, r24
     14e:	30 e0       	ldi	r19, 0x00	; 0
     150:	c9 01       	movw	r24, r18
     152:	88 0f       	add	r24, r24
     154:	99 1f       	adc	r25, r25
     156:	88 0f       	add	r24, r24
     158:	99 1f       	adc	r25, r25
     15a:	82 0f       	add	r24, r18
     15c:	93 1f       	adc	r25, r19
     15e:	fc 01       	movw	r30, r24
     160:	ef 5e       	subi	r30, 0xEF	; 239
     162:	fe 4f       	sbci	r31, 0xFE	; 254
     164:	11 82       	std	Z+1, r1	; 0x01
     166:	10 82       	st	Z, r1
			gastr_SOS_TaskList[u8_counter].SOS_Cbk_ptr = NULL;
     168:	8a 81       	ldd	r24, Y+2	; 0x02
     16a:	28 2f       	mov	r18, r24
     16c:	30 e0       	ldi	r19, 0x00	; 0
     16e:	c9 01       	movw	r24, r18
     170:	88 0f       	add	r24, r24
     172:	99 1f       	adc	r25, r25
     174:	88 0f       	add	r24, r24
     176:	99 1f       	adc	r25, r25
     178:	82 0f       	add	r24, r18
     17a:	93 1f       	adc	r25, r19
     17c:	fc 01       	movw	r30, r24
     17e:	ed 5e       	subi	r30, 0xED	; 237
     180:	fe 4f       	sbci	r31, 0xFE	; 254
     182:	11 82       	std	Z+1, r1	; 0x01
     184:	10 82       	st	Z, r1
		gu8_SOS_Status = SOS_INTIALIZED;
		/*
		 * initialize task list
		 */
		for (u8_counter = SOS_UNINTIALIZED; u8_counter < SOS_MAX_TASK_NUM;
				u8_counter++)
     186:	8a 81       	ldd	r24, Y+2	; 0x02
     188:	8f 5f       	subi	r24, 0xFF	; 255
     18a:	8a 83       	std	Y+2, r24	; 0x02
		gu16_SysTickCounter = SOS_UNINTIALIZED;
		gu8_SOS_Status = SOS_INTIALIZED;
		/*
		 * initialize task list
		 */
		for (u8_counter = SOS_UNINTIALIZED; u8_counter < SOS_MAX_TASK_NUM;
     18c:	8a 81       	ldd	r24, Y+2	; 0x02
     18e:	84 31       	cpi	r24, 0x14	; 20
     190:	70 f2       	brcs	.-100    	; 0x12e <SOS_Init+0x5c>
     192:	02 c0       	rjmp	.+4      	; 0x198 <SOS_Init+0xc6>
			gastr_SOS_TaskList[u8_counter].SOS_Cbk_ptr = NULL;
		}
	}
	else
	{
		gu8_SOS_Status = SOS_UNINTIALIZED;
     194:	10 92 0d 01 	sts	0x010D, r1
	}

	/*
	 * Function shall return the Error state
	 */
	return (s8_ErrorStatus);
     198:	89 81       	ldd	r24, Y+1	; 0x01
}
     19a:	28 96       	adiw	r28, 0x08	; 8
     19c:	0f b6       	in	r0, 0x3f	; 63
     19e:	f8 94       	cli
     1a0:	de bf       	out	0x3e, r29	; 62
     1a2:	0f be       	out	0x3f, r0	; 63
     1a4:	cd bf       	out	0x3d, r28	; 61
     1a6:	cf 91       	pop	r28
     1a8:	df 91       	pop	r29
     1aa:	08 95       	ret

000001ac <SOS_CreateTask>:
/* Description: Starts a new SOS task.															*/
/************************************************************************************************/

SOS_ERROR_STATUS SOS_CreateTask(gptrfu_TaskCbk_t SOS_Task_cbk,
		uint16 SOS_Period_MS, uint8 Priority)
{
     1ac:	df 93       	push	r29
     1ae:	cf 93       	push	r28
     1b0:	00 d0       	rcall	.+0      	; 0x1b2 <SOS_CreateTask+0x6>
     1b2:	00 d0       	rcall	.+0      	; 0x1b4 <SOS_CreateTask+0x8>
     1b4:	00 d0       	rcall	.+0      	; 0x1b6 <SOS_CreateTask+0xa>
     1b6:	cd b7       	in	r28, 0x3d	; 61
     1b8:	de b7       	in	r29, 0x3e	; 62
     1ba:	9b 83       	std	Y+3, r25	; 0x03
     1bc:	8a 83       	std	Y+2, r24	; 0x02
     1be:	7d 83       	std	Y+5, r23	; 0x05
     1c0:	6c 83       	std	Y+4, r22	; 0x04
     1c2:	4e 83       	std	Y+6, r20	; 0x06
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = SOS_BASE_ERROR + ERR_SUCCESS;
     1c4:	8c e9       	ldi	r24, 0x9C	; 156
     1c6:	89 83       	std	Y+1, r24	; 0x01

	if (gu8_SOS_Status == SOS_INTIALIZED)
     1c8:	80 91 0d 01 	lds	r24, 0x010D
     1cc:	81 30       	cpi	r24, 0x01	; 1
     1ce:	09 f0       	breq	.+2      	; 0x1d2 <SOS_CreateTask+0x26>
     1d0:	5a c0       	rjmp	.+180    	; 0x286 <SOS_CreateTask+0xda>
	{
		/*
		 * add new task to the list
		 */
		if (Priority > SOS_MAX_TASK_NUM)
     1d2:	8e 81       	ldd	r24, Y+6	; 0x06
     1d4:	85 31       	cpi	r24, 0x15	; 21
     1d6:	18 f0       	brcs	.+6      	; 0x1de <SOS_CreateTask+0x32>
		{
			s8_ErrorStatus = SOS_BASE_ERROR + ERR_BUFFER_FULL;
     1d8:	85 e9       	ldi	r24, 0x95	; 149
     1da:	89 83       	std	Y+1, r24	; 0x01
     1dc:	56 c0       	rjmp	.+172    	; 0x28a <SOS_CreateTask+0xde>
		}
		else if (gastr_SOS_TaskList[Priority].Status != TASK_DELETED)
     1de:	8e 81       	ldd	r24, Y+6	; 0x06
     1e0:	28 2f       	mov	r18, r24
     1e2:	30 e0       	ldi	r19, 0x00	; 0
     1e4:	c9 01       	movw	r24, r18
     1e6:	88 0f       	add	r24, r24
     1e8:	99 1f       	adc	r25, r25
     1ea:	88 0f       	add	r24, r24
     1ec:	99 1f       	adc	r25, r25
     1ee:	82 0f       	add	r24, r18
     1f0:	93 1f       	adc	r25, r19
     1f2:	fc 01       	movw	r30, r24
     1f4:	e0 5f       	subi	r30, 0xF0	; 240
     1f6:	fe 4f       	sbci	r31, 0xFE	; 254
     1f8:	80 81       	ld	r24, Z
     1fa:	88 23       	and	r24, r24
     1fc:	19 f0       	breq	.+6      	; 0x204 <SOS_CreateTask+0x58>
		{
			s8_ErrorStatus = SOS_BASE_ERROR + ERR_ALREADY_INITIALIZED;
     1fe:	89 e9       	ldi	r24, 0x99	; 153
     200:	89 83       	std	Y+1, r24	; 0x01
     202:	43 c0       	rjmp	.+134    	; 0x28a <SOS_CreateTask+0xde>
		}
		else if (NULL == SOS_Task_cbk)
     204:	8a 81       	ldd	r24, Y+2	; 0x02
     206:	9b 81       	ldd	r25, Y+3	; 0x03
     208:	00 97       	sbiw	r24, 0x00	; 0
     20a:	19 f4       	brne	.+6      	; 0x212 <SOS_CreateTask+0x66>
		{
			s8_ErrorStatus = SOS_BASE_ERROR + ERR_NULL_PTR;
     20c:	88 e9       	ldi	r24, 0x98	; 152
     20e:	89 83       	std	Y+1, r24	; 0x01
     210:	3c c0       	rjmp	.+120    	; 0x28a <SOS_CreateTask+0xde>
		}
		else
		{
			gastr_SOS_TaskList[Priority].Delay = SOS_Period_MS;
     212:	8e 81       	ldd	r24, Y+6	; 0x06
     214:	28 2f       	mov	r18, r24
     216:	30 e0       	ldi	r19, 0x00	; 0
     218:	c9 01       	movw	r24, r18
     21a:	88 0f       	add	r24, r24
     21c:	99 1f       	adc	r25, r25
     21e:	88 0f       	add	r24, r24
     220:	99 1f       	adc	r25, r25
     222:	82 0f       	add	r24, r18
     224:	93 1f       	adc	r25, r19
     226:	fc 01       	movw	r30, r24
     228:	ef 5e       	subi	r30, 0xEF	; 239
     22a:	fe 4f       	sbci	r31, 0xFE	; 254
     22c:	8c 81       	ldd	r24, Y+4	; 0x04
     22e:	9d 81       	ldd	r25, Y+5	; 0x05
     230:	91 83       	std	Z+1, r25	; 0x01
     232:	80 83       	st	Z, r24
			gastr_SOS_TaskList[Priority].SOS_Cbk_ptr = SOS_Task_cbk;
     234:	8e 81       	ldd	r24, Y+6	; 0x06
     236:	28 2f       	mov	r18, r24
     238:	30 e0       	ldi	r19, 0x00	; 0
     23a:	c9 01       	movw	r24, r18
     23c:	88 0f       	add	r24, r24
     23e:	99 1f       	adc	r25, r25
     240:	88 0f       	add	r24, r24
     242:	99 1f       	adc	r25, r25
     244:	82 0f       	add	r24, r18
     246:	93 1f       	adc	r25, r19
     248:	fc 01       	movw	r30, r24
     24a:	ed 5e       	subi	r30, 0xED	; 237
     24c:	fe 4f       	sbci	r31, 0xFE	; 254
     24e:	8a 81       	ldd	r24, Y+2	; 0x02
     250:	9b 81       	ldd	r25, Y+3	; 0x03
     252:	91 83       	std	Z+1, r25	; 0x01
     254:	80 83       	st	Z, r24
			gastr_SOS_TaskList[Priority].Status = TASK_READY;
     256:	8e 81       	ldd	r24, Y+6	; 0x06
     258:	28 2f       	mov	r18, r24
     25a:	30 e0       	ldi	r19, 0x00	; 0
     25c:	c9 01       	movw	r24, r18
     25e:	88 0f       	add	r24, r24
     260:	99 1f       	adc	r25, r25
     262:	88 0f       	add	r24, r24
     264:	99 1f       	adc	r25, r25
     266:	82 0f       	add	r24, r18
     268:	93 1f       	adc	r25, r19
     26a:	fc 01       	movw	r30, r24
     26c:	e0 5f       	subi	r30, 0xF0	; 240
     26e:	fe 4f       	sbci	r31, 0xFE	; 254
     270:	82 e0       	ldi	r24, 0x02	; 2
     272:	80 83       	st	Z, r24

			if (Priority > gu8_MaxPriority)
     274:	90 91 0c 01 	lds	r25, 0x010C
     278:	8e 81       	ldd	r24, Y+6	; 0x06
     27a:	98 17       	cp	r25, r24
     27c:	30 f4       	brcc	.+12     	; 0x28a <SOS_CreateTask+0xde>
			{
				gu8_MaxPriority = Priority;
     27e:	8e 81       	ldd	r24, Y+6	; 0x06
     280:	80 93 0c 01 	sts	0x010C, r24
     284:	02 c0       	rjmp	.+4      	; 0x28a <SOS_CreateTask+0xde>
		}

	}
	else
	{
		s8_ErrorStatus = SOS_BASE_ERROR + ERR_NOT_INITIALIZED;
     286:	8a e9       	ldi	r24, 0x9A	; 154
     288:	89 83       	std	Y+1, r24	; 0x01
	}

	/*
	 * Function shall return the Error state
	 */
	return (s8_ErrorStatus);
     28a:	89 81       	ldd	r24, Y+1	; 0x01
}
     28c:	26 96       	adiw	r28, 0x06	; 6
     28e:	0f b6       	in	r0, 0x3f	; 63
     290:	f8 94       	cli
     292:	de bf       	out	0x3e, r29	; 62
     294:	0f be       	out	0x3f, r0	; 63
     296:	cd bf       	out	0x3d, r28	; 61
     298:	cf 91       	pop	r28
     29a:	df 91       	pop	r29
     29c:	08 95       	ret

0000029e <SOS_DeleteTask>:
/* In/Out:	N/A																					*/
/* Return: The error status of the function.													*/
/* Description: Stops a SOS task.															*/
/************************************************************************************************/
SOS_ERROR_STATUS SOS_DeleteTask(gptrfu_TaskCbk_t SOS_Task_cbk)
{
     29e:	df 93       	push	r29
     2a0:	cf 93       	push	r28
     2a2:	00 d0       	rcall	.+0      	; 0x2a4 <SOS_DeleteTask+0x6>
     2a4:	00 d0       	rcall	.+0      	; 0x2a6 <SOS_DeleteTask+0x8>
     2a6:	cd b7       	in	r28, 0x3d	; 61
     2a8:	de b7       	in	r29, 0x3e	; 62
     2aa:	9c 83       	std	Y+4, r25	; 0x04
     2ac:	8b 83       	std	Y+3, r24	; 0x03
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = SOS_BASE_ERROR + ERR_SUCCESS;
     2ae:	8c e9       	ldi	r24, 0x9C	; 156
     2b0:	8a 83       	std	Y+2, r24	; 0x02
	uint8 u8_counter;

	if (NULL == SOS_Task_cbk)
     2b2:	8b 81       	ldd	r24, Y+3	; 0x03
     2b4:	9c 81       	ldd	r25, Y+4	; 0x04
     2b6:	00 97       	sbiw	r24, 0x00	; 0
     2b8:	19 f4       	brne	.+6      	; 0x2c0 <SOS_DeleteTask+0x22>
	{
		s8_ErrorStatus = SOS_BASE_ERROR + ERR_NULL_PTR;
     2ba:	88 e9       	ldi	r24, 0x98	; 152
     2bc:	8a 83       	std	Y+2, r24	; 0x02
     2be:	2c c0       	rjmp	.+88     	; 0x318 <SOS_DeleteTask+0x7a>
	}
	else
	{
		for (u8_counter = SOS_UNINTIALIZED; u8_counter <= gu8_MaxPriority;
     2c0:	19 82       	std	Y+1, r1	; 0x01
     2c2:	25 c0       	rjmp	.+74     	; 0x30e <SOS_DeleteTask+0x70>
				u8_counter++)
		{
			if (gastr_SOS_TaskList[u8_counter].SOS_Cbk_ptr == SOS_Task_cbk)
     2c4:	89 81       	ldd	r24, Y+1	; 0x01
     2c6:	28 2f       	mov	r18, r24
     2c8:	30 e0       	ldi	r19, 0x00	; 0
     2ca:	c9 01       	movw	r24, r18
     2cc:	88 0f       	add	r24, r24
     2ce:	99 1f       	adc	r25, r25
     2d0:	88 0f       	add	r24, r24
     2d2:	99 1f       	adc	r25, r25
     2d4:	82 0f       	add	r24, r18
     2d6:	93 1f       	adc	r25, r19
     2d8:	fc 01       	movw	r30, r24
     2da:	ed 5e       	subi	r30, 0xED	; 237
     2dc:	fe 4f       	sbci	r31, 0xFE	; 254
     2de:	20 81       	ld	r18, Z
     2e0:	31 81       	ldd	r19, Z+1	; 0x01
     2e2:	8b 81       	ldd	r24, Y+3	; 0x03
     2e4:	9c 81       	ldd	r25, Y+4	; 0x04
     2e6:	28 17       	cp	r18, r24
     2e8:	39 07       	cpc	r19, r25
     2ea:	71 f4       	brne	.+28     	; 0x308 <SOS_DeleteTask+0x6a>
			{
				gastr_SOS_TaskList[u8_counter].Status = TASK_DELETED;
     2ec:	89 81       	ldd	r24, Y+1	; 0x01
     2ee:	28 2f       	mov	r18, r24
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	c9 01       	movw	r24, r18
     2f4:	88 0f       	add	r24, r24
     2f6:	99 1f       	adc	r25, r25
     2f8:	88 0f       	add	r24, r24
     2fa:	99 1f       	adc	r25, r25
     2fc:	82 0f       	add	r24, r18
     2fe:	93 1f       	adc	r25, r19
     300:	fc 01       	movw	r30, r24
     302:	e0 5f       	subi	r30, 0xF0	; 240
     304:	fe 4f       	sbci	r31, 0xFE	; 254
     306:	10 82       	st	Z, r1
		s8_ErrorStatus = SOS_BASE_ERROR + ERR_NULL_PTR;
	}
	else
	{
		for (u8_counter = SOS_UNINTIALIZED; u8_counter <= gu8_MaxPriority;
				u8_counter++)
     308:	89 81       	ldd	r24, Y+1	; 0x01
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	89 83       	std	Y+1, r24	; 0x01
	{
		s8_ErrorStatus = SOS_BASE_ERROR + ERR_NULL_PTR;
	}
	else
	{
		for (u8_counter = SOS_UNINTIALIZED; u8_counter <= gu8_MaxPriority;
     30e:	90 91 0c 01 	lds	r25, 0x010C
     312:	89 81       	ldd	r24, Y+1	; 0x01
     314:	98 17       	cp	r25, r24
     316:	b0 f6       	brcc	.-84     	; 0x2c4 <SOS_DeleteTask+0x26>
	}

	/*
	 * Function shall return the Error state
	 */
	return (s8_ErrorStatus);
     318:	8a 81       	ldd	r24, Y+2	; 0x02
}
     31a:	0f 90       	pop	r0
     31c:	0f 90       	pop	r0
     31e:	0f 90       	pop	r0
     320:	0f 90       	pop	r0
     322:	cf 91       	pop	r28
     324:	df 91       	pop	r29
     326:	08 95       	ret

00000328 <SOS_Run>:
/* In/Out:																						*/
/* Return: The error status of the function.													*/
/* Description: the main operation "call each function at it's right time".															*/
/************************************************************************************************/
SOS_ERROR_STATUS SOS_Run(void)
{
     328:	df 93       	push	r29
     32a:	cf 93       	push	r28
     32c:	00 d0       	rcall	.+0      	; 0x32e <SOS_Run+0x6>
     32e:	cd b7       	in	r28, 0x3d	; 61
     330:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = SOS_BASE_ERROR + ERR_SUCCESS;
     332:	8c e9       	ldi	r24, 0x9C	; 156
     334:	8a 83       	std	Y+2, r24	; 0x02
	uint8 u8_counter = SOS_UNINTIALIZED;
     336:	19 82       	std	Y+1, r1	; 0x01

	if (gu8_SOS_Status == SOS_INTIALIZED) /* or started */
     338:	80 91 0d 01 	lds	r24, 0x010D
     33c:	81 30       	cpi	r24, 0x01	; 1
     33e:	09 f0       	breq	.+2      	; 0x342 <SOS_Run+0x1a>
     340:	76 c0       	rjmp	.+236    	; 0x42e <SOS_Run+0x106>
	{
		/*
		 * start timer
		 */
		s8_ErrorStatus = Timer_Start(str_SOS_Init_Cfg.Timer_CH_NO,
     342:	80 91 bb 00 	lds	r24, 0x00BB
     346:	6a ef       	ldi	r22, 0xFA	; 250
     348:	70 e0       	ldi	r23, 0x00	; 0
     34a:	0e 94 1f 30 	call	0x603e	; 0x603e <Timer_Start>
     34e:	8a 83       	std	Y+2, r24	; 0x02
		MS_TIMER_COUNTS);

		while (TRUE)
		{
			if (gu8_Flag == TRUE)
     350:	80 91 0b 01 	lds	r24, 0x010B
     354:	81 30       	cpi	r24, 0x01	; 1
     356:	e1 f7       	brne	.-8      	; 0x350 <SOS_Run+0x28>
			{
				for (u8_counter = SOS_UNINTIALIZED;
     358:	19 82       	std	Y+1, r1	; 0x01
     35a:	5d c0       	rjmp	.+186    	; 0x416 <SOS_Run+0xee>
						u8_counter <= gu8_MaxPriority; u8_counter++)
				{
					if (gastr_SOS_TaskList[u8_counter].Status == TASK_DELETED)
     35c:	89 81       	ldd	r24, Y+1	; 0x01
     35e:	28 2f       	mov	r18, r24
     360:	30 e0       	ldi	r19, 0x00	; 0
     362:	c9 01       	movw	r24, r18
     364:	88 0f       	add	r24, r24
     366:	99 1f       	adc	r25, r25
     368:	88 0f       	add	r24, r24
     36a:	99 1f       	adc	r25, r25
     36c:	82 0f       	add	r24, r18
     36e:	93 1f       	adc	r25, r19
     370:	fc 01       	movw	r30, r24
     372:	e0 5f       	subi	r30, 0xF0	; 240
     374:	fe 4f       	sbci	r31, 0xFE	; 254
     376:	80 81       	ld	r24, Z
     378:	88 23       	and	r24, r24
     37a:	09 f4       	brne	.+2      	; 0x37e <SOS_Run+0x56>
     37c:	49 c0       	rjmp	.+146    	; 0x410 <SOS_Run+0xe8>
					{
						/* DO NOTHING */
					}
					else if ((gu16_SysTickCounter
     37e:	40 91 0e 01 	lds	r20, 0x010E
     382:	50 91 0f 01 	lds	r21, 0x010F
     386:	89 81       	ldd	r24, Y+1	; 0x01
     388:	28 2f       	mov	r18, r24
     38a:	30 e0       	ldi	r19, 0x00	; 0
     38c:	c9 01       	movw	r24, r18
     38e:	88 0f       	add	r24, r24
     390:	99 1f       	adc	r25, r25
     392:	88 0f       	add	r24, r24
     394:	99 1f       	adc	r25, r25
     396:	82 0f       	add	r24, r18
     398:	93 1f       	adc	r25, r19
     39a:	fc 01       	movw	r30, r24
     39c:	ef 5e       	subi	r30, 0xEF	; 239
     39e:	fe 4f       	sbci	r31, 0xFE	; 254
     3a0:	20 81       	ld	r18, Z
     3a2:	31 81       	ldd	r19, Z+1	; 0x01
     3a4:	ca 01       	movw	r24, r20
     3a6:	b9 01       	movw	r22, r18
     3a8:	0e 94 2b 3c 	call	0x7856	; 0x7856 <__udivmodhi4>
     3ac:	00 97       	sbiw	r24, 0x00	; 0
     3ae:	09 f5       	brne	.+66     	; 0x3f2 <SOS_Run+0xca>
							% gastr_SOS_TaskList[u8_counter].Delay)
							== SOS_UNINTIALIZED)
					{
						gastr_SOS_TaskList[u8_counter].Status = TASK_RUNNING;
     3b0:	89 81       	ldd	r24, Y+1	; 0x01
     3b2:	28 2f       	mov	r18, r24
     3b4:	30 e0       	ldi	r19, 0x00	; 0
     3b6:	c9 01       	movw	r24, r18
     3b8:	88 0f       	add	r24, r24
     3ba:	99 1f       	adc	r25, r25
     3bc:	88 0f       	add	r24, r24
     3be:	99 1f       	adc	r25, r25
     3c0:	82 0f       	add	r24, r18
     3c2:	93 1f       	adc	r25, r19
     3c4:	fc 01       	movw	r30, r24
     3c6:	e0 5f       	subi	r30, 0xF0	; 240
     3c8:	fe 4f       	sbci	r31, 0xFE	; 254
     3ca:	81 e0       	ldi	r24, 0x01	; 1
     3cc:	80 83       	st	Z, r24
						gastr_SOS_TaskList[u8_counter].SOS_Cbk_ptr();
     3ce:	89 81       	ldd	r24, Y+1	; 0x01
     3d0:	28 2f       	mov	r18, r24
     3d2:	30 e0       	ldi	r19, 0x00	; 0
     3d4:	c9 01       	movw	r24, r18
     3d6:	88 0f       	add	r24, r24
     3d8:	99 1f       	adc	r25, r25
     3da:	88 0f       	add	r24, r24
     3dc:	99 1f       	adc	r25, r25
     3de:	82 0f       	add	r24, r18
     3e0:	93 1f       	adc	r25, r19
     3e2:	fc 01       	movw	r30, r24
     3e4:	ed 5e       	subi	r30, 0xED	; 237
     3e6:	fe 4f       	sbci	r31, 0xFE	; 254
     3e8:	01 90       	ld	r0, Z+
     3ea:	f0 81       	ld	r31, Z
     3ec:	e0 2d       	mov	r30, r0
     3ee:	09 95       	icall
     3f0:	0f c0       	rjmp	.+30     	; 0x410 <SOS_Run+0xe8>
						 * gastr_SOS_TaskList[u8_counter].Status = TASK_READY;
						 */
					}
					else
					{
						gastr_SOS_TaskList[u8_counter].Status =
     3f2:	89 81       	ldd	r24, Y+1	; 0x01
     3f4:	28 2f       	mov	r18, r24
     3f6:	30 e0       	ldi	r19, 0x00	; 0
     3f8:	c9 01       	movw	r24, r18
     3fa:	88 0f       	add	r24, r24
     3fc:	99 1f       	adc	r25, r25
     3fe:	88 0f       	add	r24, r24
     400:	99 1f       	adc	r25, r25
     402:	82 0f       	add	r24, r18
     404:	93 1f       	adc	r25, r19
     406:	fc 01       	movw	r30, r24
     408:	e0 5f       	subi	r30, 0xF0	; 240
     40a:	fe 4f       	sbci	r31, 0xFE	; 254
     40c:	83 e0       	ldi	r24, 0x03	; 3
     40e:	80 83       	st	Z, r24
		while (TRUE)
		{
			if (gu8_Flag == TRUE)
			{
				for (u8_counter = SOS_UNINTIALIZED;
						u8_counter <= gu8_MaxPriority; u8_counter++)
     410:	89 81       	ldd	r24, Y+1	; 0x01
     412:	8f 5f       	subi	r24, 0xFF	; 255
     414:	89 83       	std	Y+1, r24	; 0x01
     416:	90 91 0c 01 	lds	r25, 0x010C
     41a:	89 81       	ldd	r24, Y+1	; 0x01
     41c:	98 17       	cp	r25, r24
     41e:	08 f0       	brcs	.+2      	; 0x422 <SOS_Run+0xfa>
     420:	9d cf       	rjmp	.-198    	; 0x35c <SOS_Run+0x34>
					{
						gastr_SOS_TaskList[u8_counter].Status =
						TASK_BLOCKING;
					}
				}
				gu8_Flag = SOS_UNINTIALIZED;
     422:	10 92 0b 01 	sts	0x010B, r1
				CPU_Sleep(IDLE);
     426:	80 e0       	ldi	r24, 0x00	; 0
     428:	0e 94 e0 32 	call	0x65c0	; 0x65c0 <CPU_Sleep>
     42c:	91 cf       	rjmp	.-222    	; 0x350 <SOS_Run+0x28>
			}
		}
	}
	else
	{
		s8_ErrorStatus = SOS_BASE_ERROR + ERR_NOT_INITIALIZED;
     42e:	8a e9       	ldi	r24, 0x9A	; 154
     430:	8a 83       	std	Y+2, r24	; 0x02
	}
	/*
	 * Function shall return the Error state
	 */
	return (s8_ErrorStatus);
     432:	8a 81       	ldd	r24, Y+2	; 0x02
}
     434:	0f 90       	pop	r0
     436:	0f 90       	pop	r0
     438:	cf 91       	pop	r28
     43a:	df 91       	pop	r29
     43c:	08 95       	ret

0000043e <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     43e:	df 93       	push	r29
     440:	cf 93       	push	r28
     442:	00 d0       	rcall	.+0      	; 0x444 <xEventGroupCreate+0x6>
     444:	cd b7       	in	r28, 0x3d	; 61
     446:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     448:	8b e0       	ldi	r24, 0x0B	; 11
     44a:	90 e0       	ldi	r25, 0x00	; 0
     44c:	0e 94 64 05 	call	0xac8	; 0xac8 <pvPortMalloc>
     450:	9a 83       	std	Y+2, r25	; 0x02
     452:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     454:	89 81       	ldd	r24, Y+1	; 0x01
     456:	9a 81       	ldd	r25, Y+2	; 0x02
     458:	00 97       	sbiw	r24, 0x00	; 0
     45a:	49 f0       	breq	.+18     	; 0x46e <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     45c:	e9 81       	ldd	r30, Y+1	; 0x01
     45e:	fa 81       	ldd	r31, Y+2	; 0x02
     460:	11 82       	std	Z+1, r1	; 0x01
     462:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     464:	89 81       	ldd	r24, Y+1	; 0x01
     466:	9a 81       	ldd	r25, Y+2	; 0x02
     468:	02 96       	adiw	r24, 0x02	; 2
     46a:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     46e:	89 81       	ldd	r24, Y+1	; 0x01
     470:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     472:	0f 90       	pop	r0
     474:	0f 90       	pop	r0
     476:	cf 91       	pop	r28
     478:	df 91       	pop	r29
     47a:	08 95       	ret

0000047c <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     47c:	df 93       	push	r29
     47e:	cf 93       	push	r28
     480:	cd b7       	in	r28, 0x3d	; 61
     482:	de b7       	in	r29, 0x3e	; 62
     484:	60 97       	sbiw	r28, 0x10	; 16
     486:	0f b6       	in	r0, 0x3f	; 63
     488:	f8 94       	cli
     48a:	de bf       	out	0x3e, r29	; 62
     48c:	0f be       	out	0x3f, r0	; 63
     48e:	cd bf       	out	0x3d, r28	; 61
     490:	9a 87       	std	Y+10, r25	; 0x0a
     492:	89 87       	std	Y+9, r24	; 0x09
     494:	7c 87       	std	Y+12, r23	; 0x0c
     496:	6b 87       	std	Y+11, r22	; 0x0b
     498:	5e 87       	std	Y+14, r21	; 0x0e
     49a:	4d 87       	std	Y+13, r20	; 0x0d
     49c:	38 8b       	std	Y+16, r19	; 0x10
     49e:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     4a0:	89 85       	ldd	r24, Y+9	; 0x09
     4a2:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a4:	9c 83       	std	Y+4, r25	; 0x04
     4a6:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     4a8:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     4aa:	0e 94 8e 1c 	call	0x391c	; 0x391c <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     4ae:	eb 81       	ldd	r30, Y+3	; 0x03
     4b0:	fc 81       	ldd	r31, Y+4	; 0x04
     4b2:	80 81       	ld	r24, Z
     4b4:	91 81       	ldd	r25, Z+1	; 0x01
     4b6:	98 87       	std	Y+8, r25	; 0x08
     4b8:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     4ba:	89 85       	ldd	r24, Y+9	; 0x09
     4bc:	9a 85       	ldd	r25, Y+10	; 0x0a
     4be:	2b 85       	ldd	r18, Y+11	; 0x0b
     4c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     4c2:	b9 01       	movw	r22, r18
     4c4:	0e 94 15 04 	call	0x82a	; 0x82a <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     4c8:	2f 81       	ldd	r18, Y+7	; 0x07
     4ca:	38 85       	ldd	r19, Y+8	; 0x08
     4cc:	8b 85       	ldd	r24, Y+11	; 0x0b
     4ce:	9c 85       	ldd	r25, Y+12	; 0x0c
     4d0:	28 2b       	or	r18, r24
     4d2:	39 2b       	or	r19, r25
     4d4:	8d 85       	ldd	r24, Y+13	; 0x0d
     4d6:	9e 85       	ldd	r25, Y+14	; 0x0e
     4d8:	28 23       	and	r18, r24
     4da:	39 23       	and	r19, r25
     4dc:	8d 85       	ldd	r24, Y+13	; 0x0d
     4de:	9e 85       	ldd	r25, Y+14	; 0x0e
     4e0:	28 17       	cp	r18, r24
     4e2:	39 07       	cpc	r19, r25
     4e4:	c9 f4       	brne	.+50     	; 0x518 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     4e6:	2f 81       	ldd	r18, Y+7	; 0x07
     4e8:	38 85       	ldd	r19, Y+8	; 0x08
     4ea:	8b 85       	ldd	r24, Y+11	; 0x0b
     4ec:	9c 85       	ldd	r25, Y+12	; 0x0c
     4ee:	82 2b       	or	r24, r18
     4f0:	93 2b       	or	r25, r19
     4f2:	9e 83       	std	Y+6, r25	; 0x06
     4f4:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     4f6:	eb 81       	ldd	r30, Y+3	; 0x03
     4f8:	fc 81       	ldd	r31, Y+4	; 0x04
     4fa:	20 81       	ld	r18, Z
     4fc:	31 81       	ldd	r19, Z+1	; 0x01
     4fe:	8d 85       	ldd	r24, Y+13	; 0x0d
     500:	9e 85       	ldd	r25, Y+14	; 0x0e
     502:	80 95       	com	r24
     504:	90 95       	com	r25
     506:	82 23       	and	r24, r18
     508:	93 23       	and	r25, r19
     50a:	eb 81       	ldd	r30, Y+3	; 0x03
     50c:	fc 81       	ldd	r31, Y+4	; 0x04
     50e:	91 83       	std	Z+1, r25	; 0x01
     510:	80 83       	st	Z, r24

			xTicksToWait = 0;
     512:	18 8a       	std	Y+16, r1	; 0x10
     514:	1f 86       	std	Y+15, r1	; 0x0f
     516:	1e c0       	rjmp	.+60     	; 0x554 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     518:	8f 85       	ldd	r24, Y+15	; 0x0f
     51a:	98 89       	ldd	r25, Y+16	; 0x10
     51c:	00 97       	sbiw	r24, 0x00	; 0
     51e:	91 f0       	breq	.+36     	; 0x544 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     520:	8b 81       	ldd	r24, Y+3	; 0x03
     522:	9c 81       	ldd	r25, Y+4	; 0x04
     524:	bc 01       	movw	r22, r24
     526:	6e 5f       	subi	r22, 0xFE	; 254
     528:	7f 4f       	sbci	r23, 0xFF	; 255
     52a:	8d 85       	ldd	r24, Y+13	; 0x0d
     52c:	9e 85       	ldd	r25, Y+14	; 0x0e
     52e:	9c 01       	movw	r18, r24
     530:	35 60       	ori	r19, 0x05	; 5
     532:	4f 85       	ldd	r20, Y+15	; 0x0f
     534:	58 89       	ldd	r21, Y+16	; 0x10
     536:	cb 01       	movw	r24, r22
     538:	b9 01       	movw	r22, r18
     53a:	0e 94 ce 1e 	call	0x3d9c	; 0x3d9c <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     53e:	1e 82       	std	Y+6, r1	; 0x06
     540:	1d 82       	std	Y+5, r1	; 0x05
     542:	08 c0       	rjmp	.+16     	; 0x554 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     544:	eb 81       	ldd	r30, Y+3	; 0x03
     546:	fc 81       	ldd	r31, Y+4	; 0x04
     548:	80 81       	ld	r24, Z
     54a:	91 81       	ldd	r25, Z+1	; 0x01
     54c:	9e 83       	std	Y+6, r25	; 0x06
     54e:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     550:	81 e0       	ldi	r24, 0x01	; 1
     552:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     554:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>
     558:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     55a:	8f 85       	ldd	r24, Y+15	; 0x0f
     55c:	98 89       	ldd	r25, Y+16	; 0x10
     55e:	00 97       	sbiw	r24, 0x00	; 0
     560:	09 f4       	brne	.+2      	; 0x564 <xEventGroupSync+0xe8>
     562:	3a c0       	rjmp	.+116    	; 0x5d8 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
     564:	8a 81       	ldd	r24, Y+2	; 0x02
     566:	88 23       	and	r24, r24
     568:	11 f4       	brne	.+4      	; 0x56e <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     56a:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     56e:	0e 94 01 21 	call	0x4202	; 0x4202 <uxTaskResetEventItemValue>
     572:	9e 83       	std	Y+6, r25	; 0x06
     574:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     576:	8d 81       	ldd	r24, Y+5	; 0x05
     578:	9e 81       	ldd	r25, Y+6	; 0x06
     57a:	80 70       	andi	r24, 0x00	; 0
     57c:	92 70       	andi	r25, 0x02	; 2
     57e:	00 97       	sbiw	r24, 0x00	; 0
     580:	31 f5       	brne	.+76     	; 0x5ce <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     582:	0f b6       	in	r0, 0x3f	; 63
     584:	f8 94       	cli
     586:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     588:	eb 81       	ldd	r30, Y+3	; 0x03
     58a:	fc 81       	ldd	r31, Y+4	; 0x04
     58c:	80 81       	ld	r24, Z
     58e:	91 81       	ldd	r25, Z+1	; 0x01
     590:	9e 83       	std	Y+6, r25	; 0x06
     592:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     594:	2d 81       	ldd	r18, Y+5	; 0x05
     596:	3e 81       	ldd	r19, Y+6	; 0x06
     598:	8d 85       	ldd	r24, Y+13	; 0x0d
     59a:	9e 85       	ldd	r25, Y+14	; 0x0e
     59c:	28 23       	and	r18, r24
     59e:	39 23       	and	r19, r25
     5a0:	8d 85       	ldd	r24, Y+13	; 0x0d
     5a2:	9e 85       	ldd	r25, Y+14	; 0x0e
     5a4:	28 17       	cp	r18, r24
     5a6:	39 07       	cpc	r19, r25
     5a8:	71 f4       	brne	.+28     	; 0x5c6 <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     5aa:	eb 81       	ldd	r30, Y+3	; 0x03
     5ac:	fc 81       	ldd	r31, Y+4	; 0x04
     5ae:	20 81       	ld	r18, Z
     5b0:	31 81       	ldd	r19, Z+1	; 0x01
     5b2:	8d 85       	ldd	r24, Y+13	; 0x0d
     5b4:	9e 85       	ldd	r25, Y+14	; 0x0e
     5b6:	80 95       	com	r24
     5b8:	90 95       	com	r25
     5ba:	82 23       	and	r24, r18
     5bc:	93 23       	and	r25, r19
     5be:	eb 81       	ldd	r30, Y+3	; 0x03
     5c0:	fc 81       	ldd	r31, Y+4	; 0x04
     5c2:	91 83       	std	Z+1, r25	; 0x01
     5c4:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     5c6:	0f 90       	pop	r0
     5c8:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     5ca:	81 e0       	ldi	r24, 0x01	; 1
     5cc:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     5ce:	8d 81       	ldd	r24, Y+5	; 0x05
     5d0:	9e 81       	ldd	r25, Y+6	; 0x06
     5d2:	90 70       	andi	r25, 0x00	; 0
     5d4:	9e 83       	std	Y+6, r25	; 0x06
     5d6:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     5d8:	8d 81       	ldd	r24, Y+5	; 0x05
     5da:	9e 81       	ldd	r25, Y+6	; 0x06
}
     5dc:	60 96       	adiw	r28, 0x10	; 16
     5de:	0f b6       	in	r0, 0x3f	; 63
     5e0:	f8 94       	cli
     5e2:	de bf       	out	0x3e, r29	; 62
     5e4:	0f be       	out	0x3f, r0	; 63
     5e6:	cd bf       	out	0x3d, r28	; 61
     5e8:	cf 91       	pop	r28
     5ea:	df 91       	pop	r29
     5ec:	08 95       	ret

000005ee <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     5ee:	0f 93       	push	r16
     5f0:	1f 93       	push	r17
     5f2:	df 93       	push	r29
     5f4:	cf 93       	push	r28
     5f6:	cd b7       	in	r28, 0x3d	; 61
     5f8:	de b7       	in	r29, 0x3e	; 62
     5fa:	63 97       	sbiw	r28, 0x13	; 19
     5fc:	0f b6       	in	r0, 0x3f	; 63
     5fe:	f8 94       	cli
     600:	de bf       	out	0x3e, r29	; 62
     602:	0f be       	out	0x3f, r0	; 63
     604:	cd bf       	out	0x3d, r28	; 61
     606:	9d 87       	std	Y+13, r25	; 0x0d
     608:	8c 87       	std	Y+12, r24	; 0x0c
     60a:	7f 87       	std	Y+15, r23	; 0x0f
     60c:	6e 87       	std	Y+14, r22	; 0x0e
     60e:	48 8b       	std	Y+16, r20	; 0x10
     610:	29 8b       	std	Y+17, r18	; 0x11
     612:	1b 8b       	std	Y+19, r17	; 0x13
     614:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     616:	8c 85       	ldd	r24, Y+12	; 0x0c
     618:	9d 85       	ldd	r25, Y+13	; 0x0d
     61a:	9b 87       	std	Y+11, r25	; 0x0b
     61c:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     61e:	1f 82       	std	Y+7, r1	; 0x07
     620:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     622:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     624:	0e 94 8e 1c 	call	0x391c	; 0x391c <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     628:	ea 85       	ldd	r30, Y+10	; 0x0a
     62a:	fb 85       	ldd	r31, Y+11	; 0x0b
     62c:	80 81       	ld	r24, Z
     62e:	91 81       	ldd	r25, Z+1	; 0x01
     630:	9a 83       	std	Y+2, r25	; 0x02
     632:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     634:	89 81       	ldd	r24, Y+1	; 0x01
     636:	9a 81       	ldd	r25, Y+2	; 0x02
     638:	2e 85       	ldd	r18, Y+14	; 0x0e
     63a:	3f 85       	ldd	r19, Y+15	; 0x0f
     63c:	b9 01       	movw	r22, r18
     63e:	49 89       	ldd	r20, Y+17	; 0x11
     640:	0e 94 32 05 	call	0xa64	; 0xa64 <prvTestWaitCondition>
     644:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     646:	8d 81       	ldd	r24, Y+5	; 0x05
     648:	88 23       	and	r24, r24
     64a:	c1 f0       	breq	.+48     	; 0x67c <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     64c:	89 81       	ldd	r24, Y+1	; 0x01
     64e:	9a 81       	ldd	r25, Y+2	; 0x02
     650:	99 87       	std	Y+9, r25	; 0x09
     652:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     654:	1b 8a       	std	Y+19, r1	; 0x13
     656:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     658:	88 89       	ldd	r24, Y+16	; 0x10
     65a:	88 23       	and	r24, r24
     65c:	e9 f1       	breq	.+122    	; 0x6d8 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     65e:	ea 85       	ldd	r30, Y+10	; 0x0a
     660:	fb 85       	ldd	r31, Y+11	; 0x0b
     662:	20 81       	ld	r18, Z
     664:	31 81       	ldd	r19, Z+1	; 0x01
     666:	8e 85       	ldd	r24, Y+14	; 0x0e
     668:	9f 85       	ldd	r25, Y+15	; 0x0f
     66a:	80 95       	com	r24
     66c:	90 95       	com	r25
     66e:	82 23       	and	r24, r18
     670:	93 23       	and	r25, r19
     672:	ea 85       	ldd	r30, Y+10	; 0x0a
     674:	fb 85       	ldd	r31, Y+11	; 0x0b
     676:	91 83       	std	Z+1, r25	; 0x01
     678:	80 83       	st	Z, r24
     67a:	2e c0       	rjmp	.+92     	; 0x6d8 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     67c:	8a 89       	ldd	r24, Y+18	; 0x12
     67e:	9b 89       	ldd	r25, Y+19	; 0x13
     680:	00 97       	sbiw	r24, 0x00	; 0
     682:	39 f4       	brne	.+14     	; 0x692 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     684:	89 81       	ldd	r24, Y+1	; 0x01
     686:	9a 81       	ldd	r25, Y+2	; 0x02
     688:	99 87       	std	Y+9, r25	; 0x09
     68a:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     68c:	81 e0       	ldi	r24, 0x01	; 1
     68e:	8b 83       	std	Y+3, r24	; 0x03
     690:	23 c0       	rjmp	.+70     	; 0x6d8 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     692:	88 89       	ldd	r24, Y+16	; 0x10
     694:	88 23       	and	r24, r24
     696:	29 f0       	breq	.+10     	; 0x6a2 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     698:	8e 81       	ldd	r24, Y+6	; 0x06
     69a:	9f 81       	ldd	r25, Y+7	; 0x07
     69c:	91 60       	ori	r25, 0x01	; 1
     69e:	9f 83       	std	Y+7, r25	; 0x07
     6a0:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     6a2:	89 89       	ldd	r24, Y+17	; 0x11
     6a4:	88 23       	and	r24, r24
     6a6:	29 f0       	breq	.+10     	; 0x6b2 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     6a8:	8e 81       	ldd	r24, Y+6	; 0x06
     6aa:	9f 81       	ldd	r25, Y+7	; 0x07
     6ac:	94 60       	ori	r25, 0x04	; 4
     6ae:	9f 83       	std	Y+7, r25	; 0x07
     6b0:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     6b2:	8a 85       	ldd	r24, Y+10	; 0x0a
     6b4:	9b 85       	ldd	r25, Y+11	; 0x0b
     6b6:	bc 01       	movw	r22, r24
     6b8:	6e 5f       	subi	r22, 0xFE	; 254
     6ba:	7f 4f       	sbci	r23, 0xFF	; 255
     6bc:	2e 85       	ldd	r18, Y+14	; 0x0e
     6be:	3f 85       	ldd	r19, Y+15	; 0x0f
     6c0:	8e 81       	ldd	r24, Y+6	; 0x06
     6c2:	9f 81       	ldd	r25, Y+7	; 0x07
     6c4:	28 2b       	or	r18, r24
     6c6:	39 2b       	or	r19, r25
     6c8:	4a 89       	ldd	r20, Y+18	; 0x12
     6ca:	5b 89       	ldd	r21, Y+19	; 0x13
     6cc:	cb 01       	movw	r24, r22
     6ce:	b9 01       	movw	r22, r18
     6d0:	0e 94 ce 1e 	call	0x3d9c	; 0x3d9c <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     6d4:	19 86       	std	Y+9, r1	; 0x09
     6d6:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     6d8:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>
     6dc:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     6de:	8a 89       	ldd	r24, Y+18	; 0x12
     6e0:	9b 89       	ldd	r25, Y+19	; 0x13
     6e2:	00 97       	sbiw	r24, 0x00	; 0
     6e4:	09 f4       	brne	.+2      	; 0x6e8 <xEventGroupWaitBits+0xfa>
     6e6:	3c c0       	rjmp	.+120    	; 0x760 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     6e8:	8c 81       	ldd	r24, Y+4	; 0x04
     6ea:	88 23       	and	r24, r24
     6ec:	11 f4       	brne	.+4      	; 0x6f2 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     6ee:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     6f2:	0e 94 01 21 	call	0x4202	; 0x4202 <uxTaskResetEventItemValue>
     6f6:	99 87       	std	Y+9, r25	; 0x09
     6f8:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     6fa:	88 85       	ldd	r24, Y+8	; 0x08
     6fc:	99 85       	ldd	r25, Y+9	; 0x09
     6fe:	80 70       	andi	r24, 0x00	; 0
     700:	92 70       	andi	r25, 0x02	; 2
     702:	00 97       	sbiw	r24, 0x00	; 0
     704:	41 f5       	brne	.+80     	; 0x756 <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     706:	0f b6       	in	r0, 0x3f	; 63
     708:	f8 94       	cli
     70a:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     70c:	ea 85       	ldd	r30, Y+10	; 0x0a
     70e:	fb 85       	ldd	r31, Y+11	; 0x0b
     710:	80 81       	ld	r24, Z
     712:	91 81       	ldd	r25, Z+1	; 0x01
     714:	99 87       	std	Y+9, r25	; 0x09
     716:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     718:	88 85       	ldd	r24, Y+8	; 0x08
     71a:	99 85       	ldd	r25, Y+9	; 0x09
     71c:	2e 85       	ldd	r18, Y+14	; 0x0e
     71e:	3f 85       	ldd	r19, Y+15	; 0x0f
     720:	b9 01       	movw	r22, r18
     722:	49 89       	ldd	r20, Y+17	; 0x11
     724:	0e 94 32 05 	call	0xa64	; 0xa64 <prvTestWaitCondition>
     728:	88 23       	and	r24, r24
     72a:	89 f0       	breq	.+34     	; 0x74e <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     72c:	88 89       	ldd	r24, Y+16	; 0x10
     72e:	88 23       	and	r24, r24
     730:	71 f0       	breq	.+28     	; 0x74e <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     732:	ea 85       	ldd	r30, Y+10	; 0x0a
     734:	fb 85       	ldd	r31, Y+11	; 0x0b
     736:	20 81       	ld	r18, Z
     738:	31 81       	ldd	r19, Z+1	; 0x01
     73a:	8e 85       	ldd	r24, Y+14	; 0x0e
     73c:	9f 85       	ldd	r25, Y+15	; 0x0f
     73e:	80 95       	com	r24
     740:	90 95       	com	r25
     742:	82 23       	and	r24, r18
     744:	93 23       	and	r25, r19
     746:	ea 85       	ldd	r30, Y+10	; 0x0a
     748:	fb 85       	ldd	r31, Y+11	; 0x0b
     74a:	91 83       	std	Z+1, r25	; 0x01
     74c:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     74e:	81 e0       	ldi	r24, 0x01	; 1
     750:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     752:	0f 90       	pop	r0
     754:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     756:	88 85       	ldd	r24, Y+8	; 0x08
     758:	99 85       	ldd	r25, Y+9	; 0x09
     75a:	90 70       	andi	r25, 0x00	; 0
     75c:	99 87       	std	Y+9, r25	; 0x09
     75e:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     760:	88 85       	ldd	r24, Y+8	; 0x08
     762:	99 85       	ldd	r25, Y+9	; 0x09
}
     764:	63 96       	adiw	r28, 0x13	; 19
     766:	0f b6       	in	r0, 0x3f	; 63
     768:	f8 94       	cli
     76a:	de bf       	out	0x3e, r29	; 62
     76c:	0f be       	out	0x3f, r0	; 63
     76e:	cd bf       	out	0x3d, r28	; 61
     770:	cf 91       	pop	r28
     772:	df 91       	pop	r29
     774:	1f 91       	pop	r17
     776:	0f 91       	pop	r16
     778:	08 95       	ret

0000077a <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     77a:	df 93       	push	r29
     77c:	cf 93       	push	r28
     77e:	cd b7       	in	r28, 0x3d	; 61
     780:	de b7       	in	r29, 0x3e	; 62
     782:	28 97       	sbiw	r28, 0x08	; 8
     784:	0f b6       	in	r0, 0x3f	; 63
     786:	f8 94       	cli
     788:	de bf       	out	0x3e, r29	; 62
     78a:	0f be       	out	0x3f, r0	; 63
     78c:	cd bf       	out	0x3d, r28	; 61
     78e:	9e 83       	std	Y+6, r25	; 0x06
     790:	8d 83       	std	Y+5, r24	; 0x05
     792:	78 87       	std	Y+8, r23	; 0x08
     794:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     796:	8d 81       	ldd	r24, Y+5	; 0x05
     798:	9e 81       	ldd	r25, Y+6	; 0x06
     79a:	9c 83       	std	Y+4, r25	; 0x04
     79c:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     79e:	0f b6       	in	r0, 0x3f	; 63
     7a0:	f8 94       	cli
     7a2:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     7a4:	eb 81       	ldd	r30, Y+3	; 0x03
     7a6:	fc 81       	ldd	r31, Y+4	; 0x04
     7a8:	80 81       	ld	r24, Z
     7aa:	91 81       	ldd	r25, Z+1	; 0x01
     7ac:	9a 83       	std	Y+2, r25	; 0x02
     7ae:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     7b0:	eb 81       	ldd	r30, Y+3	; 0x03
     7b2:	fc 81       	ldd	r31, Y+4	; 0x04
     7b4:	20 81       	ld	r18, Z
     7b6:	31 81       	ldd	r19, Z+1	; 0x01
     7b8:	8f 81       	ldd	r24, Y+7	; 0x07
     7ba:	98 85       	ldd	r25, Y+8	; 0x08
     7bc:	80 95       	com	r24
     7be:	90 95       	com	r25
     7c0:	82 23       	and	r24, r18
     7c2:	93 23       	and	r25, r19
     7c4:	eb 81       	ldd	r30, Y+3	; 0x03
     7c6:	fc 81       	ldd	r31, Y+4	; 0x04
     7c8:	91 83       	std	Z+1, r25	; 0x01
     7ca:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     7cc:	0f 90       	pop	r0
     7ce:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     7d0:	89 81       	ldd	r24, Y+1	; 0x01
     7d2:	9a 81       	ldd	r25, Y+2	; 0x02
}
     7d4:	28 96       	adiw	r28, 0x08	; 8
     7d6:	0f b6       	in	r0, 0x3f	; 63
     7d8:	f8 94       	cli
     7da:	de bf       	out	0x3e, r29	; 62
     7dc:	0f be       	out	0x3f, r0	; 63
     7de:	cd bf       	out	0x3d, r28	; 61
     7e0:	cf 91       	pop	r28
     7e2:	df 91       	pop	r29
     7e4:	08 95       	ret

000007e6 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     7e6:	df 93       	push	r29
     7e8:	cf 93       	push	r28
     7ea:	cd b7       	in	r28, 0x3d	; 61
     7ec:	de b7       	in	r29, 0x3e	; 62
     7ee:	27 97       	sbiw	r28, 0x07	; 7
     7f0:	0f b6       	in	r0, 0x3f	; 63
     7f2:	f8 94       	cli
     7f4:	de bf       	out	0x3e, r29	; 62
     7f6:	0f be       	out	0x3f, r0	; 63
     7f8:	cd bf       	out	0x3d, r28	; 61
     7fa:	9f 83       	std	Y+7, r25	; 0x07
     7fc:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     7fe:	8e 81       	ldd	r24, Y+6	; 0x06
     800:	9f 81       	ldd	r25, Y+7	; 0x07
     802:	9c 83       	std	Y+4, r25	; 0x04
     804:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     806:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     808:	eb 81       	ldd	r30, Y+3	; 0x03
     80a:	fc 81       	ldd	r31, Y+4	; 0x04
     80c:	80 81       	ld	r24, Z
     80e:	91 81       	ldd	r25, Z+1	; 0x01
     810:	9a 83       	std	Y+2, r25	; 0x02
     812:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     814:	89 81       	ldd	r24, Y+1	; 0x01
     816:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     818:	27 96       	adiw	r28, 0x07	; 7
     81a:	0f b6       	in	r0, 0x3f	; 63
     81c:	f8 94       	cli
     81e:	de bf       	out	0x3e, r29	; 62
     820:	0f be       	out	0x3f, r0	; 63
     822:	cd bf       	out	0x3d, r28	; 61
     824:	cf 91       	pop	r28
     826:	df 91       	pop	r29
     828:	08 95       	ret

0000082a <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     82a:	df 93       	push	r29
     82c:	cf 93       	push	r28
     82e:	cd b7       	in	r28, 0x3d	; 61
     830:	de b7       	in	r29, 0x3e	; 62
     832:	65 97       	sbiw	r28, 0x15	; 21
     834:	0f b6       	in	r0, 0x3f	; 63
     836:	f8 94       	cli
     838:	de bf       	out	0x3e, r29	; 62
     83a:	0f be       	out	0x3f, r0	; 63
     83c:	cd bf       	out	0x3d, r28	; 61
     83e:	9b 8b       	std	Y+19, r25	; 0x13
     840:	8a 8b       	std	Y+18, r24	; 0x12
     842:	7d 8b       	std	Y+21, r23	; 0x15
     844:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     846:	19 86       	std	Y+9, r1	; 0x09
     848:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     84a:	8a 89       	ldd	r24, Y+18	; 0x12
     84c:	9b 89       	ldd	r25, Y+19	; 0x13
     84e:	9b 83       	std	Y+3, r25	; 0x03
     850:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     852:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     854:	8a 81       	ldd	r24, Y+2	; 0x02
     856:	9b 81       	ldd	r25, Y+3	; 0x03
     858:	02 96       	adiw	r24, 0x02	; 2
     85a:	9b 87       	std	Y+11, r25	; 0x0b
     85c:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     85e:	8a 85       	ldd	r24, Y+10	; 0x0a
     860:	9b 85       	ldd	r25, Y+11	; 0x0b
     862:	03 96       	adiw	r24, 0x03	; 3
     864:	9d 87       	std	Y+13, r25	; 0x0d
     866:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     868:	0e 94 8e 1c 	call	0x391c	; 0x391c <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     86c:	ea 85       	ldd	r30, Y+10	; 0x0a
     86e:	fb 85       	ldd	r31, Y+11	; 0x0b
     870:	85 81       	ldd	r24, Z+5	; 0x05
     872:	96 81       	ldd	r25, Z+6	; 0x06
     874:	99 8b       	std	Y+17, r25	; 0x11
     876:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     878:	ea 81       	ldd	r30, Y+2	; 0x02
     87a:	fb 81       	ldd	r31, Y+3	; 0x03
     87c:	20 81       	ld	r18, Z
     87e:	31 81       	ldd	r19, Z+1	; 0x01
     880:	8c 89       	ldd	r24, Y+20	; 0x14
     882:	9d 89       	ldd	r25, Y+21	; 0x15
     884:	82 2b       	or	r24, r18
     886:	93 2b       	or	r25, r19
     888:	ea 81       	ldd	r30, Y+2	; 0x02
     88a:	fb 81       	ldd	r31, Y+3	; 0x03
     88c:	91 83       	std	Z+1, r25	; 0x01
     88e:	80 83       	st	Z, r24
     890:	59 c0       	rjmp	.+178    	; 0x944 <__stack+0xe5>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     892:	e8 89       	ldd	r30, Y+16	; 0x10
     894:	f9 89       	ldd	r31, Y+17	; 0x11
     896:	82 81       	ldd	r24, Z+2	; 0x02
     898:	93 81       	ldd	r25, Z+3	; 0x03
     89a:	9f 87       	std	Y+15, r25	; 0x0f
     89c:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     89e:	e8 89       	ldd	r30, Y+16	; 0x10
     8a0:	f9 89       	ldd	r31, Y+17	; 0x11
     8a2:	80 81       	ld	r24, Z
     8a4:	91 81       	ldd	r25, Z+1	; 0x01
     8a6:	9f 83       	std	Y+7, r25	; 0x07
     8a8:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     8aa:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     8ac:	8e 81       	ldd	r24, Y+6	; 0x06
     8ae:	9f 81       	ldd	r25, Y+7	; 0x07
     8b0:	80 70       	andi	r24, 0x00	; 0
     8b2:	9d 83       	std	Y+5, r25	; 0x05
     8b4:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     8b6:	8e 81       	ldd	r24, Y+6	; 0x06
     8b8:	9f 81       	ldd	r25, Y+7	; 0x07
     8ba:	90 70       	andi	r25, 0x00	; 0
     8bc:	9f 83       	std	Y+7, r25	; 0x07
     8be:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     8c0:	8c 81       	ldd	r24, Y+4	; 0x04
     8c2:	9d 81       	ldd	r25, Y+5	; 0x05
     8c4:	80 70       	andi	r24, 0x00	; 0
     8c6:	94 70       	andi	r25, 0x04	; 4
     8c8:	00 97       	sbiw	r24, 0x00	; 0
     8ca:	69 f4       	brne	.+26     	; 0x8e6 <__stack+0x87>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     8cc:	ea 81       	ldd	r30, Y+2	; 0x02
     8ce:	fb 81       	ldd	r31, Y+3	; 0x03
     8d0:	20 81       	ld	r18, Z
     8d2:	31 81       	ldd	r19, Z+1	; 0x01
     8d4:	8e 81       	ldd	r24, Y+6	; 0x06
     8d6:	9f 81       	ldd	r25, Y+7	; 0x07
     8d8:	82 23       	and	r24, r18
     8da:	93 23       	and	r25, r19
     8dc:	00 97       	sbiw	r24, 0x00	; 0
     8de:	91 f0       	breq	.+36     	; 0x904 <__stack+0xa5>
				{
					xMatchFound = pdTRUE;
     8e0:	81 e0       	ldi	r24, 0x01	; 1
     8e2:	89 83       	std	Y+1, r24	; 0x01
     8e4:	0f c0       	rjmp	.+30     	; 0x904 <__stack+0xa5>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     8e6:	ea 81       	ldd	r30, Y+2	; 0x02
     8e8:	fb 81       	ldd	r31, Y+3	; 0x03
     8ea:	20 81       	ld	r18, Z
     8ec:	31 81       	ldd	r19, Z+1	; 0x01
     8ee:	8e 81       	ldd	r24, Y+6	; 0x06
     8f0:	9f 81       	ldd	r25, Y+7	; 0x07
     8f2:	28 23       	and	r18, r24
     8f4:	39 23       	and	r19, r25
     8f6:	8e 81       	ldd	r24, Y+6	; 0x06
     8f8:	9f 81       	ldd	r25, Y+7	; 0x07
     8fa:	28 17       	cp	r18, r24
     8fc:	39 07       	cpc	r19, r25
     8fe:	11 f4       	brne	.+4      	; 0x904 <__stack+0xa5>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     904:	89 81       	ldd	r24, Y+1	; 0x01
     906:	88 23       	and	r24, r24
     908:	c9 f0       	breq	.+50     	; 0x93c <__stack+0xdd>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     90a:	8c 81       	ldd	r24, Y+4	; 0x04
     90c:	9d 81       	ldd	r25, Y+5	; 0x05
     90e:	80 70       	andi	r24, 0x00	; 0
     910:	91 70       	andi	r25, 0x01	; 1
     912:	00 97       	sbiw	r24, 0x00	; 0
     914:	41 f0       	breq	.+16     	; 0x926 <__stack+0xc7>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     916:	88 85       	ldd	r24, Y+8	; 0x08
     918:	99 85       	ldd	r25, Y+9	; 0x09
     91a:	2e 81       	ldd	r18, Y+6	; 0x06
     91c:	3f 81       	ldd	r19, Y+7	; 0x07
     91e:	82 2b       	or	r24, r18
     920:	93 2b       	or	r25, r19
     922:	99 87       	std	Y+9, r25	; 0x09
     924:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     926:	ea 81       	ldd	r30, Y+2	; 0x02
     928:	fb 81       	ldd	r31, Y+3	; 0x03
     92a:	80 81       	ld	r24, Z
     92c:	91 81       	ldd	r25, Z+1	; 0x01
     92e:	9c 01       	movw	r18, r24
     930:	32 60       	ori	r19, 0x02	; 2
     932:	88 89       	ldd	r24, Y+16	; 0x10
     934:	99 89       	ldd	r25, Y+17	; 0x11
     936:	b9 01       	movw	r22, r18
     938:	0e 94 69 1f 	call	0x3ed2	; 0x3ed2 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     93c:	8e 85       	ldd	r24, Y+14	; 0x0e
     93e:	9f 85       	ldd	r25, Y+15	; 0x0f
     940:	99 8b       	std	Y+17, r25	; 0x11
     942:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     944:	28 89       	ldd	r18, Y+16	; 0x10
     946:	39 89       	ldd	r19, Y+17	; 0x11
     948:	8c 85       	ldd	r24, Y+12	; 0x0c
     94a:	9d 85       	ldd	r25, Y+13	; 0x0d
     94c:	28 17       	cp	r18, r24
     94e:	39 07       	cpc	r19, r25
     950:	09 f0       	breq	.+2      	; 0x954 <__stack+0xf5>
     952:	9f cf       	rjmp	.-194    	; 0x892 <__stack+0x33>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     954:	ea 81       	ldd	r30, Y+2	; 0x02
     956:	fb 81       	ldd	r31, Y+3	; 0x03
     958:	20 81       	ld	r18, Z
     95a:	31 81       	ldd	r19, Z+1	; 0x01
     95c:	88 85       	ldd	r24, Y+8	; 0x08
     95e:	99 85       	ldd	r25, Y+9	; 0x09
     960:	80 95       	com	r24
     962:	90 95       	com	r25
     964:	82 23       	and	r24, r18
     966:	93 23       	and	r25, r19
     968:	ea 81       	ldd	r30, Y+2	; 0x02
     96a:	fb 81       	ldd	r31, Y+3	; 0x03
     96c:	91 83       	std	Z+1, r25	; 0x01
     96e:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     970:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     974:	ea 81       	ldd	r30, Y+2	; 0x02
     976:	fb 81       	ldd	r31, Y+3	; 0x03
     978:	80 81       	ld	r24, Z
     97a:	91 81       	ldd	r25, Z+1	; 0x01
}
     97c:	65 96       	adiw	r28, 0x15	; 21
     97e:	0f b6       	in	r0, 0x3f	; 63
     980:	f8 94       	cli
     982:	de bf       	out	0x3e, r29	; 62
     984:	0f be       	out	0x3f, r0	; 63
     986:	cd bf       	out	0x3d, r28	; 61
     988:	cf 91       	pop	r28
     98a:	df 91       	pop	r29
     98c:	08 95       	ret

0000098e <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     98e:	df 93       	push	r29
     990:	cf 93       	push	r28
     992:	00 d0       	rcall	.+0      	; 0x994 <vEventGroupDelete+0x6>
     994:	00 d0       	rcall	.+0      	; 0x996 <vEventGroupDelete+0x8>
     996:	00 d0       	rcall	.+0      	; 0x998 <vEventGroupDelete+0xa>
     998:	cd b7       	in	r28, 0x3d	; 61
     99a:	de b7       	in	r29, 0x3e	; 62
     99c:	9e 83       	std	Y+6, r25	; 0x06
     99e:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
     9a0:	8d 81       	ldd	r24, Y+5	; 0x05
     9a2:	9e 81       	ldd	r25, Y+6	; 0x06
     9a4:	9c 83       	std	Y+4, r25	; 0x04
     9a6:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     9a8:	8b 81       	ldd	r24, Y+3	; 0x03
     9aa:	9c 81       	ldd	r25, Y+4	; 0x04
     9ac:	02 96       	adiw	r24, 0x02	; 2
     9ae:	9a 83       	std	Y+2, r25	; 0x02
     9b0:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     9b2:	0e 94 8e 1c 	call	0x391c	; 0x391c <vTaskSuspendAll>
     9b6:	08 c0       	rjmp	.+16     	; 0x9c8 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     9b8:	e9 81       	ldd	r30, Y+1	; 0x01
     9ba:	fa 81       	ldd	r31, Y+2	; 0x02
     9bc:	85 81       	ldd	r24, Z+5	; 0x05
     9be:	96 81       	ldd	r25, Z+6	; 0x06
     9c0:	60 e0       	ldi	r22, 0x00	; 0
     9c2:	72 e0       	ldi	r23, 0x02	; 2
     9c4:	0e 94 69 1f 	call	0x3ed2	; 0x3ed2 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     9c8:	e9 81       	ldd	r30, Y+1	; 0x01
     9ca:	fa 81       	ldd	r31, Y+2	; 0x02
     9cc:	80 81       	ld	r24, Z
     9ce:	88 23       	and	r24, r24
     9d0:	99 f7       	brne	.-26     	; 0x9b8 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     9d2:	8b 81       	ldd	r24, Y+3	; 0x03
     9d4:	9c 81       	ldd	r25, Y+4	; 0x04
     9d6:	0e 94 ba 05 	call	0xb74	; 0xb74 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     9da:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>
}
     9de:	26 96       	adiw	r28, 0x06	; 6
     9e0:	0f b6       	in	r0, 0x3f	; 63
     9e2:	f8 94       	cli
     9e4:	de bf       	out	0x3e, r29	; 62
     9e6:	0f be       	out	0x3f, r0	; 63
     9e8:	cd bf       	out	0x3d, r28	; 61
     9ea:	cf 91       	pop	r28
     9ec:	df 91       	pop	r29
     9ee:	08 95       	ret

000009f0 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     9f0:	df 93       	push	r29
     9f2:	cf 93       	push	r28
     9f4:	00 d0       	rcall	.+0      	; 0x9f6 <vEventGroupSetBitsCallback+0x6>
     9f6:	00 d0       	rcall	.+0      	; 0x9f8 <vEventGroupSetBitsCallback+0x8>
     9f8:	00 d0       	rcall	.+0      	; 0x9fa <vEventGroupSetBitsCallback+0xa>
     9fa:	cd b7       	in	r28, 0x3d	; 61
     9fc:	de b7       	in	r29, 0x3e	; 62
     9fe:	9a 83       	std	Y+2, r25	; 0x02
     a00:	89 83       	std	Y+1, r24	; 0x01
     a02:	4b 83       	std	Y+3, r20	; 0x03
     a04:	5c 83       	std	Y+4, r21	; 0x04
     a06:	6d 83       	std	Y+5, r22	; 0x05
     a08:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     a0a:	89 81       	ldd	r24, Y+1	; 0x01
     a0c:	9a 81       	ldd	r25, Y+2	; 0x02
     a0e:	2b 81       	ldd	r18, Y+3	; 0x03
     a10:	3c 81       	ldd	r19, Y+4	; 0x04
     a12:	b9 01       	movw	r22, r18
     a14:	0e 94 15 04 	call	0x82a	; 0x82a <xEventGroupSetBits>
}
     a18:	26 96       	adiw	r28, 0x06	; 6
     a1a:	0f b6       	in	r0, 0x3f	; 63
     a1c:	f8 94       	cli
     a1e:	de bf       	out	0x3e, r29	; 62
     a20:	0f be       	out	0x3f, r0	; 63
     a22:	cd bf       	out	0x3d, r28	; 61
     a24:	cf 91       	pop	r28
     a26:	df 91       	pop	r29
     a28:	08 95       	ret

00000a2a <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     a2a:	df 93       	push	r29
     a2c:	cf 93       	push	r28
     a2e:	00 d0       	rcall	.+0      	; 0xa30 <vEventGroupClearBitsCallback+0x6>
     a30:	00 d0       	rcall	.+0      	; 0xa32 <vEventGroupClearBitsCallback+0x8>
     a32:	00 d0       	rcall	.+0      	; 0xa34 <vEventGroupClearBitsCallback+0xa>
     a34:	cd b7       	in	r28, 0x3d	; 61
     a36:	de b7       	in	r29, 0x3e	; 62
     a38:	9a 83       	std	Y+2, r25	; 0x02
     a3a:	89 83       	std	Y+1, r24	; 0x01
     a3c:	4b 83       	std	Y+3, r20	; 0x03
     a3e:	5c 83       	std	Y+4, r21	; 0x04
     a40:	6d 83       	std	Y+5, r22	; 0x05
     a42:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     a44:	89 81       	ldd	r24, Y+1	; 0x01
     a46:	9a 81       	ldd	r25, Y+2	; 0x02
     a48:	2b 81       	ldd	r18, Y+3	; 0x03
     a4a:	3c 81       	ldd	r19, Y+4	; 0x04
     a4c:	b9 01       	movw	r22, r18
     a4e:	0e 94 bd 03 	call	0x77a	; 0x77a <xEventGroupClearBits>
}
     a52:	26 96       	adiw	r28, 0x06	; 6
     a54:	0f b6       	in	r0, 0x3f	; 63
     a56:	f8 94       	cli
     a58:	de bf       	out	0x3e, r29	; 62
     a5a:	0f be       	out	0x3f, r0	; 63
     a5c:	cd bf       	out	0x3d, r28	; 61
     a5e:	cf 91       	pop	r28
     a60:	df 91       	pop	r29
     a62:	08 95       	ret

00000a64 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     a64:	df 93       	push	r29
     a66:	cf 93       	push	r28
     a68:	00 d0       	rcall	.+0      	; 0xa6a <prvTestWaitCondition+0x6>
     a6a:	00 d0       	rcall	.+0      	; 0xa6c <prvTestWaitCondition+0x8>
     a6c:	00 d0       	rcall	.+0      	; 0xa6e <prvTestWaitCondition+0xa>
     a6e:	cd b7       	in	r28, 0x3d	; 61
     a70:	de b7       	in	r29, 0x3e	; 62
     a72:	9b 83       	std	Y+3, r25	; 0x03
     a74:	8a 83       	std	Y+2, r24	; 0x02
     a76:	7d 83       	std	Y+5, r23	; 0x05
     a78:	6c 83       	std	Y+4, r22	; 0x04
     a7a:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     a7c:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     a7e:	8e 81       	ldd	r24, Y+6	; 0x06
     a80:	88 23       	and	r24, r24
     a82:	59 f4       	brne	.+22     	; 0xa9a <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     a84:	8a 81       	ldd	r24, Y+2	; 0x02
     a86:	9b 81       	ldd	r25, Y+3	; 0x03
     a88:	2c 81       	ldd	r18, Y+4	; 0x04
     a8a:	3d 81       	ldd	r19, Y+5	; 0x05
     a8c:	82 23       	and	r24, r18
     a8e:	93 23       	and	r25, r19
     a90:	00 97       	sbiw	r24, 0x00	; 0
     a92:	81 f0       	breq	.+32     	; 0xab4 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     a94:	81 e0       	ldi	r24, 0x01	; 1
     a96:	89 83       	std	Y+1, r24	; 0x01
     a98:	0d c0       	rjmp	.+26     	; 0xab4 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     a9a:	2a 81       	ldd	r18, Y+2	; 0x02
     a9c:	3b 81       	ldd	r19, Y+3	; 0x03
     a9e:	8c 81       	ldd	r24, Y+4	; 0x04
     aa0:	9d 81       	ldd	r25, Y+5	; 0x05
     aa2:	28 23       	and	r18, r24
     aa4:	39 23       	and	r19, r25
     aa6:	8c 81       	ldd	r24, Y+4	; 0x04
     aa8:	9d 81       	ldd	r25, Y+5	; 0x05
     aaa:	28 17       	cp	r18, r24
     aac:	39 07       	cpc	r19, r25
     aae:	11 f4       	brne	.+4      	; 0xab4 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     ab0:	81 e0       	ldi	r24, 0x01	; 1
     ab2:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     ab4:	89 81       	ldd	r24, Y+1	; 0x01
}
     ab6:	26 96       	adiw	r28, 0x06	; 6
     ab8:	0f b6       	in	r0, 0x3f	; 63
     aba:	f8 94       	cli
     abc:	de bf       	out	0x3e, r29	; 62
     abe:	0f be       	out	0x3f, r0	; 63
     ac0:	cd bf       	out	0x3d, r28	; 61
     ac2:	cf 91       	pop	r28
     ac4:	df 91       	pop	r29
     ac6:	08 95       	ret

00000ac8 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     ac8:	df 93       	push	r29
     aca:	cf 93       	push	r28
     acc:	00 d0       	rcall	.+0      	; 0xace <pvPortMalloc+0x6>
     ace:	00 d0       	rcall	.+0      	; 0xad0 <pvPortMalloc+0x8>
     ad0:	cd b7       	in	r28, 0x3d	; 61
     ad2:	de b7       	in	r29, 0x3e	; 62
     ad4:	9c 83       	std	Y+4, r25	; 0x04
     ad6:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     ad8:	1a 82       	std	Y+2, r1	; 0x02
     ada:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     adc:	0e 94 8e 1c 	call	0x391c	; 0x391c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     ae0:	80 91 76 01 	lds	r24, 0x0176
     ae4:	90 91 77 01 	lds	r25, 0x0177
     ae8:	00 97       	sbiw	r24, 0x00	; 0
     aea:	31 f4       	brne	.+12     	; 0xaf8 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     aec:	89 e7       	ldi	r24, 0x79	; 121
     aee:	91 e0       	ldi	r25, 0x01	; 1
     af0:	90 93 77 01 	sts	0x0177, r25
     af4:	80 93 76 01 	sts	0x0176, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     af8:	80 91 74 01 	lds	r24, 0x0174
     afc:	90 91 75 01 	lds	r25, 0x0175
     b00:	2b 81       	ldd	r18, Y+3	; 0x03
     b02:	3c 81       	ldd	r19, Y+4	; 0x04
     b04:	82 0f       	add	r24, r18
     b06:	93 1f       	adc	r25, r19
     b08:	25 e0       	ldi	r18, 0x05	; 5
     b0a:	8b 3d       	cpi	r24, 0xDB	; 219
     b0c:	92 07       	cpc	r25, r18
     b0e:	38 f5       	brcc	.+78     	; 0xb5e <pvPortMalloc+0x96>
     b10:	20 91 74 01 	lds	r18, 0x0174
     b14:	30 91 75 01 	lds	r19, 0x0175
     b18:	8b 81       	ldd	r24, Y+3	; 0x03
     b1a:	9c 81       	ldd	r25, Y+4	; 0x04
     b1c:	28 0f       	add	r18, r24
     b1e:	39 1f       	adc	r19, r25
     b20:	80 91 74 01 	lds	r24, 0x0174
     b24:	90 91 75 01 	lds	r25, 0x0175
     b28:	82 17       	cp	r24, r18
     b2a:	93 07       	cpc	r25, r19
     b2c:	c0 f4       	brcc	.+48     	; 0xb5e <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     b2e:	20 91 76 01 	lds	r18, 0x0176
     b32:	30 91 77 01 	lds	r19, 0x0177
     b36:	80 91 74 01 	lds	r24, 0x0174
     b3a:	90 91 75 01 	lds	r25, 0x0175
     b3e:	82 0f       	add	r24, r18
     b40:	93 1f       	adc	r25, r19
     b42:	9a 83       	std	Y+2, r25	; 0x02
     b44:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     b46:	20 91 74 01 	lds	r18, 0x0174
     b4a:	30 91 75 01 	lds	r19, 0x0175
     b4e:	8b 81       	ldd	r24, Y+3	; 0x03
     b50:	9c 81       	ldd	r25, Y+4	; 0x04
     b52:	82 0f       	add	r24, r18
     b54:	93 1f       	adc	r25, r19
     b56:	90 93 75 01 	sts	0x0175, r25
     b5a:	80 93 74 01 	sts	0x0174, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     b5e:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     b62:	89 81       	ldd	r24, Y+1	; 0x01
     b64:	9a 81       	ldd	r25, Y+2	; 0x02
}
     b66:	0f 90       	pop	r0
     b68:	0f 90       	pop	r0
     b6a:	0f 90       	pop	r0
     b6c:	0f 90       	pop	r0
     b6e:	cf 91       	pop	r28
     b70:	df 91       	pop	r29
     b72:	08 95       	ret

00000b74 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     b74:	df 93       	push	r29
     b76:	cf 93       	push	r28
     b78:	00 d0       	rcall	.+0      	; 0xb7a <vPortFree+0x6>
     b7a:	cd b7       	in	r28, 0x3d	; 61
     b7c:	de b7       	in	r29, 0x3e	; 62
     b7e:	9a 83       	std	Y+2, r25	; 0x02
     b80:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     b82:	0f 90       	pop	r0
     b84:	0f 90       	pop	r0
     b86:	cf 91       	pop	r28
     b88:	df 91       	pop	r29
     b8a:	08 95       	ret

00000b8c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     b8c:	df 93       	push	r29
     b8e:	cf 93       	push	r28
     b90:	cd b7       	in	r28, 0x3d	; 61
     b92:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     b94:	10 92 75 01 	sts	0x0175, r1
     b98:	10 92 74 01 	sts	0x0174, r1
}
     b9c:	cf 91       	pop	r28
     b9e:	df 91       	pop	r29
     ba0:	08 95       	ret

00000ba2 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     ba2:	df 93       	push	r29
     ba4:	cf 93       	push	r28
     ba6:	cd b7       	in	r28, 0x3d	; 61
     ba8:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     baa:	20 91 74 01 	lds	r18, 0x0174
     bae:	30 91 75 01 	lds	r19, 0x0175
     bb2:	8b ed       	ldi	r24, 0xDB	; 219
     bb4:	95 e0       	ldi	r25, 0x05	; 5
     bb6:	82 1b       	sub	r24, r18
     bb8:	93 0b       	sbc	r25, r19
}
     bba:	cf 91       	pop	r28
     bbc:	df 91       	pop	r29
     bbe:	08 95       	ret

00000bc0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     bc0:	df 93       	push	r29
     bc2:	cf 93       	push	r28
     bc4:	00 d0       	rcall	.+0      	; 0xbc6 <vListInitialise+0x6>
     bc6:	cd b7       	in	r28, 0x3d	; 61
     bc8:	de b7       	in	r29, 0x3e	; 62
     bca:	9a 83       	std	Y+2, r25	; 0x02
     bcc:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     bce:	89 81       	ldd	r24, Y+1	; 0x01
     bd0:	9a 81       	ldd	r25, Y+2	; 0x02
     bd2:	03 96       	adiw	r24, 0x03	; 3
     bd4:	e9 81       	ldd	r30, Y+1	; 0x01
     bd6:	fa 81       	ldd	r31, Y+2	; 0x02
     bd8:	92 83       	std	Z+2, r25	; 0x02
     bda:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     bdc:	e9 81       	ldd	r30, Y+1	; 0x01
     bde:	fa 81       	ldd	r31, Y+2	; 0x02
     be0:	8f ef       	ldi	r24, 0xFF	; 255
     be2:	9f ef       	ldi	r25, 0xFF	; 255
     be4:	94 83       	std	Z+4, r25	; 0x04
     be6:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     be8:	89 81       	ldd	r24, Y+1	; 0x01
     bea:	9a 81       	ldd	r25, Y+2	; 0x02
     bec:	03 96       	adiw	r24, 0x03	; 3
     bee:	e9 81       	ldd	r30, Y+1	; 0x01
     bf0:	fa 81       	ldd	r31, Y+2	; 0x02
     bf2:	96 83       	std	Z+6, r25	; 0x06
     bf4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     bf6:	89 81       	ldd	r24, Y+1	; 0x01
     bf8:	9a 81       	ldd	r25, Y+2	; 0x02
     bfa:	03 96       	adiw	r24, 0x03	; 3
     bfc:	e9 81       	ldd	r30, Y+1	; 0x01
     bfe:	fa 81       	ldd	r31, Y+2	; 0x02
     c00:	90 87       	std	Z+8, r25	; 0x08
     c02:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     c04:	e9 81       	ldd	r30, Y+1	; 0x01
     c06:	fa 81       	ldd	r31, Y+2	; 0x02
     c08:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     c0a:	0f 90       	pop	r0
     c0c:	0f 90       	pop	r0
     c0e:	cf 91       	pop	r28
     c10:	df 91       	pop	r29
     c12:	08 95       	ret

00000c14 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     c14:	df 93       	push	r29
     c16:	cf 93       	push	r28
     c18:	00 d0       	rcall	.+0      	; 0xc1a <vListInitialiseItem+0x6>
     c1a:	cd b7       	in	r28, 0x3d	; 61
     c1c:	de b7       	in	r29, 0x3e	; 62
     c1e:	9a 83       	std	Y+2, r25	; 0x02
     c20:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     c22:	e9 81       	ldd	r30, Y+1	; 0x01
     c24:	fa 81       	ldd	r31, Y+2	; 0x02
     c26:	11 86       	std	Z+9, r1	; 0x09
     c28:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     c2a:	0f 90       	pop	r0
     c2c:	0f 90       	pop	r0
     c2e:	cf 91       	pop	r28
     c30:	df 91       	pop	r29
     c32:	08 95       	ret

00000c34 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     c34:	df 93       	push	r29
     c36:	cf 93       	push	r28
     c38:	00 d0       	rcall	.+0      	; 0xc3a <vListInsertEnd+0x6>
     c3a:	00 d0       	rcall	.+0      	; 0xc3c <vListInsertEnd+0x8>
     c3c:	00 d0       	rcall	.+0      	; 0xc3e <vListInsertEnd+0xa>
     c3e:	cd b7       	in	r28, 0x3d	; 61
     c40:	de b7       	in	r29, 0x3e	; 62
     c42:	9c 83       	std	Y+4, r25	; 0x04
     c44:	8b 83       	std	Y+3, r24	; 0x03
     c46:	7e 83       	std	Y+6, r23	; 0x06
     c48:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     c4a:	eb 81       	ldd	r30, Y+3	; 0x03
     c4c:	fc 81       	ldd	r31, Y+4	; 0x04
     c4e:	81 81       	ldd	r24, Z+1	; 0x01
     c50:	92 81       	ldd	r25, Z+2	; 0x02
     c52:	9a 83       	std	Y+2, r25	; 0x02
     c54:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     c56:	ed 81       	ldd	r30, Y+5	; 0x05
     c58:	fe 81       	ldd	r31, Y+6	; 0x06
     c5a:	89 81       	ldd	r24, Y+1	; 0x01
     c5c:	9a 81       	ldd	r25, Y+2	; 0x02
     c5e:	93 83       	std	Z+3, r25	; 0x03
     c60:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     c62:	e9 81       	ldd	r30, Y+1	; 0x01
     c64:	fa 81       	ldd	r31, Y+2	; 0x02
     c66:	84 81       	ldd	r24, Z+4	; 0x04
     c68:	95 81       	ldd	r25, Z+5	; 0x05
     c6a:	ed 81       	ldd	r30, Y+5	; 0x05
     c6c:	fe 81       	ldd	r31, Y+6	; 0x06
     c6e:	95 83       	std	Z+5, r25	; 0x05
     c70:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     c72:	e9 81       	ldd	r30, Y+1	; 0x01
     c74:	fa 81       	ldd	r31, Y+2	; 0x02
     c76:	04 80       	ldd	r0, Z+4	; 0x04
     c78:	f5 81       	ldd	r31, Z+5	; 0x05
     c7a:	e0 2d       	mov	r30, r0
     c7c:	8d 81       	ldd	r24, Y+5	; 0x05
     c7e:	9e 81       	ldd	r25, Y+6	; 0x06
     c80:	93 83       	std	Z+3, r25	; 0x03
     c82:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     c84:	e9 81       	ldd	r30, Y+1	; 0x01
     c86:	fa 81       	ldd	r31, Y+2	; 0x02
     c88:	8d 81       	ldd	r24, Y+5	; 0x05
     c8a:	9e 81       	ldd	r25, Y+6	; 0x06
     c8c:	95 83       	std	Z+5, r25	; 0x05
     c8e:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     c90:	ed 81       	ldd	r30, Y+5	; 0x05
     c92:	fe 81       	ldd	r31, Y+6	; 0x06
     c94:	8b 81       	ldd	r24, Y+3	; 0x03
     c96:	9c 81       	ldd	r25, Y+4	; 0x04
     c98:	91 87       	std	Z+9, r25	; 0x09
     c9a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     c9c:	eb 81       	ldd	r30, Y+3	; 0x03
     c9e:	fc 81       	ldd	r31, Y+4	; 0x04
     ca0:	80 81       	ld	r24, Z
     ca2:	8f 5f       	subi	r24, 0xFF	; 255
     ca4:	eb 81       	ldd	r30, Y+3	; 0x03
     ca6:	fc 81       	ldd	r31, Y+4	; 0x04
     ca8:	80 83       	st	Z, r24
}
     caa:	26 96       	adiw	r28, 0x06	; 6
     cac:	0f b6       	in	r0, 0x3f	; 63
     cae:	f8 94       	cli
     cb0:	de bf       	out	0x3e, r29	; 62
     cb2:	0f be       	out	0x3f, r0	; 63
     cb4:	cd bf       	out	0x3d, r28	; 61
     cb6:	cf 91       	pop	r28
     cb8:	df 91       	pop	r29
     cba:	08 95       	ret

00000cbc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     cbc:	df 93       	push	r29
     cbe:	cf 93       	push	r28
     cc0:	cd b7       	in	r28, 0x3d	; 61
     cc2:	de b7       	in	r29, 0x3e	; 62
     cc4:	28 97       	sbiw	r28, 0x08	; 8
     cc6:	0f b6       	in	r0, 0x3f	; 63
     cc8:	f8 94       	cli
     cca:	de bf       	out	0x3e, r29	; 62
     ccc:	0f be       	out	0x3f, r0	; 63
     cce:	cd bf       	out	0x3d, r28	; 61
     cd0:	9e 83       	std	Y+6, r25	; 0x06
     cd2:	8d 83       	std	Y+5, r24	; 0x05
     cd4:	78 87       	std	Y+8, r23	; 0x08
     cd6:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     cd8:	ef 81       	ldd	r30, Y+7	; 0x07
     cda:	f8 85       	ldd	r31, Y+8	; 0x08
     cdc:	80 81       	ld	r24, Z
     cde:	91 81       	ldd	r25, Z+1	; 0x01
     ce0:	9a 83       	std	Y+2, r25	; 0x02
     ce2:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     ce4:	89 81       	ldd	r24, Y+1	; 0x01
     ce6:	9a 81       	ldd	r25, Y+2	; 0x02
     ce8:	2f ef       	ldi	r18, 0xFF	; 255
     cea:	8f 3f       	cpi	r24, 0xFF	; 255
     cec:	92 07       	cpc	r25, r18
     cee:	39 f4       	brne	.+14     	; 0xcfe <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     cf0:	ed 81       	ldd	r30, Y+5	; 0x05
     cf2:	fe 81       	ldd	r31, Y+6	; 0x06
     cf4:	87 81       	ldd	r24, Z+7	; 0x07
     cf6:	90 85       	ldd	r25, Z+8	; 0x08
     cf8:	9c 83       	std	Y+4, r25	; 0x04
     cfa:	8b 83       	std	Y+3, r24	; 0x03
     cfc:	18 c0       	rjmp	.+48     	; 0xd2e <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     cfe:	8d 81       	ldd	r24, Y+5	; 0x05
     d00:	9e 81       	ldd	r25, Y+6	; 0x06
     d02:	03 96       	adiw	r24, 0x03	; 3
     d04:	9c 83       	std	Y+4, r25	; 0x04
     d06:	8b 83       	std	Y+3, r24	; 0x03
     d08:	06 c0       	rjmp	.+12     	; 0xd16 <vListInsert+0x5a>
     d0a:	eb 81       	ldd	r30, Y+3	; 0x03
     d0c:	fc 81       	ldd	r31, Y+4	; 0x04
     d0e:	82 81       	ldd	r24, Z+2	; 0x02
     d10:	93 81       	ldd	r25, Z+3	; 0x03
     d12:	9c 83       	std	Y+4, r25	; 0x04
     d14:	8b 83       	std	Y+3, r24	; 0x03
     d16:	eb 81       	ldd	r30, Y+3	; 0x03
     d18:	fc 81       	ldd	r31, Y+4	; 0x04
     d1a:	02 80       	ldd	r0, Z+2	; 0x02
     d1c:	f3 81       	ldd	r31, Z+3	; 0x03
     d1e:	e0 2d       	mov	r30, r0
     d20:	20 81       	ld	r18, Z
     d22:	31 81       	ldd	r19, Z+1	; 0x01
     d24:	89 81       	ldd	r24, Y+1	; 0x01
     d26:	9a 81       	ldd	r25, Y+2	; 0x02
     d28:	82 17       	cp	r24, r18
     d2a:	93 07       	cpc	r25, r19
     d2c:	70 f7       	brcc	.-36     	; 0xd0a <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     d2e:	eb 81       	ldd	r30, Y+3	; 0x03
     d30:	fc 81       	ldd	r31, Y+4	; 0x04
     d32:	82 81       	ldd	r24, Z+2	; 0x02
     d34:	93 81       	ldd	r25, Z+3	; 0x03
     d36:	ef 81       	ldd	r30, Y+7	; 0x07
     d38:	f8 85       	ldd	r31, Y+8	; 0x08
     d3a:	93 83       	std	Z+3, r25	; 0x03
     d3c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     d3e:	ef 81       	ldd	r30, Y+7	; 0x07
     d40:	f8 85       	ldd	r31, Y+8	; 0x08
     d42:	02 80       	ldd	r0, Z+2	; 0x02
     d44:	f3 81       	ldd	r31, Z+3	; 0x03
     d46:	e0 2d       	mov	r30, r0
     d48:	8f 81       	ldd	r24, Y+7	; 0x07
     d4a:	98 85       	ldd	r25, Y+8	; 0x08
     d4c:	95 83       	std	Z+5, r25	; 0x05
     d4e:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     d50:	ef 81       	ldd	r30, Y+7	; 0x07
     d52:	f8 85       	ldd	r31, Y+8	; 0x08
     d54:	8b 81       	ldd	r24, Y+3	; 0x03
     d56:	9c 81       	ldd	r25, Y+4	; 0x04
     d58:	95 83       	std	Z+5, r25	; 0x05
     d5a:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
     d5c:	eb 81       	ldd	r30, Y+3	; 0x03
     d5e:	fc 81       	ldd	r31, Y+4	; 0x04
     d60:	8f 81       	ldd	r24, Y+7	; 0x07
     d62:	98 85       	ldd	r25, Y+8	; 0x08
     d64:	93 83       	std	Z+3, r25	; 0x03
     d66:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     d68:	ef 81       	ldd	r30, Y+7	; 0x07
     d6a:	f8 85       	ldd	r31, Y+8	; 0x08
     d6c:	8d 81       	ldd	r24, Y+5	; 0x05
     d6e:	9e 81       	ldd	r25, Y+6	; 0x06
     d70:	91 87       	std	Z+9, r25	; 0x09
     d72:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     d74:	ed 81       	ldd	r30, Y+5	; 0x05
     d76:	fe 81       	ldd	r31, Y+6	; 0x06
     d78:	80 81       	ld	r24, Z
     d7a:	8f 5f       	subi	r24, 0xFF	; 255
     d7c:	ed 81       	ldd	r30, Y+5	; 0x05
     d7e:	fe 81       	ldd	r31, Y+6	; 0x06
     d80:	80 83       	st	Z, r24
}
     d82:	28 96       	adiw	r28, 0x08	; 8
     d84:	0f b6       	in	r0, 0x3f	; 63
     d86:	f8 94       	cli
     d88:	de bf       	out	0x3e, r29	; 62
     d8a:	0f be       	out	0x3f, r0	; 63
     d8c:	cd bf       	out	0x3d, r28	; 61
     d8e:	cf 91       	pop	r28
     d90:	df 91       	pop	r29
     d92:	08 95       	ret

00000d94 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     d94:	df 93       	push	r29
     d96:	cf 93       	push	r28
     d98:	00 d0       	rcall	.+0      	; 0xd9a <uxListRemove+0x6>
     d9a:	00 d0       	rcall	.+0      	; 0xd9c <uxListRemove+0x8>
     d9c:	cd b7       	in	r28, 0x3d	; 61
     d9e:	de b7       	in	r29, 0x3e	; 62
     da0:	9c 83       	std	Y+4, r25	; 0x04
     da2:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     da4:	eb 81       	ldd	r30, Y+3	; 0x03
     da6:	fc 81       	ldd	r31, Y+4	; 0x04
     da8:	80 85       	ldd	r24, Z+8	; 0x08
     daa:	91 85       	ldd	r25, Z+9	; 0x09
     dac:	9a 83       	std	Y+2, r25	; 0x02
     dae:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     db0:	eb 81       	ldd	r30, Y+3	; 0x03
     db2:	fc 81       	ldd	r31, Y+4	; 0x04
     db4:	a2 81       	ldd	r26, Z+2	; 0x02
     db6:	b3 81       	ldd	r27, Z+3	; 0x03
     db8:	eb 81       	ldd	r30, Y+3	; 0x03
     dba:	fc 81       	ldd	r31, Y+4	; 0x04
     dbc:	84 81       	ldd	r24, Z+4	; 0x04
     dbe:	95 81       	ldd	r25, Z+5	; 0x05
     dc0:	15 96       	adiw	r26, 0x05	; 5
     dc2:	9c 93       	st	X, r25
     dc4:	8e 93       	st	-X, r24
     dc6:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     dc8:	eb 81       	ldd	r30, Y+3	; 0x03
     dca:	fc 81       	ldd	r31, Y+4	; 0x04
     dcc:	a4 81       	ldd	r26, Z+4	; 0x04
     dce:	b5 81       	ldd	r27, Z+5	; 0x05
     dd0:	eb 81       	ldd	r30, Y+3	; 0x03
     dd2:	fc 81       	ldd	r31, Y+4	; 0x04
     dd4:	82 81       	ldd	r24, Z+2	; 0x02
     dd6:	93 81       	ldd	r25, Z+3	; 0x03
     dd8:	13 96       	adiw	r26, 0x03	; 3
     dda:	9c 93       	st	X, r25
     ddc:	8e 93       	st	-X, r24
     dde:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     de0:	e9 81       	ldd	r30, Y+1	; 0x01
     de2:	fa 81       	ldd	r31, Y+2	; 0x02
     de4:	21 81       	ldd	r18, Z+1	; 0x01
     de6:	32 81       	ldd	r19, Z+2	; 0x02
     de8:	8b 81       	ldd	r24, Y+3	; 0x03
     dea:	9c 81       	ldd	r25, Y+4	; 0x04
     dec:	28 17       	cp	r18, r24
     dee:	39 07       	cpc	r19, r25
     df0:	41 f4       	brne	.+16     	; 0xe02 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     df2:	eb 81       	ldd	r30, Y+3	; 0x03
     df4:	fc 81       	ldd	r31, Y+4	; 0x04
     df6:	84 81       	ldd	r24, Z+4	; 0x04
     df8:	95 81       	ldd	r25, Z+5	; 0x05
     dfa:	e9 81       	ldd	r30, Y+1	; 0x01
     dfc:	fa 81       	ldd	r31, Y+2	; 0x02
     dfe:	92 83       	std	Z+2, r25	; 0x02
     e00:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     e02:	eb 81       	ldd	r30, Y+3	; 0x03
     e04:	fc 81       	ldd	r31, Y+4	; 0x04
     e06:	11 86       	std	Z+9, r1	; 0x09
     e08:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     e0a:	e9 81       	ldd	r30, Y+1	; 0x01
     e0c:	fa 81       	ldd	r31, Y+2	; 0x02
     e0e:	80 81       	ld	r24, Z
     e10:	81 50       	subi	r24, 0x01	; 1
     e12:	e9 81       	ldd	r30, Y+1	; 0x01
     e14:	fa 81       	ldd	r31, Y+2	; 0x02
     e16:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
     e18:	e9 81       	ldd	r30, Y+1	; 0x01
     e1a:	fa 81       	ldd	r31, Y+2	; 0x02
     e1c:	80 81       	ld	r24, Z
}
     e1e:	0f 90       	pop	r0
     e20:	0f 90       	pop	r0
     e22:	0f 90       	pop	r0
     e24:	0f 90       	pop	r0
     e26:	cf 91       	pop	r28
     e28:	df 91       	pop	r29
     e2a:	08 95       	ret

00000e2c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     e2c:	df 93       	push	r29
     e2e:	cf 93       	push	r28
     e30:	cd b7       	in	r28, 0x3d	; 61
     e32:	de b7       	in	r29, 0x3e	; 62
     e34:	28 97       	sbiw	r28, 0x08	; 8
     e36:	0f b6       	in	r0, 0x3f	; 63
     e38:	f8 94       	cli
     e3a:	de bf       	out	0x3e, r29	; 62
     e3c:	0f be       	out	0x3f, r0	; 63
     e3e:	cd bf       	out	0x3d, r28	; 61
     e40:	9c 83       	std	Y+4, r25	; 0x04
     e42:	8b 83       	std	Y+3, r24	; 0x03
     e44:	7e 83       	std	Y+6, r23	; 0x06
     e46:	6d 83       	std	Y+5, r22	; 0x05
     e48:	58 87       	std	Y+8, r21	; 0x08
     e4a:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     e4c:	eb 81       	ldd	r30, Y+3	; 0x03
     e4e:	fc 81       	ldd	r31, Y+4	; 0x04
     e50:	81 e1       	ldi	r24, 0x11	; 17
     e52:	80 83       	st	Z, r24
	pxTopOfStack--;
     e54:	8b 81       	ldd	r24, Y+3	; 0x03
     e56:	9c 81       	ldd	r25, Y+4	; 0x04
     e58:	01 97       	sbiw	r24, 0x01	; 1
     e5a:	9c 83       	std	Y+4, r25	; 0x04
     e5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     e5e:	eb 81       	ldd	r30, Y+3	; 0x03
     e60:	fc 81       	ldd	r31, Y+4	; 0x04
     e62:	82 e2       	ldi	r24, 0x22	; 34
     e64:	80 83       	st	Z, r24
	pxTopOfStack--;
     e66:	8b 81       	ldd	r24, Y+3	; 0x03
     e68:	9c 81       	ldd	r25, Y+4	; 0x04
     e6a:	01 97       	sbiw	r24, 0x01	; 1
     e6c:	9c 83       	std	Y+4, r25	; 0x04
     e6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     e70:	eb 81       	ldd	r30, Y+3	; 0x03
     e72:	fc 81       	ldd	r31, Y+4	; 0x04
     e74:	83 e3       	ldi	r24, 0x33	; 51
     e76:	80 83       	st	Z, r24
	pxTopOfStack--;
     e78:	8b 81       	ldd	r24, Y+3	; 0x03
     e7a:	9c 81       	ldd	r25, Y+4	; 0x04
     e7c:	01 97       	sbiw	r24, 0x01	; 1
     e7e:	9c 83       	std	Y+4, r25	; 0x04
     e80:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     e82:	8d 81       	ldd	r24, Y+5	; 0x05
     e84:	9e 81       	ldd	r25, Y+6	; 0x06
     e86:	9a 83       	std	Y+2, r25	; 0x02
     e88:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     e8a:	89 81       	ldd	r24, Y+1	; 0x01
     e8c:	eb 81       	ldd	r30, Y+3	; 0x03
     e8e:	fc 81       	ldd	r31, Y+4	; 0x04
     e90:	80 83       	st	Z, r24
	pxTopOfStack--;
     e92:	8b 81       	ldd	r24, Y+3	; 0x03
     e94:	9c 81       	ldd	r25, Y+4	; 0x04
     e96:	01 97       	sbiw	r24, 0x01	; 1
     e98:	9c 83       	std	Y+4, r25	; 0x04
     e9a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     e9c:	89 81       	ldd	r24, Y+1	; 0x01
     e9e:	9a 81       	ldd	r25, Y+2	; 0x02
     ea0:	89 2f       	mov	r24, r25
     ea2:	99 27       	eor	r25, r25
     ea4:	9a 83       	std	Y+2, r25	; 0x02
     ea6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     ea8:	89 81       	ldd	r24, Y+1	; 0x01
     eaa:	eb 81       	ldd	r30, Y+3	; 0x03
     eac:	fc 81       	ldd	r31, Y+4	; 0x04
     eae:	80 83       	st	Z, r24
	pxTopOfStack--;
     eb0:	8b 81       	ldd	r24, Y+3	; 0x03
     eb2:	9c 81       	ldd	r25, Y+4	; 0x04
     eb4:	01 97       	sbiw	r24, 0x01	; 1
     eb6:	9c 83       	std	Y+4, r25	; 0x04
     eb8:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     eba:	eb 81       	ldd	r30, Y+3	; 0x03
     ebc:	fc 81       	ldd	r31, Y+4	; 0x04
     ebe:	10 82       	st	Z, r1
	pxTopOfStack--;
     ec0:	8b 81       	ldd	r24, Y+3	; 0x03
     ec2:	9c 81       	ldd	r25, Y+4	; 0x04
     ec4:	01 97       	sbiw	r24, 0x01	; 1
     ec6:	9c 83       	std	Y+4, r25	; 0x04
     ec8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     eca:	eb 81       	ldd	r30, Y+3	; 0x03
     ecc:	fc 81       	ldd	r31, Y+4	; 0x04
     ece:	80 e8       	ldi	r24, 0x80	; 128
     ed0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ed2:	8b 81       	ldd	r24, Y+3	; 0x03
     ed4:	9c 81       	ldd	r25, Y+4	; 0x04
     ed6:	01 97       	sbiw	r24, 0x01	; 1
     ed8:	9c 83       	std	Y+4, r25	; 0x04
     eda:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     edc:	eb 81       	ldd	r30, Y+3	; 0x03
     ede:	fc 81       	ldd	r31, Y+4	; 0x04
     ee0:	10 82       	st	Z, r1
	pxTopOfStack--;
     ee2:	8b 81       	ldd	r24, Y+3	; 0x03
     ee4:	9c 81       	ldd	r25, Y+4	; 0x04
     ee6:	01 97       	sbiw	r24, 0x01	; 1
     ee8:	9c 83       	std	Y+4, r25	; 0x04
     eea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     eec:	eb 81       	ldd	r30, Y+3	; 0x03
     eee:	fc 81       	ldd	r31, Y+4	; 0x04
     ef0:	82 e0       	ldi	r24, 0x02	; 2
     ef2:	80 83       	st	Z, r24
	pxTopOfStack--;
     ef4:	8b 81       	ldd	r24, Y+3	; 0x03
     ef6:	9c 81       	ldd	r25, Y+4	; 0x04
     ef8:	01 97       	sbiw	r24, 0x01	; 1
     efa:	9c 83       	std	Y+4, r25	; 0x04
     efc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     efe:	eb 81       	ldd	r30, Y+3	; 0x03
     f00:	fc 81       	ldd	r31, Y+4	; 0x04
     f02:	83 e0       	ldi	r24, 0x03	; 3
     f04:	80 83       	st	Z, r24
	pxTopOfStack--;
     f06:	8b 81       	ldd	r24, Y+3	; 0x03
     f08:	9c 81       	ldd	r25, Y+4	; 0x04
     f0a:	01 97       	sbiw	r24, 0x01	; 1
     f0c:	9c 83       	std	Y+4, r25	; 0x04
     f0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     f10:	eb 81       	ldd	r30, Y+3	; 0x03
     f12:	fc 81       	ldd	r31, Y+4	; 0x04
     f14:	84 e0       	ldi	r24, 0x04	; 4
     f16:	80 83       	st	Z, r24
	pxTopOfStack--;
     f18:	8b 81       	ldd	r24, Y+3	; 0x03
     f1a:	9c 81       	ldd	r25, Y+4	; 0x04
     f1c:	01 97       	sbiw	r24, 0x01	; 1
     f1e:	9c 83       	std	Y+4, r25	; 0x04
     f20:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     f22:	eb 81       	ldd	r30, Y+3	; 0x03
     f24:	fc 81       	ldd	r31, Y+4	; 0x04
     f26:	85 e0       	ldi	r24, 0x05	; 5
     f28:	80 83       	st	Z, r24
	pxTopOfStack--;
     f2a:	8b 81       	ldd	r24, Y+3	; 0x03
     f2c:	9c 81       	ldd	r25, Y+4	; 0x04
     f2e:	01 97       	sbiw	r24, 0x01	; 1
     f30:	9c 83       	std	Y+4, r25	; 0x04
     f32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     f34:	eb 81       	ldd	r30, Y+3	; 0x03
     f36:	fc 81       	ldd	r31, Y+4	; 0x04
     f38:	86 e0       	ldi	r24, 0x06	; 6
     f3a:	80 83       	st	Z, r24
	pxTopOfStack--;
     f3c:	8b 81       	ldd	r24, Y+3	; 0x03
     f3e:	9c 81       	ldd	r25, Y+4	; 0x04
     f40:	01 97       	sbiw	r24, 0x01	; 1
     f42:	9c 83       	std	Y+4, r25	; 0x04
     f44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     f46:	eb 81       	ldd	r30, Y+3	; 0x03
     f48:	fc 81       	ldd	r31, Y+4	; 0x04
     f4a:	87 e0       	ldi	r24, 0x07	; 7
     f4c:	80 83       	st	Z, r24
	pxTopOfStack--;
     f4e:	8b 81       	ldd	r24, Y+3	; 0x03
     f50:	9c 81       	ldd	r25, Y+4	; 0x04
     f52:	01 97       	sbiw	r24, 0x01	; 1
     f54:	9c 83       	std	Y+4, r25	; 0x04
     f56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     f58:	eb 81       	ldd	r30, Y+3	; 0x03
     f5a:	fc 81       	ldd	r31, Y+4	; 0x04
     f5c:	88 e0       	ldi	r24, 0x08	; 8
     f5e:	80 83       	st	Z, r24
	pxTopOfStack--;
     f60:	8b 81       	ldd	r24, Y+3	; 0x03
     f62:	9c 81       	ldd	r25, Y+4	; 0x04
     f64:	01 97       	sbiw	r24, 0x01	; 1
     f66:	9c 83       	std	Y+4, r25	; 0x04
     f68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     f6a:	eb 81       	ldd	r30, Y+3	; 0x03
     f6c:	fc 81       	ldd	r31, Y+4	; 0x04
     f6e:	89 e0       	ldi	r24, 0x09	; 9
     f70:	80 83       	st	Z, r24
	pxTopOfStack--;
     f72:	8b 81       	ldd	r24, Y+3	; 0x03
     f74:	9c 81       	ldd	r25, Y+4	; 0x04
     f76:	01 97       	sbiw	r24, 0x01	; 1
     f78:	9c 83       	std	Y+4, r25	; 0x04
     f7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     f7c:	eb 81       	ldd	r30, Y+3	; 0x03
     f7e:	fc 81       	ldd	r31, Y+4	; 0x04
     f80:	80 e1       	ldi	r24, 0x10	; 16
     f82:	80 83       	st	Z, r24
	pxTopOfStack--;
     f84:	8b 81       	ldd	r24, Y+3	; 0x03
     f86:	9c 81       	ldd	r25, Y+4	; 0x04
     f88:	01 97       	sbiw	r24, 0x01	; 1
     f8a:	9c 83       	std	Y+4, r25	; 0x04
     f8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     f8e:	eb 81       	ldd	r30, Y+3	; 0x03
     f90:	fc 81       	ldd	r31, Y+4	; 0x04
     f92:	81 e1       	ldi	r24, 0x11	; 17
     f94:	80 83       	st	Z, r24
	pxTopOfStack--;
     f96:	8b 81       	ldd	r24, Y+3	; 0x03
     f98:	9c 81       	ldd	r25, Y+4	; 0x04
     f9a:	01 97       	sbiw	r24, 0x01	; 1
     f9c:	9c 83       	std	Y+4, r25	; 0x04
     f9e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     fa0:	eb 81       	ldd	r30, Y+3	; 0x03
     fa2:	fc 81       	ldd	r31, Y+4	; 0x04
     fa4:	82 e1       	ldi	r24, 0x12	; 18
     fa6:	80 83       	st	Z, r24
	pxTopOfStack--;
     fa8:	8b 81       	ldd	r24, Y+3	; 0x03
     faa:	9c 81       	ldd	r25, Y+4	; 0x04
     fac:	01 97       	sbiw	r24, 0x01	; 1
     fae:	9c 83       	std	Y+4, r25	; 0x04
     fb0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     fb2:	eb 81       	ldd	r30, Y+3	; 0x03
     fb4:	fc 81       	ldd	r31, Y+4	; 0x04
     fb6:	83 e1       	ldi	r24, 0x13	; 19
     fb8:	80 83       	st	Z, r24
	pxTopOfStack--;
     fba:	8b 81       	ldd	r24, Y+3	; 0x03
     fbc:	9c 81       	ldd	r25, Y+4	; 0x04
     fbe:	01 97       	sbiw	r24, 0x01	; 1
     fc0:	9c 83       	std	Y+4, r25	; 0x04
     fc2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     fc4:	eb 81       	ldd	r30, Y+3	; 0x03
     fc6:	fc 81       	ldd	r31, Y+4	; 0x04
     fc8:	84 e1       	ldi	r24, 0x14	; 20
     fca:	80 83       	st	Z, r24
	pxTopOfStack--;
     fcc:	8b 81       	ldd	r24, Y+3	; 0x03
     fce:	9c 81       	ldd	r25, Y+4	; 0x04
     fd0:	01 97       	sbiw	r24, 0x01	; 1
     fd2:	9c 83       	std	Y+4, r25	; 0x04
     fd4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     fd6:	eb 81       	ldd	r30, Y+3	; 0x03
     fd8:	fc 81       	ldd	r31, Y+4	; 0x04
     fda:	85 e1       	ldi	r24, 0x15	; 21
     fdc:	80 83       	st	Z, r24
	pxTopOfStack--;
     fde:	8b 81       	ldd	r24, Y+3	; 0x03
     fe0:	9c 81       	ldd	r25, Y+4	; 0x04
     fe2:	01 97       	sbiw	r24, 0x01	; 1
     fe4:	9c 83       	std	Y+4, r25	; 0x04
     fe6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     fe8:	eb 81       	ldd	r30, Y+3	; 0x03
     fea:	fc 81       	ldd	r31, Y+4	; 0x04
     fec:	86 e1       	ldi	r24, 0x16	; 22
     fee:	80 83       	st	Z, r24
	pxTopOfStack--;
     ff0:	8b 81       	ldd	r24, Y+3	; 0x03
     ff2:	9c 81       	ldd	r25, Y+4	; 0x04
     ff4:	01 97       	sbiw	r24, 0x01	; 1
     ff6:	9c 83       	std	Y+4, r25	; 0x04
     ff8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     ffa:	eb 81       	ldd	r30, Y+3	; 0x03
     ffc:	fc 81       	ldd	r31, Y+4	; 0x04
     ffe:	87 e1       	ldi	r24, 0x17	; 23
    1000:	80 83       	st	Z, r24
	pxTopOfStack--;
    1002:	8b 81       	ldd	r24, Y+3	; 0x03
    1004:	9c 81       	ldd	r25, Y+4	; 0x04
    1006:	01 97       	sbiw	r24, 0x01	; 1
    1008:	9c 83       	std	Y+4, r25	; 0x04
    100a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    100c:	eb 81       	ldd	r30, Y+3	; 0x03
    100e:	fc 81       	ldd	r31, Y+4	; 0x04
    1010:	88 e1       	ldi	r24, 0x18	; 24
    1012:	80 83       	st	Z, r24
	pxTopOfStack--;
    1014:	8b 81       	ldd	r24, Y+3	; 0x03
    1016:	9c 81       	ldd	r25, Y+4	; 0x04
    1018:	01 97       	sbiw	r24, 0x01	; 1
    101a:	9c 83       	std	Y+4, r25	; 0x04
    101c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    101e:	eb 81       	ldd	r30, Y+3	; 0x03
    1020:	fc 81       	ldd	r31, Y+4	; 0x04
    1022:	89 e1       	ldi	r24, 0x19	; 25
    1024:	80 83       	st	Z, r24
	pxTopOfStack--;
    1026:	8b 81       	ldd	r24, Y+3	; 0x03
    1028:	9c 81       	ldd	r25, Y+4	; 0x04
    102a:	01 97       	sbiw	r24, 0x01	; 1
    102c:	9c 83       	std	Y+4, r25	; 0x04
    102e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1030:	eb 81       	ldd	r30, Y+3	; 0x03
    1032:	fc 81       	ldd	r31, Y+4	; 0x04
    1034:	80 e2       	ldi	r24, 0x20	; 32
    1036:	80 83       	st	Z, r24
	pxTopOfStack--;
    1038:	8b 81       	ldd	r24, Y+3	; 0x03
    103a:	9c 81       	ldd	r25, Y+4	; 0x04
    103c:	01 97       	sbiw	r24, 0x01	; 1
    103e:	9c 83       	std	Y+4, r25	; 0x04
    1040:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1042:	eb 81       	ldd	r30, Y+3	; 0x03
    1044:	fc 81       	ldd	r31, Y+4	; 0x04
    1046:	81 e2       	ldi	r24, 0x21	; 33
    1048:	80 83       	st	Z, r24
	pxTopOfStack--;
    104a:	8b 81       	ldd	r24, Y+3	; 0x03
    104c:	9c 81       	ldd	r25, Y+4	; 0x04
    104e:	01 97       	sbiw	r24, 0x01	; 1
    1050:	9c 83       	std	Y+4, r25	; 0x04
    1052:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1054:	eb 81       	ldd	r30, Y+3	; 0x03
    1056:	fc 81       	ldd	r31, Y+4	; 0x04
    1058:	82 e2       	ldi	r24, 0x22	; 34
    105a:	80 83       	st	Z, r24
	pxTopOfStack--;
    105c:	8b 81       	ldd	r24, Y+3	; 0x03
    105e:	9c 81       	ldd	r25, Y+4	; 0x04
    1060:	01 97       	sbiw	r24, 0x01	; 1
    1062:	9c 83       	std	Y+4, r25	; 0x04
    1064:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1066:	eb 81       	ldd	r30, Y+3	; 0x03
    1068:	fc 81       	ldd	r31, Y+4	; 0x04
    106a:	83 e2       	ldi	r24, 0x23	; 35
    106c:	80 83       	st	Z, r24
	pxTopOfStack--;
    106e:	8b 81       	ldd	r24, Y+3	; 0x03
    1070:	9c 81       	ldd	r25, Y+4	; 0x04
    1072:	01 97       	sbiw	r24, 0x01	; 1
    1074:	9c 83       	std	Y+4, r25	; 0x04
    1076:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    1078:	8f 81       	ldd	r24, Y+7	; 0x07
    107a:	98 85       	ldd	r25, Y+8	; 0x08
    107c:	9a 83       	std	Y+2, r25	; 0x02
    107e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1080:	89 81       	ldd	r24, Y+1	; 0x01
    1082:	eb 81       	ldd	r30, Y+3	; 0x03
    1084:	fc 81       	ldd	r31, Y+4	; 0x04
    1086:	80 83       	st	Z, r24
	pxTopOfStack--;
    1088:	8b 81       	ldd	r24, Y+3	; 0x03
    108a:	9c 81       	ldd	r25, Y+4	; 0x04
    108c:	01 97       	sbiw	r24, 0x01	; 1
    108e:	9c 83       	std	Y+4, r25	; 0x04
    1090:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1092:	89 81       	ldd	r24, Y+1	; 0x01
    1094:	9a 81       	ldd	r25, Y+2	; 0x02
    1096:	89 2f       	mov	r24, r25
    1098:	99 27       	eor	r25, r25
    109a:	9a 83       	std	Y+2, r25	; 0x02
    109c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    109e:	89 81       	ldd	r24, Y+1	; 0x01
    10a0:	eb 81       	ldd	r30, Y+3	; 0x03
    10a2:	fc 81       	ldd	r31, Y+4	; 0x04
    10a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    10a6:	8b 81       	ldd	r24, Y+3	; 0x03
    10a8:	9c 81       	ldd	r25, Y+4	; 0x04
    10aa:	01 97       	sbiw	r24, 0x01	; 1
    10ac:	9c 83       	std	Y+4, r25	; 0x04
    10ae:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    10b0:	eb 81       	ldd	r30, Y+3	; 0x03
    10b2:	fc 81       	ldd	r31, Y+4	; 0x04
    10b4:	86 e2       	ldi	r24, 0x26	; 38
    10b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    10b8:	8b 81       	ldd	r24, Y+3	; 0x03
    10ba:	9c 81       	ldd	r25, Y+4	; 0x04
    10bc:	01 97       	sbiw	r24, 0x01	; 1
    10be:	9c 83       	std	Y+4, r25	; 0x04
    10c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    10c2:	eb 81       	ldd	r30, Y+3	; 0x03
    10c4:	fc 81       	ldd	r31, Y+4	; 0x04
    10c6:	87 e2       	ldi	r24, 0x27	; 39
    10c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    10ca:	8b 81       	ldd	r24, Y+3	; 0x03
    10cc:	9c 81       	ldd	r25, Y+4	; 0x04
    10ce:	01 97       	sbiw	r24, 0x01	; 1
    10d0:	9c 83       	std	Y+4, r25	; 0x04
    10d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    10d4:	eb 81       	ldd	r30, Y+3	; 0x03
    10d6:	fc 81       	ldd	r31, Y+4	; 0x04
    10d8:	88 e2       	ldi	r24, 0x28	; 40
    10da:	80 83       	st	Z, r24
	pxTopOfStack--;
    10dc:	8b 81       	ldd	r24, Y+3	; 0x03
    10de:	9c 81       	ldd	r25, Y+4	; 0x04
    10e0:	01 97       	sbiw	r24, 0x01	; 1
    10e2:	9c 83       	std	Y+4, r25	; 0x04
    10e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    10e6:	eb 81       	ldd	r30, Y+3	; 0x03
    10e8:	fc 81       	ldd	r31, Y+4	; 0x04
    10ea:	89 e2       	ldi	r24, 0x29	; 41
    10ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    10ee:	8b 81       	ldd	r24, Y+3	; 0x03
    10f0:	9c 81       	ldd	r25, Y+4	; 0x04
    10f2:	01 97       	sbiw	r24, 0x01	; 1
    10f4:	9c 83       	std	Y+4, r25	; 0x04
    10f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    10f8:	eb 81       	ldd	r30, Y+3	; 0x03
    10fa:	fc 81       	ldd	r31, Y+4	; 0x04
    10fc:	80 e3       	ldi	r24, 0x30	; 48
    10fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    1100:	8b 81       	ldd	r24, Y+3	; 0x03
    1102:	9c 81       	ldd	r25, Y+4	; 0x04
    1104:	01 97       	sbiw	r24, 0x01	; 1
    1106:	9c 83       	std	Y+4, r25	; 0x04
    1108:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    110a:	eb 81       	ldd	r30, Y+3	; 0x03
    110c:	fc 81       	ldd	r31, Y+4	; 0x04
    110e:	81 e3       	ldi	r24, 0x31	; 49
    1110:	80 83       	st	Z, r24
	pxTopOfStack--;
    1112:	8b 81       	ldd	r24, Y+3	; 0x03
    1114:	9c 81       	ldd	r25, Y+4	; 0x04
    1116:	01 97       	sbiw	r24, 0x01	; 1
    1118:	9c 83       	std	Y+4, r25	; 0x04
    111a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    111c:	8b 81       	ldd	r24, Y+3	; 0x03
    111e:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1120:	28 96       	adiw	r28, 0x08	; 8
    1122:	0f b6       	in	r0, 0x3f	; 63
    1124:	f8 94       	cli
    1126:	de bf       	out	0x3e, r29	; 62
    1128:	0f be       	out	0x3f, r0	; 63
    112a:	cd bf       	out	0x3d, r28	; 61
    112c:	cf 91       	pop	r28
    112e:	df 91       	pop	r29
    1130:	08 95       	ret

00001132 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    1132:	df 93       	push	r29
    1134:	cf 93       	push	r28
    1136:	cd b7       	in	r28, 0x3d	; 61
    1138:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    113a:	0e 94 8b 09 	call	0x1316	; 0x1316 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    113e:	a0 91 54 07 	lds	r26, 0x0754
    1142:	b0 91 55 07 	lds	r27, 0x0755
    1146:	cd 91       	ld	r28, X+
    1148:	cd bf       	out	0x3d, r28	; 61
    114a:	dd 91       	ld	r29, X+
    114c:	de bf       	out	0x3e, r29	; 62
    114e:	ff 91       	pop	r31
    1150:	ef 91       	pop	r30
    1152:	df 91       	pop	r29
    1154:	cf 91       	pop	r28
    1156:	bf 91       	pop	r27
    1158:	af 91       	pop	r26
    115a:	9f 91       	pop	r25
    115c:	8f 91       	pop	r24
    115e:	7f 91       	pop	r23
    1160:	6f 91       	pop	r22
    1162:	5f 91       	pop	r21
    1164:	4f 91       	pop	r20
    1166:	3f 91       	pop	r19
    1168:	2f 91       	pop	r18
    116a:	1f 91       	pop	r17
    116c:	0f 91       	pop	r16
    116e:	ff 90       	pop	r15
    1170:	ef 90       	pop	r14
    1172:	df 90       	pop	r13
    1174:	cf 90       	pop	r12
    1176:	bf 90       	pop	r11
    1178:	af 90       	pop	r10
    117a:	9f 90       	pop	r9
    117c:	8f 90       	pop	r8
    117e:	7f 90       	pop	r7
    1180:	6f 90       	pop	r6
    1182:	5f 90       	pop	r5
    1184:	4f 90       	pop	r4
    1186:	3f 90       	pop	r3
    1188:	2f 90       	pop	r2
    118a:	1f 90       	pop	r1
    118c:	0f 90       	pop	r0
    118e:	0f be       	out	0x3f, r0	; 63
    1190:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1192:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1194:	81 e0       	ldi	r24, 0x01	; 1
}
    1196:	cf 91       	pop	r28
    1198:	df 91       	pop	r29
    119a:	08 95       	ret

0000119c <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    119c:	df 93       	push	r29
    119e:	cf 93       	push	r28
    11a0:	cd b7       	in	r28, 0x3d	; 61
    11a2:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    11a4:	cf 91       	pop	r28
    11a6:	df 91       	pop	r29
    11a8:	08 95       	ret

000011aa <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    11aa:	0f 92       	push	r0
    11ac:	0f b6       	in	r0, 0x3f	; 63
    11ae:	f8 94       	cli
    11b0:	0f 92       	push	r0
    11b2:	1f 92       	push	r1
    11b4:	11 24       	eor	r1, r1
    11b6:	2f 92       	push	r2
    11b8:	3f 92       	push	r3
    11ba:	4f 92       	push	r4
    11bc:	5f 92       	push	r5
    11be:	6f 92       	push	r6
    11c0:	7f 92       	push	r7
    11c2:	8f 92       	push	r8
    11c4:	9f 92       	push	r9
    11c6:	af 92       	push	r10
    11c8:	bf 92       	push	r11
    11ca:	cf 92       	push	r12
    11cc:	df 92       	push	r13
    11ce:	ef 92       	push	r14
    11d0:	ff 92       	push	r15
    11d2:	0f 93       	push	r16
    11d4:	1f 93       	push	r17
    11d6:	2f 93       	push	r18
    11d8:	3f 93       	push	r19
    11da:	4f 93       	push	r20
    11dc:	5f 93       	push	r21
    11de:	6f 93       	push	r22
    11e0:	7f 93       	push	r23
    11e2:	8f 93       	push	r24
    11e4:	9f 93       	push	r25
    11e6:	af 93       	push	r26
    11e8:	bf 93       	push	r27
    11ea:	cf 93       	push	r28
    11ec:	df 93       	push	r29
    11ee:	ef 93       	push	r30
    11f0:	ff 93       	push	r31
    11f2:	a0 91 54 07 	lds	r26, 0x0754
    11f6:	b0 91 55 07 	lds	r27, 0x0755
    11fa:	0d b6       	in	r0, 0x3d	; 61
    11fc:	0d 92       	st	X+, r0
    11fe:	0e b6       	in	r0, 0x3e	; 62
    1200:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1202:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1206:	a0 91 54 07 	lds	r26, 0x0754
    120a:	b0 91 55 07 	lds	r27, 0x0755
    120e:	cd 91       	ld	r28, X+
    1210:	cd bf       	out	0x3d, r28	; 61
    1212:	dd 91       	ld	r29, X+
    1214:	de bf       	out	0x3e, r29	; 62
    1216:	ff 91       	pop	r31
    1218:	ef 91       	pop	r30
    121a:	df 91       	pop	r29
    121c:	cf 91       	pop	r28
    121e:	bf 91       	pop	r27
    1220:	af 91       	pop	r26
    1222:	9f 91       	pop	r25
    1224:	8f 91       	pop	r24
    1226:	7f 91       	pop	r23
    1228:	6f 91       	pop	r22
    122a:	5f 91       	pop	r21
    122c:	4f 91       	pop	r20
    122e:	3f 91       	pop	r19
    1230:	2f 91       	pop	r18
    1232:	1f 91       	pop	r17
    1234:	0f 91       	pop	r16
    1236:	ff 90       	pop	r15
    1238:	ef 90       	pop	r14
    123a:	df 90       	pop	r13
    123c:	cf 90       	pop	r12
    123e:	bf 90       	pop	r11
    1240:	af 90       	pop	r10
    1242:	9f 90       	pop	r9
    1244:	8f 90       	pop	r8
    1246:	7f 90       	pop	r7
    1248:	6f 90       	pop	r6
    124a:	5f 90       	pop	r5
    124c:	4f 90       	pop	r4
    124e:	3f 90       	pop	r3
    1250:	2f 90       	pop	r2
    1252:	1f 90       	pop	r1
    1254:	0f 90       	pop	r0
    1256:	0f be       	out	0x3f, r0	; 63
    1258:	0f 90       	pop	r0

	asm volatile ( "ret" );
    125a:	08 95       	ret

0000125c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    125c:	0f 92       	push	r0
    125e:	0f b6       	in	r0, 0x3f	; 63
    1260:	f8 94       	cli
    1262:	0f 92       	push	r0
    1264:	1f 92       	push	r1
    1266:	11 24       	eor	r1, r1
    1268:	2f 92       	push	r2
    126a:	3f 92       	push	r3
    126c:	4f 92       	push	r4
    126e:	5f 92       	push	r5
    1270:	6f 92       	push	r6
    1272:	7f 92       	push	r7
    1274:	8f 92       	push	r8
    1276:	9f 92       	push	r9
    1278:	af 92       	push	r10
    127a:	bf 92       	push	r11
    127c:	cf 92       	push	r12
    127e:	df 92       	push	r13
    1280:	ef 92       	push	r14
    1282:	ff 92       	push	r15
    1284:	0f 93       	push	r16
    1286:	1f 93       	push	r17
    1288:	2f 93       	push	r18
    128a:	3f 93       	push	r19
    128c:	4f 93       	push	r20
    128e:	5f 93       	push	r21
    1290:	6f 93       	push	r22
    1292:	7f 93       	push	r23
    1294:	8f 93       	push	r24
    1296:	9f 93       	push	r25
    1298:	af 93       	push	r26
    129a:	bf 93       	push	r27
    129c:	cf 93       	push	r28
    129e:	df 93       	push	r29
    12a0:	ef 93       	push	r30
    12a2:	ff 93       	push	r31
    12a4:	a0 91 54 07 	lds	r26, 0x0754
    12a8:	b0 91 55 07 	lds	r27, 0x0755
    12ac:	0d b6       	in	r0, 0x3d	; 61
    12ae:	0d 92       	st	X+, r0
    12b0:	0e b6       	in	r0, 0x3e	; 62
    12b2:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    12b4:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <xTaskIncrementTick>
    12b8:	88 23       	and	r24, r24
    12ba:	11 f0       	breq	.+4      	; 0x12c0 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    12bc:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    12c0:	a0 91 54 07 	lds	r26, 0x0754
    12c4:	b0 91 55 07 	lds	r27, 0x0755
    12c8:	cd 91       	ld	r28, X+
    12ca:	cd bf       	out	0x3d, r28	; 61
    12cc:	dd 91       	ld	r29, X+
    12ce:	de bf       	out	0x3e, r29	; 62
    12d0:	ff 91       	pop	r31
    12d2:	ef 91       	pop	r30
    12d4:	df 91       	pop	r29
    12d6:	cf 91       	pop	r28
    12d8:	bf 91       	pop	r27
    12da:	af 91       	pop	r26
    12dc:	9f 91       	pop	r25
    12de:	8f 91       	pop	r24
    12e0:	7f 91       	pop	r23
    12e2:	6f 91       	pop	r22
    12e4:	5f 91       	pop	r21
    12e6:	4f 91       	pop	r20
    12e8:	3f 91       	pop	r19
    12ea:	2f 91       	pop	r18
    12ec:	1f 91       	pop	r17
    12ee:	0f 91       	pop	r16
    12f0:	ff 90       	pop	r15
    12f2:	ef 90       	pop	r14
    12f4:	df 90       	pop	r13
    12f6:	cf 90       	pop	r12
    12f8:	bf 90       	pop	r11
    12fa:	af 90       	pop	r10
    12fc:	9f 90       	pop	r9
    12fe:	8f 90       	pop	r8
    1300:	7f 90       	pop	r7
    1302:	6f 90       	pop	r6
    1304:	5f 90       	pop	r5
    1306:	4f 90       	pop	r4
    1308:	3f 90       	pop	r3
    130a:	2f 90       	pop	r2
    130c:	1f 90       	pop	r1
    130e:	0f 90       	pop	r0
    1310:	0f be       	out	0x3f, r0	; 63
    1312:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1314:	08 95       	ret

00001316 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1316:	df 93       	push	r29
    1318:	cf 93       	push	r28
    131a:	00 d0       	rcall	.+0      	; 0x131c <prvSetupTimerInterrupt+0x6>
    131c:	00 d0       	rcall	.+0      	; 0x131e <prvSetupTimerInterrupt+0x8>
    131e:	00 d0       	rcall	.+0      	; 0x1320 <prvSetupTimerInterrupt+0xa>
    1320:	cd b7       	in	r28, 0x3d	; 61
    1322:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1324:	80 e8       	ldi	r24, 0x80	; 128
    1326:	9e e3       	ldi	r25, 0x3E	; 62
    1328:	a0 e0       	ldi	r26, 0x00	; 0
    132a:	b0 e0       	ldi	r27, 0x00	; 0
    132c:	8b 83       	std	Y+3, r24	; 0x03
    132e:	9c 83       	std	Y+4, r25	; 0x04
    1330:	ad 83       	std	Y+5, r26	; 0x05
    1332:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1334:	8b 81       	ldd	r24, Y+3	; 0x03
    1336:	9c 81       	ldd	r25, Y+4	; 0x04
    1338:	ad 81       	ldd	r26, Y+5	; 0x05
    133a:	be 81       	ldd	r27, Y+6	; 0x06
    133c:	68 94       	set
    133e:	15 f8       	bld	r1, 5
    1340:	b6 95       	lsr	r27
    1342:	a7 95       	ror	r26
    1344:	97 95       	ror	r25
    1346:	87 95       	ror	r24
    1348:	16 94       	lsr	r1
    134a:	d1 f7       	brne	.-12     	; 0x1340 <prvSetupTimerInterrupt+0x2a>
    134c:	8b 83       	std	Y+3, r24	; 0x03
    134e:	9c 83       	std	Y+4, r25	; 0x04
    1350:	ad 83       	std	Y+5, r26	; 0x05
    1352:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    1354:	8b 81       	ldd	r24, Y+3	; 0x03
    1356:	9c 81       	ldd	r25, Y+4	; 0x04
    1358:	ad 81       	ldd	r26, Y+5	; 0x05
    135a:	be 81       	ldd	r27, Y+6	; 0x06
    135c:	01 97       	sbiw	r24, 0x01	; 1
    135e:	a1 09       	sbc	r26, r1
    1360:	b1 09       	sbc	r27, r1
    1362:	8b 83       	std	Y+3, r24	; 0x03
    1364:	9c 83       	std	Y+4, r25	; 0x04
    1366:	ad 83       	std	Y+5, r26	; 0x05
    1368:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    136a:	8b 81       	ldd	r24, Y+3	; 0x03
    136c:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    136e:	8b 81       	ldd	r24, Y+3	; 0x03
    1370:	9c 81       	ldd	r25, Y+4	; 0x04
    1372:	ad 81       	ldd	r26, Y+5	; 0x05
    1374:	be 81       	ldd	r27, Y+6	; 0x06
    1376:	89 2f       	mov	r24, r25
    1378:	9a 2f       	mov	r25, r26
    137a:	ab 2f       	mov	r26, r27
    137c:	bb 27       	eor	r27, r27
    137e:	8b 83       	std	Y+3, r24	; 0x03
    1380:	9c 83       	std	Y+4, r25	; 0x04
    1382:	ad 83       	std	Y+5, r26	; 0x05
    1384:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1386:	8b 81       	ldd	r24, Y+3	; 0x03
    1388:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    138a:	eb e4       	ldi	r30, 0x4B	; 75
    138c:	f0 e0       	ldi	r31, 0x00	; 0
    138e:	8a 81       	ldd	r24, Y+2	; 0x02
    1390:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1392:	ea e4       	ldi	r30, 0x4A	; 74
    1394:	f0 e0       	ldi	r31, 0x00	; 0
    1396:	89 81       	ldd	r24, Y+1	; 0x01
    1398:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    139a:	8b e0       	ldi	r24, 0x0B	; 11
    139c:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    139e:	ee e4       	ldi	r30, 0x4E	; 78
    13a0:	f0 e0       	ldi	r31, 0x00	; 0
    13a2:	89 81       	ldd	r24, Y+1	; 0x01
    13a4:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    13a6:	e9 e5       	ldi	r30, 0x59	; 89
    13a8:	f0 e0       	ldi	r31, 0x00	; 0
    13aa:	80 81       	ld	r24, Z
    13ac:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    13ae:	89 81       	ldd	r24, Y+1	; 0x01
    13b0:	80 61       	ori	r24, 0x10	; 16
    13b2:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    13b4:	e9 e5       	ldi	r30, 0x59	; 89
    13b6:	f0 e0       	ldi	r31, 0x00	; 0
    13b8:	89 81       	ldd	r24, Y+1	; 0x01
    13ba:	80 83       	st	Z, r24
}
    13bc:	26 96       	adiw	r28, 0x06	; 6
    13be:	0f b6       	in	r0, 0x3f	; 63
    13c0:	f8 94       	cli
    13c2:	de bf       	out	0x3e, r29	; 62
    13c4:	0f be       	out	0x3f, r0	; 63
    13c6:	cd bf       	out	0x3d, r28	; 61
    13c8:	cf 91       	pop	r28
    13ca:	df 91       	pop	r29
    13cc:	08 95       	ret

000013ce <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal ) );
	void TIMER1_COMPA_vect( void )
	{
    13ce:	1f 92       	push	r1
    13d0:	0f 92       	push	r0
    13d2:	0f b6       	in	r0, 0x3f	; 63
    13d4:	0f 92       	push	r0
    13d6:	11 24       	eor	r1, r1
    13d8:	2f 93       	push	r18
    13da:	3f 93       	push	r19
    13dc:	4f 93       	push	r20
    13de:	5f 93       	push	r21
    13e0:	6f 93       	push	r22
    13e2:	7f 93       	push	r23
    13e4:	8f 93       	push	r24
    13e6:	9f 93       	push	r25
    13e8:	af 93       	push	r26
    13ea:	bf 93       	push	r27
    13ec:	ef 93       	push	r30
    13ee:	ff 93       	push	r31
    13f0:	df 93       	push	r29
    13f2:	cf 93       	push	r28
    13f4:	cd b7       	in	r28, 0x3d	; 61
    13f6:	de b7       	in	r29, 0x3e	; 62
		xTaskIncrementTick();
    13f8:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <xTaskIncrementTick>
	}
    13fc:	cf 91       	pop	r28
    13fe:	df 91       	pop	r29
    1400:	ff 91       	pop	r31
    1402:	ef 91       	pop	r30
    1404:	bf 91       	pop	r27
    1406:	af 91       	pop	r26
    1408:	9f 91       	pop	r25
    140a:	8f 91       	pop	r24
    140c:	7f 91       	pop	r23
    140e:	6f 91       	pop	r22
    1410:	5f 91       	pop	r21
    1412:	4f 91       	pop	r20
    1414:	3f 91       	pop	r19
    1416:	2f 91       	pop	r18
    1418:	0f 90       	pop	r0
    141a:	0f be       	out	0x3f, r0	; 63
    141c:	0f 90       	pop	r0
    141e:	1f 90       	pop	r1
    1420:	18 95       	reti

00001422 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1422:	df 93       	push	r29
    1424:	cf 93       	push	r28
    1426:	00 d0       	rcall	.+0      	; 0x1428 <xQueueGenericReset+0x6>
    1428:	00 d0       	rcall	.+0      	; 0x142a <xQueueGenericReset+0x8>
    142a:	0f 92       	push	r0
    142c:	cd b7       	in	r28, 0x3d	; 61
    142e:	de b7       	in	r29, 0x3e	; 62
    1430:	9c 83       	std	Y+4, r25	; 0x04
    1432:	8b 83       	std	Y+3, r24	; 0x03
    1434:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    1436:	8b 81       	ldd	r24, Y+3	; 0x03
    1438:	9c 81       	ldd	r25, Y+4	; 0x04
    143a:	9a 83       	std	Y+2, r25	; 0x02
    143c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    143e:	0f b6       	in	r0, 0x3f	; 63
    1440:	f8 94       	cli
    1442:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1444:	e9 81       	ldd	r30, Y+1	; 0x01
    1446:	fa 81       	ldd	r31, Y+2	; 0x02
    1448:	40 81       	ld	r20, Z
    144a:	51 81       	ldd	r21, Z+1	; 0x01
    144c:	e9 81       	ldd	r30, Y+1	; 0x01
    144e:	fa 81       	ldd	r31, Y+2	; 0x02
    1450:	83 8d       	ldd	r24, Z+27	; 0x1b
    1452:	28 2f       	mov	r18, r24
    1454:	30 e0       	ldi	r19, 0x00	; 0
    1456:	e9 81       	ldd	r30, Y+1	; 0x01
    1458:	fa 81       	ldd	r31, Y+2	; 0x02
    145a:	84 8d       	ldd	r24, Z+28	; 0x1c
    145c:	88 2f       	mov	r24, r24
    145e:	90 e0       	ldi	r25, 0x00	; 0
    1460:	bc 01       	movw	r22, r24
    1462:	26 9f       	mul	r18, r22
    1464:	c0 01       	movw	r24, r0
    1466:	27 9f       	mul	r18, r23
    1468:	90 0d       	add	r25, r0
    146a:	36 9f       	mul	r19, r22
    146c:	90 0d       	add	r25, r0
    146e:	11 24       	eor	r1, r1
    1470:	84 0f       	add	r24, r20
    1472:	95 1f       	adc	r25, r21
    1474:	e9 81       	ldd	r30, Y+1	; 0x01
    1476:	fa 81       	ldd	r31, Y+2	; 0x02
    1478:	95 83       	std	Z+5, r25	; 0x05
    147a:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    147c:	e9 81       	ldd	r30, Y+1	; 0x01
    147e:	fa 81       	ldd	r31, Y+2	; 0x02
    1480:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1482:	e9 81       	ldd	r30, Y+1	; 0x01
    1484:	fa 81       	ldd	r31, Y+2	; 0x02
    1486:	80 81       	ld	r24, Z
    1488:	91 81       	ldd	r25, Z+1	; 0x01
    148a:	e9 81       	ldd	r30, Y+1	; 0x01
    148c:	fa 81       	ldd	r31, Y+2	; 0x02
    148e:	93 83       	std	Z+3, r25	; 0x03
    1490:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1492:	e9 81       	ldd	r30, Y+1	; 0x01
    1494:	fa 81       	ldd	r31, Y+2	; 0x02
    1496:	40 81       	ld	r20, Z
    1498:	51 81       	ldd	r21, Z+1	; 0x01
    149a:	e9 81       	ldd	r30, Y+1	; 0x01
    149c:	fa 81       	ldd	r31, Y+2	; 0x02
    149e:	83 8d       	ldd	r24, Z+27	; 0x1b
    14a0:	88 2f       	mov	r24, r24
    14a2:	90 e0       	ldi	r25, 0x00	; 0
    14a4:	9c 01       	movw	r18, r24
    14a6:	21 50       	subi	r18, 0x01	; 1
    14a8:	30 40       	sbci	r19, 0x00	; 0
    14aa:	e9 81       	ldd	r30, Y+1	; 0x01
    14ac:	fa 81       	ldd	r31, Y+2	; 0x02
    14ae:	84 8d       	ldd	r24, Z+28	; 0x1c
    14b0:	88 2f       	mov	r24, r24
    14b2:	90 e0       	ldi	r25, 0x00	; 0
    14b4:	bc 01       	movw	r22, r24
    14b6:	26 9f       	mul	r18, r22
    14b8:	c0 01       	movw	r24, r0
    14ba:	27 9f       	mul	r18, r23
    14bc:	90 0d       	add	r25, r0
    14be:	36 9f       	mul	r19, r22
    14c0:	90 0d       	add	r25, r0
    14c2:	11 24       	eor	r1, r1
    14c4:	84 0f       	add	r24, r20
    14c6:	95 1f       	adc	r25, r21
    14c8:	e9 81       	ldd	r30, Y+1	; 0x01
    14ca:	fa 81       	ldd	r31, Y+2	; 0x02
    14cc:	97 83       	std	Z+7, r25	; 0x07
    14ce:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    14d0:	e9 81       	ldd	r30, Y+1	; 0x01
    14d2:	fa 81       	ldd	r31, Y+2	; 0x02
    14d4:	8f ef       	ldi	r24, 0xFF	; 255
    14d6:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    14d8:	e9 81       	ldd	r30, Y+1	; 0x01
    14da:	fa 81       	ldd	r31, Y+2	; 0x02
    14dc:	8f ef       	ldi	r24, 0xFF	; 255
    14de:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    14e0:	8d 81       	ldd	r24, Y+5	; 0x05
    14e2:	88 23       	and	r24, r24
    14e4:	59 f4       	brne	.+22     	; 0x14fc <xQueueGenericReset+0xda>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14e6:	e9 81       	ldd	r30, Y+1	; 0x01
    14e8:	fa 81       	ldd	r31, Y+2	; 0x02
    14ea:	80 85       	ldd	r24, Z+8	; 0x08
    14ec:	88 23       	and	r24, r24
    14ee:	81 f0       	breq	.+32     	; 0x1510 <xQueueGenericReset+0xee>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    14f0:	89 81       	ldd	r24, Y+1	; 0x01
    14f2:	9a 81       	ldd	r25, Y+2	; 0x02
    14f4:	08 96       	adiw	r24, 0x08	; 8
    14f6:	0e 94 fe 1e 	call	0x3dfc	; 0x3dfc <xTaskRemoveFromEventList>
    14fa:	0a c0       	rjmp	.+20     	; 0x1510 <xQueueGenericReset+0xee>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    14fc:	89 81       	ldd	r24, Y+1	; 0x01
    14fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1500:	08 96       	adiw	r24, 0x08	; 8
    1502:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1506:	89 81       	ldd	r24, Y+1	; 0x01
    1508:	9a 81       	ldd	r25, Y+2	; 0x02
    150a:	41 96       	adiw	r24, 0x11	; 17
    150c:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1510:	0f 90       	pop	r0
    1512:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1514:	81 e0       	ldi	r24, 0x01	; 1
}
    1516:	0f 90       	pop	r0
    1518:	0f 90       	pop	r0
    151a:	0f 90       	pop	r0
    151c:	0f 90       	pop	r0
    151e:	0f 90       	pop	r0
    1520:	cf 91       	pop	r28
    1522:	df 91       	pop	r29
    1524:	08 95       	ret

00001526 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1526:	0f 93       	push	r16
    1528:	1f 93       	push	r17
    152a:	df 93       	push	r29
    152c:	cf 93       	push	r28
    152e:	cd b7       	in	r28, 0x3d	; 61
    1530:	de b7       	in	r29, 0x3e	; 62
    1532:	29 97       	sbiw	r28, 0x09	; 9
    1534:	0f b6       	in	r0, 0x3f	; 63
    1536:	f8 94       	cli
    1538:	de bf       	out	0x3e, r29	; 62
    153a:	0f be       	out	0x3f, r0	; 63
    153c:	cd bf       	out	0x3d, r28	; 61
    153e:	8f 83       	std	Y+7, r24	; 0x07
    1540:	68 87       	std	Y+8, r22	; 0x08
    1542:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1544:	88 85       	ldd	r24, Y+8	; 0x08
    1546:	88 23       	and	r24, r24
    1548:	19 f4       	brne	.+6      	; 0x1550 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    154a:	1c 82       	std	Y+4, r1	; 0x04
    154c:	1b 82       	std	Y+3, r1	; 0x03
    154e:	10 c0       	rjmp	.+32     	; 0x1570 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1550:	8f 81       	ldd	r24, Y+7	; 0x07
    1552:	28 2f       	mov	r18, r24
    1554:	30 e0       	ldi	r19, 0x00	; 0
    1556:	88 85       	ldd	r24, Y+8	; 0x08
    1558:	88 2f       	mov	r24, r24
    155a:	90 e0       	ldi	r25, 0x00	; 0
    155c:	ac 01       	movw	r20, r24
    155e:	24 9f       	mul	r18, r20
    1560:	c0 01       	movw	r24, r0
    1562:	25 9f       	mul	r18, r21
    1564:	90 0d       	add	r25, r0
    1566:	34 9f       	mul	r19, r20
    1568:	90 0d       	add	r25, r0
    156a:	11 24       	eor	r1, r1
    156c:	9c 83       	std	Y+4, r25	; 0x04
    156e:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1570:	8b 81       	ldd	r24, Y+3	; 0x03
    1572:	9c 81       	ldd	r25, Y+4	; 0x04
    1574:	4f 96       	adiw	r24, 0x1f	; 31
    1576:	0e 94 64 05 	call	0xac8	; 0xac8 <pvPortMalloc>
    157a:	9e 83       	std	Y+6, r25	; 0x06
    157c:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    157e:	8d 81       	ldd	r24, Y+5	; 0x05
    1580:	9e 81       	ldd	r25, Y+6	; 0x06
    1582:	00 97       	sbiw	r24, 0x00	; 0
    1584:	a1 f0       	breq	.+40     	; 0x15ae <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1586:	8d 81       	ldd	r24, Y+5	; 0x05
    1588:	9e 81       	ldd	r25, Y+6	; 0x06
    158a:	9a 83       	std	Y+2, r25	; 0x02
    158c:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    158e:	89 81       	ldd	r24, Y+1	; 0x01
    1590:	9a 81       	ldd	r25, Y+2	; 0x02
    1592:	4f 96       	adiw	r24, 0x1f	; 31
    1594:	9a 83       	std	Y+2, r25	; 0x02
    1596:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1598:	29 81       	ldd	r18, Y+1	; 0x01
    159a:	3a 81       	ldd	r19, Y+2	; 0x02
    159c:	ed 81       	ldd	r30, Y+5	; 0x05
    159e:	fe 81       	ldd	r31, Y+6	; 0x06
    15a0:	8f 81       	ldd	r24, Y+7	; 0x07
    15a2:	68 85       	ldd	r22, Y+8	; 0x08
    15a4:	a9 01       	movw	r20, r18
    15a6:	29 85       	ldd	r18, Y+9	; 0x09
    15a8:	8f 01       	movw	r16, r30
    15aa:	0e 94 e4 0a 	call	0x15c8	; 0x15c8 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    15ae:	8d 81       	ldd	r24, Y+5	; 0x05
    15b0:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    15b2:	29 96       	adiw	r28, 0x09	; 9
    15b4:	0f b6       	in	r0, 0x3f	; 63
    15b6:	f8 94       	cli
    15b8:	de bf       	out	0x3e, r29	; 62
    15ba:	0f be       	out	0x3f, r0	; 63
    15bc:	cd bf       	out	0x3d, r28	; 61
    15be:	cf 91       	pop	r28
    15c0:	df 91       	pop	r29
    15c2:	1f 91       	pop	r17
    15c4:	0f 91       	pop	r16
    15c6:	08 95       	ret

000015c8 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    15c8:	0f 93       	push	r16
    15ca:	1f 93       	push	r17
    15cc:	df 93       	push	r29
    15ce:	cf 93       	push	r28
    15d0:	cd b7       	in	r28, 0x3d	; 61
    15d2:	de b7       	in	r29, 0x3e	; 62
    15d4:	27 97       	sbiw	r28, 0x07	; 7
    15d6:	0f b6       	in	r0, 0x3f	; 63
    15d8:	f8 94       	cli
    15da:	de bf       	out	0x3e, r29	; 62
    15dc:	0f be       	out	0x3f, r0	; 63
    15de:	cd bf       	out	0x3d, r28	; 61
    15e0:	89 83       	std	Y+1, r24	; 0x01
    15e2:	6a 83       	std	Y+2, r22	; 0x02
    15e4:	5c 83       	std	Y+4, r21	; 0x04
    15e6:	4b 83       	std	Y+3, r20	; 0x03
    15e8:	2d 83       	std	Y+5, r18	; 0x05
    15ea:	1f 83       	std	Y+7, r17	; 0x07
    15ec:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    15ee:	8a 81       	ldd	r24, Y+2	; 0x02
    15f0:	88 23       	and	r24, r24
    15f2:	39 f4       	brne	.+14     	; 0x1602 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    15f4:	8e 81       	ldd	r24, Y+6	; 0x06
    15f6:	9f 81       	ldd	r25, Y+7	; 0x07
    15f8:	ee 81       	ldd	r30, Y+6	; 0x06
    15fa:	ff 81       	ldd	r31, Y+7	; 0x07
    15fc:	91 83       	std	Z+1, r25	; 0x01
    15fe:	80 83       	st	Z, r24
    1600:	06 c0       	rjmp	.+12     	; 0x160e <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1602:	8b 81       	ldd	r24, Y+3	; 0x03
    1604:	9c 81       	ldd	r25, Y+4	; 0x04
    1606:	ee 81       	ldd	r30, Y+6	; 0x06
    1608:	ff 81       	ldd	r31, Y+7	; 0x07
    160a:	91 83       	std	Z+1, r25	; 0x01
    160c:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    160e:	ee 81       	ldd	r30, Y+6	; 0x06
    1610:	ff 81       	ldd	r31, Y+7	; 0x07
    1612:	89 81       	ldd	r24, Y+1	; 0x01
    1614:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1616:	ee 81       	ldd	r30, Y+6	; 0x06
    1618:	ff 81       	ldd	r31, Y+7	; 0x07
    161a:	8a 81       	ldd	r24, Y+2	; 0x02
    161c:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    161e:	8e 81       	ldd	r24, Y+6	; 0x06
    1620:	9f 81       	ldd	r25, Y+7	; 0x07
    1622:	61 e0       	ldi	r22, 0x01	; 1
    1624:	0e 94 11 0a 	call	0x1422	; 0x1422 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    1628:	27 96       	adiw	r28, 0x07	; 7
    162a:	0f b6       	in	r0, 0x3f	; 63
    162c:	f8 94       	cli
    162e:	de bf       	out	0x3e, r29	; 62
    1630:	0f be       	out	0x3f, r0	; 63
    1632:	cd bf       	out	0x3d, r28	; 61
    1634:	cf 91       	pop	r28
    1636:	df 91       	pop	r29
    1638:	1f 91       	pop	r17
    163a:	0f 91       	pop	r16
    163c:	08 95       	ret

0000163e <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    163e:	df 93       	push	r29
    1640:	cf 93       	push	r28
    1642:	cd b7       	in	r28, 0x3d	; 61
    1644:	de b7       	in	r29, 0x3e	; 62
    1646:	2f 97       	sbiw	r28, 0x0f	; 15
    1648:	0f b6       	in	r0, 0x3f	; 63
    164a:	f8 94       	cli
    164c:	de bf       	out	0x3e, r29	; 62
    164e:	0f be       	out	0x3f, r0	; 63
    1650:	cd bf       	out	0x3d, r28	; 61
    1652:	99 87       	std	Y+9, r25	; 0x09
    1654:	88 87       	std	Y+8, r24	; 0x08
    1656:	7b 87       	std	Y+11, r23	; 0x0b
    1658:	6a 87       	std	Y+10, r22	; 0x0a
    165a:	5d 87       	std	Y+13, r21	; 0x0d
    165c:	4c 87       	std	Y+12, r20	; 0x0c
    165e:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1660:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1662:	88 85       	ldd	r24, Y+8	; 0x08
    1664:	99 85       	ldd	r25, Y+9	; 0x09
    1666:	9a 83       	std	Y+2, r25	; 0x02
    1668:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    166a:	0f b6       	in	r0, 0x3f	; 63
    166c:	f8 94       	cli
    166e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1670:	e9 81       	ldd	r30, Y+1	; 0x01
    1672:	fa 81       	ldd	r31, Y+2	; 0x02
    1674:	92 8d       	ldd	r25, Z+26	; 0x1a
    1676:	e9 81       	ldd	r30, Y+1	; 0x01
    1678:	fa 81       	ldd	r31, Y+2	; 0x02
    167a:	83 8d       	ldd	r24, Z+27	; 0x1b
    167c:	98 17       	cp	r25, r24
    167e:	18 f0       	brcs	.+6      	; 0x1686 <xQueueGenericSend+0x48>
    1680:	8e 85       	ldd	r24, Y+14	; 0x0e
    1682:	82 30       	cpi	r24, 0x02	; 2
    1684:	c1 f4       	brne	.+48     	; 0x16b6 <xQueueGenericSend+0x78>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1686:	89 81       	ldd	r24, Y+1	; 0x01
    1688:	9a 81       	ldd	r25, Y+2	; 0x02
    168a:	2a 85       	ldd	r18, Y+10	; 0x0a
    168c:	3b 85       	ldd	r19, Y+11	; 0x0b
    168e:	b9 01       	movw	r22, r18
    1690:	4e 85       	ldd	r20, Y+14	; 0x0e
    1692:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <prvCopyDataToQueue>
    1696:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1698:	e9 81       	ldd	r30, Y+1	; 0x01
    169a:	fa 81       	ldd	r31, Y+2	; 0x02
    169c:	81 89       	ldd	r24, Z+17	; 0x11
    169e:	88 23       	and	r24, r24
    16a0:	29 f0       	breq	.+10     	; 0x16ac <xQueueGenericSend+0x6e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16a2:	89 81       	ldd	r24, Y+1	; 0x01
    16a4:	9a 81       	ldd	r25, Y+2	; 0x02
    16a6:	41 96       	adiw	r24, 0x11	; 17
    16a8:	0e 94 fe 1e 	call	0x3dfc	; 0x3dfc <xTaskRemoveFromEventList>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    16ac:	0f 90       	pop	r0
    16ae:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    16b0:	81 e0       	ldi	r24, 0x01	; 1
    16b2:	8f 87       	std	Y+15, r24	; 0x0f
    16b4:	5c c0       	rjmp	.+184    	; 0x176e <xQueueGenericSend+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    16b6:	8c 85       	ldd	r24, Y+12	; 0x0c
    16b8:	9d 85       	ldd	r25, Y+13	; 0x0d
    16ba:	00 97       	sbiw	r24, 0x00	; 0
    16bc:	21 f4       	brne	.+8      	; 0x16c6 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    16be:	0f 90       	pop	r0
    16c0:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    16c2:	1f 86       	std	Y+15, r1	; 0x0f
    16c4:	54 c0       	rjmp	.+168    	; 0x176e <xQueueGenericSend+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    16c6:	8c 81       	ldd	r24, Y+4	; 0x04
    16c8:	88 23       	and	r24, r24
    16ca:	31 f4       	brne	.+12     	; 0x16d8 <xQueueGenericSend+0x9a>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    16cc:	ce 01       	movw	r24, r28
    16ce:	05 96       	adiw	r24, 0x05	; 5
    16d0:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    16d4:	81 e0       	ldi	r24, 0x01	; 1
    16d6:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    16d8:	0f 90       	pop	r0
    16da:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    16dc:	0e 94 8e 1c 	call	0x391c	; 0x391c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    16e0:	0f b6       	in	r0, 0x3f	; 63
    16e2:	f8 94       	cli
    16e4:	0f 92       	push	r0
    16e6:	e9 81       	ldd	r30, Y+1	; 0x01
    16e8:	fa 81       	ldd	r31, Y+2	; 0x02
    16ea:	85 8d       	ldd	r24, Z+29	; 0x1d
    16ec:	8f 3f       	cpi	r24, 0xFF	; 255
    16ee:	19 f4       	brne	.+6      	; 0x16f6 <xQueueGenericSend+0xb8>
    16f0:	e9 81       	ldd	r30, Y+1	; 0x01
    16f2:	fa 81       	ldd	r31, Y+2	; 0x02
    16f4:	15 8e       	std	Z+29, r1	; 0x1d
    16f6:	e9 81       	ldd	r30, Y+1	; 0x01
    16f8:	fa 81       	ldd	r31, Y+2	; 0x02
    16fa:	86 8d       	ldd	r24, Z+30	; 0x1e
    16fc:	8f 3f       	cpi	r24, 0xFF	; 255
    16fe:	19 f4       	brne	.+6      	; 0x1706 <xQueueGenericSend+0xc8>
    1700:	e9 81       	ldd	r30, Y+1	; 0x01
    1702:	fa 81       	ldd	r31, Y+2	; 0x02
    1704:	16 8e       	std	Z+30, r1	; 0x1e
    1706:	0f 90       	pop	r0
    1708:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    170a:	ce 01       	movw	r24, r28
    170c:	05 96       	adiw	r24, 0x05	; 5
    170e:	9e 01       	movw	r18, r28
    1710:	24 5f       	subi	r18, 0xF4	; 244
    1712:	3f 4f       	sbci	r19, 0xFF	; 255
    1714:	b9 01       	movw	r22, r18
    1716:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <xTaskCheckForTimeOut>
    171a:	88 23       	and	r24, r24
    171c:	09 f5       	brne	.+66     	; 0x1760 <xQueueGenericSend+0x122>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    171e:	89 81       	ldd	r24, Y+1	; 0x01
    1720:	9a 81       	ldd	r25, Y+2	; 0x02
    1722:	0e 94 d7 10 	call	0x21ae	; 0x21ae <prvIsQueueFull>
    1726:	88 23       	and	r24, r24
    1728:	a1 f0       	breq	.+40     	; 0x1752 <xQueueGenericSend+0x114>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    172a:	89 81       	ldd	r24, Y+1	; 0x01
    172c:	9a 81       	ldd	r25, Y+2	; 0x02
    172e:	08 96       	adiw	r24, 0x08	; 8
    1730:	2c 85       	ldd	r18, Y+12	; 0x0c
    1732:	3d 85       	ldd	r19, Y+13	; 0x0d
    1734:	b9 01       	movw	r22, r18
    1736:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    173a:	89 81       	ldd	r24, Y+1	; 0x01
    173c:	9a 81       	ldd	r25, Y+2	; 0x02
    173e:	0e 94 48 10 	call	0x2090	; 0x2090 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1742:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>
    1746:	88 23       	and	r24, r24
    1748:	09 f0       	breq	.+2      	; 0x174c <xQueueGenericSend+0x10e>
    174a:	8f cf       	rjmp	.-226    	; 0x166a <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    174c:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vPortYield>
    1750:	8c cf       	rjmp	.-232    	; 0x166a <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1752:	89 81       	ldd	r24, Y+1	; 0x01
    1754:	9a 81       	ldd	r25, Y+2	; 0x02
    1756:	0e 94 48 10 	call	0x2090	; 0x2090 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    175a:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>
    175e:	85 cf       	rjmp	.-246    	; 0x166a <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1760:	89 81       	ldd	r24, Y+1	; 0x01
    1762:	9a 81       	ldd	r25, Y+2	; 0x02
    1764:	0e 94 48 10 	call	0x2090	; 0x2090 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1768:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    176c:	1f 86       	std	Y+15, r1	; 0x0f
    176e:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    1770:	2f 96       	adiw	r28, 0x0f	; 15
    1772:	0f b6       	in	r0, 0x3f	; 63
    1774:	f8 94       	cli
    1776:	de bf       	out	0x3e, r29	; 62
    1778:	0f be       	out	0x3f, r0	; 63
    177a:	cd bf       	out	0x3d, r28	; 61
    177c:	cf 91       	pop	r28
    177e:	df 91       	pop	r29
    1780:	08 95       	ret

00001782 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1782:	df 93       	push	r29
    1784:	cf 93       	push	r28
    1786:	cd b7       	in	r28, 0x3d	; 61
    1788:	de b7       	in	r29, 0x3e	; 62
    178a:	2c 97       	sbiw	r28, 0x0c	; 12
    178c:	0f b6       	in	r0, 0x3f	; 63
    178e:	f8 94       	cli
    1790:	de bf       	out	0x3e, r29	; 62
    1792:	0f be       	out	0x3f, r0	; 63
    1794:	cd bf       	out	0x3d, r28	; 61
    1796:	9f 83       	std	Y+7, r25	; 0x07
    1798:	8e 83       	std	Y+6, r24	; 0x06
    179a:	79 87       	std	Y+9, r23	; 0x09
    179c:	68 87       	std	Y+8, r22	; 0x08
    179e:	5b 87       	std	Y+11, r21	; 0x0b
    17a0:	4a 87       	std	Y+10, r20	; 0x0a
    17a2:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    17a4:	8e 81       	ldd	r24, Y+6	; 0x06
    17a6:	9f 81       	ldd	r25, Y+7	; 0x07
    17a8:	9b 83       	std	Y+3, r25	; 0x03
    17aa:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    17ac:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    17ae:	ea 81       	ldd	r30, Y+2	; 0x02
    17b0:	fb 81       	ldd	r31, Y+3	; 0x03
    17b2:	92 8d       	ldd	r25, Z+26	; 0x1a
    17b4:	ea 81       	ldd	r30, Y+2	; 0x02
    17b6:	fb 81       	ldd	r31, Y+3	; 0x03
    17b8:	83 8d       	ldd	r24, Z+27	; 0x1b
    17ba:	98 17       	cp	r25, r24
    17bc:	18 f0       	brcs	.+6      	; 0x17c4 <xQueueGenericSendFromISR+0x42>
    17be:	8c 85       	ldd	r24, Y+12	; 0x0c
    17c0:	82 30       	cpi	r24, 0x02	; 2
    17c2:	61 f5       	brne	.+88     	; 0x181c <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    17c4:	ea 81       	ldd	r30, Y+2	; 0x02
    17c6:	fb 81       	ldd	r31, Y+3	; 0x03
    17c8:	86 8d       	ldd	r24, Z+30	; 0x1e
    17ca:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    17cc:	8a 81       	ldd	r24, Y+2	; 0x02
    17ce:	9b 81       	ldd	r25, Y+3	; 0x03
    17d0:	28 85       	ldd	r18, Y+8	; 0x08
    17d2:	39 85       	ldd	r19, Y+9	; 0x09
    17d4:	b9 01       	movw	r22, r18
    17d6:	4c 85       	ldd	r20, Y+12	; 0x0c
    17d8:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    17dc:	89 81       	ldd	r24, Y+1	; 0x01
    17de:	8f 3f       	cpi	r24, 0xFF	; 255
    17e0:	a9 f4       	brne	.+42     	; 0x180c <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17e2:	ea 81       	ldd	r30, Y+2	; 0x02
    17e4:	fb 81       	ldd	r31, Y+3	; 0x03
    17e6:	81 89       	ldd	r24, Z+17	; 0x11
    17e8:	88 23       	and	r24, r24
    17ea:	a9 f0       	breq	.+42     	; 0x1816 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17ec:	8a 81       	ldd	r24, Y+2	; 0x02
    17ee:	9b 81       	ldd	r25, Y+3	; 0x03
    17f0:	41 96       	adiw	r24, 0x11	; 17
    17f2:	0e 94 fe 1e 	call	0x3dfc	; 0x3dfc <xTaskRemoveFromEventList>
    17f6:	88 23       	and	r24, r24
    17f8:	71 f0       	breq	.+28     	; 0x1816 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    17fa:	8a 85       	ldd	r24, Y+10	; 0x0a
    17fc:	9b 85       	ldd	r25, Y+11	; 0x0b
    17fe:	00 97       	sbiw	r24, 0x00	; 0
    1800:	51 f0       	breq	.+20     	; 0x1816 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1802:	ea 85       	ldd	r30, Y+10	; 0x0a
    1804:	fb 85       	ldd	r31, Y+11	; 0x0b
    1806:	81 e0       	ldi	r24, 0x01	; 1
    1808:	80 83       	st	Z, r24
    180a:	05 c0       	rjmp	.+10     	; 0x1816 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    180c:	89 81       	ldd	r24, Y+1	; 0x01
    180e:	8f 5f       	subi	r24, 0xFF	; 255
    1810:	ea 81       	ldd	r30, Y+2	; 0x02
    1812:	fb 81       	ldd	r31, Y+3	; 0x03
    1814:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1816:	81 e0       	ldi	r24, 0x01	; 1
    1818:	8d 83       	std	Y+5, r24	; 0x05
    181a:	01 c0       	rjmp	.+2      	; 0x181e <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    181c:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    181e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1820:	2c 96       	adiw	r28, 0x0c	; 12
    1822:	0f b6       	in	r0, 0x3f	; 63
    1824:	f8 94       	cli
    1826:	de bf       	out	0x3e, r29	; 62
    1828:	0f be       	out	0x3f, r0	; 63
    182a:	cd bf       	out	0x3d, r28	; 61
    182c:	cf 91       	pop	r28
    182e:	df 91       	pop	r29
    1830:	08 95       	ret

00001832 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1832:	df 93       	push	r29
    1834:	cf 93       	push	r28
    1836:	cd b7       	in	r28, 0x3d	; 61
    1838:	de b7       	in	r29, 0x3e	; 62
    183a:	2a 97       	sbiw	r28, 0x0a	; 10
    183c:	0f b6       	in	r0, 0x3f	; 63
    183e:	f8 94       	cli
    1840:	de bf       	out	0x3e, r29	; 62
    1842:	0f be       	out	0x3f, r0	; 63
    1844:	cd bf       	out	0x3d, r28	; 61
    1846:	98 87       	std	Y+8, r25	; 0x08
    1848:	8f 83       	std	Y+7, r24	; 0x07
    184a:	7a 87       	std	Y+10, r23	; 0x0a
    184c:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    184e:	8f 81       	ldd	r24, Y+7	; 0x07
    1850:	98 85       	ldd	r25, Y+8	; 0x08
    1852:	9c 83       	std	Y+4, r25	; 0x04
    1854:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1856:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1858:	eb 81       	ldd	r30, Y+3	; 0x03
    185a:	fc 81       	ldd	r31, Y+4	; 0x04
    185c:	82 8d       	ldd	r24, Z+26	; 0x1a
    185e:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1860:	eb 81       	ldd	r30, Y+3	; 0x03
    1862:	fc 81       	ldd	r31, Y+4	; 0x04
    1864:	93 8d       	ldd	r25, Z+27	; 0x1b
    1866:	8a 81       	ldd	r24, Y+2	; 0x02
    1868:	89 17       	cp	r24, r25
    186a:	48 f5       	brcc	.+82     	; 0x18be <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    186c:	eb 81       	ldd	r30, Y+3	; 0x03
    186e:	fc 81       	ldd	r31, Y+4	; 0x04
    1870:	86 8d       	ldd	r24, Z+30	; 0x1e
    1872:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1874:	8a 81       	ldd	r24, Y+2	; 0x02
    1876:	8f 5f       	subi	r24, 0xFF	; 255
    1878:	eb 81       	ldd	r30, Y+3	; 0x03
    187a:	fc 81       	ldd	r31, Y+4	; 0x04
    187c:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    187e:	89 81       	ldd	r24, Y+1	; 0x01
    1880:	8f 3f       	cpi	r24, 0xFF	; 255
    1882:	a9 f4       	brne	.+42     	; 0x18ae <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1884:	eb 81       	ldd	r30, Y+3	; 0x03
    1886:	fc 81       	ldd	r31, Y+4	; 0x04
    1888:	81 89       	ldd	r24, Z+17	; 0x11
    188a:	88 23       	and	r24, r24
    188c:	a9 f0       	breq	.+42     	; 0x18b8 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    188e:	8b 81       	ldd	r24, Y+3	; 0x03
    1890:	9c 81       	ldd	r25, Y+4	; 0x04
    1892:	41 96       	adiw	r24, 0x11	; 17
    1894:	0e 94 fe 1e 	call	0x3dfc	; 0x3dfc <xTaskRemoveFromEventList>
    1898:	88 23       	and	r24, r24
    189a:	71 f0       	breq	.+28     	; 0x18b8 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    189c:	89 85       	ldd	r24, Y+9	; 0x09
    189e:	9a 85       	ldd	r25, Y+10	; 0x0a
    18a0:	00 97       	sbiw	r24, 0x00	; 0
    18a2:	51 f0       	breq	.+20     	; 0x18b8 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    18a4:	e9 85       	ldd	r30, Y+9	; 0x09
    18a6:	fa 85       	ldd	r31, Y+10	; 0x0a
    18a8:	81 e0       	ldi	r24, 0x01	; 1
    18aa:	80 83       	st	Z, r24
    18ac:	05 c0       	rjmp	.+10     	; 0x18b8 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    18ae:	89 81       	ldd	r24, Y+1	; 0x01
    18b0:	8f 5f       	subi	r24, 0xFF	; 255
    18b2:	eb 81       	ldd	r30, Y+3	; 0x03
    18b4:	fc 81       	ldd	r31, Y+4	; 0x04
    18b6:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    18b8:	81 e0       	ldi	r24, 0x01	; 1
    18ba:	8e 83       	std	Y+6, r24	; 0x06
    18bc:	01 c0       	rjmp	.+2      	; 0x18c0 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    18be:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    18c0:	8e 81       	ldd	r24, Y+6	; 0x06
}
    18c2:	2a 96       	adiw	r28, 0x0a	; 10
    18c4:	0f b6       	in	r0, 0x3f	; 63
    18c6:	f8 94       	cli
    18c8:	de bf       	out	0x3e, r29	; 62
    18ca:	0f be       	out	0x3f, r0	; 63
    18cc:	cd bf       	out	0x3d, r28	; 61
    18ce:	cf 91       	pop	r28
    18d0:	df 91       	pop	r29
    18d2:	08 95       	ret

000018d4 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    18d4:	df 93       	push	r29
    18d6:	cf 93       	push	r28
    18d8:	cd b7       	in	r28, 0x3d	; 61
    18da:	de b7       	in	r29, 0x3e	; 62
    18dc:	2e 97       	sbiw	r28, 0x0e	; 14
    18de:	0f b6       	in	r0, 0x3f	; 63
    18e0:	f8 94       	cli
    18e2:	de bf       	out	0x3e, r29	; 62
    18e4:	0f be       	out	0x3f, r0	; 63
    18e6:	cd bf       	out	0x3d, r28	; 61
    18e8:	99 87       	std	Y+9, r25	; 0x09
    18ea:	88 87       	std	Y+8, r24	; 0x08
    18ec:	7b 87       	std	Y+11, r23	; 0x0b
    18ee:	6a 87       	std	Y+10, r22	; 0x0a
    18f0:	5d 87       	std	Y+13, r21	; 0x0d
    18f2:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    18f4:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    18f6:	88 85       	ldd	r24, Y+8	; 0x08
    18f8:	99 85       	ldd	r25, Y+9	; 0x09
    18fa:	9b 83       	std	Y+3, r25	; 0x03
    18fc:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    18fe:	0f b6       	in	r0, 0x3f	; 63
    1900:	f8 94       	cli
    1902:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1904:	ea 81       	ldd	r30, Y+2	; 0x02
    1906:	fb 81       	ldd	r31, Y+3	; 0x03
    1908:	82 8d       	ldd	r24, Z+26	; 0x1a
    190a:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    190c:	89 81       	ldd	r24, Y+1	; 0x01
    190e:	88 23       	and	r24, r24
    1910:	d9 f0       	breq	.+54     	; 0x1948 <xQueueReceive+0x74>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1912:	8a 81       	ldd	r24, Y+2	; 0x02
    1914:	9b 81       	ldd	r25, Y+3	; 0x03
    1916:	2a 85       	ldd	r18, Y+10	; 0x0a
    1918:	3b 85       	ldd	r19, Y+11	; 0x0b
    191a:	b9 01       	movw	r22, r18
    191c:	0e 94 01 10 	call	0x2002	; 0x2002 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1920:	89 81       	ldd	r24, Y+1	; 0x01
    1922:	81 50       	subi	r24, 0x01	; 1
    1924:	ea 81       	ldd	r30, Y+2	; 0x02
    1926:	fb 81       	ldd	r31, Y+3	; 0x03
    1928:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    192a:	ea 81       	ldd	r30, Y+2	; 0x02
    192c:	fb 81       	ldd	r31, Y+3	; 0x03
    192e:	80 85       	ldd	r24, Z+8	; 0x08
    1930:	88 23       	and	r24, r24
    1932:	29 f0       	breq	.+10     	; 0x193e <xQueueReceive+0x6a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1934:	8a 81       	ldd	r24, Y+2	; 0x02
    1936:	9b 81       	ldd	r25, Y+3	; 0x03
    1938:	08 96       	adiw	r24, 0x08	; 8
    193a:	0e 94 fe 1e 	call	0x3dfc	; 0x3dfc <xTaskRemoveFromEventList>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    193e:	0f 90       	pop	r0
    1940:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1942:	81 e0       	ldi	r24, 0x01	; 1
    1944:	8e 87       	std	Y+14, r24	; 0x0e
    1946:	63 c0       	rjmp	.+198    	; 0x1a0e <xQueueReceive+0x13a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1948:	8c 85       	ldd	r24, Y+12	; 0x0c
    194a:	9d 85       	ldd	r25, Y+13	; 0x0d
    194c:	00 97       	sbiw	r24, 0x00	; 0
    194e:	21 f4       	brne	.+8      	; 0x1958 <xQueueReceive+0x84>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1950:	0f 90       	pop	r0
    1952:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1954:	1e 86       	std	Y+14, r1	; 0x0e
    1956:	5b c0       	rjmp	.+182    	; 0x1a0e <xQueueReceive+0x13a>
				}
				else if( xEntryTimeSet == pdFALSE )
    1958:	8c 81       	ldd	r24, Y+4	; 0x04
    195a:	88 23       	and	r24, r24
    195c:	31 f4       	brne	.+12     	; 0x196a <xQueueReceive+0x96>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    195e:	ce 01       	movw	r24, r28
    1960:	05 96       	adiw	r24, 0x05	; 5
    1962:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1966:	81 e0       	ldi	r24, 0x01	; 1
    1968:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    196a:	0f 90       	pop	r0
    196c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    196e:	0e 94 8e 1c 	call	0x391c	; 0x391c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1972:	0f b6       	in	r0, 0x3f	; 63
    1974:	f8 94       	cli
    1976:	0f 92       	push	r0
    1978:	ea 81       	ldd	r30, Y+2	; 0x02
    197a:	fb 81       	ldd	r31, Y+3	; 0x03
    197c:	85 8d       	ldd	r24, Z+29	; 0x1d
    197e:	8f 3f       	cpi	r24, 0xFF	; 255
    1980:	19 f4       	brne	.+6      	; 0x1988 <xQueueReceive+0xb4>
    1982:	ea 81       	ldd	r30, Y+2	; 0x02
    1984:	fb 81       	ldd	r31, Y+3	; 0x03
    1986:	15 8e       	std	Z+29, r1	; 0x1d
    1988:	ea 81       	ldd	r30, Y+2	; 0x02
    198a:	fb 81       	ldd	r31, Y+3	; 0x03
    198c:	86 8d       	ldd	r24, Z+30	; 0x1e
    198e:	8f 3f       	cpi	r24, 0xFF	; 255
    1990:	19 f4       	brne	.+6      	; 0x1998 <xQueueReceive+0xc4>
    1992:	ea 81       	ldd	r30, Y+2	; 0x02
    1994:	fb 81       	ldd	r31, Y+3	; 0x03
    1996:	16 8e       	std	Z+30, r1	; 0x1e
    1998:	0f 90       	pop	r0
    199a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    199c:	ce 01       	movw	r24, r28
    199e:	05 96       	adiw	r24, 0x05	; 5
    19a0:	9e 01       	movw	r18, r28
    19a2:	24 5f       	subi	r18, 0xF4	; 244
    19a4:	3f 4f       	sbci	r19, 0xFF	; 255
    19a6:	b9 01       	movw	r22, r18
    19a8:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <xTaskCheckForTimeOut>
    19ac:	88 23       	and	r24, r24
    19ae:	09 f5       	brne	.+66     	; 0x19f2 <xQueueReceive+0x11e>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    19b0:	8a 81       	ldd	r24, Y+2	; 0x02
    19b2:	9b 81       	ldd	r25, Y+3	; 0x03
    19b4:	0e 94 9b 10 	call	0x2136	; 0x2136 <prvIsQueueEmpty>
    19b8:	88 23       	and	r24, r24
    19ba:	a1 f0       	breq	.+40     	; 0x19e4 <xQueueReceive+0x110>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    19bc:	8a 81       	ldd	r24, Y+2	; 0x02
    19be:	9b 81       	ldd	r25, Y+3	; 0x03
    19c0:	41 96       	adiw	r24, 0x11	; 17
    19c2:	2c 85       	ldd	r18, Y+12	; 0x0c
    19c4:	3d 85       	ldd	r19, Y+13	; 0x0d
    19c6:	b9 01       	movw	r22, r18
    19c8:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    19cc:	8a 81       	ldd	r24, Y+2	; 0x02
    19ce:	9b 81       	ldd	r25, Y+3	; 0x03
    19d0:	0e 94 48 10 	call	0x2090	; 0x2090 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    19d4:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>
    19d8:	88 23       	and	r24, r24
    19da:	09 f0       	breq	.+2      	; 0x19de <xQueueReceive+0x10a>
    19dc:	90 cf       	rjmp	.-224    	; 0x18fe <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    19de:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vPortYield>
    19e2:	8d cf       	rjmp	.-230    	; 0x18fe <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    19e4:	8a 81       	ldd	r24, Y+2	; 0x02
    19e6:	9b 81       	ldd	r25, Y+3	; 0x03
    19e8:	0e 94 48 10 	call	0x2090	; 0x2090 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    19ec:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>
    19f0:	86 cf       	rjmp	.-244    	; 0x18fe <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    19f2:	8a 81       	ldd	r24, Y+2	; 0x02
    19f4:	9b 81       	ldd	r25, Y+3	; 0x03
    19f6:	0e 94 48 10 	call	0x2090	; 0x2090 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    19fa:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    19fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1a00:	9b 81       	ldd	r25, Y+3	; 0x03
    1a02:	0e 94 9b 10 	call	0x2136	; 0x2136 <prvIsQueueEmpty>
    1a06:	88 23       	and	r24, r24
    1a08:	09 f4       	brne	.+2      	; 0x1a0c <xQueueReceive+0x138>
    1a0a:	79 cf       	rjmp	.-270    	; 0x18fe <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1a0c:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1a0e:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    1a10:	2e 96       	adiw	r28, 0x0e	; 14
    1a12:	0f b6       	in	r0, 0x3f	; 63
    1a14:	f8 94       	cli
    1a16:	de bf       	out	0x3e, r29	; 62
    1a18:	0f be       	out	0x3f, r0	; 63
    1a1a:	cd bf       	out	0x3d, r28	; 61
    1a1c:	cf 91       	pop	r28
    1a1e:	df 91       	pop	r29
    1a20:	08 95       	ret

00001a22 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1a22:	df 93       	push	r29
    1a24:	cf 93       	push	r28
    1a26:	cd b7       	in	r28, 0x3d	; 61
    1a28:	de b7       	in	r29, 0x3e	; 62
    1a2a:	2c 97       	sbiw	r28, 0x0c	; 12
    1a2c:	0f b6       	in	r0, 0x3f	; 63
    1a2e:	f8 94       	cli
    1a30:	de bf       	out	0x3e, r29	; 62
    1a32:	0f be       	out	0x3f, r0	; 63
    1a34:	cd bf       	out	0x3d, r28	; 61
    1a36:	99 87       	std	Y+9, r25	; 0x09
    1a38:	88 87       	std	Y+8, r24	; 0x08
    1a3a:	7b 87       	std	Y+11, r23	; 0x0b
    1a3c:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    1a3e:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1a40:	88 85       	ldd	r24, Y+8	; 0x08
    1a42:	99 85       	ldd	r25, Y+9	; 0x09
    1a44:	9b 83       	std	Y+3, r25	; 0x03
    1a46:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1a48:	0f b6       	in	r0, 0x3f	; 63
    1a4a:	f8 94       	cli
    1a4c:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1a4e:	ea 81       	ldd	r30, Y+2	; 0x02
    1a50:	fb 81       	ldd	r31, Y+3	; 0x03
    1a52:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a54:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1a56:	89 81       	ldd	r24, Y+1	; 0x01
    1a58:	88 23       	and	r24, r24
    1a5a:	a1 f0       	breq	.+40     	; 0x1a84 <xQueueSemaphoreTake+0x62>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1a5c:	89 81       	ldd	r24, Y+1	; 0x01
    1a5e:	81 50       	subi	r24, 0x01	; 1
    1a60:	ea 81       	ldd	r30, Y+2	; 0x02
    1a62:	fb 81       	ldd	r31, Y+3	; 0x03
    1a64:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a66:	ea 81       	ldd	r30, Y+2	; 0x02
    1a68:	fb 81       	ldd	r31, Y+3	; 0x03
    1a6a:	80 85       	ldd	r24, Z+8	; 0x08
    1a6c:	88 23       	and	r24, r24
    1a6e:	29 f0       	breq	.+10     	; 0x1a7a <xQueueSemaphoreTake+0x58>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a70:	8a 81       	ldd	r24, Y+2	; 0x02
    1a72:	9b 81       	ldd	r25, Y+3	; 0x03
    1a74:	08 96       	adiw	r24, 0x08	; 8
    1a76:	0e 94 fe 1e 	call	0x3dfc	; 0x3dfc <xTaskRemoveFromEventList>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1a7a:	0f 90       	pop	r0
    1a7c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a7e:	81 e0       	ldi	r24, 0x01	; 1
    1a80:	8c 87       	std	Y+12, r24	; 0x0c
    1a82:	63 c0       	rjmp	.+198    	; 0x1b4a <xQueueSemaphoreTake+0x128>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1a84:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a86:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a88:	00 97       	sbiw	r24, 0x00	; 0
    1a8a:	21 f4       	brne	.+8      	; 0x1a94 <xQueueSemaphoreTake+0x72>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    1a8c:	0f 90       	pop	r0
    1a8e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1a90:	1c 86       	std	Y+12, r1	; 0x0c
    1a92:	5b c0       	rjmp	.+182    	; 0x1b4a <xQueueSemaphoreTake+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1a94:	8c 81       	ldd	r24, Y+4	; 0x04
    1a96:	88 23       	and	r24, r24
    1a98:	31 f4       	brne	.+12     	; 0x1aa6 <xQueueSemaphoreTake+0x84>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1a9a:	ce 01       	movw	r24, r28
    1a9c:	05 96       	adiw	r24, 0x05	; 5
    1a9e:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1aa2:	81 e0       	ldi	r24, 0x01	; 1
    1aa4:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1aa6:	0f 90       	pop	r0
    1aa8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1aaa:	0e 94 8e 1c 	call	0x391c	; 0x391c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1aae:	0f b6       	in	r0, 0x3f	; 63
    1ab0:	f8 94       	cli
    1ab2:	0f 92       	push	r0
    1ab4:	ea 81       	ldd	r30, Y+2	; 0x02
    1ab6:	fb 81       	ldd	r31, Y+3	; 0x03
    1ab8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1aba:	8f 3f       	cpi	r24, 0xFF	; 255
    1abc:	19 f4       	brne	.+6      	; 0x1ac4 <xQueueSemaphoreTake+0xa2>
    1abe:	ea 81       	ldd	r30, Y+2	; 0x02
    1ac0:	fb 81       	ldd	r31, Y+3	; 0x03
    1ac2:	15 8e       	std	Z+29, r1	; 0x1d
    1ac4:	ea 81       	ldd	r30, Y+2	; 0x02
    1ac6:	fb 81       	ldd	r31, Y+3	; 0x03
    1ac8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1aca:	8f 3f       	cpi	r24, 0xFF	; 255
    1acc:	19 f4       	brne	.+6      	; 0x1ad4 <xQueueSemaphoreTake+0xb2>
    1ace:	ea 81       	ldd	r30, Y+2	; 0x02
    1ad0:	fb 81       	ldd	r31, Y+3	; 0x03
    1ad2:	16 8e       	std	Z+30, r1	; 0x1e
    1ad4:	0f 90       	pop	r0
    1ad6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1ad8:	ce 01       	movw	r24, r28
    1ada:	05 96       	adiw	r24, 0x05	; 5
    1adc:	9e 01       	movw	r18, r28
    1ade:	26 5f       	subi	r18, 0xF6	; 246
    1ae0:	3f 4f       	sbci	r19, 0xFF	; 255
    1ae2:	b9 01       	movw	r22, r18
    1ae4:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <xTaskCheckForTimeOut>
    1ae8:	88 23       	and	r24, r24
    1aea:	09 f5       	brne	.+66     	; 0x1b2e <xQueueSemaphoreTake+0x10c>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1aec:	8a 81       	ldd	r24, Y+2	; 0x02
    1aee:	9b 81       	ldd	r25, Y+3	; 0x03
    1af0:	0e 94 9b 10 	call	0x2136	; 0x2136 <prvIsQueueEmpty>
    1af4:	88 23       	and	r24, r24
    1af6:	a1 f0       	breq	.+40     	; 0x1b20 <xQueueSemaphoreTake+0xfe>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1af8:	8a 81       	ldd	r24, Y+2	; 0x02
    1afa:	9b 81       	ldd	r25, Y+3	; 0x03
    1afc:	41 96       	adiw	r24, 0x11	; 17
    1afe:	2a 85       	ldd	r18, Y+10	; 0x0a
    1b00:	3b 85       	ldd	r19, Y+11	; 0x0b
    1b02:	b9 01       	movw	r22, r18
    1b04:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1b08:	8a 81       	ldd	r24, Y+2	; 0x02
    1b0a:	9b 81       	ldd	r25, Y+3	; 0x03
    1b0c:	0e 94 48 10 	call	0x2090	; 0x2090 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1b10:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>
    1b14:	88 23       	and	r24, r24
    1b16:	09 f0       	breq	.+2      	; 0x1b1a <xQueueSemaphoreTake+0xf8>
    1b18:	97 cf       	rjmp	.-210    	; 0x1a48 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    1b1a:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vPortYield>
    1b1e:	94 cf       	rjmp	.-216    	; 0x1a48 <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1b20:	8a 81       	ldd	r24, Y+2	; 0x02
    1b22:	9b 81       	ldd	r25, Y+3	; 0x03
    1b24:	0e 94 48 10 	call	0x2090	; 0x2090 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1b28:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>
    1b2c:	8d cf       	rjmp	.-230    	; 0x1a48 <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1b2e:	8a 81       	ldd	r24, Y+2	; 0x02
    1b30:	9b 81       	ldd	r25, Y+3	; 0x03
    1b32:	0e 94 48 10 	call	0x2090	; 0x2090 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1b36:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b3a:	8a 81       	ldd	r24, Y+2	; 0x02
    1b3c:	9b 81       	ldd	r25, Y+3	; 0x03
    1b3e:	0e 94 9b 10 	call	0x2136	; 0x2136 <prvIsQueueEmpty>
    1b42:	88 23       	and	r24, r24
    1b44:	09 f4       	brne	.+2      	; 0x1b48 <xQueueSemaphoreTake+0x126>
    1b46:	80 cf       	rjmp	.-256    	; 0x1a48 <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1b48:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1b4a:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    1b4c:	2c 96       	adiw	r28, 0x0c	; 12
    1b4e:	0f b6       	in	r0, 0x3f	; 63
    1b50:	f8 94       	cli
    1b52:	de bf       	out	0x3e, r29	; 62
    1b54:	0f be       	out	0x3f, r0	; 63
    1b56:	cd bf       	out	0x3d, r28	; 61
    1b58:	cf 91       	pop	r28
    1b5a:	df 91       	pop	r29
    1b5c:	08 95       	ret

00001b5e <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1b5e:	df 93       	push	r29
    1b60:	cf 93       	push	r28
    1b62:	cd b7       	in	r28, 0x3d	; 61
    1b64:	de b7       	in	r29, 0x3e	; 62
    1b66:	60 97       	sbiw	r28, 0x10	; 16
    1b68:	0f b6       	in	r0, 0x3f	; 63
    1b6a:	f8 94       	cli
    1b6c:	de bf       	out	0x3e, r29	; 62
    1b6e:	0f be       	out	0x3f, r0	; 63
    1b70:	cd bf       	out	0x3d, r28	; 61
    1b72:	9b 87       	std	Y+11, r25	; 0x0b
    1b74:	8a 87       	std	Y+10, r24	; 0x0a
    1b76:	7d 87       	std	Y+13, r23	; 0x0d
    1b78:	6c 87       	std	Y+12, r22	; 0x0c
    1b7a:	5f 87       	std	Y+15, r21	; 0x0f
    1b7c:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    1b7e:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    1b80:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b82:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b84:	9b 83       	std	Y+3, r25	; 0x03
    1b86:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1b88:	0f b6       	in	r0, 0x3f	; 63
    1b8a:	f8 94       	cli
    1b8c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1b8e:	ea 81       	ldd	r30, Y+2	; 0x02
    1b90:	fb 81       	ldd	r31, Y+3	; 0x03
    1b92:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b94:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b96:	89 81       	ldd	r24, Y+1	; 0x01
    1b98:	88 23       	and	r24, r24
    1b9a:	11 f1       	breq	.+68     	; 0x1be0 <xQueuePeek+0x82>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1b9c:	ea 81       	ldd	r30, Y+2	; 0x02
    1b9e:	fb 81       	ldd	r31, Y+3	; 0x03
    1ba0:	86 81       	ldd	r24, Z+6	; 0x06
    1ba2:	97 81       	ldd	r25, Z+7	; 0x07
    1ba4:	9d 83       	std	Y+5, r25	; 0x05
    1ba6:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1ba8:	8a 81       	ldd	r24, Y+2	; 0x02
    1baa:	9b 81       	ldd	r25, Y+3	; 0x03
    1bac:	2c 85       	ldd	r18, Y+12	; 0x0c
    1bae:	3d 85       	ldd	r19, Y+13	; 0x0d
    1bb0:	b9 01       	movw	r22, r18
    1bb2:	0e 94 01 10 	call	0x2002	; 0x2002 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1bb6:	ea 81       	ldd	r30, Y+2	; 0x02
    1bb8:	fb 81       	ldd	r31, Y+3	; 0x03
    1bba:	8c 81       	ldd	r24, Y+4	; 0x04
    1bbc:	9d 81       	ldd	r25, Y+5	; 0x05
    1bbe:	97 83       	std	Z+7, r25	; 0x07
    1bc0:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1bc2:	ea 81       	ldd	r30, Y+2	; 0x02
    1bc4:	fb 81       	ldd	r31, Y+3	; 0x03
    1bc6:	81 89       	ldd	r24, Z+17	; 0x11
    1bc8:	88 23       	and	r24, r24
    1bca:	29 f0       	breq	.+10     	; 0x1bd6 <xQueuePeek+0x78>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1bcc:	8a 81       	ldd	r24, Y+2	; 0x02
    1bce:	9b 81       	ldd	r25, Y+3	; 0x03
    1bd0:	41 96       	adiw	r24, 0x11	; 17
    1bd2:	0e 94 fe 1e 	call	0x3dfc	; 0x3dfc <xTaskRemoveFromEventList>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1bd6:	0f 90       	pop	r0
    1bd8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1bda:	81 e0       	ldi	r24, 0x01	; 1
    1bdc:	88 8b       	std	Y+16, r24	; 0x10
    1bde:	63 c0       	rjmp	.+198    	; 0x1ca6 <xQueuePeek+0x148>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1be0:	8e 85       	ldd	r24, Y+14	; 0x0e
    1be2:	9f 85       	ldd	r25, Y+15	; 0x0f
    1be4:	00 97       	sbiw	r24, 0x00	; 0
    1be6:	21 f4       	brne	.+8      	; 0x1bf0 <xQueuePeek+0x92>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1be8:	0f 90       	pop	r0
    1bea:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1bec:	18 8a       	std	Y+16, r1	; 0x10
    1bee:	5b c0       	rjmp	.+182    	; 0x1ca6 <xQueuePeek+0x148>
				}
				else if( xEntryTimeSet == pdFALSE )
    1bf0:	8e 81       	ldd	r24, Y+6	; 0x06
    1bf2:	88 23       	and	r24, r24
    1bf4:	31 f4       	brne	.+12     	; 0x1c02 <xQueuePeek+0xa4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1bf6:	ce 01       	movw	r24, r28
    1bf8:	07 96       	adiw	r24, 0x07	; 7
    1bfa:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1bfe:	81 e0       	ldi	r24, 0x01	; 1
    1c00:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1c02:	0f 90       	pop	r0
    1c04:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1c06:	0e 94 8e 1c 	call	0x391c	; 0x391c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1c0a:	0f b6       	in	r0, 0x3f	; 63
    1c0c:	f8 94       	cli
    1c0e:	0f 92       	push	r0
    1c10:	ea 81       	ldd	r30, Y+2	; 0x02
    1c12:	fb 81       	ldd	r31, Y+3	; 0x03
    1c14:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c16:	8f 3f       	cpi	r24, 0xFF	; 255
    1c18:	19 f4       	brne	.+6      	; 0x1c20 <xQueuePeek+0xc2>
    1c1a:	ea 81       	ldd	r30, Y+2	; 0x02
    1c1c:	fb 81       	ldd	r31, Y+3	; 0x03
    1c1e:	15 8e       	std	Z+29, r1	; 0x1d
    1c20:	ea 81       	ldd	r30, Y+2	; 0x02
    1c22:	fb 81       	ldd	r31, Y+3	; 0x03
    1c24:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c26:	8f 3f       	cpi	r24, 0xFF	; 255
    1c28:	19 f4       	brne	.+6      	; 0x1c30 <xQueuePeek+0xd2>
    1c2a:	ea 81       	ldd	r30, Y+2	; 0x02
    1c2c:	fb 81       	ldd	r31, Y+3	; 0x03
    1c2e:	16 8e       	std	Z+30, r1	; 0x1e
    1c30:	0f 90       	pop	r0
    1c32:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c34:	ce 01       	movw	r24, r28
    1c36:	07 96       	adiw	r24, 0x07	; 7
    1c38:	9e 01       	movw	r18, r28
    1c3a:	22 5f       	subi	r18, 0xF2	; 242
    1c3c:	3f 4f       	sbci	r19, 0xFF	; 255
    1c3e:	b9 01       	movw	r22, r18
    1c40:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <xTaskCheckForTimeOut>
    1c44:	88 23       	and	r24, r24
    1c46:	09 f5       	brne	.+66     	; 0x1c8a <xQueuePeek+0x12c>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c48:	8a 81       	ldd	r24, Y+2	; 0x02
    1c4a:	9b 81       	ldd	r25, Y+3	; 0x03
    1c4c:	0e 94 9b 10 	call	0x2136	; 0x2136 <prvIsQueueEmpty>
    1c50:	88 23       	and	r24, r24
    1c52:	a1 f0       	breq	.+40     	; 0x1c7c <xQueuePeek+0x11e>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c54:	8a 81       	ldd	r24, Y+2	; 0x02
    1c56:	9b 81       	ldd	r25, Y+3	; 0x03
    1c58:	41 96       	adiw	r24, 0x11	; 17
    1c5a:	2e 85       	ldd	r18, Y+14	; 0x0e
    1c5c:	3f 85       	ldd	r19, Y+15	; 0x0f
    1c5e:	b9 01       	movw	r22, r18
    1c60:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1c64:	8a 81       	ldd	r24, Y+2	; 0x02
    1c66:	9b 81       	ldd	r25, Y+3	; 0x03
    1c68:	0e 94 48 10 	call	0x2090	; 0x2090 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1c6c:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>
    1c70:	88 23       	and	r24, r24
    1c72:	09 f0       	breq	.+2      	; 0x1c76 <xQueuePeek+0x118>
    1c74:	89 cf       	rjmp	.-238    	; 0x1b88 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    1c76:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vPortYield>
    1c7a:	86 cf       	rjmp	.-244    	; 0x1b88 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    1c7c:	8a 81       	ldd	r24, Y+2	; 0x02
    1c7e:	9b 81       	ldd	r25, Y+3	; 0x03
    1c80:	0e 94 48 10 	call	0x2090	; 0x2090 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1c84:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>
    1c88:	7f cf       	rjmp	.-258    	; 0x1b88 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    1c8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c8c:	9b 81       	ldd	r25, Y+3	; 0x03
    1c8e:	0e 94 48 10 	call	0x2090	; 0x2090 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1c92:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c96:	8a 81       	ldd	r24, Y+2	; 0x02
    1c98:	9b 81       	ldd	r25, Y+3	; 0x03
    1c9a:	0e 94 9b 10 	call	0x2136	; 0x2136 <prvIsQueueEmpty>
    1c9e:	88 23       	and	r24, r24
    1ca0:	09 f4       	brne	.+2      	; 0x1ca4 <xQueuePeek+0x146>
    1ca2:	72 cf       	rjmp	.-284    	; 0x1b88 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1ca4:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1ca6:	88 89       	ldd	r24, Y+16	; 0x10
}
    1ca8:	60 96       	adiw	r28, 0x10	; 16
    1caa:	0f b6       	in	r0, 0x3f	; 63
    1cac:	f8 94       	cli
    1cae:	de bf       	out	0x3e, r29	; 62
    1cb0:	0f be       	out	0x3f, r0	; 63
    1cb2:	cd bf       	out	0x3d, r28	; 61
    1cb4:	cf 91       	pop	r28
    1cb6:	df 91       	pop	r29
    1cb8:	08 95       	ret

00001cba <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1cba:	df 93       	push	r29
    1cbc:	cf 93       	push	r28
    1cbe:	cd b7       	in	r28, 0x3d	; 61
    1cc0:	de b7       	in	r29, 0x3e	; 62
    1cc2:	2c 97       	sbiw	r28, 0x0c	; 12
    1cc4:	0f b6       	in	r0, 0x3f	; 63
    1cc6:	f8 94       	cli
    1cc8:	de bf       	out	0x3e, r29	; 62
    1cca:	0f be       	out	0x3f, r0	; 63
    1ccc:	cd bf       	out	0x3d, r28	; 61
    1cce:	98 87       	std	Y+8, r25	; 0x08
    1cd0:	8f 83       	std	Y+7, r24	; 0x07
    1cd2:	7a 87       	std	Y+10, r23	; 0x0a
    1cd4:	69 87       	std	Y+9, r22	; 0x09
    1cd6:	5c 87       	std	Y+12, r21	; 0x0c
    1cd8:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1cda:	8f 81       	ldd	r24, Y+7	; 0x07
    1cdc:	98 85       	ldd	r25, Y+8	; 0x08
    1cde:	9c 83       	std	Y+4, r25	; 0x04
    1ce0:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1ce2:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1ce4:	eb 81       	ldd	r30, Y+3	; 0x03
    1ce6:	fc 81       	ldd	r31, Y+4	; 0x04
    1ce8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cea:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1cec:	8a 81       	ldd	r24, Y+2	; 0x02
    1cee:	88 23       	and	r24, r24
    1cf0:	81 f1       	breq	.+96     	; 0x1d52 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1cf2:	eb 81       	ldd	r30, Y+3	; 0x03
    1cf4:	fc 81       	ldd	r31, Y+4	; 0x04
    1cf6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1cf8:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1cfa:	8b 81       	ldd	r24, Y+3	; 0x03
    1cfc:	9c 81       	ldd	r25, Y+4	; 0x04
    1cfe:	29 85       	ldd	r18, Y+9	; 0x09
    1d00:	3a 85       	ldd	r19, Y+10	; 0x0a
    1d02:	b9 01       	movw	r22, r18
    1d04:	0e 94 01 10 	call	0x2002	; 0x2002 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1d08:	8a 81       	ldd	r24, Y+2	; 0x02
    1d0a:	81 50       	subi	r24, 0x01	; 1
    1d0c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d0e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d10:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1d12:	89 81       	ldd	r24, Y+1	; 0x01
    1d14:	8f 3f       	cpi	r24, 0xFF	; 255
    1d16:	a9 f4       	brne	.+42     	; 0x1d42 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d18:	eb 81       	ldd	r30, Y+3	; 0x03
    1d1a:	fc 81       	ldd	r31, Y+4	; 0x04
    1d1c:	80 85       	ldd	r24, Z+8	; 0x08
    1d1e:	88 23       	and	r24, r24
    1d20:	a9 f0       	breq	.+42     	; 0x1d4c <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d22:	8b 81       	ldd	r24, Y+3	; 0x03
    1d24:	9c 81       	ldd	r25, Y+4	; 0x04
    1d26:	08 96       	adiw	r24, 0x08	; 8
    1d28:	0e 94 fe 1e 	call	0x3dfc	; 0x3dfc <xTaskRemoveFromEventList>
    1d2c:	88 23       	and	r24, r24
    1d2e:	71 f0       	breq	.+28     	; 0x1d4c <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1d30:	8b 85       	ldd	r24, Y+11	; 0x0b
    1d32:	9c 85       	ldd	r25, Y+12	; 0x0c
    1d34:	00 97       	sbiw	r24, 0x00	; 0
    1d36:	51 f0       	breq	.+20     	; 0x1d4c <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1d38:	eb 85       	ldd	r30, Y+11	; 0x0b
    1d3a:	fc 85       	ldd	r31, Y+12	; 0x0c
    1d3c:	81 e0       	ldi	r24, 0x01	; 1
    1d3e:	80 83       	st	Z, r24
    1d40:	05 c0       	rjmp	.+10     	; 0x1d4c <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1d42:	89 81       	ldd	r24, Y+1	; 0x01
    1d44:	8f 5f       	subi	r24, 0xFF	; 255
    1d46:	eb 81       	ldd	r30, Y+3	; 0x03
    1d48:	fc 81       	ldd	r31, Y+4	; 0x04
    1d4a:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1d4c:	81 e0       	ldi	r24, 0x01	; 1
    1d4e:	8e 83       	std	Y+6, r24	; 0x06
    1d50:	01 c0       	rjmp	.+2      	; 0x1d54 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    1d52:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1d54:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1d56:	2c 96       	adiw	r28, 0x0c	; 12
    1d58:	0f b6       	in	r0, 0x3f	; 63
    1d5a:	f8 94       	cli
    1d5c:	de bf       	out	0x3e, r29	; 62
    1d5e:	0f be       	out	0x3f, r0	; 63
    1d60:	cd bf       	out	0x3d, r28	; 61
    1d62:	cf 91       	pop	r28
    1d64:	df 91       	pop	r29
    1d66:	08 95       	ret

00001d68 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1d68:	df 93       	push	r29
    1d6a:	cf 93       	push	r28
    1d6c:	cd b7       	in	r28, 0x3d	; 61
    1d6e:	de b7       	in	r29, 0x3e	; 62
    1d70:	2a 97       	sbiw	r28, 0x0a	; 10
    1d72:	0f b6       	in	r0, 0x3f	; 63
    1d74:	f8 94       	cli
    1d76:	de bf       	out	0x3e, r29	; 62
    1d78:	0f be       	out	0x3f, r0	; 63
    1d7a:	cd bf       	out	0x3d, r28	; 61
    1d7c:	98 87       	std	Y+8, r25	; 0x08
    1d7e:	8f 83       	std	Y+7, r24	; 0x07
    1d80:	7a 87       	std	Y+10, r23	; 0x0a
    1d82:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    1d84:	8f 81       	ldd	r24, Y+7	; 0x07
    1d86:	98 85       	ldd	r25, Y+8	; 0x08
    1d88:	9a 83       	std	Y+2, r25	; 0x02
    1d8a:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1d8c:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1d8e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d90:	fa 81       	ldd	r31, Y+2	; 0x02
    1d92:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d94:	88 23       	and	r24, r24
    1d96:	b1 f0       	breq	.+44     	; 0x1dc4 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1d98:	e9 81       	ldd	r30, Y+1	; 0x01
    1d9a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d9c:	86 81       	ldd	r24, Z+6	; 0x06
    1d9e:	97 81       	ldd	r25, Z+7	; 0x07
    1da0:	9c 83       	std	Y+4, r25	; 0x04
    1da2:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1da4:	89 81       	ldd	r24, Y+1	; 0x01
    1da6:	9a 81       	ldd	r25, Y+2	; 0x02
    1da8:	29 85       	ldd	r18, Y+9	; 0x09
    1daa:	3a 85       	ldd	r19, Y+10	; 0x0a
    1dac:	b9 01       	movw	r22, r18
    1dae:	0e 94 01 10 	call	0x2002	; 0x2002 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1db2:	e9 81       	ldd	r30, Y+1	; 0x01
    1db4:	fa 81       	ldd	r31, Y+2	; 0x02
    1db6:	8b 81       	ldd	r24, Y+3	; 0x03
    1db8:	9c 81       	ldd	r25, Y+4	; 0x04
    1dba:	97 83       	std	Z+7, r25	; 0x07
    1dbc:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    1dbe:	81 e0       	ldi	r24, 0x01	; 1
    1dc0:	8e 83       	std	Y+6, r24	; 0x06
    1dc2:	01 c0       	rjmp	.+2      	; 0x1dc6 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    1dc4:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1dc6:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1dc8:	2a 96       	adiw	r28, 0x0a	; 10
    1dca:	0f b6       	in	r0, 0x3f	; 63
    1dcc:	f8 94       	cli
    1dce:	de bf       	out	0x3e, r29	; 62
    1dd0:	0f be       	out	0x3f, r0	; 63
    1dd2:	cd bf       	out	0x3d, r28	; 61
    1dd4:	cf 91       	pop	r28
    1dd6:	df 91       	pop	r29
    1dd8:	08 95       	ret

00001dda <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    1dda:	df 93       	push	r29
    1ddc:	cf 93       	push	r28
    1dde:	00 d0       	rcall	.+0      	; 0x1de0 <uxQueueMessagesWaiting+0x6>
    1de0:	0f 92       	push	r0
    1de2:	cd b7       	in	r28, 0x3d	; 61
    1de4:	de b7       	in	r29, 0x3e	; 62
    1de6:	9b 83       	std	Y+3, r25	; 0x03
    1de8:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1dea:	0f b6       	in	r0, 0x3f	; 63
    1dec:	f8 94       	cli
    1dee:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1df0:	ea 81       	ldd	r30, Y+2	; 0x02
    1df2:	fb 81       	ldd	r31, Y+3	; 0x03
    1df4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1df6:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1df8:	0f 90       	pop	r0
    1dfa:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1dfc:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1dfe:	0f 90       	pop	r0
    1e00:	0f 90       	pop	r0
    1e02:	0f 90       	pop	r0
    1e04:	cf 91       	pop	r28
    1e06:	df 91       	pop	r29
    1e08:	08 95       	ret

00001e0a <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1e0a:	df 93       	push	r29
    1e0c:	cf 93       	push	r28
    1e0e:	00 d0       	rcall	.+0      	; 0x1e10 <uxQueueSpacesAvailable+0x6>
    1e10:	00 d0       	rcall	.+0      	; 0x1e12 <uxQueueSpacesAvailable+0x8>
    1e12:	0f 92       	push	r0
    1e14:	cd b7       	in	r28, 0x3d	; 61
    1e16:	de b7       	in	r29, 0x3e	; 62
    1e18:	9d 83       	std	Y+5, r25	; 0x05
    1e1a:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    1e1c:	8c 81       	ldd	r24, Y+4	; 0x04
    1e1e:	9d 81       	ldd	r25, Y+5	; 0x05
    1e20:	9a 83       	std	Y+2, r25	; 0x02
    1e22:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1e24:	0f b6       	in	r0, 0x3f	; 63
    1e26:	f8 94       	cli
    1e28:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1e2a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e2c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e2e:	93 8d       	ldd	r25, Z+27	; 0x1b
    1e30:	e9 81       	ldd	r30, Y+1	; 0x01
    1e32:	fa 81       	ldd	r31, Y+2	; 0x02
    1e34:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e36:	29 2f       	mov	r18, r25
    1e38:	28 1b       	sub	r18, r24
    1e3a:	82 2f       	mov	r24, r18
    1e3c:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    1e3e:	0f 90       	pop	r0
    1e40:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1e42:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1e44:	0f 90       	pop	r0
    1e46:	0f 90       	pop	r0
    1e48:	0f 90       	pop	r0
    1e4a:	0f 90       	pop	r0
    1e4c:	0f 90       	pop	r0
    1e4e:	cf 91       	pop	r28
    1e50:	df 91       	pop	r29
    1e52:	08 95       	ret

00001e54 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    1e54:	df 93       	push	r29
    1e56:	cf 93       	push	r28
    1e58:	00 d0       	rcall	.+0      	; 0x1e5a <uxQueueMessagesWaitingFromISR+0x6>
    1e5a:	00 d0       	rcall	.+0      	; 0x1e5c <uxQueueMessagesWaitingFromISR+0x8>
    1e5c:	0f 92       	push	r0
    1e5e:	cd b7       	in	r28, 0x3d	; 61
    1e60:	de b7       	in	r29, 0x3e	; 62
    1e62:	9d 83       	std	Y+5, r25	; 0x05
    1e64:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    1e66:	8c 81       	ldd	r24, Y+4	; 0x04
    1e68:	9d 81       	ldd	r25, Y+5	; 0x05
    1e6a:	9a 83       	std	Y+2, r25	; 0x02
    1e6c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1e6e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e70:	fa 81       	ldd	r31, Y+2	; 0x02
    1e72:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e74:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    1e76:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1e78:	0f 90       	pop	r0
    1e7a:	0f 90       	pop	r0
    1e7c:	0f 90       	pop	r0
    1e7e:	0f 90       	pop	r0
    1e80:	0f 90       	pop	r0
    1e82:	cf 91       	pop	r28
    1e84:	df 91       	pop	r29
    1e86:	08 95       	ret

00001e88 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1e88:	df 93       	push	r29
    1e8a:	cf 93       	push	r28
    1e8c:	00 d0       	rcall	.+0      	; 0x1e8e <vQueueDelete+0x6>
    1e8e:	00 d0       	rcall	.+0      	; 0x1e90 <vQueueDelete+0x8>
    1e90:	cd b7       	in	r28, 0x3d	; 61
    1e92:	de b7       	in	r29, 0x3e	; 62
    1e94:	9c 83       	std	Y+4, r25	; 0x04
    1e96:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    1e98:	8b 81       	ldd	r24, Y+3	; 0x03
    1e9a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e9c:	9a 83       	std	Y+2, r25	; 0x02
    1e9e:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1ea0:	89 81       	ldd	r24, Y+1	; 0x01
    1ea2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ea4:	0e 94 ba 05 	call	0xb74	; 0xb74 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1ea8:	0f 90       	pop	r0
    1eaa:	0f 90       	pop	r0
    1eac:	0f 90       	pop	r0
    1eae:	0f 90       	pop	r0
    1eb0:	cf 91       	pop	r28
    1eb2:	df 91       	pop	r29
    1eb4:	08 95       	ret

00001eb6 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1eb6:	df 93       	push	r29
    1eb8:	cf 93       	push	r28
    1eba:	cd b7       	in	r28, 0x3d	; 61
    1ebc:	de b7       	in	r29, 0x3e	; 62
    1ebe:	27 97       	sbiw	r28, 0x07	; 7
    1ec0:	0f b6       	in	r0, 0x3f	; 63
    1ec2:	f8 94       	cli
    1ec4:	de bf       	out	0x3e, r29	; 62
    1ec6:	0f be       	out	0x3f, r0	; 63
    1ec8:	cd bf       	out	0x3d, r28	; 61
    1eca:	9c 83       	std	Y+4, r25	; 0x04
    1ecc:	8b 83       	std	Y+3, r24	; 0x03
    1ece:	7e 83       	std	Y+6, r23	; 0x06
    1ed0:	6d 83       	std	Y+5, r22	; 0x05
    1ed2:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    1ed4:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1ed6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ed8:	fc 81       	ldd	r31, Y+4	; 0x04
    1eda:	82 8d       	ldd	r24, Z+26	; 0x1a
    1edc:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1ede:	eb 81       	ldd	r30, Y+3	; 0x03
    1ee0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ee2:	84 8d       	ldd	r24, Z+28	; 0x1c
    1ee4:	88 23       	and	r24, r24
    1ee6:	09 f4       	brne	.+2      	; 0x1eea <prvCopyDataToQueue+0x34>
    1ee8:	7d c0       	rjmp	.+250    	; 0x1fe4 <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1eea:	8f 81       	ldd	r24, Y+7	; 0x07
    1eec:	88 23       	and	r24, r24
    1eee:	99 f5       	brne	.+102    	; 0x1f56 <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1ef0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ef2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ef4:	62 81       	ldd	r22, Z+2	; 0x02
    1ef6:	73 81       	ldd	r23, Z+3	; 0x03
    1ef8:	eb 81       	ldd	r30, Y+3	; 0x03
    1efa:	fc 81       	ldd	r31, Y+4	; 0x04
    1efc:	84 8d       	ldd	r24, Z+28	; 0x1c
    1efe:	48 2f       	mov	r20, r24
    1f00:	50 e0       	ldi	r21, 0x00	; 0
    1f02:	2d 81       	ldd	r18, Y+5	; 0x05
    1f04:	3e 81       	ldd	r19, Y+6	; 0x06
    1f06:	cb 01       	movw	r24, r22
    1f08:	b9 01       	movw	r22, r18
    1f0a:	0e 94 61 3c 	call	0x78c2	; 0x78c2 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1f0e:	eb 81       	ldd	r30, Y+3	; 0x03
    1f10:	fc 81       	ldd	r31, Y+4	; 0x04
    1f12:	22 81       	ldd	r18, Z+2	; 0x02
    1f14:	33 81       	ldd	r19, Z+3	; 0x03
    1f16:	eb 81       	ldd	r30, Y+3	; 0x03
    1f18:	fc 81       	ldd	r31, Y+4	; 0x04
    1f1a:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f1c:	88 2f       	mov	r24, r24
    1f1e:	90 e0       	ldi	r25, 0x00	; 0
    1f20:	82 0f       	add	r24, r18
    1f22:	93 1f       	adc	r25, r19
    1f24:	eb 81       	ldd	r30, Y+3	; 0x03
    1f26:	fc 81       	ldd	r31, Y+4	; 0x04
    1f28:	93 83       	std	Z+3, r25	; 0x03
    1f2a:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1f2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f30:	22 81       	ldd	r18, Z+2	; 0x02
    1f32:	33 81       	ldd	r19, Z+3	; 0x03
    1f34:	eb 81       	ldd	r30, Y+3	; 0x03
    1f36:	fc 81       	ldd	r31, Y+4	; 0x04
    1f38:	84 81       	ldd	r24, Z+4	; 0x04
    1f3a:	95 81       	ldd	r25, Z+5	; 0x05
    1f3c:	28 17       	cp	r18, r24
    1f3e:	39 07       	cpc	r19, r25
    1f40:	08 f4       	brcc	.+2      	; 0x1f44 <prvCopyDataToQueue+0x8e>
    1f42:	50 c0       	rjmp	.+160    	; 0x1fe4 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1f44:	eb 81       	ldd	r30, Y+3	; 0x03
    1f46:	fc 81       	ldd	r31, Y+4	; 0x04
    1f48:	80 81       	ld	r24, Z
    1f4a:	91 81       	ldd	r25, Z+1	; 0x01
    1f4c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f4e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f50:	93 83       	std	Z+3, r25	; 0x03
    1f52:	82 83       	std	Z+2, r24	; 0x02
    1f54:	47 c0       	rjmp	.+142    	; 0x1fe4 <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1f56:	eb 81       	ldd	r30, Y+3	; 0x03
    1f58:	fc 81       	ldd	r31, Y+4	; 0x04
    1f5a:	66 81       	ldd	r22, Z+6	; 0x06
    1f5c:	77 81       	ldd	r23, Z+7	; 0x07
    1f5e:	eb 81       	ldd	r30, Y+3	; 0x03
    1f60:	fc 81       	ldd	r31, Y+4	; 0x04
    1f62:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f64:	48 2f       	mov	r20, r24
    1f66:	50 e0       	ldi	r21, 0x00	; 0
    1f68:	2d 81       	ldd	r18, Y+5	; 0x05
    1f6a:	3e 81       	ldd	r19, Y+6	; 0x06
    1f6c:	cb 01       	movw	r24, r22
    1f6e:	b9 01       	movw	r22, r18
    1f70:	0e 94 61 3c 	call	0x78c2	; 0x78c2 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1f74:	eb 81       	ldd	r30, Y+3	; 0x03
    1f76:	fc 81       	ldd	r31, Y+4	; 0x04
    1f78:	26 81       	ldd	r18, Z+6	; 0x06
    1f7a:	37 81       	ldd	r19, Z+7	; 0x07
    1f7c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f7e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f80:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f82:	88 2f       	mov	r24, r24
    1f84:	90 e0       	ldi	r25, 0x00	; 0
    1f86:	90 95       	com	r25
    1f88:	81 95       	neg	r24
    1f8a:	9f 4f       	sbci	r25, 0xFF	; 255
    1f8c:	82 0f       	add	r24, r18
    1f8e:	93 1f       	adc	r25, r19
    1f90:	eb 81       	ldd	r30, Y+3	; 0x03
    1f92:	fc 81       	ldd	r31, Y+4	; 0x04
    1f94:	97 83       	std	Z+7, r25	; 0x07
    1f96:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1f98:	eb 81       	ldd	r30, Y+3	; 0x03
    1f9a:	fc 81       	ldd	r31, Y+4	; 0x04
    1f9c:	26 81       	ldd	r18, Z+6	; 0x06
    1f9e:	37 81       	ldd	r19, Z+7	; 0x07
    1fa0:	eb 81       	ldd	r30, Y+3	; 0x03
    1fa2:	fc 81       	ldd	r31, Y+4	; 0x04
    1fa4:	80 81       	ld	r24, Z
    1fa6:	91 81       	ldd	r25, Z+1	; 0x01
    1fa8:	28 17       	cp	r18, r24
    1faa:	39 07       	cpc	r19, r25
    1fac:	90 f4       	brcc	.+36     	; 0x1fd2 <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1fae:	eb 81       	ldd	r30, Y+3	; 0x03
    1fb0:	fc 81       	ldd	r31, Y+4	; 0x04
    1fb2:	24 81       	ldd	r18, Z+4	; 0x04
    1fb4:	35 81       	ldd	r19, Z+5	; 0x05
    1fb6:	eb 81       	ldd	r30, Y+3	; 0x03
    1fb8:	fc 81       	ldd	r31, Y+4	; 0x04
    1fba:	84 8d       	ldd	r24, Z+28	; 0x1c
    1fbc:	88 2f       	mov	r24, r24
    1fbe:	90 e0       	ldi	r25, 0x00	; 0
    1fc0:	90 95       	com	r25
    1fc2:	81 95       	neg	r24
    1fc4:	9f 4f       	sbci	r25, 0xFF	; 255
    1fc6:	82 0f       	add	r24, r18
    1fc8:	93 1f       	adc	r25, r19
    1fca:	eb 81       	ldd	r30, Y+3	; 0x03
    1fcc:	fc 81       	ldd	r31, Y+4	; 0x04
    1fce:	97 83       	std	Z+7, r25	; 0x07
    1fd0:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1fd2:	8f 81       	ldd	r24, Y+7	; 0x07
    1fd4:	82 30       	cpi	r24, 0x02	; 2
    1fd6:	31 f4       	brne	.+12     	; 0x1fe4 <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1fd8:	89 81       	ldd	r24, Y+1	; 0x01
    1fda:	88 23       	and	r24, r24
    1fdc:	19 f0       	breq	.+6      	; 0x1fe4 <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1fde:	89 81       	ldd	r24, Y+1	; 0x01
    1fe0:	81 50       	subi	r24, 0x01	; 1
    1fe2:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1fe4:	89 81       	ldd	r24, Y+1	; 0x01
    1fe6:	8f 5f       	subi	r24, 0xFF	; 255
    1fe8:	eb 81       	ldd	r30, Y+3	; 0x03
    1fea:	fc 81       	ldd	r31, Y+4	; 0x04
    1fec:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    1fee:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1ff0:	27 96       	adiw	r28, 0x07	; 7
    1ff2:	0f b6       	in	r0, 0x3f	; 63
    1ff4:	f8 94       	cli
    1ff6:	de bf       	out	0x3e, r29	; 62
    1ff8:	0f be       	out	0x3f, r0	; 63
    1ffa:	cd bf       	out	0x3d, r28	; 61
    1ffc:	cf 91       	pop	r28
    1ffe:	df 91       	pop	r29
    2000:	08 95       	ret

00002002 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2002:	df 93       	push	r29
    2004:	cf 93       	push	r28
    2006:	00 d0       	rcall	.+0      	; 0x2008 <prvCopyDataFromQueue+0x6>
    2008:	00 d0       	rcall	.+0      	; 0x200a <prvCopyDataFromQueue+0x8>
    200a:	cd b7       	in	r28, 0x3d	; 61
    200c:	de b7       	in	r29, 0x3e	; 62
    200e:	9a 83       	std	Y+2, r25	; 0x02
    2010:	89 83       	std	Y+1, r24	; 0x01
    2012:	7c 83       	std	Y+4, r23	; 0x04
    2014:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2016:	e9 81       	ldd	r30, Y+1	; 0x01
    2018:	fa 81       	ldd	r31, Y+2	; 0x02
    201a:	84 8d       	ldd	r24, Z+28	; 0x1c
    201c:	88 23       	and	r24, r24
    201e:	89 f1       	breq	.+98     	; 0x2082 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2020:	e9 81       	ldd	r30, Y+1	; 0x01
    2022:	fa 81       	ldd	r31, Y+2	; 0x02
    2024:	26 81       	ldd	r18, Z+6	; 0x06
    2026:	37 81       	ldd	r19, Z+7	; 0x07
    2028:	e9 81       	ldd	r30, Y+1	; 0x01
    202a:	fa 81       	ldd	r31, Y+2	; 0x02
    202c:	84 8d       	ldd	r24, Z+28	; 0x1c
    202e:	88 2f       	mov	r24, r24
    2030:	90 e0       	ldi	r25, 0x00	; 0
    2032:	82 0f       	add	r24, r18
    2034:	93 1f       	adc	r25, r19
    2036:	e9 81       	ldd	r30, Y+1	; 0x01
    2038:	fa 81       	ldd	r31, Y+2	; 0x02
    203a:	97 83       	std	Z+7, r25	; 0x07
    203c:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    203e:	e9 81       	ldd	r30, Y+1	; 0x01
    2040:	fa 81       	ldd	r31, Y+2	; 0x02
    2042:	26 81       	ldd	r18, Z+6	; 0x06
    2044:	37 81       	ldd	r19, Z+7	; 0x07
    2046:	e9 81       	ldd	r30, Y+1	; 0x01
    2048:	fa 81       	ldd	r31, Y+2	; 0x02
    204a:	84 81       	ldd	r24, Z+4	; 0x04
    204c:	95 81       	ldd	r25, Z+5	; 0x05
    204e:	28 17       	cp	r18, r24
    2050:	39 07       	cpc	r19, r25
    2052:	40 f0       	brcs	.+16     	; 0x2064 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2054:	e9 81       	ldd	r30, Y+1	; 0x01
    2056:	fa 81       	ldd	r31, Y+2	; 0x02
    2058:	80 81       	ld	r24, Z
    205a:	91 81       	ldd	r25, Z+1	; 0x01
    205c:	e9 81       	ldd	r30, Y+1	; 0x01
    205e:	fa 81       	ldd	r31, Y+2	; 0x02
    2060:	97 83       	std	Z+7, r25	; 0x07
    2062:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2064:	e9 81       	ldd	r30, Y+1	; 0x01
    2066:	fa 81       	ldd	r31, Y+2	; 0x02
    2068:	46 81       	ldd	r20, Z+6	; 0x06
    206a:	57 81       	ldd	r21, Z+7	; 0x07
    206c:	e9 81       	ldd	r30, Y+1	; 0x01
    206e:	fa 81       	ldd	r31, Y+2	; 0x02
    2070:	84 8d       	ldd	r24, Z+28	; 0x1c
    2072:	28 2f       	mov	r18, r24
    2074:	30 e0       	ldi	r19, 0x00	; 0
    2076:	8b 81       	ldd	r24, Y+3	; 0x03
    2078:	9c 81       	ldd	r25, Y+4	; 0x04
    207a:	ba 01       	movw	r22, r20
    207c:	a9 01       	movw	r20, r18
    207e:	0e 94 61 3c 	call	0x78c2	; 0x78c2 <memcpy>
	}
}
    2082:	0f 90       	pop	r0
    2084:	0f 90       	pop	r0
    2086:	0f 90       	pop	r0
    2088:	0f 90       	pop	r0
    208a:	cf 91       	pop	r28
    208c:	df 91       	pop	r29
    208e:	08 95       	ret

00002090 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2090:	df 93       	push	r29
    2092:	cf 93       	push	r28
    2094:	00 d0       	rcall	.+0      	; 0x2096 <prvUnlockQueue+0x6>
    2096:	00 d0       	rcall	.+0      	; 0x2098 <prvUnlockQueue+0x8>
    2098:	cd b7       	in	r28, 0x3d	; 61
    209a:	de b7       	in	r29, 0x3e	; 62
    209c:	9c 83       	std	Y+4, r25	; 0x04
    209e:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    20a0:	0f b6       	in	r0, 0x3f	; 63
    20a2:	f8 94       	cli
    20a4:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    20a6:	eb 81       	ldd	r30, Y+3	; 0x03
    20a8:	fc 81       	ldd	r31, Y+4	; 0x04
    20aa:	86 8d       	ldd	r24, Z+30	; 0x1e
    20ac:	8a 83       	std	Y+2, r24	; 0x02
    20ae:	11 c0       	rjmp	.+34     	; 0x20d2 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20b0:	eb 81       	ldd	r30, Y+3	; 0x03
    20b2:	fc 81       	ldd	r31, Y+4	; 0x04
    20b4:	81 89       	ldd	r24, Z+17	; 0x11
    20b6:	88 23       	and	r24, r24
    20b8:	79 f0       	breq	.+30     	; 0x20d8 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20ba:	8b 81       	ldd	r24, Y+3	; 0x03
    20bc:	9c 81       	ldd	r25, Y+4	; 0x04
    20be:	41 96       	adiw	r24, 0x11	; 17
    20c0:	0e 94 fe 1e 	call	0x3dfc	; 0x3dfc <xTaskRemoveFromEventList>
    20c4:	88 23       	and	r24, r24
    20c6:	11 f0       	breq	.+4      	; 0x20cc <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    20c8:	0e 94 6a 20 	call	0x40d4	; 0x40d4 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    20cc:	8a 81       	ldd	r24, Y+2	; 0x02
    20ce:	81 50       	subi	r24, 0x01	; 1
    20d0:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    20d2:	8a 81       	ldd	r24, Y+2	; 0x02
    20d4:	18 16       	cp	r1, r24
    20d6:	64 f3       	brlt	.-40     	; 0x20b0 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    20d8:	eb 81       	ldd	r30, Y+3	; 0x03
    20da:	fc 81       	ldd	r31, Y+4	; 0x04
    20dc:	8f ef       	ldi	r24, 0xFF	; 255
    20de:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    20e0:	0f 90       	pop	r0
    20e2:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    20e4:	0f b6       	in	r0, 0x3f	; 63
    20e6:	f8 94       	cli
    20e8:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    20ea:	eb 81       	ldd	r30, Y+3	; 0x03
    20ec:	fc 81       	ldd	r31, Y+4	; 0x04
    20ee:	85 8d       	ldd	r24, Z+29	; 0x1d
    20f0:	89 83       	std	Y+1, r24	; 0x01
    20f2:	11 c0       	rjmp	.+34     	; 0x2116 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    20f4:	eb 81       	ldd	r30, Y+3	; 0x03
    20f6:	fc 81       	ldd	r31, Y+4	; 0x04
    20f8:	80 85       	ldd	r24, Z+8	; 0x08
    20fa:	88 23       	and	r24, r24
    20fc:	79 f0       	breq	.+30     	; 0x211c <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    20fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2100:	9c 81       	ldd	r25, Y+4	; 0x04
    2102:	08 96       	adiw	r24, 0x08	; 8
    2104:	0e 94 fe 1e 	call	0x3dfc	; 0x3dfc <xTaskRemoveFromEventList>
    2108:	88 23       	and	r24, r24
    210a:	11 f0       	breq	.+4      	; 0x2110 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    210c:	0e 94 6a 20 	call	0x40d4	; 0x40d4 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    2110:	89 81       	ldd	r24, Y+1	; 0x01
    2112:	81 50       	subi	r24, 0x01	; 1
    2114:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    2116:	89 81       	ldd	r24, Y+1	; 0x01
    2118:	18 16       	cp	r1, r24
    211a:	64 f3       	brlt	.-40     	; 0x20f4 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    211c:	eb 81       	ldd	r30, Y+3	; 0x03
    211e:	fc 81       	ldd	r31, Y+4	; 0x04
    2120:	8f ef       	ldi	r24, 0xFF	; 255
    2122:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2124:	0f 90       	pop	r0
    2126:	0f be       	out	0x3f, r0	; 63
}
    2128:	0f 90       	pop	r0
    212a:	0f 90       	pop	r0
    212c:	0f 90       	pop	r0
    212e:	0f 90       	pop	r0
    2130:	cf 91       	pop	r28
    2132:	df 91       	pop	r29
    2134:	08 95       	ret

00002136 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2136:	df 93       	push	r29
    2138:	cf 93       	push	r28
    213a:	00 d0       	rcall	.+0      	; 0x213c <prvIsQueueEmpty+0x6>
    213c:	0f 92       	push	r0
    213e:	cd b7       	in	r28, 0x3d	; 61
    2140:	de b7       	in	r29, 0x3e	; 62
    2142:	9b 83       	std	Y+3, r25	; 0x03
    2144:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2146:	0f b6       	in	r0, 0x3f	; 63
    2148:	f8 94       	cli
    214a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    214c:	ea 81       	ldd	r30, Y+2	; 0x02
    214e:	fb 81       	ldd	r31, Y+3	; 0x03
    2150:	82 8d       	ldd	r24, Z+26	; 0x1a
    2152:	88 23       	and	r24, r24
    2154:	19 f4       	brne	.+6      	; 0x215c <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2156:	81 e0       	ldi	r24, 0x01	; 1
    2158:	89 83       	std	Y+1, r24	; 0x01
    215a:	01 c0       	rjmp	.+2      	; 0x215e <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    215c:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    215e:	0f 90       	pop	r0
    2160:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2162:	89 81       	ldd	r24, Y+1	; 0x01
}
    2164:	0f 90       	pop	r0
    2166:	0f 90       	pop	r0
    2168:	0f 90       	pop	r0
    216a:	cf 91       	pop	r28
    216c:	df 91       	pop	r29
    216e:	08 95       	ret

00002170 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2170:	df 93       	push	r29
    2172:	cf 93       	push	r28
    2174:	00 d0       	rcall	.+0      	; 0x2176 <xQueueIsQueueEmptyFromISR+0x6>
    2176:	00 d0       	rcall	.+0      	; 0x2178 <xQueueIsQueueEmptyFromISR+0x8>
    2178:	0f 92       	push	r0
    217a:	cd b7       	in	r28, 0x3d	; 61
    217c:	de b7       	in	r29, 0x3e	; 62
    217e:	9d 83       	std	Y+5, r25	; 0x05
    2180:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2182:	8c 81       	ldd	r24, Y+4	; 0x04
    2184:	9d 81       	ldd	r25, Y+5	; 0x05
    2186:	9a 83       	std	Y+2, r25	; 0x02
    2188:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    218a:	e9 81       	ldd	r30, Y+1	; 0x01
    218c:	fa 81       	ldd	r31, Y+2	; 0x02
    218e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2190:	88 23       	and	r24, r24
    2192:	19 f4       	brne	.+6      	; 0x219a <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    2194:	81 e0       	ldi	r24, 0x01	; 1
    2196:	8b 83       	std	Y+3, r24	; 0x03
    2198:	01 c0       	rjmp	.+2      	; 0x219c <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    219a:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    219c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    219e:	0f 90       	pop	r0
    21a0:	0f 90       	pop	r0
    21a2:	0f 90       	pop	r0
    21a4:	0f 90       	pop	r0
    21a6:	0f 90       	pop	r0
    21a8:	cf 91       	pop	r28
    21aa:	df 91       	pop	r29
    21ac:	08 95       	ret

000021ae <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    21ae:	df 93       	push	r29
    21b0:	cf 93       	push	r28
    21b2:	00 d0       	rcall	.+0      	; 0x21b4 <prvIsQueueFull+0x6>
    21b4:	0f 92       	push	r0
    21b6:	cd b7       	in	r28, 0x3d	; 61
    21b8:	de b7       	in	r29, 0x3e	; 62
    21ba:	9b 83       	std	Y+3, r25	; 0x03
    21bc:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    21be:	0f b6       	in	r0, 0x3f	; 63
    21c0:	f8 94       	cli
    21c2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    21c4:	ea 81       	ldd	r30, Y+2	; 0x02
    21c6:	fb 81       	ldd	r31, Y+3	; 0x03
    21c8:	92 8d       	ldd	r25, Z+26	; 0x1a
    21ca:	ea 81       	ldd	r30, Y+2	; 0x02
    21cc:	fb 81       	ldd	r31, Y+3	; 0x03
    21ce:	83 8d       	ldd	r24, Z+27	; 0x1b
    21d0:	98 17       	cp	r25, r24
    21d2:	19 f4       	brne	.+6      	; 0x21da <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    21d4:	81 e0       	ldi	r24, 0x01	; 1
    21d6:	89 83       	std	Y+1, r24	; 0x01
    21d8:	01 c0       	rjmp	.+2      	; 0x21dc <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    21da:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    21dc:	0f 90       	pop	r0
    21de:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    21e0:	89 81       	ldd	r24, Y+1	; 0x01
}
    21e2:	0f 90       	pop	r0
    21e4:	0f 90       	pop	r0
    21e6:	0f 90       	pop	r0
    21e8:	cf 91       	pop	r28
    21ea:	df 91       	pop	r29
    21ec:	08 95       	ret

000021ee <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    21ee:	df 93       	push	r29
    21f0:	cf 93       	push	r28
    21f2:	00 d0       	rcall	.+0      	; 0x21f4 <xQueueIsQueueFullFromISR+0x6>
    21f4:	00 d0       	rcall	.+0      	; 0x21f6 <xQueueIsQueueFullFromISR+0x8>
    21f6:	0f 92       	push	r0
    21f8:	cd b7       	in	r28, 0x3d	; 61
    21fa:	de b7       	in	r29, 0x3e	; 62
    21fc:	9d 83       	std	Y+5, r25	; 0x05
    21fe:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2200:	8c 81       	ldd	r24, Y+4	; 0x04
    2202:	9d 81       	ldd	r25, Y+5	; 0x05
    2204:	9a 83       	std	Y+2, r25	; 0x02
    2206:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2208:	e9 81       	ldd	r30, Y+1	; 0x01
    220a:	fa 81       	ldd	r31, Y+2	; 0x02
    220c:	92 8d       	ldd	r25, Z+26	; 0x1a
    220e:	e9 81       	ldd	r30, Y+1	; 0x01
    2210:	fa 81       	ldd	r31, Y+2	; 0x02
    2212:	83 8d       	ldd	r24, Z+27	; 0x1b
    2214:	98 17       	cp	r25, r24
    2216:	19 f4       	brne	.+6      	; 0x221e <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    2218:	81 e0       	ldi	r24, 0x01	; 1
    221a:	8b 83       	std	Y+3, r24	; 0x03
    221c:	01 c0       	rjmp	.+2      	; 0x2220 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    221e:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2220:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2222:	0f 90       	pop	r0
    2224:	0f 90       	pop	r0
    2226:	0f 90       	pop	r0
    2228:	0f 90       	pop	r0
    222a:	0f 90       	pop	r0
    222c:	cf 91       	pop	r28
    222e:	df 91       	pop	r29
    2230:	08 95       	ret

00002232 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    2232:	0f 93       	push	r16
    2234:	df 93       	push	r29
    2236:	cf 93       	push	r28
    2238:	cd b7       	in	r28, 0x3d	; 61
    223a:	de b7       	in	r29, 0x3e	; 62
    223c:	28 97       	sbiw	r28, 0x08	; 8
    223e:	0f b6       	in	r0, 0x3f	; 63
    2240:	f8 94       	cli
    2242:	de bf       	out	0x3e, r29	; 62
    2244:	0f be       	out	0x3f, r0	; 63
    2246:	cd bf       	out	0x3d, r28	; 61
    2248:	9d 83       	std	Y+5, r25	; 0x05
    224a:	8c 83       	std	Y+4, r24	; 0x04
    224c:	7f 83       	std	Y+7, r23	; 0x07
    224e:	6e 83       	std	Y+6, r22	; 0x06
    2250:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    2252:	88 85       	ldd	r24, Y+8	; 0x08
    2254:	81 30       	cpi	r24, 0x01	; 1
    2256:	19 f4       	brne	.+6      	; 0x225e <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    2258:	81 e0       	ldi	r24, 0x01	; 1
    225a:	89 83       	std	Y+1, r24	; 0x01
    225c:	01 c0       	rjmp	.+2      	; 0x2260 <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    225e:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    2260:	8e 81       	ldd	r24, Y+6	; 0x06
    2262:	9f 81       	ldd	r25, Y+7	; 0x07
    2264:	00 97       	sbiw	r24, 0x00	; 0
    2266:	21 f4       	brne	.+8      	; 0x2270 <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    2268:	81 e0       	ldi	r24, 0x01	; 1
    226a:	90 e0       	ldi	r25, 0x00	; 0
    226c:	9f 83       	std	Y+7, r25	; 0x07
    226e:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    2270:	8c 81       	ldd	r24, Y+4	; 0x04
    2272:	9d 81       	ldd	r25, Y+5	; 0x05
    2274:	01 96       	adiw	r24, 0x01	; 1
    2276:	9d 83       	std	Y+5, r25	; 0x05
    2278:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    227a:	8c 81       	ldd	r24, Y+4	; 0x04
    227c:	9d 81       	ldd	r25, Y+5	; 0x05
    227e:	0f 96       	adiw	r24, 0x0f	; 15
    2280:	0e 94 64 05 	call	0xac8	; 0xac8 <pvPortMalloc>
    2284:	9b 83       	std	Y+3, r25	; 0x03
    2286:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    2288:	8a 81       	ldd	r24, Y+2	; 0x02
    228a:	9b 81       	ldd	r25, Y+3	; 0x03
    228c:	00 97       	sbiw	r24, 0x00	; 0
    228e:	89 f0       	breq	.+34     	; 0x22b2 <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    2290:	6a 81       	ldd	r22, Y+2	; 0x02
    2292:	7b 81       	ldd	r23, Y+3	; 0x03
    2294:	8a 81       	ldd	r24, Y+2	; 0x02
    2296:	9b 81       	ldd	r25, Y+3	; 0x03
    2298:	9c 01       	movw	r18, r24
    229a:	21 5f       	subi	r18, 0xF1	; 241
    229c:	3f 4f       	sbci	r19, 0xFF	; 255
    229e:	4c 81       	ldd	r20, Y+4	; 0x04
    22a0:	5d 81       	ldd	r21, Y+5	; 0x05
    22a2:	ee 81       	ldd	r30, Y+6	; 0x06
    22a4:	ff 81       	ldd	r31, Y+7	; 0x07
    22a6:	cb 01       	movw	r24, r22
    22a8:	b9 01       	movw	r22, r18
    22aa:	9f 01       	movw	r18, r30
    22ac:	09 81       	ldd	r16, Y+1	; 0x01
    22ae:	0e 94 71 18 	call	0x30e2	; 0x30e2 <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    22b2:	8a 81       	ldd	r24, Y+2	; 0x02
    22b4:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    22b6:	28 96       	adiw	r28, 0x08	; 8
    22b8:	0f b6       	in	r0, 0x3f	; 63
    22ba:	f8 94       	cli
    22bc:	de bf       	out	0x3e, r29	; 62
    22be:	0f be       	out	0x3f, r0	; 63
    22c0:	cd bf       	out	0x3d, r28	; 61
    22c2:	cf 91       	pop	r28
    22c4:	df 91       	pop	r29
    22c6:	0f 91       	pop	r16
    22c8:	08 95       	ret

000022ca <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    22ca:	df 93       	push	r29
    22cc:	cf 93       	push	r28
    22ce:	00 d0       	rcall	.+0      	; 0x22d0 <vStreamBufferDelete+0x6>
    22d0:	00 d0       	rcall	.+0      	; 0x22d2 <vStreamBufferDelete+0x8>
    22d2:	cd b7       	in	r28, 0x3d	; 61
    22d4:	de b7       	in	r29, 0x3e	; 62
    22d6:	9c 83       	std	Y+4, r25	; 0x04
    22d8:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    22da:	8b 81       	ldd	r24, Y+3	; 0x03
    22dc:	9c 81       	ldd	r25, Y+4	; 0x04
    22de:	9a 83       	std	Y+2, r25	; 0x02
    22e0:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    22e2:	e9 81       	ldd	r30, Y+1	; 0x01
    22e4:	fa 81       	ldd	r31, Y+2	; 0x02
    22e6:	86 85       	ldd	r24, Z+14	; 0x0e
    22e8:	88 2f       	mov	r24, r24
    22ea:	90 e0       	ldi	r25, 0x00	; 0
    22ec:	82 70       	andi	r24, 0x02	; 2
    22ee:	90 70       	andi	r25, 0x00	; 0
    22f0:	00 97       	sbiw	r24, 0x00	; 0
    22f2:	29 f4       	brne	.+10     	; 0x22fe <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    22f4:	89 81       	ldd	r24, Y+1	; 0x01
    22f6:	9a 81       	ldd	r25, Y+2	; 0x02
    22f8:	0e 94 ba 05 	call	0xb74	; 0xb74 <vPortFree>
    22fc:	08 c0       	rjmp	.+16     	; 0x230e <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    22fe:	89 81       	ldd	r24, Y+1	; 0x01
    2300:	9a 81       	ldd	r25, Y+2	; 0x02
    2302:	60 e0       	ldi	r22, 0x00	; 0
    2304:	70 e0       	ldi	r23, 0x00	; 0
    2306:	4f e0       	ldi	r20, 0x0F	; 15
    2308:	50 e0       	ldi	r21, 0x00	; 0
    230a:	0e 94 6a 3c 	call	0x78d4	; 0x78d4 <memset>
	}
}
    230e:	0f 90       	pop	r0
    2310:	0f 90       	pop	r0
    2312:	0f 90       	pop	r0
    2314:	0f 90       	pop	r0
    2316:	cf 91       	pop	r28
    2318:	df 91       	pop	r29
    231a:	08 95       	ret

0000231c <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    231c:	0f 93       	push	r16
    231e:	df 93       	push	r29
    2320:	cf 93       	push	r28
    2322:	00 d0       	rcall	.+0      	; 0x2324 <xStreamBufferReset+0x8>
    2324:	00 d0       	rcall	.+0      	; 0x2326 <xStreamBufferReset+0xa>
    2326:	0f 92       	push	r0
    2328:	cd b7       	in	r28, 0x3d	; 61
    232a:	de b7       	in	r29, 0x3e	; 62
    232c:	9d 83       	std	Y+5, r25	; 0x05
    232e:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2330:	8c 81       	ldd	r24, Y+4	; 0x04
    2332:	9d 81       	ldd	r25, Y+5	; 0x05
    2334:	9b 83       	std	Y+3, r25	; 0x03
    2336:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    2338:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    233a:	0f b6       	in	r0, 0x3f	; 63
    233c:	f8 94       	cli
    233e:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    2340:	ea 81       	ldd	r30, Y+2	; 0x02
    2342:	fb 81       	ldd	r31, Y+3	; 0x03
    2344:	80 85       	ldd	r24, Z+8	; 0x08
    2346:	91 85       	ldd	r25, Z+9	; 0x09
    2348:	00 97       	sbiw	r24, 0x00	; 0
    234a:	f1 f4       	brne	.+60     	; 0x2388 <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    234c:	ea 81       	ldd	r30, Y+2	; 0x02
    234e:	fb 81       	ldd	r31, Y+3	; 0x03
    2350:	82 85       	ldd	r24, Z+10	; 0x0a
    2352:	93 85       	ldd	r25, Z+11	; 0x0b
    2354:	00 97       	sbiw	r24, 0x00	; 0
    2356:	c1 f4       	brne	.+48     	; 0x2388 <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    2358:	ea 81       	ldd	r30, Y+2	; 0x02
    235a:	fb 81       	ldd	r31, Y+3	; 0x03
    235c:	24 85       	ldd	r18, Z+12	; 0x0c
    235e:	35 85       	ldd	r19, Z+13	; 0x0d
    2360:	ea 81       	ldd	r30, Y+2	; 0x02
    2362:	fb 81       	ldd	r31, Y+3	; 0x03
    2364:	44 81       	ldd	r20, Z+4	; 0x04
    2366:	55 81       	ldd	r21, Z+5	; 0x05
    2368:	ea 81       	ldd	r30, Y+2	; 0x02
    236a:	fb 81       	ldd	r31, Y+3	; 0x03
    236c:	a6 81       	ldd	r26, Z+6	; 0x06
    236e:	b7 81       	ldd	r27, Z+7	; 0x07
    2370:	ea 81       	ldd	r30, Y+2	; 0x02
    2372:	fb 81       	ldd	r31, Y+3	; 0x03
    2374:	e6 85       	ldd	r30, Z+14	; 0x0e
    2376:	8a 81       	ldd	r24, Y+2	; 0x02
    2378:	9b 81       	ldd	r25, Y+3	; 0x03
    237a:	b9 01       	movw	r22, r18
    237c:	9d 01       	movw	r18, r26
    237e:	0e 2f       	mov	r16, r30
    2380:	0e 94 71 18 	call	0x30e2	; 0x30e2 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    2384:	81 e0       	ldi	r24, 0x01	; 1
    2386:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    2388:	0f 90       	pop	r0
    238a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    238c:	89 81       	ldd	r24, Y+1	; 0x01
}
    238e:	0f 90       	pop	r0
    2390:	0f 90       	pop	r0
    2392:	0f 90       	pop	r0
    2394:	0f 90       	pop	r0
    2396:	0f 90       	pop	r0
    2398:	cf 91       	pop	r28
    239a:	df 91       	pop	r29
    239c:	0f 91       	pop	r16
    239e:	08 95       	ret

000023a0 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    23a0:	df 93       	push	r29
    23a2:	cf 93       	push	r28
    23a4:	cd b7       	in	r28, 0x3d	; 61
    23a6:	de b7       	in	r29, 0x3e	; 62
    23a8:	27 97       	sbiw	r28, 0x07	; 7
    23aa:	0f b6       	in	r0, 0x3f	; 63
    23ac:	f8 94       	cli
    23ae:	de bf       	out	0x3e, r29	; 62
    23b0:	0f be       	out	0x3f, r0	; 63
    23b2:	cd bf       	out	0x3d, r28	; 61
    23b4:	9d 83       	std	Y+5, r25	; 0x05
    23b6:	8c 83       	std	Y+4, r24	; 0x04
    23b8:	7f 83       	std	Y+7, r23	; 0x07
    23ba:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    23bc:	8c 81       	ldd	r24, Y+4	; 0x04
    23be:	9d 81       	ldd	r25, Y+5	; 0x05
    23c0:	9b 83       	std	Y+3, r25	; 0x03
    23c2:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    23c4:	8e 81       	ldd	r24, Y+6	; 0x06
    23c6:	9f 81       	ldd	r25, Y+7	; 0x07
    23c8:	00 97       	sbiw	r24, 0x00	; 0
    23ca:	21 f4       	brne	.+8      	; 0x23d4 <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    23cc:	81 e0       	ldi	r24, 0x01	; 1
    23ce:	90 e0       	ldi	r25, 0x00	; 0
    23d0:	9f 83       	std	Y+7, r25	; 0x07
    23d2:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    23d4:	ea 81       	ldd	r30, Y+2	; 0x02
    23d6:	fb 81       	ldd	r31, Y+3	; 0x03
    23d8:	24 81       	ldd	r18, Z+4	; 0x04
    23da:	35 81       	ldd	r19, Z+5	; 0x05
    23dc:	8e 81       	ldd	r24, Y+6	; 0x06
    23de:	9f 81       	ldd	r25, Y+7	; 0x07
    23e0:	28 17       	cp	r18, r24
    23e2:	39 07       	cpc	r19, r25
    23e4:	48 f0       	brcs	.+18     	; 0x23f8 <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    23e6:	ea 81       	ldd	r30, Y+2	; 0x02
    23e8:	fb 81       	ldd	r31, Y+3	; 0x03
    23ea:	8e 81       	ldd	r24, Y+6	; 0x06
    23ec:	9f 81       	ldd	r25, Y+7	; 0x07
    23ee:	97 83       	std	Z+7, r25	; 0x07
    23f0:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    23f2:	81 e0       	ldi	r24, 0x01	; 1
    23f4:	89 83       	std	Y+1, r24	; 0x01
    23f6:	01 c0       	rjmp	.+2      	; 0x23fa <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    23f8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    23fa:	89 81       	ldd	r24, Y+1	; 0x01
}
    23fc:	27 96       	adiw	r28, 0x07	; 7
    23fe:	0f b6       	in	r0, 0x3f	; 63
    2400:	f8 94       	cli
    2402:	de bf       	out	0x3e, r29	; 62
    2404:	0f be       	out	0x3f, r0	; 63
    2406:	cd bf       	out	0x3d, r28	; 61
    2408:	cf 91       	pop	r28
    240a:	df 91       	pop	r29
    240c:	08 95       	ret

0000240e <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    240e:	df 93       	push	r29
    2410:	cf 93       	push	r28
    2412:	00 d0       	rcall	.+0      	; 0x2414 <xStreamBufferSpacesAvailable+0x6>
    2414:	00 d0       	rcall	.+0      	; 0x2416 <xStreamBufferSpacesAvailable+0x8>
    2416:	00 d0       	rcall	.+0      	; 0x2418 <xStreamBufferSpacesAvailable+0xa>
    2418:	cd b7       	in	r28, 0x3d	; 61
    241a:	de b7       	in	r29, 0x3e	; 62
    241c:	9e 83       	std	Y+6, r25	; 0x06
    241e:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2420:	8d 81       	ldd	r24, Y+5	; 0x05
    2422:	9e 81       	ldd	r25, Y+6	; 0x06
    2424:	9c 83       	std	Y+4, r25	; 0x04
    2426:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2428:	eb 81       	ldd	r30, Y+3	; 0x03
    242a:	fc 81       	ldd	r31, Y+4	; 0x04
    242c:	24 81       	ldd	r18, Z+4	; 0x04
    242e:	35 81       	ldd	r19, Z+5	; 0x05
    2430:	eb 81       	ldd	r30, Y+3	; 0x03
    2432:	fc 81       	ldd	r31, Y+4	; 0x04
    2434:	80 81       	ld	r24, Z
    2436:	91 81       	ldd	r25, Z+1	; 0x01
    2438:	82 0f       	add	r24, r18
    243a:	93 1f       	adc	r25, r19
    243c:	9a 83       	std	Y+2, r25	; 0x02
    243e:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    2440:	eb 81       	ldd	r30, Y+3	; 0x03
    2442:	fc 81       	ldd	r31, Y+4	; 0x04
    2444:	22 81       	ldd	r18, Z+2	; 0x02
    2446:	33 81       	ldd	r19, Z+3	; 0x03
    2448:	89 81       	ldd	r24, Y+1	; 0x01
    244a:	9a 81       	ldd	r25, Y+2	; 0x02
    244c:	82 1b       	sub	r24, r18
    244e:	93 0b       	sbc	r25, r19
    2450:	9a 83       	std	Y+2, r25	; 0x02
    2452:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    2454:	89 81       	ldd	r24, Y+1	; 0x01
    2456:	9a 81       	ldd	r25, Y+2	; 0x02
    2458:	01 97       	sbiw	r24, 0x01	; 1
    245a:	9a 83       	std	Y+2, r25	; 0x02
    245c:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    245e:	eb 81       	ldd	r30, Y+3	; 0x03
    2460:	fc 81       	ldd	r31, Y+4	; 0x04
    2462:	24 81       	ldd	r18, Z+4	; 0x04
    2464:	35 81       	ldd	r19, Z+5	; 0x05
    2466:	89 81       	ldd	r24, Y+1	; 0x01
    2468:	9a 81       	ldd	r25, Y+2	; 0x02
    246a:	82 17       	cp	r24, r18
    246c:	93 07       	cpc	r25, r19
    246e:	50 f0       	brcs	.+20     	; 0x2484 <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    2470:	eb 81       	ldd	r30, Y+3	; 0x03
    2472:	fc 81       	ldd	r31, Y+4	; 0x04
    2474:	24 81       	ldd	r18, Z+4	; 0x04
    2476:	35 81       	ldd	r19, Z+5	; 0x05
    2478:	89 81       	ldd	r24, Y+1	; 0x01
    247a:	9a 81       	ldd	r25, Y+2	; 0x02
    247c:	82 1b       	sub	r24, r18
    247e:	93 0b       	sbc	r25, r19
    2480:	9a 83       	std	Y+2, r25	; 0x02
    2482:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    2484:	89 81       	ldd	r24, Y+1	; 0x01
    2486:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2488:	26 96       	adiw	r28, 0x06	; 6
    248a:	0f b6       	in	r0, 0x3f	; 63
    248c:	f8 94       	cli
    248e:	de bf       	out	0x3e, r29	; 62
    2490:	0f be       	out	0x3f, r0	; 63
    2492:	cd bf       	out	0x3d, r28	; 61
    2494:	cf 91       	pop	r28
    2496:	df 91       	pop	r29
    2498:	08 95       	ret

0000249a <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    249a:	df 93       	push	r29
    249c:	cf 93       	push	r28
    249e:	00 d0       	rcall	.+0      	; 0x24a0 <xStreamBufferBytesAvailable+0x6>
    24a0:	00 d0       	rcall	.+0      	; 0x24a2 <xStreamBufferBytesAvailable+0x8>
    24a2:	00 d0       	rcall	.+0      	; 0x24a4 <xStreamBufferBytesAvailable+0xa>
    24a4:	cd b7       	in	r28, 0x3d	; 61
    24a6:	de b7       	in	r29, 0x3e	; 62
    24a8:	9e 83       	std	Y+6, r25	; 0x06
    24aa:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    24ac:	8d 81       	ldd	r24, Y+5	; 0x05
    24ae:	9e 81       	ldd	r25, Y+6	; 0x06
    24b0:	9c 83       	std	Y+4, r25	; 0x04
    24b2:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    24b4:	8b 81       	ldd	r24, Y+3	; 0x03
    24b6:	9c 81       	ldd	r25, Y+4	; 0x04
    24b8:	0e 94 37 18 	call	0x306e	; 0x306e <prvBytesInBuffer>
    24bc:	9a 83       	std	Y+2, r25	; 0x02
    24be:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    24c0:	89 81       	ldd	r24, Y+1	; 0x01
    24c2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    24c4:	26 96       	adiw	r28, 0x06	; 6
    24c6:	0f b6       	in	r0, 0x3f	; 63
    24c8:	f8 94       	cli
    24ca:	de bf       	out	0x3e, r29	; 62
    24cc:	0f be       	out	0x3f, r0	; 63
    24ce:	cd bf       	out	0x3d, r28	; 61
    24d0:	cf 91       	pop	r28
    24d2:	df 91       	pop	r29
    24d4:	08 95       	ret

000024d6 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    24d6:	ef 92       	push	r14
    24d8:	ff 92       	push	r15
    24da:	0f 93       	push	r16
    24dc:	1f 93       	push	r17
    24de:	df 93       	push	r29
    24e0:	cf 93       	push	r28
    24e2:	cd b7       	in	r28, 0x3d	; 61
    24e4:	de b7       	in	r29, 0x3e	; 62
    24e6:	63 97       	sbiw	r28, 0x13	; 19
    24e8:	0f b6       	in	r0, 0x3f	; 63
    24ea:	f8 94       	cli
    24ec:	de bf       	out	0x3e, r29	; 62
    24ee:	0f be       	out	0x3f, r0	; 63
    24f0:	cd bf       	out	0x3d, r28	; 61
    24f2:	9d 87       	std	Y+13, r25	; 0x0d
    24f4:	8c 87       	std	Y+12, r24	; 0x0c
    24f6:	7f 87       	std	Y+15, r23	; 0x0f
    24f8:	6e 87       	std	Y+14, r22	; 0x0e
    24fa:	59 8b       	std	Y+17, r21	; 0x11
    24fc:	48 8b       	std	Y+16, r20	; 0x10
    24fe:	3b 8b       	std	Y+19, r19	; 0x13
    2500:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2502:	8c 85       	ldd	r24, Y+12	; 0x0c
    2504:	9d 85       	ldd	r25, Y+13	; 0x0d
    2506:	98 87       	std	Y+8, r25	; 0x08
    2508:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    250a:	1c 82       	std	Y+4, r1	; 0x04
    250c:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    250e:	88 89       	ldd	r24, Y+16	; 0x10
    2510:	99 89       	ldd	r25, Y+17	; 0x11
    2512:	9a 83       	std	Y+2, r25	; 0x02
    2514:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2516:	ef 81       	ldd	r30, Y+7	; 0x07
    2518:	f8 85       	ldd	r31, Y+8	; 0x08
    251a:	86 85       	ldd	r24, Z+14	; 0x0e
    251c:	88 2f       	mov	r24, r24
    251e:	90 e0       	ldi	r25, 0x00	; 0
    2520:	81 70       	andi	r24, 0x01	; 1
    2522:	90 70       	andi	r25, 0x00	; 0
    2524:	88 23       	and	r24, r24
    2526:	29 f0       	breq	.+10     	; 0x2532 <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2528:	89 81       	ldd	r24, Y+1	; 0x01
    252a:	9a 81       	ldd	r25, Y+2	; 0x02
    252c:	02 96       	adiw	r24, 0x02	; 2
    252e:	9a 83       	std	Y+2, r25	; 0x02
    2530:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    2532:	8a 89       	ldd	r24, Y+18	; 0x12
    2534:	9b 89       	ldd	r25, Y+19	; 0x13
    2536:	00 97       	sbiw	r24, 0x00	; 0
    2538:	09 f4       	brne	.+2      	; 0x253c <xStreamBufferSend+0x66>
    253a:	40 c0       	rjmp	.+128    	; 0x25bc <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    253c:	ce 01       	movw	r24, r28
    253e:	09 96       	adiw	r24, 0x09	; 9
    2540:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    2544:	0f b6       	in	r0, 0x3f	; 63
    2546:	f8 94       	cli
    2548:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    254a:	8f 81       	ldd	r24, Y+7	; 0x07
    254c:	98 85       	ldd	r25, Y+8	; 0x08
    254e:	0e 94 07 12 	call	0x240e	; 0x240e <xStreamBufferSpacesAvailable>
    2552:	9c 83       	std	Y+4, r25	; 0x04
    2554:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    2556:	2b 81       	ldd	r18, Y+3	; 0x03
    2558:	3c 81       	ldd	r19, Y+4	; 0x04
    255a:	89 81       	ldd	r24, Y+1	; 0x01
    255c:	9a 81       	ldd	r25, Y+2	; 0x02
    255e:	28 17       	cp	r18, r24
    2560:	39 07       	cpc	r19, r25
    2562:	50 f5       	brcc	.+84     	; 0x25b8 <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    2564:	80 e0       	ldi	r24, 0x00	; 0
    2566:	90 e0       	ldi	r25, 0x00	; 0
    2568:	0e 94 8e 24 	call	0x491c	; 0x491c <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    256c:	0e 94 ef 20 	call	0x41de	; 0x41de <xTaskGetCurrentTaskHandle>
    2570:	ef 81       	ldd	r30, Y+7	; 0x07
    2572:	f8 85       	ldd	r31, Y+8	; 0x08
    2574:	93 87       	std	Z+11, r25	; 0x0b
    2576:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    2578:	0f 90       	pop	r0
    257a:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    257c:	ea 89       	ldd	r30, Y+18	; 0x12
    257e:	fb 89       	ldd	r31, Y+19	; 0x13
    2580:	60 e0       	ldi	r22, 0x00	; 0
    2582:	70 e0       	ldi	r23, 0x00	; 0
    2584:	80 e0       	ldi	r24, 0x00	; 0
    2586:	90 e0       	ldi	r25, 0x00	; 0
    2588:	20 e0       	ldi	r18, 0x00	; 0
    258a:	30 e0       	ldi	r19, 0x00	; 0
    258c:	40 e0       	ldi	r20, 0x00	; 0
    258e:	50 e0       	ldi	r21, 0x00	; 0
    2590:	00 e0       	ldi	r16, 0x00	; 0
    2592:	10 e0       	ldi	r17, 0x00	; 0
    2594:	7f 01       	movw	r14, r30
    2596:	0e 94 9f 21 	call	0x433e	; 0x433e <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    259a:	ef 81       	ldd	r30, Y+7	; 0x07
    259c:	f8 85       	ldd	r31, Y+8	; 0x08
    259e:	13 86       	std	Z+11, r1	; 0x0b
    25a0:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    25a2:	ce 01       	movw	r24, r28
    25a4:	09 96       	adiw	r24, 0x09	; 9
    25a6:	9e 01       	movw	r18, r28
    25a8:	2e 5e       	subi	r18, 0xEE	; 238
    25aa:	3f 4f       	sbci	r19, 0xFF	; 255
    25ac:	b9 01       	movw	r22, r18
    25ae:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <xTaskCheckForTimeOut>
    25b2:	88 23       	and	r24, r24
    25b4:	39 f2       	breq	.-114    	; 0x2544 <xStreamBufferSend+0x6e>
    25b6:	02 c0       	rjmp	.+4      	; 0x25bc <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    25b8:	0f 90       	pop	r0
    25ba:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    25bc:	8b 81       	ldd	r24, Y+3	; 0x03
    25be:	9c 81       	ldd	r25, Y+4	; 0x04
    25c0:	00 97       	sbiw	r24, 0x00	; 0
    25c2:	31 f4       	brne	.+12     	; 0x25d0 <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    25c4:	8f 81       	ldd	r24, Y+7	; 0x07
    25c6:	98 85       	ldd	r25, Y+8	; 0x08
    25c8:	0e 94 07 12 	call	0x240e	; 0x240e <xStreamBufferSpacesAvailable>
    25cc:	9c 83       	std	Y+4, r25	; 0x04
    25ce:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    25d0:	8f 81       	ldd	r24, Y+7	; 0x07
    25d2:	98 85       	ldd	r25, Y+8	; 0x08
    25d4:	2e 85       	ldd	r18, Y+14	; 0x0e
    25d6:	3f 85       	ldd	r19, Y+15	; 0x0f
    25d8:	48 89       	ldd	r20, Y+16	; 0x10
    25da:	59 89       	ldd	r21, Y+17	; 0x11
    25dc:	eb 81       	ldd	r30, Y+3	; 0x03
    25de:	fc 81       	ldd	r31, Y+4	; 0x04
    25e0:	a9 81       	ldd	r26, Y+1	; 0x01
    25e2:	ba 81       	ldd	r27, Y+2	; 0x02
    25e4:	b9 01       	movw	r22, r18
    25e6:	9f 01       	movw	r18, r30
    25e8:	8d 01       	movw	r16, r26
    25ea:	0e 94 b0 13 	call	0x2760	; 0x2760 <prvWriteMessageToBuffer>
    25ee:	9e 83       	std	Y+6, r25	; 0x06
    25f0:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    25f2:	8d 81       	ldd	r24, Y+5	; 0x05
    25f4:	9e 81       	ldd	r25, Y+6	; 0x06
    25f6:	00 97       	sbiw	r24, 0x00	; 0
    25f8:	39 f1       	breq	.+78     	; 0x2648 <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    25fa:	8f 81       	ldd	r24, Y+7	; 0x07
    25fc:	98 85       	ldd	r25, Y+8	; 0x08
    25fe:	0e 94 37 18 	call	0x306e	; 0x306e <prvBytesInBuffer>
    2602:	9c 01       	movw	r18, r24
    2604:	ef 81       	ldd	r30, Y+7	; 0x07
    2606:	f8 85       	ldd	r31, Y+8	; 0x08
    2608:	86 81       	ldd	r24, Z+6	; 0x06
    260a:	97 81       	ldd	r25, Z+7	; 0x07
    260c:	28 17       	cp	r18, r24
    260e:	39 07       	cpc	r19, r25
    2610:	d8 f0       	brcs	.+54     	; 0x2648 <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    2612:	0e 94 8e 1c 	call	0x391c	; 0x391c <vTaskSuspendAll>
    2616:	ef 81       	ldd	r30, Y+7	; 0x07
    2618:	f8 85       	ldd	r31, Y+8	; 0x08
    261a:	80 85       	ldd	r24, Z+8	; 0x08
    261c:	91 85       	ldd	r25, Z+9	; 0x09
    261e:	00 97       	sbiw	r24, 0x00	; 0
    2620:	89 f0       	breq	.+34     	; 0x2644 <xStreamBufferSend+0x16e>
    2622:	ef 81       	ldd	r30, Y+7	; 0x07
    2624:	f8 85       	ldd	r31, Y+8	; 0x08
    2626:	80 85       	ldd	r24, Z+8	; 0x08
    2628:	91 85       	ldd	r25, Z+9	; 0x09
    262a:	40 e0       	ldi	r20, 0x00	; 0
    262c:	50 e0       	ldi	r21, 0x00	; 0
    262e:	60 e0       	ldi	r22, 0x00	; 0
    2630:	70 e0       	ldi	r23, 0x00	; 0
    2632:	20 e0       	ldi	r18, 0x00	; 0
    2634:	00 e0       	ldi	r16, 0x00	; 0
    2636:	10 e0       	ldi	r17, 0x00	; 0
    2638:	0e 94 3b 22 	call	0x4476	; 0x4476 <xTaskGenericNotify>
    263c:	ef 81       	ldd	r30, Y+7	; 0x07
    263e:	f8 85       	ldd	r31, Y+8	; 0x08
    2640:	11 86       	std	Z+9, r1	; 0x09
    2642:	10 86       	std	Z+8, r1	; 0x08
    2644:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    2648:	8d 81       	ldd	r24, Y+5	; 0x05
    264a:	9e 81       	ldd	r25, Y+6	; 0x06
}
    264c:	63 96       	adiw	r28, 0x13	; 19
    264e:	0f b6       	in	r0, 0x3f	; 63
    2650:	f8 94       	cli
    2652:	de bf       	out	0x3e, r29	; 62
    2654:	0f be       	out	0x3f, r0	; 63
    2656:	cd bf       	out	0x3d, r28	; 61
    2658:	cf 91       	pop	r28
    265a:	df 91       	pop	r29
    265c:	1f 91       	pop	r17
    265e:	0f 91       	pop	r16
    2660:	ff 90       	pop	r15
    2662:	ef 90       	pop	r14
    2664:	08 95       	ret

00002666 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2666:	ef 92       	push	r14
    2668:	ff 92       	push	r15
    266a:	0f 93       	push	r16
    266c:	1f 93       	push	r17
    266e:	df 93       	push	r29
    2670:	cf 93       	push	r28
    2672:	cd b7       	in	r28, 0x3d	; 61
    2674:	de b7       	in	r29, 0x3e	; 62
    2676:	61 97       	sbiw	r28, 0x11	; 17
    2678:	0f b6       	in	r0, 0x3f	; 63
    267a:	f8 94       	cli
    267c:	de bf       	out	0x3e, r29	; 62
    267e:	0f be       	out	0x3f, r0	; 63
    2680:	cd bf       	out	0x3d, r28	; 61
    2682:	9b 87       	std	Y+11, r25	; 0x0b
    2684:	8a 87       	std	Y+10, r24	; 0x0a
    2686:	7d 87       	std	Y+13, r23	; 0x0d
    2688:	6c 87       	std	Y+12, r22	; 0x0c
    268a:	5f 87       	std	Y+15, r21	; 0x0f
    268c:	4e 87       	std	Y+14, r20	; 0x0e
    268e:	39 8b       	std	Y+17, r19	; 0x11
    2690:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2692:	8a 85       	ldd	r24, Y+10	; 0x0a
    2694:	9b 85       	ldd	r25, Y+11	; 0x0b
    2696:	99 87       	std	Y+9, r25	; 0x09
    2698:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    269a:	8e 85       	ldd	r24, Y+14	; 0x0e
    269c:	9f 85       	ldd	r25, Y+15	; 0x0f
    269e:	9b 83       	std	Y+3, r25	; 0x03
    26a0:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    26a2:	e8 85       	ldd	r30, Y+8	; 0x08
    26a4:	f9 85       	ldd	r31, Y+9	; 0x09
    26a6:	86 85       	ldd	r24, Z+14	; 0x0e
    26a8:	88 2f       	mov	r24, r24
    26aa:	90 e0       	ldi	r25, 0x00	; 0
    26ac:	81 70       	andi	r24, 0x01	; 1
    26ae:	90 70       	andi	r25, 0x00	; 0
    26b0:	88 23       	and	r24, r24
    26b2:	29 f0       	breq	.+10     	; 0x26be <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    26b4:	8a 81       	ldd	r24, Y+2	; 0x02
    26b6:	9b 81       	ldd	r25, Y+3	; 0x03
    26b8:	02 96       	adiw	r24, 0x02	; 2
    26ba:	9b 83       	std	Y+3, r25	; 0x03
    26bc:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    26be:	88 85       	ldd	r24, Y+8	; 0x08
    26c0:	99 85       	ldd	r25, Y+9	; 0x09
    26c2:	0e 94 07 12 	call	0x240e	; 0x240e <xStreamBufferSpacesAvailable>
    26c6:	9d 83       	std	Y+5, r25	; 0x05
    26c8:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    26ca:	88 85       	ldd	r24, Y+8	; 0x08
    26cc:	99 85       	ldd	r25, Y+9	; 0x09
    26ce:	2c 85       	ldd	r18, Y+12	; 0x0c
    26d0:	3d 85       	ldd	r19, Y+13	; 0x0d
    26d2:	4e 85       	ldd	r20, Y+14	; 0x0e
    26d4:	5f 85       	ldd	r21, Y+15	; 0x0f
    26d6:	ec 81       	ldd	r30, Y+4	; 0x04
    26d8:	fd 81       	ldd	r31, Y+5	; 0x05
    26da:	aa 81       	ldd	r26, Y+2	; 0x02
    26dc:	bb 81       	ldd	r27, Y+3	; 0x03
    26de:	b9 01       	movw	r22, r18
    26e0:	9f 01       	movw	r18, r30
    26e2:	8d 01       	movw	r16, r26
    26e4:	0e 94 b0 13 	call	0x2760	; 0x2760 <prvWriteMessageToBuffer>
    26e8:	9f 83       	std	Y+7, r25	; 0x07
    26ea:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    26ec:	8e 81       	ldd	r24, Y+6	; 0x06
    26ee:	9f 81       	ldd	r25, Y+7	; 0x07
    26f0:	00 97       	sbiw	r24, 0x00	; 0
    26f2:	39 f1       	breq	.+78     	; 0x2742 <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    26f4:	88 85       	ldd	r24, Y+8	; 0x08
    26f6:	99 85       	ldd	r25, Y+9	; 0x09
    26f8:	0e 94 37 18 	call	0x306e	; 0x306e <prvBytesInBuffer>
    26fc:	9c 01       	movw	r18, r24
    26fe:	e8 85       	ldd	r30, Y+8	; 0x08
    2700:	f9 85       	ldd	r31, Y+9	; 0x09
    2702:	86 81       	ldd	r24, Z+6	; 0x06
    2704:	97 81       	ldd	r25, Z+7	; 0x07
    2706:	28 17       	cp	r18, r24
    2708:	39 07       	cpc	r19, r25
    270a:	d8 f0       	brcs	.+54     	; 0x2742 <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    270c:	19 82       	std	Y+1, r1	; 0x01
    270e:	e8 85       	ldd	r30, Y+8	; 0x08
    2710:	f9 85       	ldd	r31, Y+9	; 0x09
    2712:	80 85       	ldd	r24, Z+8	; 0x08
    2714:	91 85       	ldd	r25, Z+9	; 0x09
    2716:	00 97       	sbiw	r24, 0x00	; 0
    2718:	a1 f0       	breq	.+40     	; 0x2742 <xStreamBufferSendFromISR+0xdc>
    271a:	e8 85       	ldd	r30, Y+8	; 0x08
    271c:	f9 85       	ldd	r31, Y+9	; 0x09
    271e:	80 85       	ldd	r24, Z+8	; 0x08
    2720:	91 85       	ldd	r25, Z+9	; 0x09
    2722:	e8 89       	ldd	r30, Y+16	; 0x10
    2724:	f9 89       	ldd	r31, Y+17	; 0x11
    2726:	40 e0       	ldi	r20, 0x00	; 0
    2728:	50 e0       	ldi	r21, 0x00	; 0
    272a:	60 e0       	ldi	r22, 0x00	; 0
    272c:	70 e0       	ldi	r23, 0x00	; 0
    272e:	20 e0       	ldi	r18, 0x00	; 0
    2730:	00 e0       	ldi	r16, 0x00	; 0
    2732:	10 e0       	ldi	r17, 0x00	; 0
    2734:	7f 01       	movw	r14, r30
    2736:	0e 94 10 23 	call	0x4620	; 0x4620 <xTaskGenericNotifyFromISR>
    273a:	e8 85       	ldd	r30, Y+8	; 0x08
    273c:	f9 85       	ldd	r31, Y+9	; 0x09
    273e:	11 86       	std	Z+9, r1	; 0x09
    2740:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    2742:	8e 81       	ldd	r24, Y+6	; 0x06
    2744:	9f 81       	ldd	r25, Y+7	; 0x07
}
    2746:	61 96       	adiw	r28, 0x11	; 17
    2748:	0f b6       	in	r0, 0x3f	; 63
    274a:	f8 94       	cli
    274c:	de bf       	out	0x3e, r29	; 62
    274e:	0f be       	out	0x3f, r0	; 63
    2750:	cd bf       	out	0x3d, r28	; 61
    2752:	cf 91       	pop	r28
    2754:	df 91       	pop	r29
    2756:	1f 91       	pop	r17
    2758:	0f 91       	pop	r16
    275a:	ff 90       	pop	r15
    275c:	ef 90       	pop	r14
    275e:	08 95       	ret

00002760 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    2760:	0f 93       	push	r16
    2762:	1f 93       	push	r17
    2764:	df 93       	push	r29
    2766:	cf 93       	push	r28
    2768:	cd b7       	in	r28, 0x3d	; 61
    276a:	de b7       	in	r29, 0x3e	; 62
    276c:	61 97       	sbiw	r28, 0x11	; 17
    276e:	0f b6       	in	r0, 0x3f	; 63
    2770:	f8 94       	cli
    2772:	de bf       	out	0x3e, r29	; 62
    2774:	0f be       	out	0x3f, r0	; 63
    2776:	cd bf       	out	0x3d, r28	; 61
    2778:	9d 83       	std	Y+5, r25	; 0x05
    277a:	8c 83       	std	Y+4, r24	; 0x04
    277c:	7f 83       	std	Y+7, r23	; 0x07
    277e:	6e 83       	std	Y+6, r22	; 0x06
    2780:	59 87       	std	Y+9, r21	; 0x09
    2782:	48 87       	std	Y+8, r20	; 0x08
    2784:	3b 87       	std	Y+11, r19	; 0x0b
    2786:	2a 87       	std	Y+10, r18	; 0x0a
    2788:	1d 87       	std	Y+13, r17	; 0x0d
    278a:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    278c:	8a 85       	ldd	r24, Y+10	; 0x0a
    278e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2790:	00 97       	sbiw	r24, 0x00	; 0
    2792:	11 f4       	brne	.+4      	; 0x2798 <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    2794:	1b 82       	std	Y+3, r1	; 0x03
    2796:	38 c0       	rjmp	.+112    	; 0x2808 <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    2798:	ec 81       	ldd	r30, Y+4	; 0x04
    279a:	fd 81       	ldd	r31, Y+5	; 0x05
    279c:	86 85       	ldd	r24, Z+14	; 0x0e
    279e:	88 2f       	mov	r24, r24
    27a0:	90 e0       	ldi	r25, 0x00	; 0
    27a2:	81 70       	andi	r24, 0x01	; 1
    27a4:	90 70       	andi	r25, 0x00	; 0
    27a6:	00 97       	sbiw	r24, 0x00	; 0
    27a8:	d1 f4       	brne	.+52     	; 0x27de <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    27aa:	81 e0       	ldi	r24, 0x01	; 1
    27ac:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    27ae:	28 85       	ldd	r18, Y+8	; 0x08
    27b0:	39 85       	ldd	r19, Y+9	; 0x09
    27b2:	39 8b       	std	Y+17, r19	; 0x11
    27b4:	28 8b       	std	Y+16, r18	; 0x10
    27b6:	8a 85       	ldd	r24, Y+10	; 0x0a
    27b8:	9b 85       	ldd	r25, Y+11	; 0x0b
    27ba:	9f 87       	std	Y+15, r25	; 0x0f
    27bc:	8e 87       	std	Y+14, r24	; 0x0e
    27be:	2e 85       	ldd	r18, Y+14	; 0x0e
    27c0:	3f 85       	ldd	r19, Y+15	; 0x0f
    27c2:	88 89       	ldd	r24, Y+16	; 0x10
    27c4:	99 89       	ldd	r25, Y+17	; 0x11
    27c6:	82 17       	cp	r24, r18
    27c8:	93 07       	cpc	r25, r19
    27ca:	20 f4       	brcc	.+8      	; 0x27d4 <prvWriteMessageToBuffer+0x74>
    27cc:	28 89       	ldd	r18, Y+16	; 0x10
    27ce:	39 89       	ldd	r19, Y+17	; 0x11
    27d0:	3f 87       	std	Y+15, r19	; 0x0f
    27d2:	2e 87       	std	Y+14, r18	; 0x0e
    27d4:	8e 85       	ldd	r24, Y+14	; 0x0e
    27d6:	9f 85       	ldd	r25, Y+15	; 0x0f
    27d8:	99 87       	std	Y+9, r25	; 0x09
    27da:	88 87       	std	Y+8, r24	; 0x08
    27dc:	15 c0       	rjmp	.+42     	; 0x2808 <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    27de:	2a 85       	ldd	r18, Y+10	; 0x0a
    27e0:	3b 85       	ldd	r19, Y+11	; 0x0b
    27e2:	8c 85       	ldd	r24, Y+12	; 0x0c
    27e4:	9d 85       	ldd	r25, Y+13	; 0x0d
    27e6:	28 17       	cp	r18, r24
    27e8:	39 07       	cpc	r19, r25
    27ea:	68 f0       	brcs	.+26     	; 0x2806 <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    27ec:	81 e0       	ldi	r24, 0x01	; 1
    27ee:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    27f0:	9e 01       	movw	r18, r28
    27f2:	28 5f       	subi	r18, 0xF8	; 248
    27f4:	3f 4f       	sbci	r19, 0xFF	; 255
    27f6:	8c 81       	ldd	r24, Y+4	; 0x04
    27f8:	9d 81       	ldd	r25, Y+5	; 0x05
    27fa:	b9 01       	movw	r22, r18
    27fc:	42 e0       	ldi	r20, 0x02	; 2
    27fe:	50 e0       	ldi	r21, 0x00	; 0
    2800:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <prvWriteBytesToBuffer>
    2804:	01 c0       	rjmp	.+2      	; 0x2808 <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    2806:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    2808:	8b 81       	ldd	r24, Y+3	; 0x03
    280a:	88 23       	and	r24, r24
    280c:	61 f0       	breq	.+24     	; 0x2826 <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    280e:	2e 81       	ldd	r18, Y+6	; 0x06
    2810:	3f 81       	ldd	r19, Y+7	; 0x07
    2812:	48 85       	ldd	r20, Y+8	; 0x08
    2814:	59 85       	ldd	r21, Y+9	; 0x09
    2816:	8c 81       	ldd	r24, Y+4	; 0x04
    2818:	9d 81       	ldd	r25, Y+5	; 0x05
    281a:	b9 01       	movw	r22, r18
    281c:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <prvWriteBytesToBuffer>
    2820:	9a 83       	std	Y+2, r25	; 0x02
    2822:	89 83       	std	Y+1, r24	; 0x01
    2824:	02 c0       	rjmp	.+4      	; 0x282a <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    2826:	1a 82       	std	Y+2, r1	; 0x02
    2828:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    282a:	89 81       	ldd	r24, Y+1	; 0x01
    282c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    282e:	61 96       	adiw	r28, 0x11	; 17
    2830:	0f b6       	in	r0, 0x3f	; 63
    2832:	f8 94       	cli
    2834:	de bf       	out	0x3e, r29	; 62
    2836:	0f be       	out	0x3f, r0	; 63
    2838:	cd bf       	out	0x3d, r28	; 61
    283a:	cf 91       	pop	r28
    283c:	df 91       	pop	r29
    283e:	1f 91       	pop	r17
    2840:	0f 91       	pop	r16
    2842:	08 95       	ret

00002844 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    2844:	ef 92       	push	r14
    2846:	ff 92       	push	r15
    2848:	0f 93       	push	r16
    284a:	1f 93       	push	r17
    284c:	df 93       	push	r29
    284e:	cf 93       	push	r28
    2850:	cd b7       	in	r28, 0x3d	; 61
    2852:	de b7       	in	r29, 0x3e	; 62
    2854:	60 97       	sbiw	r28, 0x10	; 16
    2856:	0f b6       	in	r0, 0x3f	; 63
    2858:	f8 94       	cli
    285a:	de bf       	out	0x3e, r29	; 62
    285c:	0f be       	out	0x3f, r0	; 63
    285e:	cd bf       	out	0x3d, r28	; 61
    2860:	9a 87       	std	Y+10, r25	; 0x0a
    2862:	89 87       	std	Y+9, r24	; 0x09
    2864:	7c 87       	std	Y+12, r23	; 0x0c
    2866:	6b 87       	std	Y+11, r22	; 0x0b
    2868:	5e 87       	std	Y+14, r21	; 0x0e
    286a:	4d 87       	std	Y+13, r20	; 0x0d
    286c:	38 8b       	std	Y+16, r19	; 0x10
    286e:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2870:	89 85       	ldd	r24, Y+9	; 0x09
    2872:	9a 85       	ldd	r25, Y+10	; 0x0a
    2874:	98 87       	std	Y+8, r25	; 0x08
    2876:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    2878:	1e 82       	std	Y+6, r1	; 0x06
    287a:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    287c:	ef 81       	ldd	r30, Y+7	; 0x07
    287e:	f8 85       	ldd	r31, Y+8	; 0x08
    2880:	86 85       	ldd	r24, Z+14	; 0x0e
    2882:	88 2f       	mov	r24, r24
    2884:	90 e0       	ldi	r25, 0x00	; 0
    2886:	81 70       	andi	r24, 0x01	; 1
    2888:	90 70       	andi	r25, 0x00	; 0
    288a:	88 23       	and	r24, r24
    288c:	29 f0       	breq	.+10     	; 0x2898 <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    288e:	82 e0       	ldi	r24, 0x02	; 2
    2890:	90 e0       	ldi	r25, 0x00	; 0
    2892:	9a 83       	std	Y+2, r25	; 0x02
    2894:	89 83       	std	Y+1, r24	; 0x01
    2896:	02 c0       	rjmp	.+4      	; 0x289c <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    2898:	1a 82       	std	Y+2, r1	; 0x02
    289a:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    289c:	8f 85       	ldd	r24, Y+15	; 0x0f
    289e:	98 89       	ldd	r25, Y+16	; 0x10
    28a0:	00 97       	sbiw	r24, 0x00	; 0
    28a2:	09 f4       	brne	.+2      	; 0x28a6 <xStreamBufferReceive+0x62>
    28a4:	3d c0       	rjmp	.+122    	; 0x2920 <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    28a6:	0f b6       	in	r0, 0x3f	; 63
    28a8:	f8 94       	cli
    28aa:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    28ac:	8f 81       	ldd	r24, Y+7	; 0x07
    28ae:	98 85       	ldd	r25, Y+8	; 0x08
    28b0:	0e 94 37 18 	call	0x306e	; 0x306e <prvBytesInBuffer>
    28b4:	9c 83       	std	Y+4, r25	; 0x04
    28b6:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    28b8:	2b 81       	ldd	r18, Y+3	; 0x03
    28ba:	3c 81       	ldd	r19, Y+4	; 0x04
    28bc:	89 81       	ldd	r24, Y+1	; 0x01
    28be:	9a 81       	ldd	r25, Y+2	; 0x02
    28c0:	82 17       	cp	r24, r18
    28c2:	93 07       	cpc	r25, r19
    28c4:	50 f0       	brcs	.+20     	; 0x28da <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    28c6:	80 e0       	ldi	r24, 0x00	; 0
    28c8:	90 e0       	ldi	r25, 0x00	; 0
    28ca:	0e 94 8e 24 	call	0x491c	; 0x491c <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    28ce:	0e 94 ef 20 	call	0x41de	; 0x41de <xTaskGetCurrentTaskHandle>
    28d2:	ef 81       	ldd	r30, Y+7	; 0x07
    28d4:	f8 85       	ldd	r31, Y+8	; 0x08
    28d6:	91 87       	std	Z+9, r25	; 0x09
    28d8:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    28da:	0f 90       	pop	r0
    28dc:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    28de:	2b 81       	ldd	r18, Y+3	; 0x03
    28e0:	3c 81       	ldd	r19, Y+4	; 0x04
    28e2:	89 81       	ldd	r24, Y+1	; 0x01
    28e4:	9a 81       	ldd	r25, Y+2	; 0x02
    28e6:	82 17       	cp	r24, r18
    28e8:	93 07       	cpc	r25, r19
    28ea:	00 f1       	brcs	.+64     	; 0x292c <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    28ec:	ef 85       	ldd	r30, Y+15	; 0x0f
    28ee:	f8 89       	ldd	r31, Y+16	; 0x10
    28f0:	60 e0       	ldi	r22, 0x00	; 0
    28f2:	70 e0       	ldi	r23, 0x00	; 0
    28f4:	80 e0       	ldi	r24, 0x00	; 0
    28f6:	90 e0       	ldi	r25, 0x00	; 0
    28f8:	20 e0       	ldi	r18, 0x00	; 0
    28fa:	30 e0       	ldi	r19, 0x00	; 0
    28fc:	40 e0       	ldi	r20, 0x00	; 0
    28fe:	50 e0       	ldi	r21, 0x00	; 0
    2900:	00 e0       	ldi	r16, 0x00	; 0
    2902:	10 e0       	ldi	r17, 0x00	; 0
    2904:	7f 01       	movw	r14, r30
    2906:	0e 94 9f 21 	call	0x433e	; 0x433e <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    290a:	ef 81       	ldd	r30, Y+7	; 0x07
    290c:	f8 85       	ldd	r31, Y+8	; 0x08
    290e:	11 86       	std	Z+9, r1	; 0x09
    2910:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2912:	8f 81       	ldd	r24, Y+7	; 0x07
    2914:	98 85       	ldd	r25, Y+8	; 0x08
    2916:	0e 94 37 18 	call	0x306e	; 0x306e <prvBytesInBuffer>
    291a:	9c 83       	std	Y+4, r25	; 0x04
    291c:	8b 83       	std	Y+3, r24	; 0x03
    291e:	06 c0       	rjmp	.+12     	; 0x292c <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2920:	8f 81       	ldd	r24, Y+7	; 0x07
    2922:	98 85       	ldd	r25, Y+8	; 0x08
    2924:	0e 94 37 18 	call	0x306e	; 0x306e <prvBytesInBuffer>
    2928:	9c 83       	std	Y+4, r25	; 0x04
    292a:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    292c:	2b 81       	ldd	r18, Y+3	; 0x03
    292e:	3c 81       	ldd	r19, Y+4	; 0x04
    2930:	89 81       	ldd	r24, Y+1	; 0x01
    2932:	9a 81       	ldd	r25, Y+2	; 0x02
    2934:	82 17       	cp	r24, r18
    2936:	93 07       	cpc	r25, r19
    2938:	80 f5       	brcc	.+96     	; 0x299a <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    293a:	8f 81       	ldd	r24, Y+7	; 0x07
    293c:	98 85       	ldd	r25, Y+8	; 0x08
    293e:	2b 85       	ldd	r18, Y+11	; 0x0b
    2940:	3c 85       	ldd	r19, Y+12	; 0x0c
    2942:	4d 85       	ldd	r20, Y+13	; 0x0d
    2944:	5e 85       	ldd	r21, Y+14	; 0x0e
    2946:	eb 81       	ldd	r30, Y+3	; 0x03
    2948:	fc 81       	ldd	r31, Y+4	; 0x04
    294a:	a9 81       	ldd	r26, Y+1	; 0x01
    294c:	ba 81       	ldd	r27, Y+2	; 0x02
    294e:	b9 01       	movw	r22, r18
    2950:	9f 01       	movw	r18, r30
    2952:	8d 01       	movw	r16, r26
    2954:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <prvReadMessageFromBuffer>
    2958:	9e 83       	std	Y+6, r25	; 0x06
    295a:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    295c:	8d 81       	ldd	r24, Y+5	; 0x05
    295e:	9e 81       	ldd	r25, Y+6	; 0x06
    2960:	00 97       	sbiw	r24, 0x00	; 0
    2962:	d9 f0       	breq	.+54     	; 0x299a <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    2964:	0e 94 8e 1c 	call	0x391c	; 0x391c <vTaskSuspendAll>
    2968:	ef 81       	ldd	r30, Y+7	; 0x07
    296a:	f8 85       	ldd	r31, Y+8	; 0x08
    296c:	82 85       	ldd	r24, Z+10	; 0x0a
    296e:	93 85       	ldd	r25, Z+11	; 0x0b
    2970:	00 97       	sbiw	r24, 0x00	; 0
    2972:	89 f0       	breq	.+34     	; 0x2996 <xStreamBufferReceive+0x152>
    2974:	ef 81       	ldd	r30, Y+7	; 0x07
    2976:	f8 85       	ldd	r31, Y+8	; 0x08
    2978:	82 85       	ldd	r24, Z+10	; 0x0a
    297a:	93 85       	ldd	r25, Z+11	; 0x0b
    297c:	40 e0       	ldi	r20, 0x00	; 0
    297e:	50 e0       	ldi	r21, 0x00	; 0
    2980:	60 e0       	ldi	r22, 0x00	; 0
    2982:	70 e0       	ldi	r23, 0x00	; 0
    2984:	20 e0       	ldi	r18, 0x00	; 0
    2986:	00 e0       	ldi	r16, 0x00	; 0
    2988:	10 e0       	ldi	r17, 0x00	; 0
    298a:	0e 94 3b 22 	call	0x4476	; 0x4476 <xTaskGenericNotify>
    298e:	ef 81       	ldd	r30, Y+7	; 0x07
    2990:	f8 85       	ldd	r31, Y+8	; 0x08
    2992:	13 86       	std	Z+11, r1	; 0x0b
    2994:	12 86       	std	Z+10, r1	; 0x0a
    2996:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    299a:	8d 81       	ldd	r24, Y+5	; 0x05
    299c:	9e 81       	ldd	r25, Y+6	; 0x06
}
    299e:	60 96       	adiw	r28, 0x10	; 16
    29a0:	0f b6       	in	r0, 0x3f	; 63
    29a2:	f8 94       	cli
    29a4:	de bf       	out	0x3e, r29	; 62
    29a6:	0f be       	out	0x3f, r0	; 63
    29a8:	cd bf       	out	0x3d, r28	; 61
    29aa:	cf 91       	pop	r28
    29ac:	df 91       	pop	r29
    29ae:	1f 91       	pop	r17
    29b0:	0f 91       	pop	r16
    29b2:	ff 90       	pop	r15
    29b4:	ef 90       	pop	r14
    29b6:	08 95       	ret

000029b8 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    29b8:	df 93       	push	r29
    29ba:	cf 93       	push	r28
    29bc:	cd b7       	in	r28, 0x3d	; 61
    29be:	de b7       	in	r29, 0x3e	; 62
    29c0:	2c 97       	sbiw	r28, 0x0c	; 12
    29c2:	0f b6       	in	r0, 0x3f	; 63
    29c4:	f8 94       	cli
    29c6:	de bf       	out	0x3e, r29	; 62
    29c8:	0f be       	out	0x3f, r0	; 63
    29ca:	cd bf       	out	0x3d, r28	; 61
    29cc:	9c 87       	std	Y+12, r25	; 0x0c
    29ce:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    29d0:	8b 85       	ldd	r24, Y+11	; 0x0b
    29d2:	9c 85       	ldd	r25, Y+12	; 0x0c
    29d4:	98 87       	std	Y+8, r25	; 0x08
    29d6:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    29d8:	ef 81       	ldd	r30, Y+7	; 0x07
    29da:	f8 85       	ldd	r31, Y+8	; 0x08
    29dc:	86 85       	ldd	r24, Z+14	; 0x0e
    29de:	88 2f       	mov	r24, r24
    29e0:	90 e0       	ldi	r25, 0x00	; 0
    29e2:	81 70       	andi	r24, 0x01	; 1
    29e4:	90 70       	andi	r25, 0x00	; 0
    29e6:	88 23       	and	r24, r24
    29e8:	61 f1       	breq	.+88     	; 0x2a42 <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    29ea:	8f 81       	ldd	r24, Y+7	; 0x07
    29ec:	98 85       	ldd	r25, Y+8	; 0x08
    29ee:	0e 94 37 18 	call	0x306e	; 0x306e <prvBytesInBuffer>
    29f2:	9c 83       	std	Y+4, r25	; 0x04
    29f4:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    29f6:	8b 81       	ldd	r24, Y+3	; 0x03
    29f8:	9c 81       	ldd	r25, Y+4	; 0x04
    29fa:	83 30       	cpi	r24, 0x03	; 3
    29fc:	91 05       	cpc	r25, r1
    29fe:	f0 f0       	brcs	.+60     	; 0x2a3c <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    2a00:	ef 81       	ldd	r30, Y+7	; 0x07
    2a02:	f8 85       	ldd	r31, Y+8	; 0x08
    2a04:	80 81       	ld	r24, Z
    2a06:	91 81       	ldd	r25, Z+1	; 0x01
    2a08:	9a 83       	std	Y+2, r25	; 0x02
    2a0a:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    2a0c:	9e 01       	movw	r18, r28
    2a0e:	27 5f       	subi	r18, 0xF7	; 247
    2a10:	3f 4f       	sbci	r19, 0xFF	; 255
    2a12:	8f 81       	ldd	r24, Y+7	; 0x07
    2a14:	98 85       	ldd	r25, Y+8	; 0x08
    2a16:	eb 81       	ldd	r30, Y+3	; 0x03
    2a18:	fc 81       	ldd	r31, Y+4	; 0x04
    2a1a:	b9 01       	movw	r22, r18
    2a1c:	42 e0       	ldi	r20, 0x02	; 2
    2a1e:	50 e0       	ldi	r21, 0x00	; 0
    2a20:	9f 01       	movw	r18, r30
    2a22:	0e 94 8a 17 	call	0x2f14	; 0x2f14 <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    2a26:	89 85       	ldd	r24, Y+9	; 0x09
    2a28:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a2a:	9e 83       	std	Y+6, r25	; 0x06
    2a2c:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    2a2e:	ef 81       	ldd	r30, Y+7	; 0x07
    2a30:	f8 85       	ldd	r31, Y+8	; 0x08
    2a32:	89 81       	ldd	r24, Y+1	; 0x01
    2a34:	9a 81       	ldd	r25, Y+2	; 0x02
    2a36:	91 83       	std	Z+1, r25	; 0x01
    2a38:	80 83       	st	Z, r24
    2a3a:	05 c0       	rjmp	.+10     	; 0x2a46 <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    2a3c:	1e 82       	std	Y+6, r1	; 0x06
    2a3e:	1d 82       	std	Y+5, r1	; 0x05
    2a40:	02 c0       	rjmp	.+4      	; 0x2a46 <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    2a42:	1e 82       	std	Y+6, r1	; 0x06
    2a44:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    2a46:	8d 81       	ldd	r24, Y+5	; 0x05
    2a48:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2a4a:	2c 96       	adiw	r28, 0x0c	; 12
    2a4c:	0f b6       	in	r0, 0x3f	; 63
    2a4e:	f8 94       	cli
    2a50:	de bf       	out	0x3e, r29	; 62
    2a52:	0f be       	out	0x3f, r0	; 63
    2a54:	cd bf       	out	0x3d, r28	; 61
    2a56:	cf 91       	pop	r28
    2a58:	df 91       	pop	r29
    2a5a:	08 95       	ret

00002a5c <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    2a5c:	ef 92       	push	r14
    2a5e:	ff 92       	push	r15
    2a60:	0f 93       	push	r16
    2a62:	1f 93       	push	r17
    2a64:	df 93       	push	r29
    2a66:	cf 93       	push	r28
    2a68:	cd b7       	in	r28, 0x3d	; 61
    2a6a:	de b7       	in	r29, 0x3e	; 62
    2a6c:	61 97       	sbiw	r28, 0x11	; 17
    2a6e:	0f b6       	in	r0, 0x3f	; 63
    2a70:	f8 94       	cli
    2a72:	de bf       	out	0x3e, r29	; 62
    2a74:	0f be       	out	0x3f, r0	; 63
    2a76:	cd bf       	out	0x3d, r28	; 61
    2a78:	9b 87       	std	Y+11, r25	; 0x0b
    2a7a:	8a 87       	std	Y+10, r24	; 0x0a
    2a7c:	7d 87       	std	Y+13, r23	; 0x0d
    2a7e:	6c 87       	std	Y+12, r22	; 0x0c
    2a80:	5f 87       	std	Y+15, r21	; 0x0f
    2a82:	4e 87       	std	Y+14, r20	; 0x0e
    2a84:	39 8b       	std	Y+17, r19	; 0x11
    2a86:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2a88:	8a 85       	ldd	r24, Y+10	; 0x0a
    2a8a:	9b 85       	ldd	r25, Y+11	; 0x0b
    2a8c:	99 87       	std	Y+9, r25	; 0x09
    2a8e:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    2a90:	1f 82       	std	Y+7, r1	; 0x07
    2a92:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2a94:	e8 85       	ldd	r30, Y+8	; 0x08
    2a96:	f9 85       	ldd	r31, Y+9	; 0x09
    2a98:	86 85       	ldd	r24, Z+14	; 0x0e
    2a9a:	88 2f       	mov	r24, r24
    2a9c:	90 e0       	ldi	r25, 0x00	; 0
    2a9e:	81 70       	andi	r24, 0x01	; 1
    2aa0:	90 70       	andi	r25, 0x00	; 0
    2aa2:	88 23       	and	r24, r24
    2aa4:	29 f0       	breq	.+10     	; 0x2ab0 <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2aa6:	82 e0       	ldi	r24, 0x02	; 2
    2aa8:	90 e0       	ldi	r25, 0x00	; 0
    2aaa:	9b 83       	std	Y+3, r25	; 0x03
    2aac:	8a 83       	std	Y+2, r24	; 0x02
    2aae:	02 c0       	rjmp	.+4      	; 0x2ab4 <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    2ab0:	1b 82       	std	Y+3, r1	; 0x03
    2ab2:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2ab4:	88 85       	ldd	r24, Y+8	; 0x08
    2ab6:	99 85       	ldd	r25, Y+9	; 0x09
    2ab8:	0e 94 37 18 	call	0x306e	; 0x306e <prvBytesInBuffer>
    2abc:	9d 83       	std	Y+5, r25	; 0x05
    2abe:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    2ac0:	2c 81       	ldd	r18, Y+4	; 0x04
    2ac2:	3d 81       	ldd	r19, Y+5	; 0x05
    2ac4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ac6:	9b 81       	ldd	r25, Y+3	; 0x03
    2ac8:	82 17       	cp	r24, r18
    2aca:	93 07       	cpc	r25, r19
    2acc:	80 f5       	brcc	.+96     	; 0x2b2e <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    2ace:	88 85       	ldd	r24, Y+8	; 0x08
    2ad0:	99 85       	ldd	r25, Y+9	; 0x09
    2ad2:	2c 85       	ldd	r18, Y+12	; 0x0c
    2ad4:	3d 85       	ldd	r19, Y+13	; 0x0d
    2ad6:	4e 85       	ldd	r20, Y+14	; 0x0e
    2ad8:	5f 85       	ldd	r21, Y+15	; 0x0f
    2ada:	ec 81       	ldd	r30, Y+4	; 0x04
    2adc:	fd 81       	ldd	r31, Y+5	; 0x05
    2ade:	aa 81       	ldd	r26, Y+2	; 0x02
    2ae0:	bb 81       	ldd	r27, Y+3	; 0x03
    2ae2:	b9 01       	movw	r22, r18
    2ae4:	9f 01       	movw	r18, r30
    2ae6:	8d 01       	movw	r16, r26
    2ae8:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <prvReadMessageFromBuffer>
    2aec:	9f 83       	std	Y+7, r25	; 0x07
    2aee:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    2af0:	8e 81       	ldd	r24, Y+6	; 0x06
    2af2:	9f 81       	ldd	r25, Y+7	; 0x07
    2af4:	00 97       	sbiw	r24, 0x00	; 0
    2af6:	d9 f0       	breq	.+54     	; 0x2b2e <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    2af8:	19 82       	std	Y+1, r1	; 0x01
    2afa:	e8 85       	ldd	r30, Y+8	; 0x08
    2afc:	f9 85       	ldd	r31, Y+9	; 0x09
    2afe:	82 85       	ldd	r24, Z+10	; 0x0a
    2b00:	93 85       	ldd	r25, Z+11	; 0x0b
    2b02:	00 97       	sbiw	r24, 0x00	; 0
    2b04:	a1 f0       	breq	.+40     	; 0x2b2e <xStreamBufferReceiveFromISR+0xd2>
    2b06:	e8 85       	ldd	r30, Y+8	; 0x08
    2b08:	f9 85       	ldd	r31, Y+9	; 0x09
    2b0a:	82 85       	ldd	r24, Z+10	; 0x0a
    2b0c:	93 85       	ldd	r25, Z+11	; 0x0b
    2b0e:	e8 89       	ldd	r30, Y+16	; 0x10
    2b10:	f9 89       	ldd	r31, Y+17	; 0x11
    2b12:	40 e0       	ldi	r20, 0x00	; 0
    2b14:	50 e0       	ldi	r21, 0x00	; 0
    2b16:	60 e0       	ldi	r22, 0x00	; 0
    2b18:	70 e0       	ldi	r23, 0x00	; 0
    2b1a:	20 e0       	ldi	r18, 0x00	; 0
    2b1c:	00 e0       	ldi	r16, 0x00	; 0
    2b1e:	10 e0       	ldi	r17, 0x00	; 0
    2b20:	7f 01       	movw	r14, r30
    2b22:	0e 94 10 23 	call	0x4620	; 0x4620 <xTaskGenericNotifyFromISR>
    2b26:	e8 85       	ldd	r30, Y+8	; 0x08
    2b28:	f9 85       	ldd	r31, Y+9	; 0x09
    2b2a:	13 86       	std	Z+11, r1	; 0x0b
    2b2c:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    2b2e:	8e 81       	ldd	r24, Y+6	; 0x06
    2b30:	9f 81       	ldd	r25, Y+7	; 0x07
}
    2b32:	61 96       	adiw	r28, 0x11	; 17
    2b34:	0f b6       	in	r0, 0x3f	; 63
    2b36:	f8 94       	cli
    2b38:	de bf       	out	0x3e, r29	; 62
    2b3a:	0f be       	out	0x3f, r0	; 63
    2b3c:	cd bf       	out	0x3d, r28	; 61
    2b3e:	cf 91       	pop	r28
    2b40:	df 91       	pop	r29
    2b42:	1f 91       	pop	r17
    2b44:	0f 91       	pop	r16
    2b46:	ff 90       	pop	r15
    2b48:	ef 90       	pop	r14
    2b4a:	08 95       	ret

00002b4c <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    2b4c:	0f 93       	push	r16
    2b4e:	1f 93       	push	r17
    2b50:	df 93       	push	r29
    2b52:	cf 93       	push	r28
    2b54:	cd b7       	in	r28, 0x3d	; 61
    2b56:	de b7       	in	r29, 0x3e	; 62
    2b58:	62 97       	sbiw	r28, 0x12	; 18
    2b5a:	0f b6       	in	r0, 0x3f	; 63
    2b5c:	f8 94       	cli
    2b5e:	de bf       	out	0x3e, r29	; 62
    2b60:	0f be       	out	0x3f, r0	; 63
    2b62:	cd bf       	out	0x3d, r28	; 61
    2b64:	9a 87       	std	Y+10, r25	; 0x0a
    2b66:	89 87       	std	Y+9, r24	; 0x09
    2b68:	7c 87       	std	Y+12, r23	; 0x0c
    2b6a:	6b 87       	std	Y+11, r22	; 0x0b
    2b6c:	5e 87       	std	Y+14, r21	; 0x0e
    2b6e:	4d 87       	std	Y+13, r20	; 0x0d
    2b70:	38 8b       	std	Y+16, r19	; 0x10
    2b72:	2f 87       	std	Y+15, r18	; 0x0f
    2b74:	1a 8b       	std	Y+18, r17	; 0x12
    2b76:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    2b78:	89 89       	ldd	r24, Y+17	; 0x11
    2b7a:	9a 89       	ldd	r25, Y+18	; 0x12
    2b7c:	00 97       	sbiw	r24, 0x00	; 0
    2b7e:	91 f1       	breq	.+100    	; 0x2be4 <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    2b80:	e9 85       	ldd	r30, Y+9	; 0x09
    2b82:	fa 85       	ldd	r31, Y+10	; 0x0a
    2b84:	80 81       	ld	r24, Z
    2b86:	91 81       	ldd	r25, Z+1	; 0x01
    2b88:	9e 83       	std	Y+6, r25	; 0x06
    2b8a:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    2b8c:	ae 01       	movw	r20, r28
    2b8e:	49 5f       	subi	r20, 0xF9	; 249
    2b90:	5f 4f       	sbci	r21, 0xFF	; 255
    2b92:	89 85       	ldd	r24, Y+9	; 0x09
    2b94:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b96:	29 89       	ldd	r18, Y+17	; 0x11
    2b98:	3a 89       	ldd	r19, Y+18	; 0x12
    2b9a:	ef 85       	ldd	r30, Y+15	; 0x0f
    2b9c:	f8 89       	ldd	r31, Y+16	; 0x10
    2b9e:	ba 01       	movw	r22, r20
    2ba0:	a9 01       	movw	r20, r18
    2ba2:	9f 01       	movw	r18, r30
    2ba4:	0e 94 8a 17 	call	0x2f14	; 0x2f14 <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    2ba8:	8f 81       	ldd	r24, Y+7	; 0x07
    2baa:	98 85       	ldd	r25, Y+8	; 0x08
    2bac:	9a 83       	std	Y+2, r25	; 0x02
    2bae:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    2bb0:	2f 85       	ldd	r18, Y+15	; 0x0f
    2bb2:	38 89       	ldd	r19, Y+16	; 0x10
    2bb4:	89 89       	ldd	r24, Y+17	; 0x11
    2bb6:	9a 89       	ldd	r25, Y+18	; 0x12
    2bb8:	a9 01       	movw	r20, r18
    2bba:	48 1b       	sub	r20, r24
    2bbc:	59 0b       	sbc	r21, r25
    2bbe:	ca 01       	movw	r24, r20
    2bc0:	98 8b       	std	Y+16, r25	; 0x10
    2bc2:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    2bc4:	29 81       	ldd	r18, Y+1	; 0x01
    2bc6:	3a 81       	ldd	r19, Y+2	; 0x02
    2bc8:	8d 85       	ldd	r24, Y+13	; 0x0d
    2bca:	9e 85       	ldd	r25, Y+14	; 0x0e
    2bcc:	82 17       	cp	r24, r18
    2bce:	93 07       	cpc	r25, r19
    2bd0:	68 f4       	brcc	.+26     	; 0x2bec <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    2bd2:	e9 85       	ldd	r30, Y+9	; 0x09
    2bd4:	fa 85       	ldd	r31, Y+10	; 0x0a
    2bd6:	8d 81       	ldd	r24, Y+5	; 0x05
    2bd8:	9e 81       	ldd	r25, Y+6	; 0x06
    2bda:	91 83       	std	Z+1, r25	; 0x01
    2bdc:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    2bde:	1a 82       	std	Y+2, r1	; 0x02
    2be0:	19 82       	std	Y+1, r1	; 0x01
    2be2:	04 c0       	rjmp	.+8      	; 0x2bec <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    2be4:	8d 85       	ldd	r24, Y+13	; 0x0d
    2be6:	9e 85       	ldd	r25, Y+14	; 0x0e
    2be8:	9a 83       	std	Y+2, r25	; 0x02
    2bea:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    2bec:	4b 85       	ldd	r20, Y+11	; 0x0b
    2bee:	5c 85       	ldd	r21, Y+12	; 0x0c
    2bf0:	89 85       	ldd	r24, Y+9	; 0x09
    2bf2:	9a 85       	ldd	r25, Y+10	; 0x0a
    2bf4:	29 81       	ldd	r18, Y+1	; 0x01
    2bf6:	3a 81       	ldd	r19, Y+2	; 0x02
    2bf8:	ef 85       	ldd	r30, Y+15	; 0x0f
    2bfa:	f8 89       	ldd	r31, Y+16	; 0x10
    2bfc:	ba 01       	movw	r22, r20
    2bfe:	a9 01       	movw	r20, r18
    2c00:	9f 01       	movw	r18, r30
    2c02:	0e 94 8a 17 	call	0x2f14	; 0x2f14 <prvReadBytesFromBuffer>
    2c06:	9c 83       	std	Y+4, r25	; 0x04
    2c08:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    2c0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c0c:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2c0e:	62 96       	adiw	r28, 0x12	; 18
    2c10:	0f b6       	in	r0, 0x3f	; 63
    2c12:	f8 94       	cli
    2c14:	de bf       	out	0x3e, r29	; 62
    2c16:	0f be       	out	0x3f, r0	; 63
    2c18:	cd bf       	out	0x3d, r28	; 61
    2c1a:	cf 91       	pop	r28
    2c1c:	df 91       	pop	r29
    2c1e:	1f 91       	pop	r17
    2c20:	0f 91       	pop	r16
    2c22:	08 95       	ret

00002c24 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    2c24:	df 93       	push	r29
    2c26:	cf 93       	push	r28
    2c28:	cd b7       	in	r28, 0x3d	; 61
    2c2a:	de b7       	in	r29, 0x3e	; 62
    2c2c:	27 97       	sbiw	r28, 0x07	; 7
    2c2e:	0f b6       	in	r0, 0x3f	; 63
    2c30:	f8 94       	cli
    2c32:	de bf       	out	0x3e, r29	; 62
    2c34:	0f be       	out	0x3f, r0	; 63
    2c36:	cd bf       	out	0x3d, r28	; 61
    2c38:	9f 83       	std	Y+7, r25	; 0x07
    2c3a:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2c3c:	8e 81       	ldd	r24, Y+6	; 0x06
    2c3e:	9f 81       	ldd	r25, Y+7	; 0x07
    2c40:	9d 83       	std	Y+5, r25	; 0x05
    2c42:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    2c44:	ec 81       	ldd	r30, Y+4	; 0x04
    2c46:	fd 81       	ldd	r31, Y+5	; 0x05
    2c48:	80 81       	ld	r24, Z
    2c4a:	91 81       	ldd	r25, Z+1	; 0x01
    2c4c:	9a 83       	std	Y+2, r25	; 0x02
    2c4e:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    2c50:	ec 81       	ldd	r30, Y+4	; 0x04
    2c52:	fd 81       	ldd	r31, Y+5	; 0x05
    2c54:	22 81       	ldd	r18, Z+2	; 0x02
    2c56:	33 81       	ldd	r19, Z+3	; 0x03
    2c58:	89 81       	ldd	r24, Y+1	; 0x01
    2c5a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c5c:	28 17       	cp	r18, r24
    2c5e:	39 07       	cpc	r19, r25
    2c60:	19 f4       	brne	.+6      	; 0x2c68 <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    2c62:	81 e0       	ldi	r24, 0x01	; 1
    2c64:	8b 83       	std	Y+3, r24	; 0x03
    2c66:	01 c0       	rjmp	.+2      	; 0x2c6a <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    2c68:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2c6a:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2c6c:	27 96       	adiw	r28, 0x07	; 7
    2c6e:	0f b6       	in	r0, 0x3f	; 63
    2c70:	f8 94       	cli
    2c72:	de bf       	out	0x3e, r29	; 62
    2c74:	0f be       	out	0x3f, r0	; 63
    2c76:	cd bf       	out	0x3d, r28	; 61
    2c78:	cf 91       	pop	r28
    2c7a:	df 91       	pop	r29
    2c7c:	08 95       	ret

00002c7e <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    2c7e:	df 93       	push	r29
    2c80:	cf 93       	push	r28
    2c82:	cd b7       	in	r28, 0x3d	; 61
    2c84:	de b7       	in	r29, 0x3e	; 62
    2c86:	27 97       	sbiw	r28, 0x07	; 7
    2c88:	0f b6       	in	r0, 0x3f	; 63
    2c8a:	f8 94       	cli
    2c8c:	de bf       	out	0x3e, r29	; 62
    2c8e:	0f be       	out	0x3f, r0	; 63
    2c90:	cd bf       	out	0x3d, r28	; 61
    2c92:	9f 83       	std	Y+7, r25	; 0x07
    2c94:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2c96:	8e 81       	ldd	r24, Y+6	; 0x06
    2c98:	9f 81       	ldd	r25, Y+7	; 0x07
    2c9a:	9a 83       	std	Y+2, r25	; 0x02
    2c9c:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2c9e:	e9 81       	ldd	r30, Y+1	; 0x01
    2ca0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ca2:	86 85       	ldd	r24, Z+14	; 0x0e
    2ca4:	88 2f       	mov	r24, r24
    2ca6:	90 e0       	ldi	r25, 0x00	; 0
    2ca8:	81 70       	andi	r24, 0x01	; 1
    2caa:	90 70       	andi	r25, 0x00	; 0
    2cac:	88 23       	and	r24, r24
    2cae:	29 f0       	breq	.+10     	; 0x2cba <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2cb0:	82 e0       	ldi	r24, 0x02	; 2
    2cb2:	90 e0       	ldi	r25, 0x00	; 0
    2cb4:	9c 83       	std	Y+4, r25	; 0x04
    2cb6:	8b 83       	std	Y+3, r24	; 0x03
    2cb8:	02 c0       	rjmp	.+4      	; 0x2cbe <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    2cba:	1c 82       	std	Y+4, r1	; 0x04
    2cbc:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    2cbe:	8e 81       	ldd	r24, Y+6	; 0x06
    2cc0:	9f 81       	ldd	r25, Y+7	; 0x07
    2cc2:	0e 94 07 12 	call	0x240e	; 0x240e <xStreamBufferSpacesAvailable>
    2cc6:	9c 01       	movw	r18, r24
    2cc8:	8b 81       	ldd	r24, Y+3	; 0x03
    2cca:	9c 81       	ldd	r25, Y+4	; 0x04
    2ccc:	82 17       	cp	r24, r18
    2cce:	93 07       	cpc	r25, r19
    2cd0:	18 f0       	brcs	.+6      	; 0x2cd8 <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    2cd2:	81 e0       	ldi	r24, 0x01	; 1
    2cd4:	8d 83       	std	Y+5, r24	; 0x05
    2cd6:	01 c0       	rjmp	.+2      	; 0x2cda <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    2cd8:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    2cda:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2cdc:	27 96       	adiw	r28, 0x07	; 7
    2cde:	0f b6       	in	r0, 0x3f	; 63
    2ce0:	f8 94       	cli
    2ce2:	de bf       	out	0x3e, r29	; 62
    2ce4:	0f be       	out	0x3f, r0	; 63
    2ce6:	cd bf       	out	0x3d, r28	; 61
    2ce8:	cf 91       	pop	r28
    2cea:	df 91       	pop	r29
    2cec:	08 95       	ret

00002cee <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    2cee:	ef 92       	push	r14
    2cf0:	ff 92       	push	r15
    2cf2:	0f 93       	push	r16
    2cf4:	1f 93       	push	r17
    2cf6:	df 93       	push	r29
    2cf8:	cf 93       	push	r28
    2cfa:	cd b7       	in	r28, 0x3d	; 61
    2cfc:	de b7       	in	r29, 0x3e	; 62
    2cfe:	28 97       	sbiw	r28, 0x08	; 8
    2d00:	0f b6       	in	r0, 0x3f	; 63
    2d02:	f8 94       	cli
    2d04:	de bf       	out	0x3e, r29	; 62
    2d06:	0f be       	out	0x3f, r0	; 63
    2d08:	cd bf       	out	0x3d, r28	; 61
    2d0a:	9e 83       	std	Y+6, r25	; 0x06
    2d0c:	8d 83       	std	Y+5, r24	; 0x05
    2d0e:	78 87       	std	Y+8, r23	; 0x08
    2d10:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2d12:	8d 81       	ldd	r24, Y+5	; 0x05
    2d14:	9e 81       	ldd	r25, Y+6	; 0x06
    2d16:	9c 83       	std	Y+4, r25	; 0x04
    2d18:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    2d1a:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    2d1c:	eb 81       	ldd	r30, Y+3	; 0x03
    2d1e:	fc 81       	ldd	r31, Y+4	; 0x04
    2d20:	80 85       	ldd	r24, Z+8	; 0x08
    2d22:	91 85       	ldd	r25, Z+9	; 0x09
    2d24:	00 97       	sbiw	r24, 0x00	; 0
    2d26:	b9 f0       	breq	.+46     	; 0x2d56 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    2d28:	eb 81       	ldd	r30, Y+3	; 0x03
    2d2a:	fc 81       	ldd	r31, Y+4	; 0x04
    2d2c:	80 85       	ldd	r24, Z+8	; 0x08
    2d2e:	91 85       	ldd	r25, Z+9	; 0x09
    2d30:	ef 81       	ldd	r30, Y+7	; 0x07
    2d32:	f8 85       	ldd	r31, Y+8	; 0x08
    2d34:	40 e0       	ldi	r20, 0x00	; 0
    2d36:	50 e0       	ldi	r21, 0x00	; 0
    2d38:	60 e0       	ldi	r22, 0x00	; 0
    2d3a:	70 e0       	ldi	r23, 0x00	; 0
    2d3c:	20 e0       	ldi	r18, 0x00	; 0
    2d3e:	00 e0       	ldi	r16, 0x00	; 0
    2d40:	10 e0       	ldi	r17, 0x00	; 0
    2d42:	7f 01       	movw	r14, r30
    2d44:	0e 94 10 23 	call	0x4620	; 0x4620 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    2d48:	eb 81       	ldd	r30, Y+3	; 0x03
    2d4a:	fc 81       	ldd	r31, Y+4	; 0x04
    2d4c:	11 86       	std	Z+9, r1	; 0x09
    2d4e:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    2d50:	81 e0       	ldi	r24, 0x01	; 1
    2d52:	8a 83       	std	Y+2, r24	; 0x02
    2d54:	01 c0       	rjmp	.+2      	; 0x2d58 <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    2d56:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2d58:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2d5a:	28 96       	adiw	r28, 0x08	; 8
    2d5c:	0f b6       	in	r0, 0x3f	; 63
    2d5e:	f8 94       	cli
    2d60:	de bf       	out	0x3e, r29	; 62
    2d62:	0f be       	out	0x3f, r0	; 63
    2d64:	cd bf       	out	0x3d, r28	; 61
    2d66:	cf 91       	pop	r28
    2d68:	df 91       	pop	r29
    2d6a:	1f 91       	pop	r17
    2d6c:	0f 91       	pop	r16
    2d6e:	ff 90       	pop	r15
    2d70:	ef 90       	pop	r14
    2d72:	08 95       	ret

00002d74 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    2d74:	ef 92       	push	r14
    2d76:	ff 92       	push	r15
    2d78:	0f 93       	push	r16
    2d7a:	1f 93       	push	r17
    2d7c:	df 93       	push	r29
    2d7e:	cf 93       	push	r28
    2d80:	cd b7       	in	r28, 0x3d	; 61
    2d82:	de b7       	in	r29, 0x3e	; 62
    2d84:	28 97       	sbiw	r28, 0x08	; 8
    2d86:	0f b6       	in	r0, 0x3f	; 63
    2d88:	f8 94       	cli
    2d8a:	de bf       	out	0x3e, r29	; 62
    2d8c:	0f be       	out	0x3f, r0	; 63
    2d8e:	cd bf       	out	0x3d, r28	; 61
    2d90:	9e 83       	std	Y+6, r25	; 0x06
    2d92:	8d 83       	std	Y+5, r24	; 0x05
    2d94:	78 87       	std	Y+8, r23	; 0x08
    2d96:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2d98:	8d 81       	ldd	r24, Y+5	; 0x05
    2d9a:	9e 81       	ldd	r25, Y+6	; 0x06
    2d9c:	9c 83       	std	Y+4, r25	; 0x04
    2d9e:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    2da0:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    2da2:	eb 81       	ldd	r30, Y+3	; 0x03
    2da4:	fc 81       	ldd	r31, Y+4	; 0x04
    2da6:	82 85       	ldd	r24, Z+10	; 0x0a
    2da8:	93 85       	ldd	r25, Z+11	; 0x0b
    2daa:	00 97       	sbiw	r24, 0x00	; 0
    2dac:	b9 f0       	breq	.+46     	; 0x2ddc <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    2dae:	eb 81       	ldd	r30, Y+3	; 0x03
    2db0:	fc 81       	ldd	r31, Y+4	; 0x04
    2db2:	82 85       	ldd	r24, Z+10	; 0x0a
    2db4:	93 85       	ldd	r25, Z+11	; 0x0b
    2db6:	ef 81       	ldd	r30, Y+7	; 0x07
    2db8:	f8 85       	ldd	r31, Y+8	; 0x08
    2dba:	40 e0       	ldi	r20, 0x00	; 0
    2dbc:	50 e0       	ldi	r21, 0x00	; 0
    2dbe:	60 e0       	ldi	r22, 0x00	; 0
    2dc0:	70 e0       	ldi	r23, 0x00	; 0
    2dc2:	20 e0       	ldi	r18, 0x00	; 0
    2dc4:	00 e0       	ldi	r16, 0x00	; 0
    2dc6:	10 e0       	ldi	r17, 0x00	; 0
    2dc8:	7f 01       	movw	r14, r30
    2dca:	0e 94 10 23 	call	0x4620	; 0x4620 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    2dce:	eb 81       	ldd	r30, Y+3	; 0x03
    2dd0:	fc 81       	ldd	r31, Y+4	; 0x04
    2dd2:	13 86       	std	Z+11, r1	; 0x0b
    2dd4:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    2dd6:	81 e0       	ldi	r24, 0x01	; 1
    2dd8:	8a 83       	std	Y+2, r24	; 0x02
    2dda:	01 c0       	rjmp	.+2      	; 0x2dde <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    2ddc:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2dde:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2de0:	28 96       	adiw	r28, 0x08	; 8
    2de2:	0f b6       	in	r0, 0x3f	; 63
    2de4:	f8 94       	cli
    2de6:	de bf       	out	0x3e, r29	; 62
    2de8:	0f be       	out	0x3f, r0	; 63
    2dea:	cd bf       	out	0x3d, r28	; 61
    2dec:	cf 91       	pop	r28
    2dee:	df 91       	pop	r29
    2df0:	1f 91       	pop	r17
    2df2:	0f 91       	pop	r16
    2df4:	ff 90       	pop	r15
    2df6:	ef 90       	pop	r14
    2df8:	08 95       	ret

00002dfa <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    2dfa:	df 93       	push	r29
    2dfc:	cf 93       	push	r28
    2dfe:	cd b7       	in	r28, 0x3d	; 61
    2e00:	de b7       	in	r29, 0x3e	; 62
    2e02:	2e 97       	sbiw	r28, 0x0e	; 14
    2e04:	0f b6       	in	r0, 0x3f	; 63
    2e06:	f8 94       	cli
    2e08:	de bf       	out	0x3e, r29	; 62
    2e0a:	0f be       	out	0x3f, r0	; 63
    2e0c:	cd bf       	out	0x3d, r28	; 61
    2e0e:	9e 83       	std	Y+6, r25	; 0x06
    2e10:	8d 83       	std	Y+5, r24	; 0x05
    2e12:	78 87       	std	Y+8, r23	; 0x08
    2e14:	6f 83       	std	Y+7, r22	; 0x07
    2e16:	5a 87       	std	Y+10, r21	; 0x0a
    2e18:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    2e1a:	ed 81       	ldd	r30, Y+5	; 0x05
    2e1c:	fe 81       	ldd	r31, Y+6	; 0x06
    2e1e:	82 81       	ldd	r24, Z+2	; 0x02
    2e20:	93 81       	ldd	r25, Z+3	; 0x03
    2e22:	9c 83       	std	Y+4, r25	; 0x04
    2e24:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    2e26:	ed 81       	ldd	r30, Y+5	; 0x05
    2e28:	fe 81       	ldd	r31, Y+6	; 0x06
    2e2a:	24 81       	ldd	r18, Z+4	; 0x04
    2e2c:	35 81       	ldd	r19, Z+5	; 0x05
    2e2e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e30:	9c 81       	ldd	r25, Y+4	; 0x04
    2e32:	a9 01       	movw	r20, r18
    2e34:	48 1b       	sub	r20, r24
    2e36:	59 0b       	sbc	r21, r25
    2e38:	ca 01       	movw	r24, r20
    2e3a:	29 85       	ldd	r18, Y+9	; 0x09
    2e3c:	3a 85       	ldd	r19, Y+10	; 0x0a
    2e3e:	3e 87       	std	Y+14, r19	; 0x0e
    2e40:	2d 87       	std	Y+13, r18	; 0x0d
    2e42:	9c 87       	std	Y+12, r25	; 0x0c
    2e44:	8b 87       	std	Y+11, r24	; 0x0b
    2e46:	4b 85       	ldd	r20, Y+11	; 0x0b
    2e48:	5c 85       	ldd	r21, Y+12	; 0x0c
    2e4a:	8d 85       	ldd	r24, Y+13	; 0x0d
    2e4c:	9e 85       	ldd	r25, Y+14	; 0x0e
    2e4e:	84 17       	cp	r24, r20
    2e50:	95 07       	cpc	r25, r21
    2e52:	20 f4       	brcc	.+8      	; 0x2e5c <prvWriteBytesToBuffer+0x62>
    2e54:	2d 85       	ldd	r18, Y+13	; 0x0d
    2e56:	3e 85       	ldd	r19, Y+14	; 0x0e
    2e58:	3c 87       	std	Y+12, r19	; 0x0c
    2e5a:	2b 87       	std	Y+11, r18	; 0x0b
    2e5c:	4b 85       	ldd	r20, Y+11	; 0x0b
    2e5e:	5c 85       	ldd	r21, Y+12	; 0x0c
    2e60:	5a 83       	std	Y+2, r21	; 0x02
    2e62:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2e64:	ed 81       	ldd	r30, Y+5	; 0x05
    2e66:	fe 81       	ldd	r31, Y+6	; 0x06
    2e68:	24 85       	ldd	r18, Z+12	; 0x0c
    2e6a:	35 85       	ldd	r19, Z+13	; 0x0d
    2e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e6e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e70:	82 0f       	add	r24, r18
    2e72:	93 1f       	adc	r25, r19
    2e74:	2f 81       	ldd	r18, Y+7	; 0x07
    2e76:	38 85       	ldd	r19, Y+8	; 0x08
    2e78:	49 81       	ldd	r20, Y+1	; 0x01
    2e7a:	5a 81       	ldd	r21, Y+2	; 0x02
    2e7c:	b9 01       	movw	r22, r18
    2e7e:	0e 94 61 3c 	call	0x78c2	; 0x78c2 <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    2e82:	29 85       	ldd	r18, Y+9	; 0x09
    2e84:	3a 85       	ldd	r19, Y+10	; 0x0a
    2e86:	89 81       	ldd	r24, Y+1	; 0x01
    2e88:	9a 81       	ldd	r25, Y+2	; 0x02
    2e8a:	82 17       	cp	r24, r18
    2e8c:	93 07       	cpc	r25, r19
    2e8e:	b0 f4       	brcc	.+44     	; 0x2ebc <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2e90:	ed 81       	ldd	r30, Y+5	; 0x05
    2e92:	fe 81       	ldd	r31, Y+6	; 0x06
    2e94:	64 85       	ldd	r22, Z+12	; 0x0c
    2e96:	75 85       	ldd	r23, Z+13	; 0x0d
    2e98:	2f 81       	ldd	r18, Y+7	; 0x07
    2e9a:	38 85       	ldd	r19, Y+8	; 0x08
    2e9c:	89 81       	ldd	r24, Y+1	; 0x01
    2e9e:	9a 81       	ldd	r25, Y+2	; 0x02
    2ea0:	a9 01       	movw	r20, r18
    2ea2:	48 0f       	add	r20, r24
    2ea4:	59 1f       	adc	r21, r25
    2ea6:	29 85       	ldd	r18, Y+9	; 0x09
    2ea8:	3a 85       	ldd	r19, Y+10	; 0x0a
    2eaa:	89 81       	ldd	r24, Y+1	; 0x01
    2eac:	9a 81       	ldd	r25, Y+2	; 0x02
    2eae:	28 1b       	sub	r18, r24
    2eb0:	39 0b       	sbc	r19, r25
    2eb2:	cb 01       	movw	r24, r22
    2eb4:	ba 01       	movw	r22, r20
    2eb6:	a9 01       	movw	r20, r18
    2eb8:	0e 94 61 3c 	call	0x78c2	; 0x78c2 <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    2ebc:	2b 81       	ldd	r18, Y+3	; 0x03
    2ebe:	3c 81       	ldd	r19, Y+4	; 0x04
    2ec0:	89 85       	ldd	r24, Y+9	; 0x09
    2ec2:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ec4:	82 0f       	add	r24, r18
    2ec6:	93 1f       	adc	r25, r19
    2ec8:	9c 83       	std	Y+4, r25	; 0x04
    2eca:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    2ecc:	ed 81       	ldd	r30, Y+5	; 0x05
    2ece:	fe 81       	ldd	r31, Y+6	; 0x06
    2ed0:	24 81       	ldd	r18, Z+4	; 0x04
    2ed2:	35 81       	ldd	r19, Z+5	; 0x05
    2ed4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ed6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ed8:	82 17       	cp	r24, r18
    2eda:	93 07       	cpc	r25, r19
    2edc:	50 f0       	brcs	.+20     	; 0x2ef2 <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    2ede:	ed 81       	ldd	r30, Y+5	; 0x05
    2ee0:	fe 81       	ldd	r31, Y+6	; 0x06
    2ee2:	24 81       	ldd	r18, Z+4	; 0x04
    2ee4:	35 81       	ldd	r19, Z+5	; 0x05
    2ee6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ee8:	9c 81       	ldd	r25, Y+4	; 0x04
    2eea:	82 1b       	sub	r24, r18
    2eec:	93 0b       	sbc	r25, r19
    2eee:	9c 83       	std	Y+4, r25	; 0x04
    2ef0:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    2ef2:	ed 81       	ldd	r30, Y+5	; 0x05
    2ef4:	fe 81       	ldd	r31, Y+6	; 0x06
    2ef6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ef8:	9c 81       	ldd	r25, Y+4	; 0x04
    2efa:	93 83       	std	Z+3, r25	; 0x03
    2efc:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    2efe:	89 85       	ldd	r24, Y+9	; 0x09
    2f00:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    2f02:	2e 96       	adiw	r28, 0x0e	; 14
    2f04:	0f b6       	in	r0, 0x3f	; 63
    2f06:	f8 94       	cli
    2f08:	de bf       	out	0x3e, r29	; 62
    2f0a:	0f be       	out	0x3f, r0	; 63
    2f0c:	cd bf       	out	0x3d, r28	; 61
    2f0e:	cf 91       	pop	r28
    2f10:	df 91       	pop	r29
    2f12:	08 95       	ret

00002f14 <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    2f14:	df 93       	push	r29
    2f16:	cf 93       	push	r28
    2f18:	cd b7       	in	r28, 0x3d	; 61
    2f1a:	de b7       	in	r29, 0x3e	; 62
    2f1c:	66 97       	sbiw	r28, 0x16	; 22
    2f1e:	0f b6       	in	r0, 0x3f	; 63
    2f20:	f8 94       	cli
    2f22:	de bf       	out	0x3e, r29	; 62
    2f24:	0f be       	out	0x3f, r0	; 63
    2f26:	cd bf       	out	0x3d, r28	; 61
    2f28:	98 87       	std	Y+8, r25	; 0x08
    2f2a:	8f 83       	std	Y+7, r24	; 0x07
    2f2c:	7a 87       	std	Y+10, r23	; 0x0a
    2f2e:	69 87       	std	Y+9, r22	; 0x09
    2f30:	5c 87       	std	Y+12, r21	; 0x0c
    2f32:	4b 87       	std	Y+11, r20	; 0x0b
    2f34:	3e 87       	std	Y+14, r19	; 0x0e
    2f36:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    2f38:	2d 85       	ldd	r18, Y+13	; 0x0d
    2f3a:	3e 85       	ldd	r19, Y+14	; 0x0e
    2f3c:	3a 8b       	std	Y+18, r19	; 0x12
    2f3e:	29 8b       	std	Y+17, r18	; 0x11
    2f40:	4b 85       	ldd	r20, Y+11	; 0x0b
    2f42:	5c 85       	ldd	r21, Y+12	; 0x0c
    2f44:	58 8b       	std	Y+16, r21	; 0x10
    2f46:	4f 87       	std	Y+15, r20	; 0x0f
    2f48:	8f 85       	ldd	r24, Y+15	; 0x0f
    2f4a:	98 89       	ldd	r25, Y+16	; 0x10
    2f4c:	29 89       	ldd	r18, Y+17	; 0x11
    2f4e:	3a 89       	ldd	r19, Y+18	; 0x12
    2f50:	28 17       	cp	r18, r24
    2f52:	39 07       	cpc	r19, r25
    2f54:	20 f4       	brcc	.+8      	; 0x2f5e <prvReadBytesFromBuffer+0x4a>
    2f56:	49 89       	ldd	r20, Y+17	; 0x11
    2f58:	5a 89       	ldd	r21, Y+18	; 0x12
    2f5a:	58 8b       	std	Y+16, r21	; 0x10
    2f5c:	4f 87       	std	Y+15, r20	; 0x0f
    2f5e:	8f 85       	ldd	r24, Y+15	; 0x0f
    2f60:	98 89       	ldd	r25, Y+16	; 0x10
    2f62:	9e 83       	std	Y+6, r25	; 0x06
    2f64:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    2f66:	8d 81       	ldd	r24, Y+5	; 0x05
    2f68:	9e 81       	ldd	r25, Y+6	; 0x06
    2f6a:	00 97       	sbiw	r24, 0x00	; 0
    2f6c:	09 f4       	brne	.+2      	; 0x2f70 <prvReadBytesFromBuffer+0x5c>
    2f6e:	74 c0       	rjmp	.+232    	; 0x3058 <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    2f70:	ef 81       	ldd	r30, Y+7	; 0x07
    2f72:	f8 85       	ldd	r31, Y+8	; 0x08
    2f74:	80 81       	ld	r24, Z
    2f76:	91 81       	ldd	r25, Z+1	; 0x01
    2f78:	9a 83       	std	Y+2, r25	; 0x02
    2f7a:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    2f7c:	ef 81       	ldd	r30, Y+7	; 0x07
    2f7e:	f8 85       	ldd	r31, Y+8	; 0x08
    2f80:	24 81       	ldd	r18, Z+4	; 0x04
    2f82:	35 81       	ldd	r19, Z+5	; 0x05
    2f84:	89 81       	ldd	r24, Y+1	; 0x01
    2f86:	9a 81       	ldd	r25, Y+2	; 0x02
    2f88:	a9 01       	movw	r20, r18
    2f8a:	48 1b       	sub	r20, r24
    2f8c:	59 0b       	sbc	r21, r25
    2f8e:	ca 01       	movw	r24, r20
    2f90:	2d 81       	ldd	r18, Y+5	; 0x05
    2f92:	3e 81       	ldd	r19, Y+6	; 0x06
    2f94:	3e 8b       	std	Y+22, r19	; 0x16
    2f96:	2d 8b       	std	Y+21, r18	; 0x15
    2f98:	9c 8b       	std	Y+20, r25	; 0x14
    2f9a:	8b 8b       	std	Y+19, r24	; 0x13
    2f9c:	4b 89       	ldd	r20, Y+19	; 0x13
    2f9e:	5c 89       	ldd	r21, Y+20	; 0x14
    2fa0:	8d 89       	ldd	r24, Y+21	; 0x15
    2fa2:	9e 89       	ldd	r25, Y+22	; 0x16
    2fa4:	84 17       	cp	r24, r20
    2fa6:	95 07       	cpc	r25, r21
    2fa8:	20 f4       	brcc	.+8      	; 0x2fb2 <prvReadBytesFromBuffer+0x9e>
    2faa:	2d 89       	ldd	r18, Y+21	; 0x15
    2fac:	3e 89       	ldd	r19, Y+22	; 0x16
    2fae:	3c 8b       	std	Y+20, r19	; 0x14
    2fb0:	2b 8b       	std	Y+19, r18	; 0x13
    2fb2:	4b 89       	ldd	r20, Y+19	; 0x13
    2fb4:	5c 89       	ldd	r21, Y+20	; 0x14
    2fb6:	5c 83       	std	Y+4, r21	; 0x04
    2fb8:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2fba:	ef 81       	ldd	r30, Y+7	; 0x07
    2fbc:	f8 85       	ldd	r31, Y+8	; 0x08
    2fbe:	24 85       	ldd	r18, Z+12	; 0x0c
    2fc0:	35 85       	ldd	r19, Z+13	; 0x0d
    2fc2:	89 81       	ldd	r24, Y+1	; 0x01
    2fc4:	9a 81       	ldd	r25, Y+2	; 0x02
    2fc6:	a9 01       	movw	r20, r18
    2fc8:	48 0f       	add	r20, r24
    2fca:	59 1f       	adc	r21, r25
    2fcc:	89 85       	ldd	r24, Y+9	; 0x09
    2fce:	9a 85       	ldd	r25, Y+10	; 0x0a
    2fd0:	2b 81       	ldd	r18, Y+3	; 0x03
    2fd2:	3c 81       	ldd	r19, Y+4	; 0x04
    2fd4:	ba 01       	movw	r22, r20
    2fd6:	a9 01       	movw	r20, r18
    2fd8:	0e 94 61 3c 	call	0x78c2	; 0x78c2 <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    2fdc:	2d 81       	ldd	r18, Y+5	; 0x05
    2fde:	3e 81       	ldd	r19, Y+6	; 0x06
    2fe0:	8b 81       	ldd	r24, Y+3	; 0x03
    2fe2:	9c 81       	ldd	r25, Y+4	; 0x04
    2fe4:	82 17       	cp	r24, r18
    2fe6:	93 07       	cpc	r25, r19
    2fe8:	b0 f4       	brcc	.+44     	; 0x3016 <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2fea:	29 85       	ldd	r18, Y+9	; 0x09
    2fec:	3a 85       	ldd	r19, Y+10	; 0x0a
    2fee:	8b 81       	ldd	r24, Y+3	; 0x03
    2ff0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ff2:	b9 01       	movw	r22, r18
    2ff4:	68 0f       	add	r22, r24
    2ff6:	79 1f       	adc	r23, r25
    2ff8:	ef 81       	ldd	r30, Y+7	; 0x07
    2ffa:	f8 85       	ldd	r31, Y+8	; 0x08
    2ffc:	44 85       	ldd	r20, Z+12	; 0x0c
    2ffe:	55 85       	ldd	r21, Z+13	; 0x0d
    3000:	2d 81       	ldd	r18, Y+5	; 0x05
    3002:	3e 81       	ldd	r19, Y+6	; 0x06
    3004:	8b 81       	ldd	r24, Y+3	; 0x03
    3006:	9c 81       	ldd	r25, Y+4	; 0x04
    3008:	28 1b       	sub	r18, r24
    300a:	39 0b       	sbc	r19, r25
    300c:	cb 01       	movw	r24, r22
    300e:	ba 01       	movw	r22, r20
    3010:	a9 01       	movw	r20, r18
    3012:	0e 94 61 3c 	call	0x78c2	; 0x78c2 <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    3016:	29 81       	ldd	r18, Y+1	; 0x01
    3018:	3a 81       	ldd	r19, Y+2	; 0x02
    301a:	8d 81       	ldd	r24, Y+5	; 0x05
    301c:	9e 81       	ldd	r25, Y+6	; 0x06
    301e:	82 0f       	add	r24, r18
    3020:	93 1f       	adc	r25, r19
    3022:	9a 83       	std	Y+2, r25	; 0x02
    3024:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    3026:	ef 81       	ldd	r30, Y+7	; 0x07
    3028:	f8 85       	ldd	r31, Y+8	; 0x08
    302a:	24 81       	ldd	r18, Z+4	; 0x04
    302c:	35 81       	ldd	r19, Z+5	; 0x05
    302e:	89 81       	ldd	r24, Y+1	; 0x01
    3030:	9a 81       	ldd	r25, Y+2	; 0x02
    3032:	82 17       	cp	r24, r18
    3034:	93 07       	cpc	r25, r19
    3036:	50 f0       	brcs	.+20     	; 0x304c <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    3038:	ef 81       	ldd	r30, Y+7	; 0x07
    303a:	f8 85       	ldd	r31, Y+8	; 0x08
    303c:	24 81       	ldd	r18, Z+4	; 0x04
    303e:	35 81       	ldd	r19, Z+5	; 0x05
    3040:	89 81       	ldd	r24, Y+1	; 0x01
    3042:	9a 81       	ldd	r25, Y+2	; 0x02
    3044:	82 1b       	sub	r24, r18
    3046:	93 0b       	sbc	r25, r19
    3048:	9a 83       	std	Y+2, r25	; 0x02
    304a:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    304c:	ef 81       	ldd	r30, Y+7	; 0x07
    304e:	f8 85       	ldd	r31, Y+8	; 0x08
    3050:	89 81       	ldd	r24, Y+1	; 0x01
    3052:	9a 81       	ldd	r25, Y+2	; 0x02
    3054:	91 83       	std	Z+1, r25	; 0x01
    3056:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    3058:	8d 81       	ldd	r24, Y+5	; 0x05
    305a:	9e 81       	ldd	r25, Y+6	; 0x06
}
    305c:	66 96       	adiw	r28, 0x16	; 22
    305e:	0f b6       	in	r0, 0x3f	; 63
    3060:	f8 94       	cli
    3062:	de bf       	out	0x3e, r29	; 62
    3064:	0f be       	out	0x3f, r0	; 63
    3066:	cd bf       	out	0x3d, r28	; 61
    3068:	cf 91       	pop	r28
    306a:	df 91       	pop	r29
    306c:	08 95       	ret

0000306e <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    306e:	df 93       	push	r29
    3070:	cf 93       	push	r28
    3072:	00 d0       	rcall	.+0      	; 0x3074 <prvBytesInBuffer+0x6>
    3074:	00 d0       	rcall	.+0      	; 0x3076 <prvBytesInBuffer+0x8>
    3076:	cd b7       	in	r28, 0x3d	; 61
    3078:	de b7       	in	r29, 0x3e	; 62
    307a:	9c 83       	std	Y+4, r25	; 0x04
    307c:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    307e:	eb 81       	ldd	r30, Y+3	; 0x03
    3080:	fc 81       	ldd	r31, Y+4	; 0x04
    3082:	24 81       	ldd	r18, Z+4	; 0x04
    3084:	35 81       	ldd	r19, Z+5	; 0x05
    3086:	eb 81       	ldd	r30, Y+3	; 0x03
    3088:	fc 81       	ldd	r31, Y+4	; 0x04
    308a:	82 81       	ldd	r24, Z+2	; 0x02
    308c:	93 81       	ldd	r25, Z+3	; 0x03
    308e:	82 0f       	add	r24, r18
    3090:	93 1f       	adc	r25, r19
    3092:	9a 83       	std	Y+2, r25	; 0x02
    3094:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    3096:	eb 81       	ldd	r30, Y+3	; 0x03
    3098:	fc 81       	ldd	r31, Y+4	; 0x04
    309a:	20 81       	ld	r18, Z
    309c:	31 81       	ldd	r19, Z+1	; 0x01
    309e:	89 81       	ldd	r24, Y+1	; 0x01
    30a0:	9a 81       	ldd	r25, Y+2	; 0x02
    30a2:	82 1b       	sub	r24, r18
    30a4:	93 0b       	sbc	r25, r19
    30a6:	9a 83       	std	Y+2, r25	; 0x02
    30a8:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    30aa:	eb 81       	ldd	r30, Y+3	; 0x03
    30ac:	fc 81       	ldd	r31, Y+4	; 0x04
    30ae:	24 81       	ldd	r18, Z+4	; 0x04
    30b0:	35 81       	ldd	r19, Z+5	; 0x05
    30b2:	89 81       	ldd	r24, Y+1	; 0x01
    30b4:	9a 81       	ldd	r25, Y+2	; 0x02
    30b6:	82 17       	cp	r24, r18
    30b8:	93 07       	cpc	r25, r19
    30ba:	50 f0       	brcs	.+20     	; 0x30d0 <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    30bc:	eb 81       	ldd	r30, Y+3	; 0x03
    30be:	fc 81       	ldd	r31, Y+4	; 0x04
    30c0:	24 81       	ldd	r18, Z+4	; 0x04
    30c2:	35 81       	ldd	r19, Z+5	; 0x05
    30c4:	89 81       	ldd	r24, Y+1	; 0x01
    30c6:	9a 81       	ldd	r25, Y+2	; 0x02
    30c8:	82 1b       	sub	r24, r18
    30ca:	93 0b       	sbc	r25, r19
    30cc:	9a 83       	std	Y+2, r25	; 0x02
    30ce:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    30d0:	89 81       	ldd	r24, Y+1	; 0x01
    30d2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    30d4:	0f 90       	pop	r0
    30d6:	0f 90       	pop	r0
    30d8:	0f 90       	pop	r0
    30da:	0f 90       	pop	r0
    30dc:	cf 91       	pop	r28
    30de:	df 91       	pop	r29
    30e0:	08 95       	ret

000030e2 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    30e2:	0f 93       	push	r16
    30e4:	df 93       	push	r29
    30e6:	cf 93       	push	r28
    30e8:	cd b7       	in	r28, 0x3d	; 61
    30ea:	de b7       	in	r29, 0x3e	; 62
    30ec:	29 97       	sbiw	r28, 0x09	; 9
    30ee:	0f b6       	in	r0, 0x3f	; 63
    30f0:	f8 94       	cli
    30f2:	de bf       	out	0x3e, r29	; 62
    30f4:	0f be       	out	0x3f, r0	; 63
    30f6:	cd bf       	out	0x3d, r28	; 61
    30f8:	9a 83       	std	Y+2, r25	; 0x02
    30fa:	89 83       	std	Y+1, r24	; 0x01
    30fc:	7c 83       	std	Y+4, r23	; 0x04
    30fe:	6b 83       	std	Y+3, r22	; 0x03
    3100:	5e 83       	std	Y+6, r21	; 0x06
    3102:	4d 83       	std	Y+5, r20	; 0x05
    3104:	38 87       	std	Y+8, r19	; 0x08
    3106:	2f 83       	std	Y+7, r18	; 0x07
    3108:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    310a:	89 81       	ldd	r24, Y+1	; 0x01
    310c:	9a 81       	ldd	r25, Y+2	; 0x02
    310e:	60 e0       	ldi	r22, 0x00	; 0
    3110:	70 e0       	ldi	r23, 0x00	; 0
    3112:	4f e0       	ldi	r20, 0x0F	; 15
    3114:	50 e0       	ldi	r21, 0x00	; 0
    3116:	0e 94 6a 3c 	call	0x78d4	; 0x78d4 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    311a:	e9 81       	ldd	r30, Y+1	; 0x01
    311c:	fa 81       	ldd	r31, Y+2	; 0x02
    311e:	8b 81       	ldd	r24, Y+3	; 0x03
    3120:	9c 81       	ldd	r25, Y+4	; 0x04
    3122:	95 87       	std	Z+13, r25	; 0x0d
    3124:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    3126:	e9 81       	ldd	r30, Y+1	; 0x01
    3128:	fa 81       	ldd	r31, Y+2	; 0x02
    312a:	8d 81       	ldd	r24, Y+5	; 0x05
    312c:	9e 81       	ldd	r25, Y+6	; 0x06
    312e:	95 83       	std	Z+5, r25	; 0x05
    3130:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    3132:	e9 81       	ldd	r30, Y+1	; 0x01
    3134:	fa 81       	ldd	r31, Y+2	; 0x02
    3136:	8f 81       	ldd	r24, Y+7	; 0x07
    3138:	98 85       	ldd	r25, Y+8	; 0x08
    313a:	97 83       	std	Z+7, r25	; 0x07
    313c:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    313e:	e9 81       	ldd	r30, Y+1	; 0x01
    3140:	fa 81       	ldd	r31, Y+2	; 0x02
    3142:	89 85       	ldd	r24, Y+9	; 0x09
    3144:	86 87       	std	Z+14, r24	; 0x0e
}
    3146:	29 96       	adiw	r28, 0x09	; 9
    3148:	0f b6       	in	r0, 0x3f	; 63
    314a:	f8 94       	cli
    314c:	de bf       	out	0x3e, r29	; 62
    314e:	0f be       	out	0x3f, r0	; 63
    3150:	cd bf       	out	0x3d, r28	; 61
    3152:	cf 91       	pop	r28
    3154:	df 91       	pop	r29
    3156:	0f 91       	pop	r16
    3158:	08 95       	ret

0000315a <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    315a:	8f 92       	push	r8
    315c:	9f 92       	push	r9
    315e:	af 92       	push	r10
    3160:	bf 92       	push	r11
    3162:	cf 92       	push	r12
    3164:	df 92       	push	r13
    3166:	ef 92       	push	r14
    3168:	ff 92       	push	r15
    316a:	0f 93       	push	r16
    316c:	1f 93       	push	r17
    316e:	df 93       	push	r29
    3170:	cf 93       	push	r28
    3172:	cd b7       	in	r28, 0x3d	; 61
    3174:	de b7       	in	r29, 0x3e	; 62
    3176:	60 97       	sbiw	r28, 0x10	; 16
    3178:	0f b6       	in	r0, 0x3f	; 63
    317a:	f8 94       	cli
    317c:	de bf       	out	0x3e, r29	; 62
    317e:	0f be       	out	0x3f, r0	; 63
    3180:	cd bf       	out	0x3d, r28	; 61
    3182:	9f 83       	std	Y+7, r25	; 0x07
    3184:	8e 83       	std	Y+6, r24	; 0x06
    3186:	79 87       	std	Y+9, r23	; 0x09
    3188:	68 87       	std	Y+8, r22	; 0x08
    318a:	5b 87       	std	Y+11, r21	; 0x0b
    318c:	4a 87       	std	Y+10, r20	; 0x0a
    318e:	3d 87       	std	Y+13, r19	; 0x0d
    3190:	2c 87       	std	Y+12, r18	; 0x0c
    3192:	0e 87       	std	Y+14, r16	; 0x0e
    3194:	f8 8a       	std	Y+16, r15	; 0x10
    3196:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3198:	8a 85       	ldd	r24, Y+10	; 0x0a
    319a:	9b 85       	ldd	r25, Y+11	; 0x0b
    319c:	0e 94 64 05 	call	0xac8	; 0xac8 <pvPortMalloc>
    31a0:	9a 83       	std	Y+2, r25	; 0x02
    31a2:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    31a4:	89 81       	ldd	r24, Y+1	; 0x01
    31a6:	9a 81       	ldd	r25, Y+2	; 0x02
    31a8:	00 97       	sbiw	r24, 0x00	; 0
    31aa:	b1 f0       	breq	.+44     	; 0x31d8 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    31ac:	86 e2       	ldi	r24, 0x26	; 38
    31ae:	90 e0       	ldi	r25, 0x00	; 0
    31b0:	0e 94 64 05 	call	0xac8	; 0xac8 <pvPortMalloc>
    31b4:	9d 83       	std	Y+5, r25	; 0x05
    31b6:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    31b8:	8c 81       	ldd	r24, Y+4	; 0x04
    31ba:	9d 81       	ldd	r25, Y+5	; 0x05
    31bc:	00 97       	sbiw	r24, 0x00	; 0
    31be:	39 f0       	breq	.+14     	; 0x31ce <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    31c0:	ec 81       	ldd	r30, Y+4	; 0x04
    31c2:	fd 81       	ldd	r31, Y+5	; 0x05
    31c4:	89 81       	ldd	r24, Y+1	; 0x01
    31c6:	9a 81       	ldd	r25, Y+2	; 0x02
    31c8:	90 8f       	std	Z+24, r25	; 0x18
    31ca:	87 8b       	std	Z+23, r24	; 0x17
    31cc:	07 c0       	rjmp	.+14     	; 0x31dc <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    31ce:	89 81       	ldd	r24, Y+1	; 0x01
    31d0:	9a 81       	ldd	r25, Y+2	; 0x02
    31d2:	0e 94 ba 05 	call	0xb74	; 0xb74 <vPortFree>
    31d6:	02 c0       	rjmp	.+4      	; 0x31dc <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    31d8:	1d 82       	std	Y+5, r1	; 0x05
    31da:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    31dc:	8c 81       	ldd	r24, Y+4	; 0x04
    31de:	9d 81       	ldd	r25, Y+5	; 0x05
    31e0:	00 97       	sbiw	r24, 0x00	; 0
    31e2:	e9 f0       	breq	.+58     	; 0x321e <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    31e4:	8a 85       	ldd	r24, Y+10	; 0x0a
    31e6:	9b 85       	ldd	r25, Y+11	; 0x0b
    31e8:	9c 01       	movw	r18, r24
    31ea:	40 e0       	ldi	r20, 0x00	; 0
    31ec:	50 e0       	ldi	r21, 0x00	; 0
    31ee:	8e 81       	ldd	r24, Y+6	; 0x06
    31f0:	9f 81       	ldd	r25, Y+7	; 0x07
    31f2:	68 85       	ldd	r22, Y+8	; 0x08
    31f4:	79 85       	ldd	r23, Y+9	; 0x09
    31f6:	ec 85       	ldd	r30, Y+12	; 0x0c
    31f8:	fd 85       	ldd	r31, Y+13	; 0x0d
    31fa:	af 85       	ldd	r26, Y+15	; 0x0f
    31fc:	b8 89       	ldd	r27, Y+16	; 0x10
    31fe:	ac 80       	ldd	r10, Y+4	; 0x04
    3200:	bd 80       	ldd	r11, Y+5	; 0x05
    3202:	8f 01       	movw	r16, r30
    3204:	ee 84       	ldd	r14, Y+14	; 0x0e
    3206:	6d 01       	movw	r12, r26
    3208:	88 24       	eor	r8, r8
    320a:	99 24       	eor	r9, r9
    320c:	0e 94 25 19 	call	0x324a	; 0x324a <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    3210:	8c 81       	ldd	r24, Y+4	; 0x04
    3212:	9d 81       	ldd	r25, Y+5	; 0x05
    3214:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    3218:	81 e0       	ldi	r24, 0x01	; 1
    321a:	8b 83       	std	Y+3, r24	; 0x03
    321c:	02 c0       	rjmp	.+4      	; 0x3222 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    321e:	8f ef       	ldi	r24, 0xFF	; 255
    3220:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    3222:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    3224:	60 96       	adiw	r28, 0x10	; 16
    3226:	0f b6       	in	r0, 0x3f	; 63
    3228:	f8 94       	cli
    322a:	de bf       	out	0x3e, r29	; 62
    322c:	0f be       	out	0x3f, r0	; 63
    322e:	cd bf       	out	0x3d, r28	; 61
    3230:	cf 91       	pop	r28
    3232:	df 91       	pop	r29
    3234:	1f 91       	pop	r17
    3236:	0f 91       	pop	r16
    3238:	ff 90       	pop	r15
    323a:	ef 90       	pop	r14
    323c:	df 90       	pop	r13
    323e:	cf 90       	pop	r12
    3240:	bf 90       	pop	r11
    3242:	af 90       	pop	r10
    3244:	9f 90       	pop	r9
    3246:	8f 90       	pop	r8
    3248:	08 95       	ret

0000324a <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    324a:	8f 92       	push	r8
    324c:	9f 92       	push	r9
    324e:	af 92       	push	r10
    3250:	bf 92       	push	r11
    3252:	cf 92       	push	r12
    3254:	df 92       	push	r13
    3256:	ef 92       	push	r14
    3258:	0f 93       	push	r16
    325a:	1f 93       	push	r17
    325c:	df 93       	push	r29
    325e:	cf 93       	push	r28
    3260:	cd b7       	in	r28, 0x3d	; 61
    3262:	de b7       	in	r29, 0x3e	; 62
    3264:	64 97       	sbiw	r28, 0x14	; 20
    3266:	0f b6       	in	r0, 0x3f	; 63
    3268:	f8 94       	cli
    326a:	de bf       	out	0x3e, r29	; 62
    326c:	0f be       	out	0x3f, r0	; 63
    326e:	cd bf       	out	0x3d, r28	; 61
    3270:	9d 83       	std	Y+5, r25	; 0x05
    3272:	8c 83       	std	Y+4, r24	; 0x04
    3274:	7f 83       	std	Y+7, r23	; 0x07
    3276:	6e 83       	std	Y+6, r22	; 0x06
    3278:	28 87       	std	Y+8, r18	; 0x08
    327a:	39 87       	std	Y+9, r19	; 0x09
    327c:	4a 87       	std	Y+10, r20	; 0x0a
    327e:	5b 87       	std	Y+11, r21	; 0x0b
    3280:	1d 87       	std	Y+13, r17	; 0x0d
    3282:	0c 87       	std	Y+12, r16	; 0x0c
    3284:	ee 86       	std	Y+14, r14	; 0x0e
    3286:	d8 8a       	std	Y+16, r13	; 0x10
    3288:	cf 86       	std	Y+15, r12	; 0x0f
    328a:	ba 8a       	std	Y+18, r11	; 0x12
    328c:	a9 8a       	std	Y+17, r10	; 0x11
    328e:	9c 8a       	std	Y+20, r9	; 0x14
    3290:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3292:	e9 89       	ldd	r30, Y+17	; 0x11
    3294:	fa 89       	ldd	r31, Y+18	; 0x12
    3296:	27 89       	ldd	r18, Z+23	; 0x17
    3298:	30 8d       	ldd	r19, Z+24	; 0x18
    329a:	88 85       	ldd	r24, Y+8	; 0x08
    329c:	99 85       	ldd	r25, Y+9	; 0x09
    329e:	01 97       	sbiw	r24, 0x01	; 1
    32a0:	82 0f       	add	r24, r18
    32a2:	93 1f       	adc	r25, r19
    32a4:	9b 83       	std	Y+3, r25	; 0x03
    32a6:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    32a8:	8e 81       	ldd	r24, Y+6	; 0x06
    32aa:	9f 81       	ldd	r25, Y+7	; 0x07
    32ac:	00 97       	sbiw	r24, 0x00	; 0
    32ae:	51 f1       	breq	.+84     	; 0x3304 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    32b0:	19 82       	std	Y+1, r1	; 0x01
    32b2:	21 c0       	rjmp	.+66     	; 0x32f6 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    32b4:	89 81       	ldd	r24, Y+1	; 0x01
    32b6:	48 2f       	mov	r20, r24
    32b8:	50 e0       	ldi	r21, 0x00	; 0
    32ba:	89 81       	ldd	r24, Y+1	; 0x01
    32bc:	28 2f       	mov	r18, r24
    32be:	30 e0       	ldi	r19, 0x00	; 0
    32c0:	8e 81       	ldd	r24, Y+6	; 0x06
    32c2:	9f 81       	ldd	r25, Y+7	; 0x07
    32c4:	fc 01       	movw	r30, r24
    32c6:	e2 0f       	add	r30, r18
    32c8:	f3 1f       	adc	r31, r19
    32ca:	20 81       	ld	r18, Z
    32cc:	89 89       	ldd	r24, Y+17	; 0x11
    32ce:	9a 89       	ldd	r25, Y+18	; 0x12
    32d0:	84 0f       	add	r24, r20
    32d2:	95 1f       	adc	r25, r21
    32d4:	fc 01       	movw	r30, r24
    32d6:	79 96       	adiw	r30, 0x19	; 25
    32d8:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    32da:	89 81       	ldd	r24, Y+1	; 0x01
    32dc:	28 2f       	mov	r18, r24
    32de:	30 e0       	ldi	r19, 0x00	; 0
    32e0:	8e 81       	ldd	r24, Y+6	; 0x06
    32e2:	9f 81       	ldd	r25, Y+7	; 0x07
    32e4:	fc 01       	movw	r30, r24
    32e6:	e2 0f       	add	r30, r18
    32e8:	f3 1f       	adc	r31, r19
    32ea:	80 81       	ld	r24, Z
    32ec:	88 23       	and	r24, r24
    32ee:	31 f0       	breq	.+12     	; 0x32fc <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    32f0:	89 81       	ldd	r24, Y+1	; 0x01
    32f2:	8f 5f       	subi	r24, 0xFF	; 255
    32f4:	89 83       	std	Y+1, r24	; 0x01
    32f6:	89 81       	ldd	r24, Y+1	; 0x01
    32f8:	88 30       	cpi	r24, 0x08	; 8
    32fa:	e0 f2       	brcs	.-72     	; 0x32b4 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    32fc:	e9 89       	ldd	r30, Y+17	; 0x11
    32fe:	fa 89       	ldd	r31, Y+18	; 0x12
    3300:	10 a2       	std	Z+32, r1	; 0x20
    3302:	03 c0       	rjmp	.+6      	; 0x330a <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3304:	e9 89       	ldd	r30, Y+17	; 0x11
    3306:	fa 89       	ldd	r31, Y+18	; 0x12
    3308:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    330a:	8e 85       	ldd	r24, Y+14	; 0x0e
    330c:	84 30       	cpi	r24, 0x04	; 4
    330e:	10 f0       	brcs	.+4      	; 0x3314 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3310:	83 e0       	ldi	r24, 0x03	; 3
    3312:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    3314:	e9 89       	ldd	r30, Y+17	; 0x11
    3316:	fa 89       	ldd	r31, Y+18	; 0x12
    3318:	8e 85       	ldd	r24, Y+14	; 0x0e
    331a:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    331c:	89 89       	ldd	r24, Y+17	; 0x11
    331e:	9a 89       	ldd	r25, Y+18	; 0x12
    3320:	02 96       	adiw	r24, 0x02	; 2
    3322:	0e 94 0a 06 	call	0xc14	; 0xc14 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3326:	89 89       	ldd	r24, Y+17	; 0x11
    3328:	9a 89       	ldd	r25, Y+18	; 0x12
    332a:	0c 96       	adiw	r24, 0x0c	; 12
    332c:	0e 94 0a 06 	call	0xc14	; 0xc14 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3330:	e9 89       	ldd	r30, Y+17	; 0x11
    3332:	fa 89       	ldd	r31, Y+18	; 0x12
    3334:	89 89       	ldd	r24, Y+17	; 0x11
    3336:	9a 89       	ldd	r25, Y+18	; 0x12
    3338:	91 87       	std	Z+9, r25	; 0x09
    333a:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    333c:	8e 85       	ldd	r24, Y+14	; 0x0e
    333e:	28 2f       	mov	r18, r24
    3340:	30 e0       	ldi	r19, 0x00	; 0
    3342:	84 e0       	ldi	r24, 0x04	; 4
    3344:	90 e0       	ldi	r25, 0x00	; 0
    3346:	82 1b       	sub	r24, r18
    3348:	93 0b       	sbc	r25, r19
    334a:	e9 89       	ldd	r30, Y+17	; 0x11
    334c:	fa 89       	ldd	r31, Y+18	; 0x12
    334e:	95 87       	std	Z+13, r25	; 0x0d
    3350:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3352:	e9 89       	ldd	r30, Y+17	; 0x11
    3354:	fa 89       	ldd	r31, Y+18	; 0x12
    3356:	89 89       	ldd	r24, Y+17	; 0x11
    3358:	9a 89       	ldd	r25, Y+18	; 0x12
    335a:	93 8b       	std	Z+19, r25	; 0x13
    335c:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    335e:	e9 89       	ldd	r30, Y+17	; 0x11
    3360:	fa 89       	ldd	r31, Y+18	; 0x12
    3362:	11 a2       	std	Z+33, r1	; 0x21
    3364:	12 a2       	std	Z+34, r1	; 0x22
    3366:	13 a2       	std	Z+35, r1	; 0x23
    3368:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    336a:	e9 89       	ldd	r30, Y+17	; 0x11
    336c:	fa 89       	ldd	r31, Y+18	; 0x12
    336e:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3370:	8a 81       	ldd	r24, Y+2	; 0x02
    3372:	9b 81       	ldd	r25, Y+3	; 0x03
    3374:	2c 81       	ldd	r18, Y+4	; 0x04
    3376:	3d 81       	ldd	r19, Y+5	; 0x05
    3378:	4c 85       	ldd	r20, Y+12	; 0x0c
    337a:	5d 85       	ldd	r21, Y+13	; 0x0d
    337c:	b9 01       	movw	r22, r18
    337e:	0e 94 16 07 	call	0xe2c	; 0xe2c <pxPortInitialiseStack>
    3382:	e9 89       	ldd	r30, Y+17	; 0x11
    3384:	fa 89       	ldd	r31, Y+18	; 0x12
    3386:	91 83       	std	Z+1, r25	; 0x01
    3388:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    338a:	8f 85       	ldd	r24, Y+15	; 0x0f
    338c:	98 89       	ldd	r25, Y+16	; 0x10
    338e:	00 97       	sbiw	r24, 0x00	; 0
    3390:	31 f0       	breq	.+12     	; 0x339e <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3392:	ef 85       	ldd	r30, Y+15	; 0x0f
    3394:	f8 89       	ldd	r31, Y+16	; 0x10
    3396:	89 89       	ldd	r24, Y+17	; 0x11
    3398:	9a 89       	ldd	r25, Y+18	; 0x12
    339a:	91 83       	std	Z+1, r25	; 0x01
    339c:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    339e:	64 96       	adiw	r28, 0x14	; 20
    33a0:	0f b6       	in	r0, 0x3f	; 63
    33a2:	f8 94       	cli
    33a4:	de bf       	out	0x3e, r29	; 62
    33a6:	0f be       	out	0x3f, r0	; 63
    33a8:	cd bf       	out	0x3d, r28	; 61
    33aa:	cf 91       	pop	r28
    33ac:	df 91       	pop	r29
    33ae:	1f 91       	pop	r17
    33b0:	0f 91       	pop	r16
    33b2:	ef 90       	pop	r14
    33b4:	df 90       	pop	r13
    33b6:	cf 90       	pop	r12
    33b8:	bf 90       	pop	r11
    33ba:	af 90       	pop	r10
    33bc:	9f 90       	pop	r9
    33be:	8f 90       	pop	r8
    33c0:	08 95       	ret

000033c2 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    33c2:	df 93       	push	r29
    33c4:	cf 93       	push	r28
    33c6:	00 d0       	rcall	.+0      	; 0x33c8 <prvAddNewTaskToReadyList+0x6>
    33c8:	00 d0       	rcall	.+0      	; 0x33ca <prvAddNewTaskToReadyList+0x8>
    33ca:	cd b7       	in	r28, 0x3d	; 61
    33cc:	de b7       	in	r29, 0x3e	; 62
    33ce:	9a 83       	std	Y+2, r25	; 0x02
    33d0:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    33d2:	0f b6       	in	r0, 0x3f	; 63
    33d4:	f8 94       	cli
    33d6:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    33d8:	80 91 56 07 	lds	r24, 0x0756
    33dc:	8f 5f       	subi	r24, 0xFF	; 255
    33de:	80 93 56 07 	sts	0x0756, r24
		if( pxCurrentTCB == NULL )
    33e2:	80 91 54 07 	lds	r24, 0x0754
    33e6:	90 91 55 07 	lds	r25, 0x0755
    33ea:	00 97       	sbiw	r24, 0x00	; 0
    33ec:	69 f4       	brne	.+26     	; 0x3408 <prvAddNewTaskToReadyList+0x46>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    33ee:	89 81       	ldd	r24, Y+1	; 0x01
    33f0:	9a 81       	ldd	r25, Y+2	; 0x02
    33f2:	90 93 55 07 	sts	0x0755, r25
    33f6:	80 93 54 07 	sts	0x0754, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    33fa:	80 91 56 07 	lds	r24, 0x0756
    33fe:	81 30       	cpi	r24, 0x01	; 1
    3400:	b9 f4       	brne	.+46     	; 0x3430 <prvAddNewTaskToReadyList+0x6e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    3402:	0e 94 80 20 	call	0x4100	; 0x4100 <prvInitialiseTaskLists>
    3406:	14 c0       	rjmp	.+40     	; 0x3430 <prvAddNewTaskToReadyList+0x6e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    3408:	80 91 5a 07 	lds	r24, 0x075A
    340c:	88 23       	and	r24, r24
    340e:	81 f4       	brne	.+32     	; 0x3430 <prvAddNewTaskToReadyList+0x6e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3410:	e0 91 54 07 	lds	r30, 0x0754
    3414:	f0 91 55 07 	lds	r31, 0x0755
    3418:	96 89       	ldd	r25, Z+22	; 0x16
    341a:	e9 81       	ldd	r30, Y+1	; 0x01
    341c:	fa 81       	ldd	r31, Y+2	; 0x02
    341e:	86 89       	ldd	r24, Z+22	; 0x16
    3420:	89 17       	cp	r24, r25
    3422:	30 f0       	brcs	.+12     	; 0x3430 <prvAddNewTaskToReadyList+0x6e>
				{
					pxCurrentTCB = pxNewTCB;
    3424:	89 81       	ldd	r24, Y+1	; 0x01
    3426:	9a 81       	ldd	r25, Y+2	; 0x02
    3428:	90 93 55 07 	sts	0x0755, r25
    342c:	80 93 54 07 	sts	0x0754, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    3430:	80 91 5e 07 	lds	r24, 0x075E
    3434:	8f 5f       	subi	r24, 0xFF	; 255
    3436:	80 93 5e 07 	sts	0x075E, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    343a:	e9 81       	ldd	r30, Y+1	; 0x01
    343c:	fa 81       	ldd	r31, Y+2	; 0x02
    343e:	96 89       	ldd	r25, Z+22	; 0x16
    3440:	80 91 59 07 	lds	r24, 0x0759
    3444:	89 17       	cp	r24, r25
    3446:	28 f4       	brcc	.+10     	; 0x3452 <prvAddNewTaskToReadyList+0x90>
    3448:	e9 81       	ldd	r30, Y+1	; 0x01
    344a:	fa 81       	ldd	r31, Y+2	; 0x02
    344c:	86 89       	ldd	r24, Z+22	; 0x16
    344e:	80 93 59 07 	sts	0x0759, r24
    3452:	e9 81       	ldd	r30, Y+1	; 0x01
    3454:	fa 81       	ldd	r31, Y+2	; 0x02
    3456:	86 89       	ldd	r24, Z+22	; 0x16
    3458:	28 2f       	mov	r18, r24
    345a:	30 e0       	ldi	r19, 0x00	; 0
    345c:	c9 01       	movw	r24, r18
    345e:	88 0f       	add	r24, r24
    3460:	99 1f       	adc	r25, r25
    3462:	88 0f       	add	r24, r24
    3464:	99 1f       	adc	r25, r25
    3466:	88 0f       	add	r24, r24
    3468:	99 1f       	adc	r25, r25
    346a:	82 0f       	add	r24, r18
    346c:	93 1f       	adc	r25, r19
    346e:	ac 01       	movw	r20, r24
    3470:	4c 59       	subi	r20, 0x9C	; 156
    3472:	58 4f       	sbci	r21, 0xF8	; 248
    3474:	89 81       	ldd	r24, Y+1	; 0x01
    3476:	9a 81       	ldd	r25, Y+2	; 0x02
    3478:	9c 01       	movw	r18, r24
    347a:	2e 5f       	subi	r18, 0xFE	; 254
    347c:	3f 4f       	sbci	r19, 0xFF	; 255
    347e:	ca 01       	movw	r24, r20
    3480:	b9 01       	movw	r22, r18
    3482:	0e 94 1a 06 	call	0xc34	; 0xc34 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    3486:	0f 90       	pop	r0
    3488:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    348a:	80 91 5a 07 	lds	r24, 0x075A
    348e:	88 23       	and	r24, r24
    3490:	21 f0       	breq	.+8      	; 0x349a <prvAddNewTaskToReadyList+0xd8>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    3492:	80 91 54 07 	lds	r24, 0x0754
    3496:	90 91 55 07 	lds	r25, 0x0755
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    349a:	0f 90       	pop	r0
    349c:	0f 90       	pop	r0
    349e:	0f 90       	pop	r0
    34a0:	0f 90       	pop	r0
    34a2:	cf 91       	pop	r28
    34a4:	df 91       	pop	r29
    34a6:	08 95       	ret

000034a8 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    34a8:	df 93       	push	r29
    34aa:	cf 93       	push	r28
    34ac:	cd b7       	in	r28, 0x3d	; 61
    34ae:	de b7       	in	r29, 0x3e	; 62
    34b0:	2a 97       	sbiw	r28, 0x0a	; 10
    34b2:	0f b6       	in	r0, 0x3f	; 63
    34b4:	f8 94       	cli
    34b6:	de bf       	out	0x3e, r29	; 62
    34b8:	0f be       	out	0x3f, r0	; 63
    34ba:	cd bf       	out	0x3d, r28	; 61
    34bc:	98 87       	std	Y+8, r25	; 0x08
    34be:	8f 83       	std	Y+7, r24	; 0x07
    34c0:	7a 87       	std	Y+10, r23	; 0x0a
    34c2:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    34c4:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    34c6:	0e 94 8e 1c 	call	0x391c	; 0x391c <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    34ca:	80 91 57 07 	lds	r24, 0x0757
    34ce:	90 91 58 07 	lds	r25, 0x0758
    34d2:	9a 83       	std	Y+2, r25	; 0x02
    34d4:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    34d6:	ef 81       	ldd	r30, Y+7	; 0x07
    34d8:	f8 85       	ldd	r31, Y+8	; 0x08
    34da:	20 81       	ld	r18, Z
    34dc:	31 81       	ldd	r19, Z+1	; 0x01
    34de:	89 85       	ldd	r24, Y+9	; 0x09
    34e0:	9a 85       	ldd	r25, Y+10	; 0x0a
    34e2:	82 0f       	add	r24, r18
    34e4:	93 1f       	adc	r25, r19
    34e6:	9e 83       	std	Y+6, r25	; 0x06
    34e8:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    34ea:	ef 81       	ldd	r30, Y+7	; 0x07
    34ec:	f8 85       	ldd	r31, Y+8	; 0x08
    34ee:	20 81       	ld	r18, Z
    34f0:	31 81       	ldd	r19, Z+1	; 0x01
    34f2:	89 81       	ldd	r24, Y+1	; 0x01
    34f4:	9a 81       	ldd	r25, Y+2	; 0x02
    34f6:	82 17       	cp	r24, r18
    34f8:	93 07       	cpc	r25, r19
    34fa:	98 f4       	brcc	.+38     	; 0x3522 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    34fc:	ef 81       	ldd	r30, Y+7	; 0x07
    34fe:	f8 85       	ldd	r31, Y+8	; 0x08
    3500:	20 81       	ld	r18, Z
    3502:	31 81       	ldd	r19, Z+1	; 0x01
    3504:	8d 81       	ldd	r24, Y+5	; 0x05
    3506:	9e 81       	ldd	r25, Y+6	; 0x06
    3508:	82 17       	cp	r24, r18
    350a:	93 07       	cpc	r25, r19
    350c:	e0 f4       	brcc	.+56     	; 0x3546 <vTaskDelayUntil+0x9e>
    350e:	2d 81       	ldd	r18, Y+5	; 0x05
    3510:	3e 81       	ldd	r19, Y+6	; 0x06
    3512:	89 81       	ldd	r24, Y+1	; 0x01
    3514:	9a 81       	ldd	r25, Y+2	; 0x02
    3516:	82 17       	cp	r24, r18
    3518:	93 07       	cpc	r25, r19
    351a:	a8 f4       	brcc	.+42     	; 0x3546 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    351c:	81 e0       	ldi	r24, 0x01	; 1
    351e:	8b 83       	std	Y+3, r24	; 0x03
    3520:	12 c0       	rjmp	.+36     	; 0x3546 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    3522:	ef 81       	ldd	r30, Y+7	; 0x07
    3524:	f8 85       	ldd	r31, Y+8	; 0x08
    3526:	20 81       	ld	r18, Z
    3528:	31 81       	ldd	r19, Z+1	; 0x01
    352a:	8d 81       	ldd	r24, Y+5	; 0x05
    352c:	9e 81       	ldd	r25, Y+6	; 0x06
    352e:	82 17       	cp	r24, r18
    3530:	93 07       	cpc	r25, r19
    3532:	38 f0       	brcs	.+14     	; 0x3542 <vTaskDelayUntil+0x9a>
    3534:	2d 81       	ldd	r18, Y+5	; 0x05
    3536:	3e 81       	ldd	r19, Y+6	; 0x06
    3538:	89 81       	ldd	r24, Y+1	; 0x01
    353a:	9a 81       	ldd	r25, Y+2	; 0x02
    353c:	82 17       	cp	r24, r18
    353e:	93 07       	cpc	r25, r19
    3540:	10 f4       	brcc	.+4      	; 0x3546 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3542:	81 e0       	ldi	r24, 0x01	; 1
    3544:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    3546:	ef 81       	ldd	r30, Y+7	; 0x07
    3548:	f8 85       	ldd	r31, Y+8	; 0x08
    354a:	8d 81       	ldd	r24, Y+5	; 0x05
    354c:	9e 81       	ldd	r25, Y+6	; 0x06
    354e:	91 83       	std	Z+1, r25	; 0x01
    3550:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    3552:	8b 81       	ldd	r24, Y+3	; 0x03
    3554:	88 23       	and	r24, r24
    3556:	49 f0       	breq	.+18     	; 0x356a <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    3558:	8d 81       	ldd	r24, Y+5	; 0x05
    355a:	9e 81       	ldd	r25, Y+6	; 0x06
    355c:	29 81       	ldd	r18, Y+1	; 0x01
    355e:	3a 81       	ldd	r19, Y+2	; 0x02
    3560:	82 1b       	sub	r24, r18
    3562:	93 0b       	sbc	r25, r19
    3564:	60 e0       	ldi	r22, 0x00	; 0
    3566:	0e 94 c8 24 	call	0x4990	; 0x4990 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    356a:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>
    356e:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3570:	8c 81       	ldd	r24, Y+4	; 0x04
    3572:	88 23       	and	r24, r24
    3574:	11 f4       	brne	.+4      	; 0x357a <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    3576:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    357a:	2a 96       	adiw	r28, 0x0a	; 10
    357c:	0f b6       	in	r0, 0x3f	; 63
    357e:	f8 94       	cli
    3580:	de bf       	out	0x3e, r29	; 62
    3582:	0f be       	out	0x3f, r0	; 63
    3584:	cd bf       	out	0x3d, r28	; 61
    3586:	cf 91       	pop	r28
    3588:	df 91       	pop	r29
    358a:	08 95       	ret

0000358c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    358c:	df 93       	push	r29
    358e:	cf 93       	push	r28
    3590:	00 d0       	rcall	.+0      	; 0x3592 <vTaskDelay+0x6>
    3592:	0f 92       	push	r0
    3594:	cd b7       	in	r28, 0x3d	; 61
    3596:	de b7       	in	r29, 0x3e	; 62
    3598:	9b 83       	std	Y+3, r25	; 0x03
    359a:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    359c:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    359e:	8a 81       	ldd	r24, Y+2	; 0x02
    35a0:	9b 81       	ldd	r25, Y+3	; 0x03
    35a2:	00 97       	sbiw	r24, 0x00	; 0
    35a4:	51 f0       	breq	.+20     	; 0x35ba <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    35a6:	0e 94 8e 1c 	call	0x391c	; 0x391c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    35aa:	8a 81       	ldd	r24, Y+2	; 0x02
    35ac:	9b 81       	ldd	r25, Y+3	; 0x03
    35ae:	60 e0       	ldi	r22, 0x00	; 0
    35b0:	0e 94 c8 24 	call	0x4990	; 0x4990 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    35b4:	0e 94 9a 1c 	call	0x3934	; 0x3934 <xTaskResumeAll>
    35b8:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    35ba:	89 81       	ldd	r24, Y+1	; 0x01
    35bc:	88 23       	and	r24, r24
    35be:	11 f4       	brne	.+4      	; 0x35c4 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    35c0:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    35c4:	0f 90       	pop	r0
    35c6:	0f 90       	pop	r0
    35c8:	0f 90       	pop	r0
    35ca:	cf 91       	pop	r28
    35cc:	df 91       	pop	r29
    35ce:	08 95       	ret

000035d0 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    35d0:	df 93       	push	r29
    35d2:	cf 93       	push	r28
    35d4:	00 d0       	rcall	.+0      	; 0x35d6 <vTaskSuspend+0x6>
    35d6:	00 d0       	rcall	.+0      	; 0x35d8 <vTaskSuspend+0x8>
    35d8:	00 d0       	rcall	.+0      	; 0x35da <vTaskSuspend+0xa>
    35da:	cd b7       	in	r28, 0x3d	; 61
    35dc:	de b7       	in	r29, 0x3e	; 62
    35de:	9c 83       	std	Y+4, r25	; 0x04
    35e0:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    35e2:	0f b6       	in	r0, 0x3f	; 63
    35e4:	f8 94       	cli
    35e6:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    35e8:	8b 81       	ldd	r24, Y+3	; 0x03
    35ea:	9c 81       	ldd	r25, Y+4	; 0x04
    35ec:	00 97       	sbiw	r24, 0x00	; 0
    35ee:	39 f4       	brne	.+14     	; 0x35fe <vTaskSuspend+0x2e>
    35f0:	80 91 54 07 	lds	r24, 0x0754
    35f4:	90 91 55 07 	lds	r25, 0x0755
    35f8:	9e 83       	std	Y+6, r25	; 0x06
    35fa:	8d 83       	std	Y+5, r24	; 0x05
    35fc:	04 c0       	rjmp	.+8      	; 0x3606 <vTaskSuspend+0x36>
    35fe:	8b 81       	ldd	r24, Y+3	; 0x03
    3600:	9c 81       	ldd	r25, Y+4	; 0x04
    3602:	9e 83       	std	Y+6, r25	; 0x06
    3604:	8d 83       	std	Y+5, r24	; 0x05
    3606:	8d 81       	ldd	r24, Y+5	; 0x05
    3608:	9e 81       	ldd	r25, Y+6	; 0x06
    360a:	9a 83       	std	Y+2, r25	; 0x02
    360c:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    360e:	89 81       	ldd	r24, Y+1	; 0x01
    3610:	9a 81       	ldd	r25, Y+2	; 0x02
    3612:	02 96       	adiw	r24, 0x02	; 2
    3614:	0e 94 ca 06 	call	0xd94	; 0xd94 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3618:	e9 81       	ldd	r30, Y+1	; 0x01
    361a:	fa 81       	ldd	r31, Y+2	; 0x02
    361c:	84 89       	ldd	r24, Z+20	; 0x14
    361e:	95 89       	ldd	r25, Z+21	; 0x15
    3620:	00 97       	sbiw	r24, 0x00	; 0
    3622:	29 f0       	breq	.+10     	; 0x362e <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3624:	89 81       	ldd	r24, Y+1	; 0x01
    3626:	9a 81       	ldd	r25, Y+2	; 0x02
    3628:	0c 96       	adiw	r24, 0x0c	; 12
    362a:	0e 94 ca 06 	call	0xd94	; 0xd94 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    362e:	89 81       	ldd	r24, Y+1	; 0x01
    3630:	9a 81       	ldd	r25, Y+2	; 0x02
    3632:	9c 01       	movw	r18, r24
    3634:	2e 5f       	subi	r18, 0xFE	; 254
    3636:	3f 4f       	sbci	r19, 0xFF	; 255
    3638:	87 ea       	ldi	r24, 0xA7	; 167
    363a:	97 e0       	ldi	r25, 0x07	; 7
    363c:	b9 01       	movw	r22, r18
    363e:	0e 94 1a 06 	call	0xc34	; 0xc34 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    3642:	e9 81       	ldd	r30, Y+1	; 0x01
    3644:	fa 81       	ldd	r31, Y+2	; 0x02
    3646:	85 a1       	ldd	r24, Z+37	; 0x25
    3648:	81 30       	cpi	r24, 0x01	; 1
    364a:	19 f4       	brne	.+6      	; 0x3652 <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    364c:	e9 81       	ldd	r30, Y+1	; 0x01
    364e:	fa 81       	ldd	r31, Y+2	; 0x02
    3650:	15 a2       	std	Z+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    3652:	0f 90       	pop	r0
    3654:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    3656:	80 91 5a 07 	lds	r24, 0x075A
    365a:	88 23       	and	r24, r24
    365c:	39 f0       	breq	.+14     	; 0x366c <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    365e:	0f b6       	in	r0, 0x3f	; 63
    3660:	f8 94       	cli
    3662:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    3664:	0e 94 c4 20 	call	0x4188	; 0x4188 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    3668:	0f 90       	pop	r0
    366a:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    366c:	20 91 54 07 	lds	r18, 0x0754
    3670:	30 91 55 07 	lds	r19, 0x0755
    3674:	89 81       	ldd	r24, Y+1	; 0x01
    3676:	9a 81       	ldd	r25, Y+2	; 0x02
    3678:	82 17       	cp	r24, r18
    367a:	93 07       	cpc	r25, r19
    367c:	a1 f4       	brne	.+40     	; 0x36a6 <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    367e:	80 91 5a 07 	lds	r24, 0x075A
    3682:	88 23       	and	r24, r24
    3684:	19 f0       	breq	.+6      	; 0x368c <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3686:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vPortYield>
    368a:	0d c0       	rjmp	.+26     	; 0x36a6 <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    368c:	90 91 a7 07 	lds	r25, 0x07A7
    3690:	80 91 56 07 	lds	r24, 0x0756
    3694:	98 17       	cp	r25, r24
    3696:	29 f4       	brne	.+10     	; 0x36a2 <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    3698:	10 92 55 07 	sts	0x0755, r1
    369c:	10 92 54 07 	sts	0x0754, r1
    36a0:	02 c0       	rjmp	.+4      	; 0x36a6 <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    36a2:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    36a6:	26 96       	adiw	r28, 0x06	; 6
    36a8:	0f b6       	in	r0, 0x3f	; 63
    36aa:	f8 94       	cli
    36ac:	de bf       	out	0x3e, r29	; 62
    36ae:	0f be       	out	0x3f, r0	; 63
    36b0:	cd bf       	out	0x3d, r28	; 61
    36b2:	cf 91       	pop	r28
    36b4:	df 91       	pop	r29
    36b6:	08 95       	ret

000036b8 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    36b8:	df 93       	push	r29
    36ba:	cf 93       	push	r28
    36bc:	00 d0       	rcall	.+0      	; 0x36be <prvTaskIsTaskSuspended+0x6>
    36be:	00 d0       	rcall	.+0      	; 0x36c0 <prvTaskIsTaskSuspended+0x8>
    36c0:	0f 92       	push	r0
    36c2:	cd b7       	in	r28, 0x3d	; 61
    36c4:	de b7       	in	r29, 0x3e	; 62
    36c6:	9d 83       	std	Y+5, r25	; 0x05
    36c8:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    36ca:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    36cc:	8c 81       	ldd	r24, Y+4	; 0x04
    36ce:	9d 81       	ldd	r25, Y+5	; 0x05
    36d0:	9a 83       	std	Y+2, r25	; 0x02
    36d2:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    36d4:	e9 81       	ldd	r30, Y+1	; 0x01
    36d6:	fa 81       	ldd	r31, Y+2	; 0x02
    36d8:	82 85       	ldd	r24, Z+10	; 0x0a
    36da:	93 85       	ldd	r25, Z+11	; 0x0b
    36dc:	27 e0       	ldi	r18, 0x07	; 7
    36de:	87 3a       	cpi	r24, 0xA7	; 167
    36e0:	92 07       	cpc	r25, r18
    36e2:	81 f4       	brne	.+32     	; 0x3704 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    36e4:	e9 81       	ldd	r30, Y+1	; 0x01
    36e6:	fa 81       	ldd	r31, Y+2	; 0x02
    36e8:	84 89       	ldd	r24, Z+20	; 0x14
    36ea:	95 89       	ldd	r25, Z+21	; 0x15
    36ec:	27 e0       	ldi	r18, 0x07	; 7
    36ee:	8e 39       	cpi	r24, 0x9E	; 158
    36f0:	92 07       	cpc	r25, r18
    36f2:	41 f0       	breq	.+16     	; 0x3704 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    36f4:	e9 81       	ldd	r30, Y+1	; 0x01
    36f6:	fa 81       	ldd	r31, Y+2	; 0x02
    36f8:	84 89       	ldd	r24, Z+20	; 0x14
    36fa:	95 89       	ldd	r25, Z+21	; 0x15
    36fc:	00 97       	sbiw	r24, 0x00	; 0
    36fe:	11 f4       	brne	.+4      	; 0x3704 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    3700:	81 e0       	ldi	r24, 0x01	; 1
    3702:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    3704:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    3706:	0f 90       	pop	r0
    3708:	0f 90       	pop	r0
    370a:	0f 90       	pop	r0
    370c:	0f 90       	pop	r0
    370e:	0f 90       	pop	r0
    3710:	cf 91       	pop	r28
    3712:	df 91       	pop	r29
    3714:	08 95       	ret

00003716 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    3716:	df 93       	push	r29
    3718:	cf 93       	push	r28
    371a:	00 d0       	rcall	.+0      	; 0x371c <vTaskResume+0x6>
    371c:	00 d0       	rcall	.+0      	; 0x371e <vTaskResume+0x8>
    371e:	00 d0       	rcall	.+0      	; 0x3720 <vTaskResume+0xa>
    3720:	cd b7       	in	r28, 0x3d	; 61
    3722:	de b7       	in	r29, 0x3e	; 62
    3724:	9c 83       	std	Y+4, r25	; 0x04
    3726:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    3728:	8b 81       	ldd	r24, Y+3	; 0x03
    372a:	9c 81       	ldd	r25, Y+4	; 0x04
    372c:	9a 83       	std	Y+2, r25	; 0x02
    372e:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    3730:	20 91 54 07 	lds	r18, 0x0754
    3734:	30 91 55 07 	lds	r19, 0x0755
    3738:	89 81       	ldd	r24, Y+1	; 0x01
    373a:	9a 81       	ldd	r25, Y+2	; 0x02
    373c:	82 17       	cp	r24, r18
    373e:	93 07       	cpc	r25, r19
    3740:	09 f4       	brne	.+2      	; 0x3744 <vTaskResume+0x2e>
    3742:	3f c0       	rjmp	.+126    	; 0x37c2 <vTaskResume+0xac>
    3744:	89 81       	ldd	r24, Y+1	; 0x01
    3746:	9a 81       	ldd	r25, Y+2	; 0x02
    3748:	00 97       	sbiw	r24, 0x00	; 0
    374a:	09 f4       	brne	.+2      	; 0x374e <vTaskResume+0x38>
    374c:	3a c0       	rjmp	.+116    	; 0x37c2 <vTaskResume+0xac>
		{
			taskENTER_CRITICAL();
    374e:	0f b6       	in	r0, 0x3f	; 63
    3750:	f8 94       	cli
    3752:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    3754:	89 81       	ldd	r24, Y+1	; 0x01
    3756:	9a 81       	ldd	r25, Y+2	; 0x02
    3758:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <prvTaskIsTaskSuspended>
    375c:	88 23       	and	r24, r24
    375e:	79 f1       	breq	.+94     	; 0x37be <vTaskResume+0xa8>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    3760:	89 81       	ldd	r24, Y+1	; 0x01
    3762:	9a 81       	ldd	r25, Y+2	; 0x02
    3764:	02 96       	adiw	r24, 0x02	; 2
    3766:	0e 94 ca 06 	call	0xd94	; 0xd94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    376a:	e9 81       	ldd	r30, Y+1	; 0x01
    376c:	fa 81       	ldd	r31, Y+2	; 0x02
    376e:	96 89       	ldd	r25, Z+22	; 0x16
    3770:	80 91 59 07 	lds	r24, 0x0759
    3774:	89 17       	cp	r24, r25
    3776:	28 f4       	brcc	.+10     	; 0x3782 <vTaskResume+0x6c>
    3778:	e9 81       	ldd	r30, Y+1	; 0x01
    377a:	fa 81       	ldd	r31, Y+2	; 0x02
    377c:	86 89       	ldd	r24, Z+22	; 0x16
    377e:	80 93 59 07 	sts	0x0759, r24
    3782:	e9 81       	ldd	r30, Y+1	; 0x01
    3784:	fa 81       	ldd	r31, Y+2	; 0x02
    3786:	86 89       	ldd	r24, Z+22	; 0x16
    3788:	28 2f       	mov	r18, r24
    378a:	30 e0       	ldi	r19, 0x00	; 0
    378c:	c9 01       	movw	r24, r18
    378e:	88 0f       	add	r24, r24
    3790:	99 1f       	adc	r25, r25
    3792:	88 0f       	add	r24, r24
    3794:	99 1f       	adc	r25, r25
    3796:	88 0f       	add	r24, r24
    3798:	99 1f       	adc	r25, r25
    379a:	82 0f       	add	r24, r18
    379c:	93 1f       	adc	r25, r19
    379e:	ac 01       	movw	r20, r24
    37a0:	4c 59       	subi	r20, 0x9C	; 156
    37a2:	58 4f       	sbci	r21, 0xF8	; 248
    37a4:	89 81       	ldd	r24, Y+1	; 0x01
    37a6:	9a 81       	ldd	r25, Y+2	; 0x02
    37a8:	9c 01       	movw	r18, r24
    37aa:	2e 5f       	subi	r18, 0xFE	; 254
    37ac:	3f 4f       	sbci	r19, 0xFF	; 255
    37ae:	ca 01       	movw	r24, r20
    37b0:	b9 01       	movw	r22, r18
    37b2:	0e 94 1a 06 	call	0xc34	; 0xc34 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    37b6:	80 91 54 07 	lds	r24, 0x0754
    37ba:	90 91 55 07 	lds	r25, 0x0755
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    37be:	0f 90       	pop	r0
    37c0:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    37c2:	26 96       	adiw	r28, 0x06	; 6
    37c4:	0f b6       	in	r0, 0x3f	; 63
    37c6:	f8 94       	cli
    37c8:	de bf       	out	0x3e, r29	; 62
    37ca:	0f be       	out	0x3f, r0	; 63
    37cc:	cd bf       	out	0x3d, r28	; 61
    37ce:	cf 91       	pop	r28
    37d0:	df 91       	pop	r29
    37d2:	08 95       	ret

000037d4 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    37d4:	df 93       	push	r29
    37d6:	cf 93       	push	r28
    37d8:	00 d0       	rcall	.+0      	; 0x37da <xTaskResumeFromISR+0x6>
    37da:	00 d0       	rcall	.+0      	; 0x37dc <xTaskResumeFromISR+0x8>
    37dc:	00 d0       	rcall	.+0      	; 0x37de <xTaskResumeFromISR+0xa>
    37de:	cd b7       	in	r28, 0x3d	; 61
    37e0:	de b7       	in	r29, 0x3e	; 62
    37e2:	9e 83       	std	Y+6, r25	; 0x06
    37e4:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    37e6:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    37e8:	8d 81       	ldd	r24, Y+5	; 0x05
    37ea:	9e 81       	ldd	r25, Y+6	; 0x06
    37ec:	9b 83       	std	Y+3, r25	; 0x03
    37ee:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    37f0:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    37f2:	8a 81       	ldd	r24, Y+2	; 0x02
    37f4:	9b 81       	ldd	r25, Y+3	; 0x03
    37f6:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <prvTaskIsTaskSuspended>
    37fa:	88 23       	and	r24, r24
    37fc:	09 f4       	brne	.+2      	; 0x3800 <xTaskResumeFromISR+0x2c>
    37fe:	46 c0       	rjmp	.+140    	; 0x388c <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3800:	80 91 63 07 	lds	r24, 0x0763
    3804:	88 23       	and	r24, r24
    3806:	c1 f5       	brne	.+112    	; 0x3878 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3808:	ea 81       	ldd	r30, Y+2	; 0x02
    380a:	fb 81       	ldd	r31, Y+3	; 0x03
    380c:	96 89       	ldd	r25, Z+22	; 0x16
    380e:	e0 91 54 07 	lds	r30, 0x0754
    3812:	f0 91 55 07 	lds	r31, 0x0755
    3816:	86 89       	ldd	r24, Z+22	; 0x16
    3818:	98 17       	cp	r25, r24
    381a:	10 f0       	brcs	.+4      	; 0x3820 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    381c:	81 e0       	ldi	r24, 0x01	; 1
    381e:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3820:	8a 81       	ldd	r24, Y+2	; 0x02
    3822:	9b 81       	ldd	r25, Y+3	; 0x03
    3824:	02 96       	adiw	r24, 0x02	; 2
    3826:	0e 94 ca 06 	call	0xd94	; 0xd94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    382a:	ea 81       	ldd	r30, Y+2	; 0x02
    382c:	fb 81       	ldd	r31, Y+3	; 0x03
    382e:	96 89       	ldd	r25, Z+22	; 0x16
    3830:	80 91 59 07 	lds	r24, 0x0759
    3834:	89 17       	cp	r24, r25
    3836:	28 f4       	brcc	.+10     	; 0x3842 <xTaskResumeFromISR+0x6e>
    3838:	ea 81       	ldd	r30, Y+2	; 0x02
    383a:	fb 81       	ldd	r31, Y+3	; 0x03
    383c:	86 89       	ldd	r24, Z+22	; 0x16
    383e:	80 93 59 07 	sts	0x0759, r24
    3842:	ea 81       	ldd	r30, Y+2	; 0x02
    3844:	fb 81       	ldd	r31, Y+3	; 0x03
    3846:	86 89       	ldd	r24, Z+22	; 0x16
    3848:	28 2f       	mov	r18, r24
    384a:	30 e0       	ldi	r19, 0x00	; 0
    384c:	c9 01       	movw	r24, r18
    384e:	88 0f       	add	r24, r24
    3850:	99 1f       	adc	r25, r25
    3852:	88 0f       	add	r24, r24
    3854:	99 1f       	adc	r25, r25
    3856:	88 0f       	add	r24, r24
    3858:	99 1f       	adc	r25, r25
    385a:	82 0f       	add	r24, r18
    385c:	93 1f       	adc	r25, r19
    385e:	ac 01       	movw	r20, r24
    3860:	4c 59       	subi	r20, 0x9C	; 156
    3862:	58 4f       	sbci	r21, 0xF8	; 248
    3864:	8a 81       	ldd	r24, Y+2	; 0x02
    3866:	9b 81       	ldd	r25, Y+3	; 0x03
    3868:	9c 01       	movw	r18, r24
    386a:	2e 5f       	subi	r18, 0xFE	; 254
    386c:	3f 4f       	sbci	r19, 0xFF	; 255
    386e:	ca 01       	movw	r24, r20
    3870:	b9 01       	movw	r22, r18
    3872:	0e 94 1a 06 	call	0xc34	; 0xc34 <vListInsertEnd>
    3876:	0a c0       	rjmp	.+20     	; 0x388c <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3878:	8a 81       	ldd	r24, Y+2	; 0x02
    387a:	9b 81       	ldd	r25, Y+3	; 0x03
    387c:	9c 01       	movw	r18, r24
    387e:	24 5f       	subi	r18, 0xF4	; 244
    3880:	3f 4f       	sbci	r19, 0xFF	; 255
    3882:	8e e9       	ldi	r24, 0x9E	; 158
    3884:	97 e0       	ldi	r25, 0x07	; 7
    3886:	b9 01       	movw	r22, r18
    3888:	0e 94 1a 06 	call	0xc34	; 0xc34 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    388c:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    388e:	26 96       	adiw	r28, 0x06	; 6
    3890:	0f b6       	in	r0, 0x3f	; 63
    3892:	f8 94       	cli
    3894:	de bf       	out	0x3e, r29	; 62
    3896:	0f be       	out	0x3f, r0	; 63
    3898:	cd bf       	out	0x3d, r28	; 61
    389a:	cf 91       	pop	r28
    389c:	df 91       	pop	r29
    389e:	08 95       	ret

000038a0 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    38a0:	ef 92       	push	r14
    38a2:	ff 92       	push	r15
    38a4:	0f 93       	push	r16
    38a6:	df 93       	push	r29
    38a8:	cf 93       	push	r28
    38aa:	0f 92       	push	r0
    38ac:	cd b7       	in	r28, 0x3d	; 61
    38ae:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    38b0:	84 e7       	ldi	r24, 0x74	; 116
    38b2:	90 e2       	ldi	r25, 0x20	; 32
    38b4:	20 e6       	ldi	r18, 0x60	; 96
    38b6:	30 e0       	ldi	r19, 0x00	; 0
    38b8:	e1 e6       	ldi	r30, 0x61	; 97
    38ba:	f7 e0       	ldi	r31, 0x07	; 7
    38bc:	b9 01       	movw	r22, r18
    38be:	45 e5       	ldi	r20, 0x55	; 85
    38c0:	50 e0       	ldi	r21, 0x00	; 0
    38c2:	20 e0       	ldi	r18, 0x00	; 0
    38c4:	30 e0       	ldi	r19, 0x00	; 0
    38c6:	00 e0       	ldi	r16, 0x00	; 0
    38c8:	7f 01       	movw	r14, r30
    38ca:	0e 94 ad 18 	call	0x315a	; 0x315a <xTaskCreate>
    38ce:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    38d0:	89 81       	ldd	r24, Y+1	; 0x01
    38d2:	81 30       	cpi	r24, 0x01	; 1
    38d4:	81 f4       	brne	.+32     	; 0x38f6 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    38d6:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    38d8:	8f ef       	ldi	r24, 0xFF	; 255
    38da:	9f ef       	ldi	r25, 0xFF	; 255
    38dc:	90 93 60 07 	sts	0x0760, r25
    38e0:	80 93 5f 07 	sts	0x075F, r24
		xSchedulerRunning = pdTRUE;
    38e4:	81 e0       	ldi	r24, 0x01	; 1
    38e6:	80 93 5a 07 	sts	0x075A, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    38ea:	10 92 58 07 	sts	0x0758, r1
    38ee:	10 92 57 07 	sts	0x0757, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    38f2:	0e 94 99 08 	call	0x1132	; 0x1132 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    38f6:	0f 90       	pop	r0
    38f8:	cf 91       	pop	r28
    38fa:	df 91       	pop	r29
    38fc:	0f 91       	pop	r16
    38fe:	ff 90       	pop	r15
    3900:	ef 90       	pop	r14
    3902:	08 95       	ret

00003904 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3904:	df 93       	push	r29
    3906:	cf 93       	push	r28
    3908:	cd b7       	in	r28, 0x3d	; 61
    390a:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    390c:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    390e:	10 92 5a 07 	sts	0x075A, r1
	vPortEndScheduler();
    3912:	0e 94 ce 08 	call	0x119c	; 0x119c <vPortEndScheduler>
}
    3916:	cf 91       	pop	r28
    3918:	df 91       	pop	r29
    391a:	08 95       	ret

0000391c <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    391c:	df 93       	push	r29
    391e:	cf 93       	push	r28
    3920:	cd b7       	in	r28, 0x3d	; 61
    3922:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    3924:	80 91 63 07 	lds	r24, 0x0763
    3928:	8f 5f       	subi	r24, 0xFF	; 255
    392a:	80 93 63 07 	sts	0x0763, r24
}
    392e:	cf 91       	pop	r28
    3930:	df 91       	pop	r29
    3932:	08 95       	ret

00003934 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3934:	df 93       	push	r29
    3936:	cf 93       	push	r28
    3938:	00 d0       	rcall	.+0      	; 0x393a <xTaskResumeAll+0x6>
    393a:	00 d0       	rcall	.+0      	; 0x393c <xTaskResumeAll+0x8>
    393c:	0f 92       	push	r0
    393e:	cd b7       	in	r28, 0x3d	; 61
    3940:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    3942:	1c 82       	std	Y+4, r1	; 0x04
    3944:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    3946:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3948:	0f b6       	in	r0, 0x3f	; 63
    394a:	f8 94       	cli
    394c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    394e:	80 91 63 07 	lds	r24, 0x0763
    3952:	81 50       	subi	r24, 0x01	; 1
    3954:	80 93 63 07 	sts	0x0763, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3958:	80 91 63 07 	lds	r24, 0x0763
    395c:	88 23       	and	r24, r24
    395e:	09 f0       	breq	.+2      	; 0x3962 <xTaskResumeAll+0x2e>
    3960:	6d c0       	rjmp	.+218    	; 0x3a3c <xTaskResumeAll+0x108>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3962:	80 91 56 07 	lds	r24, 0x0756
    3966:	88 23       	and	r24, r24
    3968:	09 f4       	brne	.+2      	; 0x396c <xTaskResumeAll+0x38>
    396a:	68 c0       	rjmp	.+208    	; 0x3a3c <xTaskResumeAll+0x108>
    396c:	45 c0       	rjmp	.+138    	; 0x39f8 <xTaskResumeAll+0xc4>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    396e:	e0 91 a3 07 	lds	r30, 0x07A3
    3972:	f0 91 a4 07 	lds	r31, 0x07A4
    3976:	86 81       	ldd	r24, Z+6	; 0x06
    3978:	97 81       	ldd	r25, Z+7	; 0x07
    397a:	9c 83       	std	Y+4, r25	; 0x04
    397c:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    397e:	8b 81       	ldd	r24, Y+3	; 0x03
    3980:	9c 81       	ldd	r25, Y+4	; 0x04
    3982:	0c 96       	adiw	r24, 0x0c	; 12
    3984:	0e 94 ca 06 	call	0xd94	; 0xd94 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3988:	8b 81       	ldd	r24, Y+3	; 0x03
    398a:	9c 81       	ldd	r25, Y+4	; 0x04
    398c:	02 96       	adiw	r24, 0x02	; 2
    398e:	0e 94 ca 06 	call	0xd94	; 0xd94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3992:	eb 81       	ldd	r30, Y+3	; 0x03
    3994:	fc 81       	ldd	r31, Y+4	; 0x04
    3996:	96 89       	ldd	r25, Z+22	; 0x16
    3998:	80 91 59 07 	lds	r24, 0x0759
    399c:	89 17       	cp	r24, r25
    399e:	28 f4       	brcc	.+10     	; 0x39aa <xTaskResumeAll+0x76>
    39a0:	eb 81       	ldd	r30, Y+3	; 0x03
    39a2:	fc 81       	ldd	r31, Y+4	; 0x04
    39a4:	86 89       	ldd	r24, Z+22	; 0x16
    39a6:	80 93 59 07 	sts	0x0759, r24
    39aa:	eb 81       	ldd	r30, Y+3	; 0x03
    39ac:	fc 81       	ldd	r31, Y+4	; 0x04
    39ae:	86 89       	ldd	r24, Z+22	; 0x16
    39b0:	28 2f       	mov	r18, r24
    39b2:	30 e0       	ldi	r19, 0x00	; 0
    39b4:	c9 01       	movw	r24, r18
    39b6:	88 0f       	add	r24, r24
    39b8:	99 1f       	adc	r25, r25
    39ba:	88 0f       	add	r24, r24
    39bc:	99 1f       	adc	r25, r25
    39be:	88 0f       	add	r24, r24
    39c0:	99 1f       	adc	r25, r25
    39c2:	82 0f       	add	r24, r18
    39c4:	93 1f       	adc	r25, r19
    39c6:	ac 01       	movw	r20, r24
    39c8:	4c 59       	subi	r20, 0x9C	; 156
    39ca:	58 4f       	sbci	r21, 0xF8	; 248
    39cc:	8b 81       	ldd	r24, Y+3	; 0x03
    39ce:	9c 81       	ldd	r25, Y+4	; 0x04
    39d0:	9c 01       	movw	r18, r24
    39d2:	2e 5f       	subi	r18, 0xFE	; 254
    39d4:	3f 4f       	sbci	r19, 0xFF	; 255
    39d6:	ca 01       	movw	r24, r20
    39d8:	b9 01       	movw	r22, r18
    39da:	0e 94 1a 06 	call	0xc34	; 0xc34 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    39de:	eb 81       	ldd	r30, Y+3	; 0x03
    39e0:	fc 81       	ldd	r31, Y+4	; 0x04
    39e2:	96 89       	ldd	r25, Z+22	; 0x16
    39e4:	e0 91 54 07 	lds	r30, 0x0754
    39e8:	f0 91 55 07 	lds	r31, 0x0755
    39ec:	86 89       	ldd	r24, Z+22	; 0x16
    39ee:	98 17       	cp	r25, r24
    39f0:	18 f0       	brcs	.+6      	; 0x39f8 <xTaskResumeAll+0xc4>
					{
						xYieldPending = pdTRUE;
    39f2:	81 e0       	ldi	r24, 0x01	; 1
    39f4:	80 93 5c 07 	sts	0x075C, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    39f8:	80 91 9e 07 	lds	r24, 0x079E
    39fc:	88 23       	and	r24, r24
    39fe:	09 f0       	breq	.+2      	; 0x3a02 <xTaskResumeAll+0xce>
    3a00:	b6 cf       	rjmp	.-148    	; 0x396e <xTaskResumeAll+0x3a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    3a02:	8b 81       	ldd	r24, Y+3	; 0x03
    3a04:	9c 81       	ldd	r25, Y+4	; 0x04
    3a06:	00 97       	sbiw	r24, 0x00	; 0
    3a08:	11 f0       	breq	.+4      	; 0x3a0e <xTaskResumeAll+0xda>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    3a0a:	0e 94 c4 20 	call	0x4188	; 0x4188 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    3a0e:	80 91 5b 07 	lds	r24, 0x075B
    3a12:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    3a14:	89 81       	ldd	r24, Y+1	; 0x01
    3a16:	88 23       	and	r24, r24
    3a18:	79 f0       	breq	.+30     	; 0x3a38 <xTaskResumeAll+0x104>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    3a1a:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <xTaskIncrementTick>
    3a1e:	88 23       	and	r24, r24
    3a20:	19 f0       	breq	.+6      	; 0x3a28 <xTaskResumeAll+0xf4>
							{
								xYieldPending = pdTRUE;
    3a22:	81 e0       	ldi	r24, 0x01	; 1
    3a24:	80 93 5c 07 	sts	0x075C, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    3a28:	89 81       	ldd	r24, Y+1	; 0x01
    3a2a:	81 50       	subi	r24, 0x01	; 1
    3a2c:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    3a2e:	89 81       	ldd	r24, Y+1	; 0x01
    3a30:	88 23       	and	r24, r24
    3a32:	99 f7       	brne	.-26     	; 0x3a1a <xTaskResumeAll+0xe6>

						uxPendedTicks = 0;
    3a34:	10 92 5b 07 	sts	0x075B, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    3a38:	80 91 5c 07 	lds	r24, 0x075C
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    3a3c:	0f 90       	pop	r0
    3a3e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3a40:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3a42:	0f 90       	pop	r0
    3a44:	0f 90       	pop	r0
    3a46:	0f 90       	pop	r0
    3a48:	0f 90       	pop	r0
    3a4a:	0f 90       	pop	r0
    3a4c:	cf 91       	pop	r28
    3a4e:	df 91       	pop	r29
    3a50:	08 95       	ret

00003a52 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3a52:	df 93       	push	r29
    3a54:	cf 93       	push	r28
    3a56:	00 d0       	rcall	.+0      	; 0x3a58 <xTaskGetTickCount+0x6>
    3a58:	cd b7       	in	r28, 0x3d	; 61
    3a5a:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    3a5c:	0f b6       	in	r0, 0x3f	; 63
    3a5e:	f8 94       	cli
    3a60:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3a62:	80 91 57 07 	lds	r24, 0x0757
    3a66:	90 91 58 07 	lds	r25, 0x0758
    3a6a:	9a 83       	std	Y+2, r25	; 0x02
    3a6c:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    3a6e:	0f 90       	pop	r0
    3a70:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3a72:	89 81       	ldd	r24, Y+1	; 0x01
    3a74:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3a76:	0f 90       	pop	r0
    3a78:	0f 90       	pop	r0
    3a7a:	cf 91       	pop	r28
    3a7c:	df 91       	pop	r29
    3a7e:	08 95       	ret

00003a80 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3a80:	df 93       	push	r29
    3a82:	cf 93       	push	r28
    3a84:	00 d0       	rcall	.+0      	; 0x3a86 <xTaskGetTickCountFromISR+0x6>
    3a86:	0f 92       	push	r0
    3a88:	cd b7       	in	r28, 0x3d	; 61
    3a8a:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    3a8c:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    3a8e:	80 91 57 07 	lds	r24, 0x0757
    3a92:	90 91 58 07 	lds	r25, 0x0758
    3a96:	9b 83       	std	Y+3, r25	; 0x03
    3a98:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3a9a:	8a 81       	ldd	r24, Y+2	; 0x02
    3a9c:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3a9e:	0f 90       	pop	r0
    3aa0:	0f 90       	pop	r0
    3aa2:	0f 90       	pop	r0
    3aa4:	cf 91       	pop	r28
    3aa6:	df 91       	pop	r29
    3aa8:	08 95       	ret

00003aaa <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3aaa:	df 93       	push	r29
    3aac:	cf 93       	push	r28
    3aae:	cd b7       	in	r28, 0x3d	; 61
    3ab0:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    3ab2:	80 91 56 07 	lds	r24, 0x0756
}
    3ab6:	cf 91       	pop	r28
    3ab8:	df 91       	pop	r29
    3aba:	08 95       	ret

00003abc <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3abc:	df 93       	push	r29
    3abe:	cf 93       	push	r28
    3ac0:	00 d0       	rcall	.+0      	; 0x3ac2 <pcTaskGetName+0x6>
    3ac2:	00 d0       	rcall	.+0      	; 0x3ac4 <pcTaskGetName+0x8>
    3ac4:	00 d0       	rcall	.+0      	; 0x3ac6 <pcTaskGetName+0xa>
    3ac6:	cd b7       	in	r28, 0x3d	; 61
    3ac8:	de b7       	in	r29, 0x3e	; 62
    3aca:	9c 83       	std	Y+4, r25	; 0x04
    3acc:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    3ace:	8b 81       	ldd	r24, Y+3	; 0x03
    3ad0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ad2:	00 97       	sbiw	r24, 0x00	; 0
    3ad4:	39 f4       	brne	.+14     	; 0x3ae4 <pcTaskGetName+0x28>
    3ad6:	80 91 54 07 	lds	r24, 0x0754
    3ada:	90 91 55 07 	lds	r25, 0x0755
    3ade:	9e 83       	std	Y+6, r25	; 0x06
    3ae0:	8d 83       	std	Y+5, r24	; 0x05
    3ae2:	04 c0       	rjmp	.+8      	; 0x3aec <pcTaskGetName+0x30>
    3ae4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ae6:	9c 81       	ldd	r25, Y+4	; 0x04
    3ae8:	9e 83       	std	Y+6, r25	; 0x06
    3aea:	8d 83       	std	Y+5, r24	; 0x05
    3aec:	8d 81       	ldd	r24, Y+5	; 0x05
    3aee:	9e 81       	ldd	r25, Y+6	; 0x06
    3af0:	9a 83       	std	Y+2, r25	; 0x02
    3af2:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    3af4:	89 81       	ldd	r24, Y+1	; 0x01
    3af6:	9a 81       	ldd	r25, Y+2	; 0x02
    3af8:	49 96       	adiw	r24, 0x19	; 25
}
    3afa:	26 96       	adiw	r28, 0x06	; 6
    3afc:	0f b6       	in	r0, 0x3f	; 63
    3afe:	f8 94       	cli
    3b00:	de bf       	out	0x3e, r29	; 62
    3b02:	0f be       	out	0x3f, r0	; 63
    3b04:	cd bf       	out	0x3d, r28	; 61
    3b06:	cf 91       	pop	r28
    3b08:	df 91       	pop	r29
    3b0a:	08 95       	ret

00003b0c <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3b0c:	df 93       	push	r29
    3b0e:	cf 93       	push	r28
    3b10:	cd b7       	in	r28, 0x3d	; 61
    3b12:	de b7       	in	r29, 0x3e	; 62
    3b14:	29 97       	sbiw	r28, 0x09	; 9
    3b16:	0f b6       	in	r0, 0x3f	; 63
    3b18:	f8 94       	cli
    3b1a:	de bf       	out	0x3e, r29	; 62
    3b1c:	0f be       	out	0x3f, r0	; 63
    3b1e:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    3b20:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3b22:	80 91 63 07 	lds	r24, 0x0763
    3b26:	88 23       	and	r24, r24
    3b28:	09 f0       	breq	.+2      	; 0x3b2c <xTaskIncrementTick+0x20>
    3b2a:	9a c0       	rjmp	.+308    	; 0x3c60 <xTaskIncrementTick+0x154>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    3b2c:	80 91 57 07 	lds	r24, 0x0757
    3b30:	90 91 58 07 	lds	r25, 0x0758
    3b34:	01 96       	adiw	r24, 0x01	; 1
    3b36:	9c 83       	std	Y+4, r25	; 0x04
    3b38:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    3b3a:	8b 81       	ldd	r24, Y+3	; 0x03
    3b3c:	9c 81       	ldd	r25, Y+4	; 0x04
    3b3e:	90 93 58 07 	sts	0x0758, r25
    3b42:	80 93 57 07 	sts	0x0757, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    3b46:	8b 81       	ldd	r24, Y+3	; 0x03
    3b48:	9c 81       	ldd	r25, Y+4	; 0x04
    3b4a:	00 97       	sbiw	r24, 0x00	; 0
    3b4c:	d9 f4       	brne	.+54     	; 0x3b84 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    3b4e:	80 91 9a 07 	lds	r24, 0x079A
    3b52:	90 91 9b 07 	lds	r25, 0x079B
    3b56:	9a 83       	std	Y+2, r25	; 0x02
    3b58:	89 83       	std	Y+1, r24	; 0x01
    3b5a:	80 91 9c 07 	lds	r24, 0x079C
    3b5e:	90 91 9d 07 	lds	r25, 0x079D
    3b62:	90 93 9b 07 	sts	0x079B, r25
    3b66:	80 93 9a 07 	sts	0x079A, r24
    3b6a:	89 81       	ldd	r24, Y+1	; 0x01
    3b6c:	9a 81       	ldd	r25, Y+2	; 0x02
    3b6e:	90 93 9d 07 	sts	0x079D, r25
    3b72:	80 93 9c 07 	sts	0x079C, r24
    3b76:	80 91 5d 07 	lds	r24, 0x075D
    3b7a:	8f 5f       	subi	r24, 0xFF	; 255
    3b7c:	80 93 5d 07 	sts	0x075D, r24
    3b80:	0e 94 c4 20 	call	0x4188	; 0x4188 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    3b84:	20 91 5f 07 	lds	r18, 0x075F
    3b88:	30 91 60 07 	lds	r19, 0x0760
    3b8c:	8b 81       	ldd	r24, Y+3	; 0x03
    3b8e:	9c 81       	ldd	r25, Y+4	; 0x04
    3b90:	82 17       	cp	r24, r18
    3b92:	93 07       	cpc	r25, r19
    3b94:	08 f4       	brcc	.+2      	; 0x3b98 <xTaskIncrementTick+0x8c>
    3b96:	69 c0       	rjmp	.+210    	; 0x3c6a <xTaskIncrementTick+0x15e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3b98:	e0 91 9a 07 	lds	r30, 0x079A
    3b9c:	f0 91 9b 07 	lds	r31, 0x079B
    3ba0:	80 81       	ld	r24, Z
    3ba2:	88 23       	and	r24, r24
    3ba4:	39 f4       	brne	.+14     	; 0x3bb4 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3ba6:	8f ef       	ldi	r24, 0xFF	; 255
    3ba8:	9f ef       	ldi	r25, 0xFF	; 255
    3baa:	90 93 60 07 	sts	0x0760, r25
    3bae:	80 93 5f 07 	sts	0x075F, r24
    3bb2:	5b c0       	rjmp	.+182    	; 0x3c6a <xTaskIncrementTick+0x15e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3bb4:	e0 91 9a 07 	lds	r30, 0x079A
    3bb8:	f0 91 9b 07 	lds	r31, 0x079B
    3bbc:	05 80       	ldd	r0, Z+5	; 0x05
    3bbe:	f6 81       	ldd	r31, Z+6	; 0x06
    3bc0:	e0 2d       	mov	r30, r0
    3bc2:	86 81       	ldd	r24, Z+6	; 0x06
    3bc4:	97 81       	ldd	r25, Z+7	; 0x07
    3bc6:	99 87       	std	Y+9, r25	; 0x09
    3bc8:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    3bca:	e8 85       	ldd	r30, Y+8	; 0x08
    3bcc:	f9 85       	ldd	r31, Y+9	; 0x09
    3bce:	82 81       	ldd	r24, Z+2	; 0x02
    3bd0:	93 81       	ldd	r25, Z+3	; 0x03
    3bd2:	9f 83       	std	Y+7, r25	; 0x07
    3bd4:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    3bd6:	2b 81       	ldd	r18, Y+3	; 0x03
    3bd8:	3c 81       	ldd	r19, Y+4	; 0x04
    3bda:	8e 81       	ldd	r24, Y+6	; 0x06
    3bdc:	9f 81       	ldd	r25, Y+7	; 0x07
    3bde:	28 17       	cp	r18, r24
    3be0:	39 07       	cpc	r19, r25
    3be2:	38 f4       	brcc	.+14     	; 0x3bf2 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    3be4:	8e 81       	ldd	r24, Y+6	; 0x06
    3be6:	9f 81       	ldd	r25, Y+7	; 0x07
    3be8:	90 93 60 07 	sts	0x0760, r25
    3bec:	80 93 5f 07 	sts	0x075F, r24
    3bf0:	3c c0       	rjmp	.+120    	; 0x3c6a <xTaskIncrementTick+0x15e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3bf2:	88 85       	ldd	r24, Y+8	; 0x08
    3bf4:	99 85       	ldd	r25, Y+9	; 0x09
    3bf6:	02 96       	adiw	r24, 0x02	; 2
    3bf8:	0e 94 ca 06 	call	0xd94	; 0xd94 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3bfc:	e8 85       	ldd	r30, Y+8	; 0x08
    3bfe:	f9 85       	ldd	r31, Y+9	; 0x09
    3c00:	84 89       	ldd	r24, Z+20	; 0x14
    3c02:	95 89       	ldd	r25, Z+21	; 0x15
    3c04:	00 97       	sbiw	r24, 0x00	; 0
    3c06:	29 f0       	breq	.+10     	; 0x3c12 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3c08:	88 85       	ldd	r24, Y+8	; 0x08
    3c0a:	99 85       	ldd	r25, Y+9	; 0x09
    3c0c:	0c 96       	adiw	r24, 0x0c	; 12
    3c0e:	0e 94 ca 06 	call	0xd94	; 0xd94 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    3c12:	e8 85       	ldd	r30, Y+8	; 0x08
    3c14:	f9 85       	ldd	r31, Y+9	; 0x09
    3c16:	96 89       	ldd	r25, Z+22	; 0x16
    3c18:	80 91 59 07 	lds	r24, 0x0759
    3c1c:	89 17       	cp	r24, r25
    3c1e:	28 f4       	brcc	.+10     	; 0x3c2a <xTaskIncrementTick+0x11e>
    3c20:	e8 85       	ldd	r30, Y+8	; 0x08
    3c22:	f9 85       	ldd	r31, Y+9	; 0x09
    3c24:	86 89       	ldd	r24, Z+22	; 0x16
    3c26:	80 93 59 07 	sts	0x0759, r24
    3c2a:	e8 85       	ldd	r30, Y+8	; 0x08
    3c2c:	f9 85       	ldd	r31, Y+9	; 0x09
    3c2e:	86 89       	ldd	r24, Z+22	; 0x16
    3c30:	28 2f       	mov	r18, r24
    3c32:	30 e0       	ldi	r19, 0x00	; 0
    3c34:	c9 01       	movw	r24, r18
    3c36:	88 0f       	add	r24, r24
    3c38:	99 1f       	adc	r25, r25
    3c3a:	88 0f       	add	r24, r24
    3c3c:	99 1f       	adc	r25, r25
    3c3e:	88 0f       	add	r24, r24
    3c40:	99 1f       	adc	r25, r25
    3c42:	82 0f       	add	r24, r18
    3c44:	93 1f       	adc	r25, r19
    3c46:	ac 01       	movw	r20, r24
    3c48:	4c 59       	subi	r20, 0x9C	; 156
    3c4a:	58 4f       	sbci	r21, 0xF8	; 248
    3c4c:	88 85       	ldd	r24, Y+8	; 0x08
    3c4e:	99 85       	ldd	r25, Y+9	; 0x09
    3c50:	9c 01       	movw	r18, r24
    3c52:	2e 5f       	subi	r18, 0xFE	; 254
    3c54:	3f 4f       	sbci	r19, 0xFF	; 255
    3c56:	ca 01       	movw	r24, r20
    3c58:	b9 01       	movw	r22, r18
    3c5a:	0e 94 1a 06 	call	0xc34	; 0xc34 <vListInsertEnd>
    3c5e:	9c cf       	rjmp	.-200    	; 0x3b98 <xTaskIncrementTick+0x8c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    3c60:	80 91 5b 07 	lds	r24, 0x075B
    3c64:	8f 5f       	subi	r24, 0xFF	; 255
    3c66:	80 93 5b 07 	sts	0x075B, r24
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    3c6a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3c6c:	29 96       	adiw	r28, 0x09	; 9
    3c6e:	0f b6       	in	r0, 0x3f	; 63
    3c70:	f8 94       	cli
    3c72:	de bf       	out	0x3e, r29	; 62
    3c74:	0f be       	out	0x3f, r0	; 63
    3c76:	cd bf       	out	0x3d, r28	; 61
    3c78:	cf 91       	pop	r28
    3c7a:	df 91       	pop	r29
    3c7c:	08 95       	ret

00003c7e <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3c7e:	df 93       	push	r29
    3c80:	cf 93       	push	r28
    3c82:	00 d0       	rcall	.+0      	; 0x3c84 <vTaskSwitchContext+0x6>
    3c84:	0f 92       	push	r0
    3c86:	cd b7       	in	r28, 0x3d	; 61
    3c88:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3c8a:	80 91 63 07 	lds	r24, 0x0763
    3c8e:	88 23       	and	r24, r24
    3c90:	21 f0       	breq	.+8      	; 0x3c9a <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3c92:	81 e0       	ldi	r24, 0x01	; 1
    3c94:	80 93 5c 07 	sts	0x075C, r24
    3c98:	59 c0       	rjmp	.+178    	; 0x3d4c <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    3c9a:	10 92 5c 07 	sts	0x075C, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3c9e:	80 91 59 07 	lds	r24, 0x0759
    3ca2:	8b 83       	std	Y+3, r24	; 0x03
    3ca4:	03 c0       	rjmp	.+6      	; 0x3cac <vTaskSwitchContext+0x2e>
    3ca6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ca8:	81 50       	subi	r24, 0x01	; 1
    3caa:	8b 83       	std	Y+3, r24	; 0x03
    3cac:	8b 81       	ldd	r24, Y+3	; 0x03
    3cae:	28 2f       	mov	r18, r24
    3cb0:	30 e0       	ldi	r19, 0x00	; 0
    3cb2:	c9 01       	movw	r24, r18
    3cb4:	88 0f       	add	r24, r24
    3cb6:	99 1f       	adc	r25, r25
    3cb8:	88 0f       	add	r24, r24
    3cba:	99 1f       	adc	r25, r25
    3cbc:	88 0f       	add	r24, r24
    3cbe:	99 1f       	adc	r25, r25
    3cc0:	82 0f       	add	r24, r18
    3cc2:	93 1f       	adc	r25, r19
    3cc4:	fc 01       	movw	r30, r24
    3cc6:	ec 59       	subi	r30, 0x9C	; 156
    3cc8:	f8 4f       	sbci	r31, 0xF8	; 248
    3cca:	80 81       	ld	r24, Z
    3ccc:	88 23       	and	r24, r24
    3cce:	59 f3       	breq	.-42     	; 0x3ca6 <vTaskSwitchContext+0x28>
    3cd0:	8b 81       	ldd	r24, Y+3	; 0x03
    3cd2:	28 2f       	mov	r18, r24
    3cd4:	30 e0       	ldi	r19, 0x00	; 0
    3cd6:	c9 01       	movw	r24, r18
    3cd8:	88 0f       	add	r24, r24
    3cda:	99 1f       	adc	r25, r25
    3cdc:	88 0f       	add	r24, r24
    3cde:	99 1f       	adc	r25, r25
    3ce0:	88 0f       	add	r24, r24
    3ce2:	99 1f       	adc	r25, r25
    3ce4:	82 0f       	add	r24, r18
    3ce6:	93 1f       	adc	r25, r19
    3ce8:	8c 59       	subi	r24, 0x9C	; 156
    3cea:	98 4f       	sbci	r25, 0xF8	; 248
    3cec:	9a 83       	std	Y+2, r25	; 0x02
    3cee:	89 83       	std	Y+1, r24	; 0x01
    3cf0:	e9 81       	ldd	r30, Y+1	; 0x01
    3cf2:	fa 81       	ldd	r31, Y+2	; 0x02
    3cf4:	01 80       	ldd	r0, Z+1	; 0x01
    3cf6:	f2 81       	ldd	r31, Z+2	; 0x02
    3cf8:	e0 2d       	mov	r30, r0
    3cfa:	82 81       	ldd	r24, Z+2	; 0x02
    3cfc:	93 81       	ldd	r25, Z+3	; 0x03
    3cfe:	e9 81       	ldd	r30, Y+1	; 0x01
    3d00:	fa 81       	ldd	r31, Y+2	; 0x02
    3d02:	92 83       	std	Z+2, r25	; 0x02
    3d04:	81 83       	std	Z+1, r24	; 0x01
    3d06:	e9 81       	ldd	r30, Y+1	; 0x01
    3d08:	fa 81       	ldd	r31, Y+2	; 0x02
    3d0a:	21 81       	ldd	r18, Z+1	; 0x01
    3d0c:	32 81       	ldd	r19, Z+2	; 0x02
    3d0e:	89 81       	ldd	r24, Y+1	; 0x01
    3d10:	9a 81       	ldd	r25, Y+2	; 0x02
    3d12:	03 96       	adiw	r24, 0x03	; 3
    3d14:	28 17       	cp	r18, r24
    3d16:	39 07       	cpc	r19, r25
    3d18:	59 f4       	brne	.+22     	; 0x3d30 <vTaskSwitchContext+0xb2>
    3d1a:	e9 81       	ldd	r30, Y+1	; 0x01
    3d1c:	fa 81       	ldd	r31, Y+2	; 0x02
    3d1e:	01 80       	ldd	r0, Z+1	; 0x01
    3d20:	f2 81       	ldd	r31, Z+2	; 0x02
    3d22:	e0 2d       	mov	r30, r0
    3d24:	82 81       	ldd	r24, Z+2	; 0x02
    3d26:	93 81       	ldd	r25, Z+3	; 0x03
    3d28:	e9 81       	ldd	r30, Y+1	; 0x01
    3d2a:	fa 81       	ldd	r31, Y+2	; 0x02
    3d2c:	92 83       	std	Z+2, r25	; 0x02
    3d2e:	81 83       	std	Z+1, r24	; 0x01
    3d30:	e9 81       	ldd	r30, Y+1	; 0x01
    3d32:	fa 81       	ldd	r31, Y+2	; 0x02
    3d34:	01 80       	ldd	r0, Z+1	; 0x01
    3d36:	f2 81       	ldd	r31, Z+2	; 0x02
    3d38:	e0 2d       	mov	r30, r0
    3d3a:	86 81       	ldd	r24, Z+6	; 0x06
    3d3c:	97 81       	ldd	r25, Z+7	; 0x07
    3d3e:	90 93 55 07 	sts	0x0755, r25
    3d42:	80 93 54 07 	sts	0x0754, r24
    3d46:	8b 81       	ldd	r24, Y+3	; 0x03
    3d48:	80 93 59 07 	sts	0x0759, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3d4c:	0f 90       	pop	r0
    3d4e:	0f 90       	pop	r0
    3d50:	0f 90       	pop	r0
    3d52:	cf 91       	pop	r28
    3d54:	df 91       	pop	r29
    3d56:	08 95       	ret

00003d58 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3d58:	df 93       	push	r29
    3d5a:	cf 93       	push	r28
    3d5c:	00 d0       	rcall	.+0      	; 0x3d5e <vTaskPlaceOnEventList+0x6>
    3d5e:	00 d0       	rcall	.+0      	; 0x3d60 <vTaskPlaceOnEventList+0x8>
    3d60:	cd b7       	in	r28, 0x3d	; 61
    3d62:	de b7       	in	r29, 0x3e	; 62
    3d64:	9a 83       	std	Y+2, r25	; 0x02
    3d66:	89 83       	std	Y+1, r24	; 0x01
    3d68:	7c 83       	std	Y+4, r23	; 0x04
    3d6a:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3d6c:	80 91 54 07 	lds	r24, 0x0754
    3d70:	90 91 55 07 	lds	r25, 0x0755
    3d74:	9c 01       	movw	r18, r24
    3d76:	24 5f       	subi	r18, 0xF4	; 244
    3d78:	3f 4f       	sbci	r19, 0xFF	; 255
    3d7a:	89 81       	ldd	r24, Y+1	; 0x01
    3d7c:	9a 81       	ldd	r25, Y+2	; 0x02
    3d7e:	b9 01       	movw	r22, r18
    3d80:	0e 94 5e 06 	call	0xcbc	; 0xcbc <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3d84:	8b 81       	ldd	r24, Y+3	; 0x03
    3d86:	9c 81       	ldd	r25, Y+4	; 0x04
    3d88:	61 e0       	ldi	r22, 0x01	; 1
    3d8a:	0e 94 c8 24 	call	0x4990	; 0x4990 <prvAddCurrentTaskToDelayedList>
}
    3d8e:	0f 90       	pop	r0
    3d90:	0f 90       	pop	r0
    3d92:	0f 90       	pop	r0
    3d94:	0f 90       	pop	r0
    3d96:	cf 91       	pop	r28
    3d98:	df 91       	pop	r29
    3d9a:	08 95       	ret

00003d9c <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3d9c:	df 93       	push	r29
    3d9e:	cf 93       	push	r28
    3da0:	00 d0       	rcall	.+0      	; 0x3da2 <vTaskPlaceOnUnorderedEventList+0x6>
    3da2:	00 d0       	rcall	.+0      	; 0x3da4 <vTaskPlaceOnUnorderedEventList+0x8>
    3da4:	00 d0       	rcall	.+0      	; 0x3da6 <vTaskPlaceOnUnorderedEventList+0xa>
    3da6:	cd b7       	in	r28, 0x3d	; 61
    3da8:	de b7       	in	r29, 0x3e	; 62
    3daa:	9a 83       	std	Y+2, r25	; 0x02
    3dac:	89 83       	std	Y+1, r24	; 0x01
    3dae:	7c 83       	std	Y+4, r23	; 0x04
    3db0:	6b 83       	std	Y+3, r22	; 0x03
    3db2:	5e 83       	std	Y+6, r21	; 0x06
    3db4:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3db6:	e0 91 54 07 	lds	r30, 0x0754
    3dba:	f0 91 55 07 	lds	r31, 0x0755
    3dbe:	8b 81       	ldd	r24, Y+3	; 0x03
    3dc0:	9c 81       	ldd	r25, Y+4	; 0x04
    3dc2:	90 68       	ori	r25, 0x80	; 128
    3dc4:	95 87       	std	Z+13, r25	; 0x0d
    3dc6:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3dc8:	80 91 54 07 	lds	r24, 0x0754
    3dcc:	90 91 55 07 	lds	r25, 0x0755
    3dd0:	9c 01       	movw	r18, r24
    3dd2:	24 5f       	subi	r18, 0xF4	; 244
    3dd4:	3f 4f       	sbci	r19, 0xFF	; 255
    3dd6:	89 81       	ldd	r24, Y+1	; 0x01
    3dd8:	9a 81       	ldd	r25, Y+2	; 0x02
    3dda:	b9 01       	movw	r22, r18
    3ddc:	0e 94 1a 06 	call	0xc34	; 0xc34 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3de0:	8d 81       	ldd	r24, Y+5	; 0x05
    3de2:	9e 81       	ldd	r25, Y+6	; 0x06
    3de4:	61 e0       	ldi	r22, 0x01	; 1
    3de6:	0e 94 c8 24 	call	0x4990	; 0x4990 <prvAddCurrentTaskToDelayedList>
}
    3dea:	26 96       	adiw	r28, 0x06	; 6
    3dec:	0f b6       	in	r0, 0x3f	; 63
    3dee:	f8 94       	cli
    3df0:	de bf       	out	0x3e, r29	; 62
    3df2:	0f be       	out	0x3f, r0	; 63
    3df4:	cd bf       	out	0x3d, r28	; 61
    3df6:	cf 91       	pop	r28
    3df8:	df 91       	pop	r29
    3dfa:	08 95       	ret

00003dfc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3dfc:	df 93       	push	r29
    3dfe:	cf 93       	push	r28
    3e00:	00 d0       	rcall	.+0      	; 0x3e02 <xTaskRemoveFromEventList+0x6>
    3e02:	00 d0       	rcall	.+0      	; 0x3e04 <xTaskRemoveFromEventList+0x8>
    3e04:	0f 92       	push	r0
    3e06:	cd b7       	in	r28, 0x3d	; 61
    3e08:	de b7       	in	r29, 0x3e	; 62
    3e0a:	9d 83       	std	Y+5, r25	; 0x05
    3e0c:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3e0e:	ec 81       	ldd	r30, Y+4	; 0x04
    3e10:	fd 81       	ldd	r31, Y+5	; 0x05
    3e12:	05 80       	ldd	r0, Z+5	; 0x05
    3e14:	f6 81       	ldd	r31, Z+6	; 0x06
    3e16:	e0 2d       	mov	r30, r0
    3e18:	86 81       	ldd	r24, Z+6	; 0x06
    3e1a:	97 81       	ldd	r25, Z+7	; 0x07
    3e1c:	9b 83       	std	Y+3, r25	; 0x03
    3e1e:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3e20:	8a 81       	ldd	r24, Y+2	; 0x02
    3e22:	9b 81       	ldd	r25, Y+3	; 0x03
    3e24:	0c 96       	adiw	r24, 0x0c	; 12
    3e26:	0e 94 ca 06 	call	0xd94	; 0xd94 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3e2a:	80 91 63 07 	lds	r24, 0x0763
    3e2e:	88 23       	and	r24, r24
    3e30:	61 f5       	brne	.+88     	; 0x3e8a <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3e32:	8a 81       	ldd	r24, Y+2	; 0x02
    3e34:	9b 81       	ldd	r25, Y+3	; 0x03
    3e36:	02 96       	adiw	r24, 0x02	; 2
    3e38:	0e 94 ca 06 	call	0xd94	; 0xd94 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    3e3c:	ea 81       	ldd	r30, Y+2	; 0x02
    3e3e:	fb 81       	ldd	r31, Y+3	; 0x03
    3e40:	96 89       	ldd	r25, Z+22	; 0x16
    3e42:	80 91 59 07 	lds	r24, 0x0759
    3e46:	89 17       	cp	r24, r25
    3e48:	28 f4       	brcc	.+10     	; 0x3e54 <xTaskRemoveFromEventList+0x58>
    3e4a:	ea 81       	ldd	r30, Y+2	; 0x02
    3e4c:	fb 81       	ldd	r31, Y+3	; 0x03
    3e4e:	86 89       	ldd	r24, Z+22	; 0x16
    3e50:	80 93 59 07 	sts	0x0759, r24
    3e54:	ea 81       	ldd	r30, Y+2	; 0x02
    3e56:	fb 81       	ldd	r31, Y+3	; 0x03
    3e58:	86 89       	ldd	r24, Z+22	; 0x16
    3e5a:	28 2f       	mov	r18, r24
    3e5c:	30 e0       	ldi	r19, 0x00	; 0
    3e5e:	c9 01       	movw	r24, r18
    3e60:	88 0f       	add	r24, r24
    3e62:	99 1f       	adc	r25, r25
    3e64:	88 0f       	add	r24, r24
    3e66:	99 1f       	adc	r25, r25
    3e68:	88 0f       	add	r24, r24
    3e6a:	99 1f       	adc	r25, r25
    3e6c:	82 0f       	add	r24, r18
    3e6e:	93 1f       	adc	r25, r19
    3e70:	ac 01       	movw	r20, r24
    3e72:	4c 59       	subi	r20, 0x9C	; 156
    3e74:	58 4f       	sbci	r21, 0xF8	; 248
    3e76:	8a 81       	ldd	r24, Y+2	; 0x02
    3e78:	9b 81       	ldd	r25, Y+3	; 0x03
    3e7a:	9c 01       	movw	r18, r24
    3e7c:	2e 5f       	subi	r18, 0xFE	; 254
    3e7e:	3f 4f       	sbci	r19, 0xFF	; 255
    3e80:	ca 01       	movw	r24, r20
    3e82:	b9 01       	movw	r22, r18
    3e84:	0e 94 1a 06 	call	0xc34	; 0xc34 <vListInsertEnd>
    3e88:	0a c0       	rjmp	.+20     	; 0x3e9e <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3e8a:	8a 81       	ldd	r24, Y+2	; 0x02
    3e8c:	9b 81       	ldd	r25, Y+3	; 0x03
    3e8e:	9c 01       	movw	r18, r24
    3e90:	24 5f       	subi	r18, 0xF4	; 244
    3e92:	3f 4f       	sbci	r19, 0xFF	; 255
    3e94:	8e e9       	ldi	r24, 0x9E	; 158
    3e96:	97 e0       	ldi	r25, 0x07	; 7
    3e98:	b9 01       	movw	r22, r18
    3e9a:	0e 94 1a 06 	call	0xc34	; 0xc34 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3e9e:	ea 81       	ldd	r30, Y+2	; 0x02
    3ea0:	fb 81       	ldd	r31, Y+3	; 0x03
    3ea2:	96 89       	ldd	r25, Z+22	; 0x16
    3ea4:	e0 91 54 07 	lds	r30, 0x0754
    3ea8:	f0 91 55 07 	lds	r31, 0x0755
    3eac:	86 89       	ldd	r24, Z+22	; 0x16
    3eae:	89 17       	cp	r24, r25
    3eb0:	30 f4       	brcc	.+12     	; 0x3ebe <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    3eb2:	81 e0       	ldi	r24, 0x01	; 1
    3eb4:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3eb6:	81 e0       	ldi	r24, 0x01	; 1
    3eb8:	80 93 5c 07 	sts	0x075C, r24
    3ebc:	01 c0       	rjmp	.+2      	; 0x3ec0 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    3ebe:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3ec0:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ec2:	0f 90       	pop	r0
    3ec4:	0f 90       	pop	r0
    3ec6:	0f 90       	pop	r0
    3ec8:	0f 90       	pop	r0
    3eca:	0f 90       	pop	r0
    3ecc:	cf 91       	pop	r28
    3ece:	df 91       	pop	r29
    3ed0:	08 95       	ret

00003ed2 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    3ed2:	df 93       	push	r29
    3ed4:	cf 93       	push	r28
    3ed6:	00 d0       	rcall	.+0      	; 0x3ed8 <vTaskRemoveFromUnorderedEventList+0x6>
    3ed8:	00 d0       	rcall	.+0      	; 0x3eda <vTaskRemoveFromUnorderedEventList+0x8>
    3eda:	00 d0       	rcall	.+0      	; 0x3edc <vTaskRemoveFromUnorderedEventList+0xa>
    3edc:	cd b7       	in	r28, 0x3d	; 61
    3ede:	de b7       	in	r29, 0x3e	; 62
    3ee0:	9c 83       	std	Y+4, r25	; 0x04
    3ee2:	8b 83       	std	Y+3, r24	; 0x03
    3ee4:	7e 83       	std	Y+6, r23	; 0x06
    3ee6:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3ee8:	8d 81       	ldd	r24, Y+5	; 0x05
    3eea:	9e 81       	ldd	r25, Y+6	; 0x06
    3eec:	90 68       	ori	r25, 0x80	; 128
    3eee:	eb 81       	ldd	r30, Y+3	; 0x03
    3ef0:	fc 81       	ldd	r31, Y+4	; 0x04
    3ef2:	91 83       	std	Z+1, r25	; 0x01
    3ef4:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3ef6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ef8:	fc 81       	ldd	r31, Y+4	; 0x04
    3efa:	86 81       	ldd	r24, Z+6	; 0x06
    3efc:	97 81       	ldd	r25, Z+7	; 0x07
    3efe:	9a 83       	std	Y+2, r25	; 0x02
    3f00:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    3f02:	8b 81       	ldd	r24, Y+3	; 0x03
    3f04:	9c 81       	ldd	r25, Y+4	; 0x04
    3f06:	0e 94 ca 06 	call	0xd94	; 0xd94 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3f0a:	89 81       	ldd	r24, Y+1	; 0x01
    3f0c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f0e:	02 96       	adiw	r24, 0x02	; 2
    3f10:	0e 94 ca 06 	call	0xd94	; 0xd94 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    3f14:	e9 81       	ldd	r30, Y+1	; 0x01
    3f16:	fa 81       	ldd	r31, Y+2	; 0x02
    3f18:	96 89       	ldd	r25, Z+22	; 0x16
    3f1a:	80 91 59 07 	lds	r24, 0x0759
    3f1e:	89 17       	cp	r24, r25
    3f20:	28 f4       	brcc	.+10     	; 0x3f2c <vTaskRemoveFromUnorderedEventList+0x5a>
    3f22:	e9 81       	ldd	r30, Y+1	; 0x01
    3f24:	fa 81       	ldd	r31, Y+2	; 0x02
    3f26:	86 89       	ldd	r24, Z+22	; 0x16
    3f28:	80 93 59 07 	sts	0x0759, r24
    3f2c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f2e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f30:	86 89       	ldd	r24, Z+22	; 0x16
    3f32:	28 2f       	mov	r18, r24
    3f34:	30 e0       	ldi	r19, 0x00	; 0
    3f36:	c9 01       	movw	r24, r18
    3f38:	88 0f       	add	r24, r24
    3f3a:	99 1f       	adc	r25, r25
    3f3c:	88 0f       	add	r24, r24
    3f3e:	99 1f       	adc	r25, r25
    3f40:	88 0f       	add	r24, r24
    3f42:	99 1f       	adc	r25, r25
    3f44:	82 0f       	add	r24, r18
    3f46:	93 1f       	adc	r25, r19
    3f48:	ac 01       	movw	r20, r24
    3f4a:	4c 59       	subi	r20, 0x9C	; 156
    3f4c:	58 4f       	sbci	r21, 0xF8	; 248
    3f4e:	89 81       	ldd	r24, Y+1	; 0x01
    3f50:	9a 81       	ldd	r25, Y+2	; 0x02
    3f52:	9c 01       	movw	r18, r24
    3f54:	2e 5f       	subi	r18, 0xFE	; 254
    3f56:	3f 4f       	sbci	r19, 0xFF	; 255
    3f58:	ca 01       	movw	r24, r20
    3f5a:	b9 01       	movw	r22, r18
    3f5c:	0e 94 1a 06 	call	0xc34	; 0xc34 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3f60:	e9 81       	ldd	r30, Y+1	; 0x01
    3f62:	fa 81       	ldd	r31, Y+2	; 0x02
    3f64:	96 89       	ldd	r25, Z+22	; 0x16
    3f66:	e0 91 54 07 	lds	r30, 0x0754
    3f6a:	f0 91 55 07 	lds	r31, 0x0755
    3f6e:	86 89       	ldd	r24, Z+22	; 0x16
    3f70:	89 17       	cp	r24, r25
    3f72:	18 f4       	brcc	.+6      	; 0x3f7a <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    3f74:	81 e0       	ldi	r24, 0x01	; 1
    3f76:	80 93 5c 07 	sts	0x075C, r24
	}
}
    3f7a:	26 96       	adiw	r28, 0x06	; 6
    3f7c:	0f b6       	in	r0, 0x3f	; 63
    3f7e:	f8 94       	cli
    3f80:	de bf       	out	0x3e, r29	; 62
    3f82:	0f be       	out	0x3f, r0	; 63
    3f84:	cd bf       	out	0x3d, r28	; 61
    3f86:	cf 91       	pop	r28
    3f88:	df 91       	pop	r29
    3f8a:	08 95       	ret

00003f8c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3f8c:	df 93       	push	r29
    3f8e:	cf 93       	push	r28
    3f90:	00 d0       	rcall	.+0      	; 0x3f92 <vTaskSetTimeOutState+0x6>
    3f92:	cd b7       	in	r28, 0x3d	; 61
    3f94:	de b7       	in	r29, 0x3e	; 62
    3f96:	9a 83       	std	Y+2, r25	; 0x02
    3f98:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    3f9a:	0f b6       	in	r0, 0x3f	; 63
    3f9c:	f8 94       	cli
    3f9e:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    3fa0:	80 91 5d 07 	lds	r24, 0x075D
    3fa4:	e9 81       	ldd	r30, Y+1	; 0x01
    3fa6:	fa 81       	ldd	r31, Y+2	; 0x02
    3fa8:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    3faa:	80 91 57 07 	lds	r24, 0x0757
    3fae:	90 91 58 07 	lds	r25, 0x0758
    3fb2:	e9 81       	ldd	r30, Y+1	; 0x01
    3fb4:	fa 81       	ldd	r31, Y+2	; 0x02
    3fb6:	92 83       	std	Z+2, r25	; 0x02
    3fb8:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3fba:	0f 90       	pop	r0
    3fbc:	0f be       	out	0x3f, r0	; 63
}
    3fbe:	0f 90       	pop	r0
    3fc0:	0f 90       	pop	r0
    3fc2:	cf 91       	pop	r28
    3fc4:	df 91       	pop	r29
    3fc6:	08 95       	ret

00003fc8 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3fc8:	df 93       	push	r29
    3fca:	cf 93       	push	r28
    3fcc:	00 d0       	rcall	.+0      	; 0x3fce <vTaskInternalSetTimeOutState+0x6>
    3fce:	cd b7       	in	r28, 0x3d	; 61
    3fd0:	de b7       	in	r29, 0x3e	; 62
    3fd2:	9a 83       	std	Y+2, r25	; 0x02
    3fd4:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3fd6:	80 91 5d 07 	lds	r24, 0x075D
    3fda:	e9 81       	ldd	r30, Y+1	; 0x01
    3fdc:	fa 81       	ldd	r31, Y+2	; 0x02
    3fde:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3fe0:	80 91 57 07 	lds	r24, 0x0757
    3fe4:	90 91 58 07 	lds	r25, 0x0758
    3fe8:	e9 81       	ldd	r30, Y+1	; 0x01
    3fea:	fa 81       	ldd	r31, Y+2	; 0x02
    3fec:	92 83       	std	Z+2, r25	; 0x02
    3fee:	81 83       	std	Z+1, r24	; 0x01
}
    3ff0:	0f 90       	pop	r0
    3ff2:	0f 90       	pop	r0
    3ff4:	cf 91       	pop	r28
    3ff6:	df 91       	pop	r29
    3ff8:	08 95       	ret

00003ffa <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    3ffa:	df 93       	push	r29
    3ffc:	cf 93       	push	r28
    3ffe:	cd b7       	in	r28, 0x3d	; 61
    4000:	de b7       	in	r29, 0x3e	; 62
    4002:	29 97       	sbiw	r28, 0x09	; 9
    4004:	0f b6       	in	r0, 0x3f	; 63
    4006:	f8 94       	cli
    4008:	de bf       	out	0x3e, r29	; 62
    400a:	0f be       	out	0x3f, r0	; 63
    400c:	cd bf       	out	0x3d, r28	; 61
    400e:	9f 83       	std	Y+7, r25	; 0x07
    4010:	8e 83       	std	Y+6, r24	; 0x06
    4012:	79 87       	std	Y+9, r23	; 0x09
    4014:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4016:	0f b6       	in	r0, 0x3f	; 63
    4018:	f8 94       	cli
    401a:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    401c:	80 91 57 07 	lds	r24, 0x0757
    4020:	90 91 58 07 	lds	r25, 0x0758
    4024:	9c 83       	std	Y+4, r25	; 0x04
    4026:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4028:	ee 81       	ldd	r30, Y+6	; 0x06
    402a:	ff 81       	ldd	r31, Y+7	; 0x07
    402c:	21 81       	ldd	r18, Z+1	; 0x01
    402e:	32 81       	ldd	r19, Z+2	; 0x02
    4030:	8b 81       	ldd	r24, Y+3	; 0x03
    4032:	9c 81       	ldd	r25, Y+4	; 0x04
    4034:	82 1b       	sub	r24, r18
    4036:	93 0b       	sbc	r25, r19
    4038:	9a 83       	std	Y+2, r25	; 0x02
    403a:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    403c:	e8 85       	ldd	r30, Y+8	; 0x08
    403e:	f9 85       	ldd	r31, Y+9	; 0x09
    4040:	80 81       	ld	r24, Z
    4042:	91 81       	ldd	r25, Z+1	; 0x01
    4044:	2f ef       	ldi	r18, 0xFF	; 255
    4046:	8f 3f       	cpi	r24, 0xFF	; 255
    4048:	92 07       	cpc	r25, r18
    404a:	11 f4       	brne	.+4      	; 0x4050 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    404c:	1d 82       	std	Y+5, r1	; 0x05
    404e:	36 c0       	rjmp	.+108    	; 0x40bc <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4050:	ee 81       	ldd	r30, Y+6	; 0x06
    4052:	ff 81       	ldd	r31, Y+7	; 0x07
    4054:	90 81       	ld	r25, Z
    4056:	80 91 5d 07 	lds	r24, 0x075D
    405a:	98 17       	cp	r25, r24
    405c:	61 f0       	breq	.+24     	; 0x4076 <xTaskCheckForTimeOut+0x7c>
    405e:	ee 81       	ldd	r30, Y+6	; 0x06
    4060:	ff 81       	ldd	r31, Y+7	; 0x07
    4062:	21 81       	ldd	r18, Z+1	; 0x01
    4064:	32 81       	ldd	r19, Z+2	; 0x02
    4066:	8b 81       	ldd	r24, Y+3	; 0x03
    4068:	9c 81       	ldd	r25, Y+4	; 0x04
    406a:	82 17       	cp	r24, r18
    406c:	93 07       	cpc	r25, r19
    406e:	18 f0       	brcs	.+6      	; 0x4076 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    4070:	81 e0       	ldi	r24, 0x01	; 1
    4072:	8d 83       	std	Y+5, r24	; 0x05
    4074:	23 c0       	rjmp	.+70     	; 0x40bc <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4076:	e8 85       	ldd	r30, Y+8	; 0x08
    4078:	f9 85       	ldd	r31, Y+9	; 0x09
    407a:	20 81       	ld	r18, Z
    407c:	31 81       	ldd	r19, Z+1	; 0x01
    407e:	89 81       	ldd	r24, Y+1	; 0x01
    4080:	9a 81       	ldd	r25, Y+2	; 0x02
    4082:	82 17       	cp	r24, r18
    4084:	93 07       	cpc	r25, r19
    4086:	a0 f4       	brcc	.+40     	; 0x40b0 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    4088:	e8 85       	ldd	r30, Y+8	; 0x08
    408a:	f9 85       	ldd	r31, Y+9	; 0x09
    408c:	20 81       	ld	r18, Z
    408e:	31 81       	ldd	r19, Z+1	; 0x01
    4090:	89 81       	ldd	r24, Y+1	; 0x01
    4092:	9a 81       	ldd	r25, Y+2	; 0x02
    4094:	a9 01       	movw	r20, r18
    4096:	48 1b       	sub	r20, r24
    4098:	59 0b       	sbc	r21, r25
    409a:	ca 01       	movw	r24, r20
    409c:	e8 85       	ldd	r30, Y+8	; 0x08
    409e:	f9 85       	ldd	r31, Y+9	; 0x09
    40a0:	91 83       	std	Z+1, r25	; 0x01
    40a2:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    40a4:	8e 81       	ldd	r24, Y+6	; 0x06
    40a6:	9f 81       	ldd	r25, Y+7	; 0x07
    40a8:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    40ac:	1d 82       	std	Y+5, r1	; 0x05
    40ae:	06 c0       	rjmp	.+12     	; 0x40bc <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    40b0:	e8 85       	ldd	r30, Y+8	; 0x08
    40b2:	f9 85       	ldd	r31, Y+9	; 0x09
    40b4:	11 82       	std	Z+1, r1	; 0x01
    40b6:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    40b8:	81 e0       	ldi	r24, 0x01	; 1
    40ba:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    40bc:	0f 90       	pop	r0
    40be:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    40c0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    40c2:	29 96       	adiw	r28, 0x09	; 9
    40c4:	0f b6       	in	r0, 0x3f	; 63
    40c6:	f8 94       	cli
    40c8:	de bf       	out	0x3e, r29	; 62
    40ca:	0f be       	out	0x3f, r0	; 63
    40cc:	cd bf       	out	0x3d, r28	; 61
    40ce:	cf 91       	pop	r28
    40d0:	df 91       	pop	r29
    40d2:	08 95       	ret

000040d4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    40d4:	df 93       	push	r29
    40d6:	cf 93       	push	r28
    40d8:	cd b7       	in	r28, 0x3d	; 61
    40da:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    40dc:	81 e0       	ldi	r24, 0x01	; 1
    40de:	80 93 5c 07 	sts	0x075C, r24
}
    40e2:	cf 91       	pop	r28
    40e4:	df 91       	pop	r29
    40e6:	08 95       	ret

000040e8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    40e8:	df 93       	push	r29
    40ea:	cf 93       	push	r28
    40ec:	00 d0       	rcall	.+0      	; 0x40ee <prvIdleTask+0x6>
    40ee:	cd b7       	in	r28, 0x3d	; 61
    40f0:	de b7       	in	r29, 0x3e	; 62
    40f2:	9a 83       	std	Y+2, r25	; 0x02
    40f4:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    40f6:	0e 94 bd 20 	call	0x417a	; 0x417a <prvCheckTasksWaitingTermination>
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    40fa:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vPortYield>
    40fe:	fb cf       	rjmp	.-10     	; 0x40f6 <prvIdleTask+0xe>

00004100 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4100:	df 93       	push	r29
    4102:	cf 93       	push	r28
    4104:	0f 92       	push	r0
    4106:	cd b7       	in	r28, 0x3d	; 61
    4108:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    410a:	19 82       	std	Y+1, r1	; 0x01
    410c:	13 c0       	rjmp	.+38     	; 0x4134 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    410e:	89 81       	ldd	r24, Y+1	; 0x01
    4110:	28 2f       	mov	r18, r24
    4112:	30 e0       	ldi	r19, 0x00	; 0
    4114:	c9 01       	movw	r24, r18
    4116:	88 0f       	add	r24, r24
    4118:	99 1f       	adc	r25, r25
    411a:	88 0f       	add	r24, r24
    411c:	99 1f       	adc	r25, r25
    411e:	88 0f       	add	r24, r24
    4120:	99 1f       	adc	r25, r25
    4122:	82 0f       	add	r24, r18
    4124:	93 1f       	adc	r25, r19
    4126:	8c 59       	subi	r24, 0x9C	; 156
    4128:	98 4f       	sbci	r25, 0xF8	; 248
    412a:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    412e:	89 81       	ldd	r24, Y+1	; 0x01
    4130:	8f 5f       	subi	r24, 0xFF	; 255
    4132:	89 83       	std	Y+1, r24	; 0x01
    4134:	89 81       	ldd	r24, Y+1	; 0x01
    4136:	84 30       	cpi	r24, 0x04	; 4
    4138:	50 f3       	brcs	.-44     	; 0x410e <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    413a:	88 e8       	ldi	r24, 0x88	; 136
    413c:	97 e0       	ldi	r25, 0x07	; 7
    413e:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    4142:	81 e9       	ldi	r24, 0x91	; 145
    4144:	97 e0       	ldi	r25, 0x07	; 7
    4146:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    414a:	8e e9       	ldi	r24, 0x9E	; 158
    414c:	97 e0       	ldi	r25, 0x07	; 7
    414e:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    4152:	87 ea       	ldi	r24, 0xA7	; 167
    4154:	97 e0       	ldi	r25, 0x07	; 7
    4156:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    415a:	88 e8       	ldi	r24, 0x88	; 136
    415c:	97 e0       	ldi	r25, 0x07	; 7
    415e:	90 93 9b 07 	sts	0x079B, r25
    4162:	80 93 9a 07 	sts	0x079A, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4166:	81 e9       	ldi	r24, 0x91	; 145
    4168:	97 e0       	ldi	r25, 0x07	; 7
    416a:	90 93 9d 07 	sts	0x079D, r25
    416e:	80 93 9c 07 	sts	0x079C, r24
}
    4172:	0f 90       	pop	r0
    4174:	cf 91       	pop	r28
    4176:	df 91       	pop	r29
    4178:	08 95       	ret

0000417a <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    417a:	df 93       	push	r29
    417c:	cf 93       	push	r28
    417e:	cd b7       	in	r28, 0x3d	; 61
    4180:	de b7       	in	r29, 0x3e	; 62

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    4182:	cf 91       	pop	r28
    4184:	df 91       	pop	r29
    4186:	08 95       	ret

00004188 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4188:	df 93       	push	r29
    418a:	cf 93       	push	r28
    418c:	00 d0       	rcall	.+0      	; 0x418e <prvResetNextTaskUnblockTime+0x6>
    418e:	cd b7       	in	r28, 0x3d	; 61
    4190:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4192:	e0 91 9a 07 	lds	r30, 0x079A
    4196:	f0 91 9b 07 	lds	r31, 0x079B
    419a:	80 81       	ld	r24, Z
    419c:	88 23       	and	r24, r24
    419e:	39 f4       	brne	.+14     	; 0x41ae <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    41a0:	8f ef       	ldi	r24, 0xFF	; 255
    41a2:	9f ef       	ldi	r25, 0xFF	; 255
    41a4:	90 93 60 07 	sts	0x0760, r25
    41a8:	80 93 5f 07 	sts	0x075F, r24
    41ac:	13 c0       	rjmp	.+38     	; 0x41d4 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    41ae:	e0 91 9a 07 	lds	r30, 0x079A
    41b2:	f0 91 9b 07 	lds	r31, 0x079B
    41b6:	05 80       	ldd	r0, Z+5	; 0x05
    41b8:	f6 81       	ldd	r31, Z+6	; 0x06
    41ba:	e0 2d       	mov	r30, r0
    41bc:	86 81       	ldd	r24, Z+6	; 0x06
    41be:	97 81       	ldd	r25, Z+7	; 0x07
    41c0:	9a 83       	std	Y+2, r25	; 0x02
    41c2:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    41c4:	e9 81       	ldd	r30, Y+1	; 0x01
    41c6:	fa 81       	ldd	r31, Y+2	; 0x02
    41c8:	82 81       	ldd	r24, Z+2	; 0x02
    41ca:	93 81       	ldd	r25, Z+3	; 0x03
    41cc:	90 93 60 07 	sts	0x0760, r25
    41d0:	80 93 5f 07 	sts	0x075F, r24
	}
}
    41d4:	0f 90       	pop	r0
    41d6:	0f 90       	pop	r0
    41d8:	cf 91       	pop	r28
    41da:	df 91       	pop	r29
    41dc:	08 95       	ret

000041de <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    41de:	df 93       	push	r29
    41e0:	cf 93       	push	r28
    41e2:	00 d0       	rcall	.+0      	; 0x41e4 <xTaskGetCurrentTaskHandle+0x6>
    41e4:	cd b7       	in	r28, 0x3d	; 61
    41e6:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    41e8:	80 91 54 07 	lds	r24, 0x0754
    41ec:	90 91 55 07 	lds	r25, 0x0755
    41f0:	9a 83       	std	Y+2, r25	; 0x02
    41f2:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    41f4:	89 81       	ldd	r24, Y+1	; 0x01
    41f6:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    41f8:	0f 90       	pop	r0
    41fa:	0f 90       	pop	r0
    41fc:	cf 91       	pop	r28
    41fe:	df 91       	pop	r29
    4200:	08 95       	ret

00004202 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4202:	df 93       	push	r29
    4204:	cf 93       	push	r28
    4206:	00 d0       	rcall	.+0      	; 0x4208 <uxTaskResetEventItemValue+0x6>
    4208:	cd b7       	in	r28, 0x3d	; 61
    420a:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    420c:	e0 91 54 07 	lds	r30, 0x0754
    4210:	f0 91 55 07 	lds	r31, 0x0755
    4214:	84 85       	ldd	r24, Z+12	; 0x0c
    4216:	95 85       	ldd	r25, Z+13	; 0x0d
    4218:	9a 83       	std	Y+2, r25	; 0x02
    421a:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    421c:	a0 91 54 07 	lds	r26, 0x0754
    4220:	b0 91 55 07 	lds	r27, 0x0755
    4224:	e0 91 54 07 	lds	r30, 0x0754
    4228:	f0 91 55 07 	lds	r31, 0x0755
    422c:	86 89       	ldd	r24, Z+22	; 0x16
    422e:	28 2f       	mov	r18, r24
    4230:	30 e0       	ldi	r19, 0x00	; 0
    4232:	84 e0       	ldi	r24, 0x04	; 4
    4234:	90 e0       	ldi	r25, 0x00	; 0
    4236:	82 1b       	sub	r24, r18
    4238:	93 0b       	sbc	r25, r19
    423a:	1d 96       	adiw	r26, 0x0d	; 13
    423c:	9c 93       	st	X, r25
    423e:	8e 93       	st	-X, r24
    4240:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    4242:	89 81       	ldd	r24, Y+1	; 0x01
    4244:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4246:	0f 90       	pop	r0
    4248:	0f 90       	pop	r0
    424a:	cf 91       	pop	r28
    424c:	df 91       	pop	r29
    424e:	08 95       	ret

00004250 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    4250:	df 93       	push	r29
    4252:	cf 93       	push	r28
    4254:	cd b7       	in	r28, 0x3d	; 61
    4256:	de b7       	in	r29, 0x3e	; 62
    4258:	27 97       	sbiw	r28, 0x07	; 7
    425a:	0f b6       	in	r0, 0x3f	; 63
    425c:	f8 94       	cli
    425e:	de bf       	out	0x3e, r29	; 62
    4260:	0f be       	out	0x3f, r0	; 63
    4262:	cd bf       	out	0x3d, r28	; 61
    4264:	8d 83       	std	Y+5, r24	; 0x05
    4266:	7f 83       	std	Y+7, r23	; 0x07
    4268:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    426a:	0f b6       	in	r0, 0x3f	; 63
    426c:	f8 94       	cli
    426e:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    4270:	e0 91 54 07 	lds	r30, 0x0754
    4274:	f0 91 55 07 	lds	r31, 0x0755
    4278:	81 a1       	ldd	r24, Z+33	; 0x21
    427a:	92 a1       	ldd	r25, Z+34	; 0x22
    427c:	a3 a1       	ldd	r26, Z+35	; 0x23
    427e:	b4 a1       	ldd	r27, Z+36	; 0x24
    4280:	00 97       	sbiw	r24, 0x00	; 0
    4282:	a1 05       	cpc	r26, r1
    4284:	b1 05       	cpc	r27, r1
    4286:	89 f4       	brne	.+34     	; 0x42aa <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4288:	e0 91 54 07 	lds	r30, 0x0754
    428c:	f0 91 55 07 	lds	r31, 0x0755
    4290:	81 e0       	ldi	r24, 0x01	; 1
    4292:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    4294:	8e 81       	ldd	r24, Y+6	; 0x06
    4296:	9f 81       	ldd	r25, Y+7	; 0x07
    4298:	00 97       	sbiw	r24, 0x00	; 0
    429a:	39 f0       	breq	.+14     	; 0x42aa <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    429c:	8e 81       	ldd	r24, Y+6	; 0x06
    429e:	9f 81       	ldd	r25, Y+7	; 0x07
    42a0:	61 e0       	ldi	r22, 0x01	; 1
    42a2:	0e 94 c8 24 	call	0x4990	; 0x4990 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    42a6:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    42aa:	0f 90       	pop	r0
    42ac:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    42ae:	0f b6       	in	r0, 0x3f	; 63
    42b0:	f8 94       	cli
    42b2:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    42b4:	e0 91 54 07 	lds	r30, 0x0754
    42b8:	f0 91 55 07 	lds	r31, 0x0755
    42bc:	81 a1       	ldd	r24, Z+33	; 0x21
    42be:	92 a1       	ldd	r25, Z+34	; 0x22
    42c0:	a3 a1       	ldd	r26, Z+35	; 0x23
    42c2:	b4 a1       	ldd	r27, Z+36	; 0x24
    42c4:	89 83       	std	Y+1, r24	; 0x01
    42c6:	9a 83       	std	Y+2, r25	; 0x02
    42c8:	ab 83       	std	Y+3, r26	; 0x03
    42ca:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    42cc:	89 81       	ldd	r24, Y+1	; 0x01
    42ce:	9a 81       	ldd	r25, Y+2	; 0x02
    42d0:	ab 81       	ldd	r26, Y+3	; 0x03
    42d2:	bc 81       	ldd	r27, Y+4	; 0x04
    42d4:	00 97       	sbiw	r24, 0x00	; 0
    42d6:	a1 05       	cpc	r26, r1
    42d8:	b1 05       	cpc	r27, r1
    42da:	d9 f0       	breq	.+54     	; 0x4312 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    42dc:	8d 81       	ldd	r24, Y+5	; 0x05
    42de:	88 23       	and	r24, r24
    42e0:	49 f0       	breq	.+18     	; 0x42f4 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    42e2:	e0 91 54 07 	lds	r30, 0x0754
    42e6:	f0 91 55 07 	lds	r31, 0x0755
    42ea:	11 a2       	std	Z+33, r1	; 0x21
    42ec:	12 a2       	std	Z+34, r1	; 0x22
    42ee:	13 a2       	std	Z+35, r1	; 0x23
    42f0:	14 a2       	std	Z+36, r1	; 0x24
    42f2:	0f c0       	rjmp	.+30     	; 0x4312 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    42f4:	e0 91 54 07 	lds	r30, 0x0754
    42f8:	f0 91 55 07 	lds	r31, 0x0755
    42fc:	89 81       	ldd	r24, Y+1	; 0x01
    42fe:	9a 81       	ldd	r25, Y+2	; 0x02
    4300:	ab 81       	ldd	r26, Y+3	; 0x03
    4302:	bc 81       	ldd	r27, Y+4	; 0x04
    4304:	01 97       	sbiw	r24, 0x01	; 1
    4306:	a1 09       	sbc	r26, r1
    4308:	b1 09       	sbc	r27, r1
    430a:	81 a3       	std	Z+33, r24	; 0x21
    430c:	92 a3       	std	Z+34, r25	; 0x22
    430e:	a3 a3       	std	Z+35, r26	; 0x23
    4310:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4312:	e0 91 54 07 	lds	r30, 0x0754
    4316:	f0 91 55 07 	lds	r31, 0x0755
    431a:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    431c:	0f 90       	pop	r0
    431e:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    4320:	89 81       	ldd	r24, Y+1	; 0x01
    4322:	9a 81       	ldd	r25, Y+2	; 0x02
    4324:	ab 81       	ldd	r26, Y+3	; 0x03
    4326:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    4328:	bc 01       	movw	r22, r24
    432a:	cd 01       	movw	r24, r26
    432c:	27 96       	adiw	r28, 0x07	; 7
    432e:	0f b6       	in	r0, 0x3f	; 63
    4330:	f8 94       	cli
    4332:	de bf       	out	0x3e, r29	; 62
    4334:	0f be       	out	0x3f, r0	; 63
    4336:	cd bf       	out	0x3d, r28	; 61
    4338:	cf 91       	pop	r28
    433a:	df 91       	pop	r29
    433c:	08 95       	ret

0000433e <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    433e:	ef 92       	push	r14
    4340:	ff 92       	push	r15
    4342:	0f 93       	push	r16
    4344:	1f 93       	push	r17
    4346:	df 93       	push	r29
    4348:	cf 93       	push	r28
    434a:	cd b7       	in	r28, 0x3d	; 61
    434c:	de b7       	in	r29, 0x3e	; 62
    434e:	2d 97       	sbiw	r28, 0x0d	; 13
    4350:	0f b6       	in	r0, 0x3f	; 63
    4352:	f8 94       	cli
    4354:	de bf       	out	0x3e, r29	; 62
    4356:	0f be       	out	0x3f, r0	; 63
    4358:	cd bf       	out	0x3d, r28	; 61
    435a:	6a 83       	std	Y+2, r22	; 0x02
    435c:	7b 83       	std	Y+3, r23	; 0x03
    435e:	8c 83       	std	Y+4, r24	; 0x04
    4360:	9d 83       	std	Y+5, r25	; 0x05
    4362:	2e 83       	std	Y+6, r18	; 0x06
    4364:	3f 83       	std	Y+7, r19	; 0x07
    4366:	48 87       	std	Y+8, r20	; 0x08
    4368:	59 87       	std	Y+9, r21	; 0x09
    436a:	1b 87       	std	Y+11, r17	; 0x0b
    436c:	0a 87       	std	Y+10, r16	; 0x0a
    436e:	fd 86       	std	Y+13, r15	; 0x0d
    4370:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    4372:	0f b6       	in	r0, 0x3f	; 63
    4374:	f8 94       	cli
    4376:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4378:	e0 91 54 07 	lds	r30, 0x0754
    437c:	f0 91 55 07 	lds	r31, 0x0755
    4380:	85 a1       	ldd	r24, Z+37	; 0x25
    4382:	82 30       	cpi	r24, 0x02	; 2
    4384:	49 f1       	breq	.+82     	; 0x43d8 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    4386:	e0 91 54 07 	lds	r30, 0x0754
    438a:	f0 91 55 07 	lds	r31, 0x0755
    438e:	21 a1       	ldd	r18, Z+33	; 0x21
    4390:	32 a1       	ldd	r19, Z+34	; 0x22
    4392:	43 a1       	ldd	r20, Z+35	; 0x23
    4394:	54 a1       	ldd	r21, Z+36	; 0x24
    4396:	8a 81       	ldd	r24, Y+2	; 0x02
    4398:	9b 81       	ldd	r25, Y+3	; 0x03
    439a:	ac 81       	ldd	r26, Y+4	; 0x04
    439c:	bd 81       	ldd	r27, Y+5	; 0x05
    439e:	80 95       	com	r24
    43a0:	90 95       	com	r25
    43a2:	a0 95       	com	r26
    43a4:	b0 95       	com	r27
    43a6:	82 23       	and	r24, r18
    43a8:	93 23       	and	r25, r19
    43aa:	a4 23       	and	r26, r20
    43ac:	b5 23       	and	r27, r21
    43ae:	81 a3       	std	Z+33, r24	; 0x21
    43b0:	92 a3       	std	Z+34, r25	; 0x22
    43b2:	a3 a3       	std	Z+35, r26	; 0x23
    43b4:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    43b6:	e0 91 54 07 	lds	r30, 0x0754
    43ba:	f0 91 55 07 	lds	r31, 0x0755
    43be:	81 e0       	ldi	r24, 0x01	; 1
    43c0:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    43c2:	8c 85       	ldd	r24, Y+12	; 0x0c
    43c4:	9d 85       	ldd	r25, Y+13	; 0x0d
    43c6:	00 97       	sbiw	r24, 0x00	; 0
    43c8:	39 f0       	breq	.+14     	; 0x43d8 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    43ca:	8c 85       	ldd	r24, Y+12	; 0x0c
    43cc:	9d 85       	ldd	r25, Y+13	; 0x0d
    43ce:	61 e0       	ldi	r22, 0x01	; 1
    43d0:	0e 94 c8 24 	call	0x4990	; 0x4990 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    43d4:	0e 94 d5 08 	call	0x11aa	; 0x11aa <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    43d8:	0f 90       	pop	r0
    43da:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    43dc:	0f b6       	in	r0, 0x3f	; 63
    43de:	f8 94       	cli
    43e0:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    43e2:	8a 85       	ldd	r24, Y+10	; 0x0a
    43e4:	9b 85       	ldd	r25, Y+11	; 0x0b
    43e6:	00 97       	sbiw	r24, 0x00	; 0
    43e8:	71 f0       	breq	.+28     	; 0x4406 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    43ea:	e0 91 54 07 	lds	r30, 0x0754
    43ee:	f0 91 55 07 	lds	r31, 0x0755
    43f2:	81 a1       	ldd	r24, Z+33	; 0x21
    43f4:	92 a1       	ldd	r25, Z+34	; 0x22
    43f6:	a3 a1       	ldd	r26, Z+35	; 0x23
    43f8:	b4 a1       	ldd	r27, Z+36	; 0x24
    43fa:	ea 85       	ldd	r30, Y+10	; 0x0a
    43fc:	fb 85       	ldd	r31, Y+11	; 0x0b
    43fe:	80 83       	st	Z, r24
    4400:	91 83       	std	Z+1, r25	; 0x01
    4402:	a2 83       	std	Z+2, r26	; 0x02
    4404:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4406:	e0 91 54 07 	lds	r30, 0x0754
    440a:	f0 91 55 07 	lds	r31, 0x0755
    440e:	85 a1       	ldd	r24, Z+37	; 0x25
    4410:	82 30       	cpi	r24, 0x02	; 2
    4412:	11 f0       	breq	.+4      	; 0x4418 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4414:	19 82       	std	Y+1, r1	; 0x01
    4416:	1a c0       	rjmp	.+52     	; 0x444c <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4418:	e0 91 54 07 	lds	r30, 0x0754
    441c:	f0 91 55 07 	lds	r31, 0x0755
    4420:	21 a1       	ldd	r18, Z+33	; 0x21
    4422:	32 a1       	ldd	r19, Z+34	; 0x22
    4424:	43 a1       	ldd	r20, Z+35	; 0x23
    4426:	54 a1       	ldd	r21, Z+36	; 0x24
    4428:	8e 81       	ldd	r24, Y+6	; 0x06
    442a:	9f 81       	ldd	r25, Y+7	; 0x07
    442c:	a8 85       	ldd	r26, Y+8	; 0x08
    442e:	b9 85       	ldd	r27, Y+9	; 0x09
    4430:	80 95       	com	r24
    4432:	90 95       	com	r25
    4434:	a0 95       	com	r26
    4436:	b0 95       	com	r27
    4438:	82 23       	and	r24, r18
    443a:	93 23       	and	r25, r19
    443c:	a4 23       	and	r26, r20
    443e:	b5 23       	and	r27, r21
    4440:	81 a3       	std	Z+33, r24	; 0x21
    4442:	92 a3       	std	Z+34, r25	; 0x22
    4444:	a3 a3       	std	Z+35, r26	; 0x23
    4446:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    4448:	81 e0       	ldi	r24, 0x01	; 1
    444a:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    444c:	e0 91 54 07 	lds	r30, 0x0754
    4450:	f0 91 55 07 	lds	r31, 0x0755
    4454:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    4456:	0f 90       	pop	r0
    4458:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    445a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    445c:	2d 96       	adiw	r28, 0x0d	; 13
    445e:	0f b6       	in	r0, 0x3f	; 63
    4460:	f8 94       	cli
    4462:	de bf       	out	0x3e, r29	; 62
    4464:	0f be       	out	0x3f, r0	; 63
    4466:	cd bf       	out	0x3d, r28	; 61
    4468:	cf 91       	pop	r28
    446a:	df 91       	pop	r29
    446c:	1f 91       	pop	r17
    446e:	0f 91       	pop	r16
    4470:	ff 90       	pop	r15
    4472:	ef 90       	pop	r14
    4474:	08 95       	ret

00004476 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    4476:	0f 93       	push	r16
    4478:	1f 93       	push	r17
    447a:	df 93       	push	r29
    447c:	cf 93       	push	r28
    447e:	cd b7       	in	r28, 0x3d	; 61
    4480:	de b7       	in	r29, 0x3e	; 62
    4482:	61 97       	sbiw	r28, 0x11	; 17
    4484:	0f b6       	in	r0, 0x3f	; 63
    4486:	f8 94       	cli
    4488:	de bf       	out	0x3e, r29	; 62
    448a:	0f be       	out	0x3f, r0	; 63
    448c:	cd bf       	out	0x3d, r28	; 61
    448e:	9e 83       	std	Y+6, r25	; 0x06
    4490:	8d 83       	std	Y+5, r24	; 0x05
    4492:	4f 83       	std	Y+7, r20	; 0x07
    4494:	58 87       	std	Y+8, r21	; 0x08
    4496:	69 87       	std	Y+9, r22	; 0x09
    4498:	7a 87       	std	Y+10, r23	; 0x0a
    449a:	2b 87       	std	Y+11, r18	; 0x0b
    449c:	1d 87       	std	Y+13, r17	; 0x0d
    449e:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    44a0:	81 e0       	ldi	r24, 0x01	; 1
    44a2:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    44a4:	8d 81       	ldd	r24, Y+5	; 0x05
    44a6:	9e 81       	ldd	r25, Y+6	; 0x06
    44a8:	9c 83       	std	Y+4, r25	; 0x04
    44aa:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    44ac:	0f b6       	in	r0, 0x3f	; 63
    44ae:	f8 94       	cli
    44b0:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    44b2:	8c 85       	ldd	r24, Y+12	; 0x0c
    44b4:	9d 85       	ldd	r25, Y+13	; 0x0d
    44b6:	00 97       	sbiw	r24, 0x00	; 0
    44b8:	61 f0       	breq	.+24     	; 0x44d2 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    44ba:	eb 81       	ldd	r30, Y+3	; 0x03
    44bc:	fc 81       	ldd	r31, Y+4	; 0x04
    44be:	81 a1       	ldd	r24, Z+33	; 0x21
    44c0:	92 a1       	ldd	r25, Z+34	; 0x22
    44c2:	a3 a1       	ldd	r26, Z+35	; 0x23
    44c4:	b4 a1       	ldd	r27, Z+36	; 0x24
    44c6:	ec 85       	ldd	r30, Y+12	; 0x0c
    44c8:	fd 85       	ldd	r31, Y+13	; 0x0d
    44ca:	80 83       	st	Z, r24
    44cc:	91 83       	std	Z+1, r25	; 0x01
    44ce:	a2 83       	std	Z+2, r26	; 0x02
    44d0:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    44d2:	eb 81       	ldd	r30, Y+3	; 0x03
    44d4:	fc 81       	ldd	r31, Y+4	; 0x04
    44d6:	85 a1       	ldd	r24, Z+37	; 0x25
    44d8:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    44da:	eb 81       	ldd	r30, Y+3	; 0x03
    44dc:	fc 81       	ldd	r31, Y+4	; 0x04
    44de:	82 e0       	ldi	r24, 0x02	; 2
    44e0:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    44e2:	8b 85       	ldd	r24, Y+11	; 0x0b
    44e4:	28 2f       	mov	r18, r24
    44e6:	30 e0       	ldi	r19, 0x00	; 0
    44e8:	39 8b       	std	Y+17, r19	; 0x11
    44ea:	28 8b       	std	Y+16, r18	; 0x10
    44ec:	88 89       	ldd	r24, Y+16	; 0x10
    44ee:	99 89       	ldd	r25, Y+17	; 0x11
    44f0:	82 30       	cpi	r24, 0x02	; 2
    44f2:	91 05       	cpc	r25, r1
    44f4:	59 f1       	breq	.+86     	; 0x454c <xTaskGenericNotify+0xd6>
    44f6:	28 89       	ldd	r18, Y+16	; 0x10
    44f8:	39 89       	ldd	r19, Y+17	; 0x11
    44fa:	23 30       	cpi	r18, 0x03	; 3
    44fc:	31 05       	cpc	r19, r1
    44fe:	34 f4       	brge	.+12     	; 0x450c <xTaskGenericNotify+0x96>
    4500:	88 89       	ldd	r24, Y+16	; 0x10
    4502:	99 89       	ldd	r25, Y+17	; 0x11
    4504:	81 30       	cpi	r24, 0x01	; 1
    4506:	91 05       	cpc	r25, r1
    4508:	61 f0       	breq	.+24     	; 0x4522 <xTaskGenericNotify+0xac>
    450a:	4a c0       	rjmp	.+148    	; 0x45a0 <xTaskGenericNotify+0x12a>
    450c:	28 89       	ldd	r18, Y+16	; 0x10
    450e:	39 89       	ldd	r19, Y+17	; 0x11
    4510:	23 30       	cpi	r18, 0x03	; 3
    4512:	31 05       	cpc	r19, r1
    4514:	59 f1       	breq	.+86     	; 0x456c <xTaskGenericNotify+0xf6>
    4516:	88 89       	ldd	r24, Y+16	; 0x10
    4518:	99 89       	ldd	r25, Y+17	; 0x11
    451a:	84 30       	cpi	r24, 0x04	; 4
    451c:	91 05       	cpc	r25, r1
    451e:	89 f1       	breq	.+98     	; 0x4582 <xTaskGenericNotify+0x10c>
    4520:	3f c0       	rjmp	.+126    	; 0x45a0 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4522:	eb 81       	ldd	r30, Y+3	; 0x03
    4524:	fc 81       	ldd	r31, Y+4	; 0x04
    4526:	21 a1       	ldd	r18, Z+33	; 0x21
    4528:	32 a1       	ldd	r19, Z+34	; 0x22
    452a:	43 a1       	ldd	r20, Z+35	; 0x23
    452c:	54 a1       	ldd	r21, Z+36	; 0x24
    452e:	8f 81       	ldd	r24, Y+7	; 0x07
    4530:	98 85       	ldd	r25, Y+8	; 0x08
    4532:	a9 85       	ldd	r26, Y+9	; 0x09
    4534:	ba 85       	ldd	r27, Y+10	; 0x0a
    4536:	82 2b       	or	r24, r18
    4538:	93 2b       	or	r25, r19
    453a:	a4 2b       	or	r26, r20
    453c:	b5 2b       	or	r27, r21
    453e:	eb 81       	ldd	r30, Y+3	; 0x03
    4540:	fc 81       	ldd	r31, Y+4	; 0x04
    4542:	81 a3       	std	Z+33, r24	; 0x21
    4544:	92 a3       	std	Z+34, r25	; 0x22
    4546:	a3 a3       	std	Z+35, r26	; 0x23
    4548:	b4 a3       	std	Z+36, r27	; 0x24
    454a:	2a c0       	rjmp	.+84     	; 0x45a0 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    454c:	eb 81       	ldd	r30, Y+3	; 0x03
    454e:	fc 81       	ldd	r31, Y+4	; 0x04
    4550:	81 a1       	ldd	r24, Z+33	; 0x21
    4552:	92 a1       	ldd	r25, Z+34	; 0x22
    4554:	a3 a1       	ldd	r26, Z+35	; 0x23
    4556:	b4 a1       	ldd	r27, Z+36	; 0x24
    4558:	01 96       	adiw	r24, 0x01	; 1
    455a:	a1 1d       	adc	r26, r1
    455c:	b1 1d       	adc	r27, r1
    455e:	eb 81       	ldd	r30, Y+3	; 0x03
    4560:	fc 81       	ldd	r31, Y+4	; 0x04
    4562:	81 a3       	std	Z+33, r24	; 0x21
    4564:	92 a3       	std	Z+34, r25	; 0x22
    4566:	a3 a3       	std	Z+35, r26	; 0x23
    4568:	b4 a3       	std	Z+36, r27	; 0x24
    456a:	1a c0       	rjmp	.+52     	; 0x45a0 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    456c:	eb 81       	ldd	r30, Y+3	; 0x03
    456e:	fc 81       	ldd	r31, Y+4	; 0x04
    4570:	8f 81       	ldd	r24, Y+7	; 0x07
    4572:	98 85       	ldd	r25, Y+8	; 0x08
    4574:	a9 85       	ldd	r26, Y+9	; 0x09
    4576:	ba 85       	ldd	r27, Y+10	; 0x0a
    4578:	81 a3       	std	Z+33, r24	; 0x21
    457a:	92 a3       	std	Z+34, r25	; 0x22
    457c:	a3 a3       	std	Z+35, r26	; 0x23
    457e:	b4 a3       	std	Z+36, r27	; 0x24
    4580:	0f c0       	rjmp	.+30     	; 0x45a0 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4582:	89 81       	ldd	r24, Y+1	; 0x01
    4584:	82 30       	cpi	r24, 0x02	; 2
    4586:	59 f0       	breq	.+22     	; 0x459e <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4588:	eb 81       	ldd	r30, Y+3	; 0x03
    458a:	fc 81       	ldd	r31, Y+4	; 0x04
    458c:	8f 81       	ldd	r24, Y+7	; 0x07
    458e:	98 85       	ldd	r25, Y+8	; 0x08
    4590:	a9 85       	ldd	r26, Y+9	; 0x09
    4592:	ba 85       	ldd	r27, Y+10	; 0x0a
    4594:	81 a3       	std	Z+33, r24	; 0x21
    4596:	92 a3       	std	Z+34, r25	; 0x22
    4598:	a3 a3       	std	Z+35, r26	; 0x23
    459a:	b4 a3       	std	Z+36, r27	; 0x24
    459c:	01 c0       	rjmp	.+2      	; 0x45a0 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    459e:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    45a0:	89 81       	ldd	r24, Y+1	; 0x01
    45a2:	81 30       	cpi	r24, 0x01	; 1
    45a4:	79 f5       	brne	.+94     	; 0x4604 <xTaskGenericNotify+0x18e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    45a6:	8b 81       	ldd	r24, Y+3	; 0x03
    45a8:	9c 81       	ldd	r25, Y+4	; 0x04
    45aa:	02 96       	adiw	r24, 0x02	; 2
    45ac:	0e 94 ca 06 	call	0xd94	; 0xd94 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    45b0:	eb 81       	ldd	r30, Y+3	; 0x03
    45b2:	fc 81       	ldd	r31, Y+4	; 0x04
    45b4:	96 89       	ldd	r25, Z+22	; 0x16
    45b6:	80 91 59 07 	lds	r24, 0x0759
    45ba:	89 17       	cp	r24, r25
    45bc:	28 f4       	brcc	.+10     	; 0x45c8 <xTaskGenericNotify+0x152>
    45be:	eb 81       	ldd	r30, Y+3	; 0x03
    45c0:	fc 81       	ldd	r31, Y+4	; 0x04
    45c2:	86 89       	ldd	r24, Z+22	; 0x16
    45c4:	80 93 59 07 	sts	0x0759, r24
    45c8:	eb 81       	ldd	r30, Y+3	; 0x03
    45ca:	fc 81       	ldd	r31, Y+4	; 0x04
    45cc:	86 89       	ldd	r24, Z+22	; 0x16
    45ce:	28 2f       	mov	r18, r24
    45d0:	30 e0       	ldi	r19, 0x00	; 0
    45d2:	c9 01       	movw	r24, r18
    45d4:	88 0f       	add	r24, r24
    45d6:	99 1f       	adc	r25, r25
    45d8:	88 0f       	add	r24, r24
    45da:	99 1f       	adc	r25, r25
    45dc:	88 0f       	add	r24, r24
    45de:	99 1f       	adc	r25, r25
    45e0:	82 0f       	add	r24, r18
    45e2:	93 1f       	adc	r25, r19
    45e4:	ac 01       	movw	r20, r24
    45e6:	4c 59       	subi	r20, 0x9C	; 156
    45e8:	58 4f       	sbci	r21, 0xF8	; 248
    45ea:	8b 81       	ldd	r24, Y+3	; 0x03
    45ec:	9c 81       	ldd	r25, Y+4	; 0x04
    45ee:	9c 01       	movw	r18, r24
    45f0:	2e 5f       	subi	r18, 0xFE	; 254
    45f2:	3f 4f       	sbci	r19, 0xFF	; 255
    45f4:	ca 01       	movw	r24, r20
    45f6:	b9 01       	movw	r22, r18
    45f8:	0e 94 1a 06 	call	0xc34	; 0xc34 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    45fc:	20 91 54 07 	lds	r18, 0x0754
    4600:	30 91 55 07 	lds	r19, 0x0755
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4604:	0f 90       	pop	r0
    4606:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4608:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    460a:	61 96       	adiw	r28, 0x11	; 17
    460c:	0f b6       	in	r0, 0x3f	; 63
    460e:	f8 94       	cli
    4610:	de bf       	out	0x3e, r29	; 62
    4612:	0f be       	out	0x3f, r0	; 63
    4614:	cd bf       	out	0x3d, r28	; 61
    4616:	cf 91       	pop	r28
    4618:	df 91       	pop	r29
    461a:	1f 91       	pop	r17
    461c:	0f 91       	pop	r16
    461e:	08 95       	ret

00004620 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4620:	ef 92       	push	r14
    4622:	ff 92       	push	r15
    4624:	0f 93       	push	r16
    4626:	1f 93       	push	r17
    4628:	df 93       	push	r29
    462a:	cf 93       	push	r28
    462c:	cd b7       	in	r28, 0x3d	; 61
    462e:	de b7       	in	r29, 0x3e	; 62
    4630:	62 97       	sbiw	r28, 0x12	; 18
    4632:	0f b6       	in	r0, 0x3f	; 63
    4634:	f8 94       	cli
    4636:	de bf       	out	0x3e, r29	; 62
    4638:	0f be       	out	0x3f, r0	; 63
    463a:	cd bf       	out	0x3d, r28	; 61
    463c:	9f 83       	std	Y+7, r25	; 0x07
    463e:	8e 83       	std	Y+6, r24	; 0x06
    4640:	48 87       	std	Y+8, r20	; 0x08
    4642:	59 87       	std	Y+9, r21	; 0x09
    4644:	6a 87       	std	Y+10, r22	; 0x0a
    4646:	7b 87       	std	Y+11, r23	; 0x0b
    4648:	2c 87       	std	Y+12, r18	; 0x0c
    464a:	1e 87       	std	Y+14, r17	; 0x0e
    464c:	0d 87       	std	Y+13, r16	; 0x0d
    464e:	f8 8a       	std	Y+16, r15	; 0x10
    4650:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    4652:	81 e0       	ldi	r24, 0x01	; 1
    4654:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    4656:	8e 81       	ldd	r24, Y+6	; 0x06
    4658:	9f 81       	ldd	r25, Y+7	; 0x07
    465a:	9d 83       	std	Y+5, r25	; 0x05
    465c:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    465e:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    4660:	8d 85       	ldd	r24, Y+13	; 0x0d
    4662:	9e 85       	ldd	r25, Y+14	; 0x0e
    4664:	00 97       	sbiw	r24, 0x00	; 0
    4666:	61 f0       	breq	.+24     	; 0x4680 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4668:	ec 81       	ldd	r30, Y+4	; 0x04
    466a:	fd 81       	ldd	r31, Y+5	; 0x05
    466c:	81 a1       	ldd	r24, Z+33	; 0x21
    466e:	92 a1       	ldd	r25, Z+34	; 0x22
    4670:	a3 a1       	ldd	r26, Z+35	; 0x23
    4672:	b4 a1       	ldd	r27, Z+36	; 0x24
    4674:	ed 85       	ldd	r30, Y+13	; 0x0d
    4676:	fe 85       	ldd	r31, Y+14	; 0x0e
    4678:	80 83       	st	Z, r24
    467a:	91 83       	std	Z+1, r25	; 0x01
    467c:	a2 83       	std	Z+2, r26	; 0x02
    467e:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4680:	ec 81       	ldd	r30, Y+4	; 0x04
    4682:	fd 81       	ldd	r31, Y+5	; 0x05
    4684:	85 a1       	ldd	r24, Z+37	; 0x25
    4686:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4688:	ec 81       	ldd	r30, Y+4	; 0x04
    468a:	fd 81       	ldd	r31, Y+5	; 0x05
    468c:	82 e0       	ldi	r24, 0x02	; 2
    468e:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    4690:	8c 85       	ldd	r24, Y+12	; 0x0c
    4692:	28 2f       	mov	r18, r24
    4694:	30 e0       	ldi	r19, 0x00	; 0
    4696:	3a 8b       	std	Y+18, r19	; 0x12
    4698:	29 8b       	std	Y+17, r18	; 0x11
    469a:	89 89       	ldd	r24, Y+17	; 0x11
    469c:	9a 89       	ldd	r25, Y+18	; 0x12
    469e:	82 30       	cpi	r24, 0x02	; 2
    46a0:	91 05       	cpc	r25, r1
    46a2:	59 f1       	breq	.+86     	; 0x46fa <xTaskGenericNotifyFromISR+0xda>
    46a4:	29 89       	ldd	r18, Y+17	; 0x11
    46a6:	3a 89       	ldd	r19, Y+18	; 0x12
    46a8:	23 30       	cpi	r18, 0x03	; 3
    46aa:	31 05       	cpc	r19, r1
    46ac:	34 f4       	brge	.+12     	; 0x46ba <xTaskGenericNotifyFromISR+0x9a>
    46ae:	89 89       	ldd	r24, Y+17	; 0x11
    46b0:	9a 89       	ldd	r25, Y+18	; 0x12
    46b2:	81 30       	cpi	r24, 0x01	; 1
    46b4:	91 05       	cpc	r25, r1
    46b6:	61 f0       	breq	.+24     	; 0x46d0 <xTaskGenericNotifyFromISR+0xb0>
    46b8:	4a c0       	rjmp	.+148    	; 0x474e <xTaskGenericNotifyFromISR+0x12e>
    46ba:	29 89       	ldd	r18, Y+17	; 0x11
    46bc:	3a 89       	ldd	r19, Y+18	; 0x12
    46be:	23 30       	cpi	r18, 0x03	; 3
    46c0:	31 05       	cpc	r19, r1
    46c2:	59 f1       	breq	.+86     	; 0x471a <xTaskGenericNotifyFromISR+0xfa>
    46c4:	89 89       	ldd	r24, Y+17	; 0x11
    46c6:	9a 89       	ldd	r25, Y+18	; 0x12
    46c8:	84 30       	cpi	r24, 0x04	; 4
    46ca:	91 05       	cpc	r25, r1
    46cc:	89 f1       	breq	.+98     	; 0x4730 <xTaskGenericNotifyFromISR+0x110>
    46ce:	3f c0       	rjmp	.+126    	; 0x474e <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    46d0:	ec 81       	ldd	r30, Y+4	; 0x04
    46d2:	fd 81       	ldd	r31, Y+5	; 0x05
    46d4:	21 a1       	ldd	r18, Z+33	; 0x21
    46d6:	32 a1       	ldd	r19, Z+34	; 0x22
    46d8:	43 a1       	ldd	r20, Z+35	; 0x23
    46da:	54 a1       	ldd	r21, Z+36	; 0x24
    46dc:	88 85       	ldd	r24, Y+8	; 0x08
    46de:	99 85       	ldd	r25, Y+9	; 0x09
    46e0:	aa 85       	ldd	r26, Y+10	; 0x0a
    46e2:	bb 85       	ldd	r27, Y+11	; 0x0b
    46e4:	82 2b       	or	r24, r18
    46e6:	93 2b       	or	r25, r19
    46e8:	a4 2b       	or	r26, r20
    46ea:	b5 2b       	or	r27, r21
    46ec:	ec 81       	ldd	r30, Y+4	; 0x04
    46ee:	fd 81       	ldd	r31, Y+5	; 0x05
    46f0:	81 a3       	std	Z+33, r24	; 0x21
    46f2:	92 a3       	std	Z+34, r25	; 0x22
    46f4:	a3 a3       	std	Z+35, r26	; 0x23
    46f6:	b4 a3       	std	Z+36, r27	; 0x24
    46f8:	2a c0       	rjmp	.+84     	; 0x474e <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    46fa:	ec 81       	ldd	r30, Y+4	; 0x04
    46fc:	fd 81       	ldd	r31, Y+5	; 0x05
    46fe:	81 a1       	ldd	r24, Z+33	; 0x21
    4700:	92 a1       	ldd	r25, Z+34	; 0x22
    4702:	a3 a1       	ldd	r26, Z+35	; 0x23
    4704:	b4 a1       	ldd	r27, Z+36	; 0x24
    4706:	01 96       	adiw	r24, 0x01	; 1
    4708:	a1 1d       	adc	r26, r1
    470a:	b1 1d       	adc	r27, r1
    470c:	ec 81       	ldd	r30, Y+4	; 0x04
    470e:	fd 81       	ldd	r31, Y+5	; 0x05
    4710:	81 a3       	std	Z+33, r24	; 0x21
    4712:	92 a3       	std	Z+34, r25	; 0x22
    4714:	a3 a3       	std	Z+35, r26	; 0x23
    4716:	b4 a3       	std	Z+36, r27	; 0x24
    4718:	1a c0       	rjmp	.+52     	; 0x474e <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    471a:	ec 81       	ldd	r30, Y+4	; 0x04
    471c:	fd 81       	ldd	r31, Y+5	; 0x05
    471e:	88 85       	ldd	r24, Y+8	; 0x08
    4720:	99 85       	ldd	r25, Y+9	; 0x09
    4722:	aa 85       	ldd	r26, Y+10	; 0x0a
    4724:	bb 85       	ldd	r27, Y+11	; 0x0b
    4726:	81 a3       	std	Z+33, r24	; 0x21
    4728:	92 a3       	std	Z+34, r25	; 0x22
    472a:	a3 a3       	std	Z+35, r26	; 0x23
    472c:	b4 a3       	std	Z+36, r27	; 0x24
    472e:	0f c0       	rjmp	.+30     	; 0x474e <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4730:	8b 81       	ldd	r24, Y+3	; 0x03
    4732:	82 30       	cpi	r24, 0x02	; 2
    4734:	59 f0       	breq	.+22     	; 0x474c <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4736:	ec 81       	ldd	r30, Y+4	; 0x04
    4738:	fd 81       	ldd	r31, Y+5	; 0x05
    473a:	88 85       	ldd	r24, Y+8	; 0x08
    473c:	99 85       	ldd	r25, Y+9	; 0x09
    473e:	aa 85       	ldd	r26, Y+10	; 0x0a
    4740:	bb 85       	ldd	r27, Y+11	; 0x0b
    4742:	81 a3       	std	Z+33, r24	; 0x21
    4744:	92 a3       	std	Z+34, r25	; 0x22
    4746:	a3 a3       	std	Z+35, r26	; 0x23
    4748:	b4 a3       	std	Z+36, r27	; 0x24
    474a:	01 c0       	rjmp	.+2      	; 0x474e <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    474c:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    474e:	8b 81       	ldd	r24, Y+3	; 0x03
    4750:	81 30       	cpi	r24, 0x01	; 1
    4752:	09 f0       	breq	.+2      	; 0x4756 <xTaskGenericNotifyFromISR+0x136>
    4754:	4f c0       	rjmp	.+158    	; 0x47f4 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4756:	80 91 63 07 	lds	r24, 0x0763
    475a:	88 23       	and	r24, r24
    475c:	61 f5       	brne	.+88     	; 0x47b6 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    475e:	8c 81       	ldd	r24, Y+4	; 0x04
    4760:	9d 81       	ldd	r25, Y+5	; 0x05
    4762:	02 96       	adiw	r24, 0x02	; 2
    4764:	0e 94 ca 06 	call	0xd94	; 0xd94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4768:	ec 81       	ldd	r30, Y+4	; 0x04
    476a:	fd 81       	ldd	r31, Y+5	; 0x05
    476c:	96 89       	ldd	r25, Z+22	; 0x16
    476e:	80 91 59 07 	lds	r24, 0x0759
    4772:	89 17       	cp	r24, r25
    4774:	28 f4       	brcc	.+10     	; 0x4780 <xTaskGenericNotifyFromISR+0x160>
    4776:	ec 81       	ldd	r30, Y+4	; 0x04
    4778:	fd 81       	ldd	r31, Y+5	; 0x05
    477a:	86 89       	ldd	r24, Z+22	; 0x16
    477c:	80 93 59 07 	sts	0x0759, r24
    4780:	ec 81       	ldd	r30, Y+4	; 0x04
    4782:	fd 81       	ldd	r31, Y+5	; 0x05
    4784:	86 89       	ldd	r24, Z+22	; 0x16
    4786:	28 2f       	mov	r18, r24
    4788:	30 e0       	ldi	r19, 0x00	; 0
    478a:	c9 01       	movw	r24, r18
    478c:	88 0f       	add	r24, r24
    478e:	99 1f       	adc	r25, r25
    4790:	88 0f       	add	r24, r24
    4792:	99 1f       	adc	r25, r25
    4794:	88 0f       	add	r24, r24
    4796:	99 1f       	adc	r25, r25
    4798:	82 0f       	add	r24, r18
    479a:	93 1f       	adc	r25, r19
    479c:	ac 01       	movw	r20, r24
    479e:	4c 59       	subi	r20, 0x9C	; 156
    47a0:	58 4f       	sbci	r21, 0xF8	; 248
    47a2:	8c 81       	ldd	r24, Y+4	; 0x04
    47a4:	9d 81       	ldd	r25, Y+5	; 0x05
    47a6:	9c 01       	movw	r18, r24
    47a8:	2e 5f       	subi	r18, 0xFE	; 254
    47aa:	3f 4f       	sbci	r19, 0xFF	; 255
    47ac:	ca 01       	movw	r24, r20
    47ae:	b9 01       	movw	r22, r18
    47b0:	0e 94 1a 06 	call	0xc34	; 0xc34 <vListInsertEnd>
    47b4:	0a c0       	rjmp	.+20     	; 0x47ca <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    47b6:	8c 81       	ldd	r24, Y+4	; 0x04
    47b8:	9d 81       	ldd	r25, Y+5	; 0x05
    47ba:	9c 01       	movw	r18, r24
    47bc:	24 5f       	subi	r18, 0xF4	; 244
    47be:	3f 4f       	sbci	r19, 0xFF	; 255
    47c0:	8e e9       	ldi	r24, 0x9E	; 158
    47c2:	97 e0       	ldi	r25, 0x07	; 7
    47c4:	b9 01       	movw	r22, r18
    47c6:	0e 94 1a 06 	call	0xc34	; 0xc34 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    47ca:	ec 81       	ldd	r30, Y+4	; 0x04
    47cc:	fd 81       	ldd	r31, Y+5	; 0x05
    47ce:	96 89       	ldd	r25, Z+22	; 0x16
    47d0:	e0 91 54 07 	lds	r30, 0x0754
    47d4:	f0 91 55 07 	lds	r31, 0x0755
    47d8:	86 89       	ldd	r24, Z+22	; 0x16
    47da:	89 17       	cp	r24, r25
    47dc:	58 f4       	brcc	.+22     	; 0x47f4 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    47de:	8f 85       	ldd	r24, Y+15	; 0x0f
    47e0:	98 89       	ldd	r25, Y+16	; 0x10
    47e2:	00 97       	sbiw	r24, 0x00	; 0
    47e4:	21 f0       	breq	.+8      	; 0x47ee <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    47e6:	ef 85       	ldd	r30, Y+15	; 0x0f
    47e8:	f8 89       	ldd	r31, Y+16	; 0x10
    47ea:	81 e0       	ldi	r24, 0x01	; 1
    47ec:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    47ee:	81 e0       	ldi	r24, 0x01	; 1
    47f0:	80 93 5c 07 	sts	0x075C, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    47f4:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    47f6:	62 96       	adiw	r28, 0x12	; 18
    47f8:	0f b6       	in	r0, 0x3f	; 63
    47fa:	f8 94       	cli
    47fc:	de bf       	out	0x3e, r29	; 62
    47fe:	0f be       	out	0x3f, r0	; 63
    4800:	cd bf       	out	0x3d, r28	; 61
    4802:	cf 91       	pop	r28
    4804:	df 91       	pop	r29
    4806:	1f 91       	pop	r17
    4808:	0f 91       	pop	r16
    480a:	ff 90       	pop	r15
    480c:	ef 90       	pop	r14
    480e:	08 95       	ret

00004810 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4810:	df 93       	push	r29
    4812:	cf 93       	push	r28
    4814:	cd b7       	in	r28, 0x3d	; 61
    4816:	de b7       	in	r29, 0x3e	; 62
    4818:	28 97       	sbiw	r28, 0x08	; 8
    481a:	0f b6       	in	r0, 0x3f	; 63
    481c:	f8 94       	cli
    481e:	de bf       	out	0x3e, r29	; 62
    4820:	0f be       	out	0x3f, r0	; 63
    4822:	cd bf       	out	0x3d, r28	; 61
    4824:	9e 83       	std	Y+6, r25	; 0x06
    4826:	8d 83       	std	Y+5, r24	; 0x05
    4828:	78 87       	std	Y+8, r23	; 0x08
    482a:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    482c:	8d 81       	ldd	r24, Y+5	; 0x05
    482e:	9e 81       	ldd	r25, Y+6	; 0x06
    4830:	9c 83       	std	Y+4, r25	; 0x04
    4832:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4834:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4836:	eb 81       	ldd	r30, Y+3	; 0x03
    4838:	fc 81       	ldd	r31, Y+4	; 0x04
    483a:	85 a1       	ldd	r24, Z+37	; 0x25
    483c:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    483e:	eb 81       	ldd	r30, Y+3	; 0x03
    4840:	fc 81       	ldd	r31, Y+4	; 0x04
    4842:	82 e0       	ldi	r24, 0x02	; 2
    4844:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    4846:	eb 81       	ldd	r30, Y+3	; 0x03
    4848:	fc 81       	ldd	r31, Y+4	; 0x04
    484a:	81 a1       	ldd	r24, Z+33	; 0x21
    484c:	92 a1       	ldd	r25, Z+34	; 0x22
    484e:	a3 a1       	ldd	r26, Z+35	; 0x23
    4850:	b4 a1       	ldd	r27, Z+36	; 0x24
    4852:	01 96       	adiw	r24, 0x01	; 1
    4854:	a1 1d       	adc	r26, r1
    4856:	b1 1d       	adc	r27, r1
    4858:	eb 81       	ldd	r30, Y+3	; 0x03
    485a:	fc 81       	ldd	r31, Y+4	; 0x04
    485c:	81 a3       	std	Z+33, r24	; 0x21
    485e:	92 a3       	std	Z+34, r25	; 0x22
    4860:	a3 a3       	std	Z+35, r26	; 0x23
    4862:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4864:	8a 81       	ldd	r24, Y+2	; 0x02
    4866:	81 30       	cpi	r24, 0x01	; 1
    4868:	09 f0       	breq	.+2      	; 0x486c <vTaskNotifyGiveFromISR+0x5c>
    486a:	4f c0       	rjmp	.+158    	; 0x490a <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    486c:	80 91 63 07 	lds	r24, 0x0763
    4870:	88 23       	and	r24, r24
    4872:	61 f5       	brne	.+88     	; 0x48cc <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4874:	8b 81       	ldd	r24, Y+3	; 0x03
    4876:	9c 81       	ldd	r25, Y+4	; 0x04
    4878:	02 96       	adiw	r24, 0x02	; 2
    487a:	0e 94 ca 06 	call	0xd94	; 0xd94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    487e:	eb 81       	ldd	r30, Y+3	; 0x03
    4880:	fc 81       	ldd	r31, Y+4	; 0x04
    4882:	96 89       	ldd	r25, Z+22	; 0x16
    4884:	80 91 59 07 	lds	r24, 0x0759
    4888:	89 17       	cp	r24, r25
    488a:	28 f4       	brcc	.+10     	; 0x4896 <vTaskNotifyGiveFromISR+0x86>
    488c:	eb 81       	ldd	r30, Y+3	; 0x03
    488e:	fc 81       	ldd	r31, Y+4	; 0x04
    4890:	86 89       	ldd	r24, Z+22	; 0x16
    4892:	80 93 59 07 	sts	0x0759, r24
    4896:	eb 81       	ldd	r30, Y+3	; 0x03
    4898:	fc 81       	ldd	r31, Y+4	; 0x04
    489a:	86 89       	ldd	r24, Z+22	; 0x16
    489c:	28 2f       	mov	r18, r24
    489e:	30 e0       	ldi	r19, 0x00	; 0
    48a0:	c9 01       	movw	r24, r18
    48a2:	88 0f       	add	r24, r24
    48a4:	99 1f       	adc	r25, r25
    48a6:	88 0f       	add	r24, r24
    48a8:	99 1f       	adc	r25, r25
    48aa:	88 0f       	add	r24, r24
    48ac:	99 1f       	adc	r25, r25
    48ae:	82 0f       	add	r24, r18
    48b0:	93 1f       	adc	r25, r19
    48b2:	ac 01       	movw	r20, r24
    48b4:	4c 59       	subi	r20, 0x9C	; 156
    48b6:	58 4f       	sbci	r21, 0xF8	; 248
    48b8:	8b 81       	ldd	r24, Y+3	; 0x03
    48ba:	9c 81       	ldd	r25, Y+4	; 0x04
    48bc:	9c 01       	movw	r18, r24
    48be:	2e 5f       	subi	r18, 0xFE	; 254
    48c0:	3f 4f       	sbci	r19, 0xFF	; 255
    48c2:	ca 01       	movw	r24, r20
    48c4:	b9 01       	movw	r22, r18
    48c6:	0e 94 1a 06 	call	0xc34	; 0xc34 <vListInsertEnd>
    48ca:	0a c0       	rjmp	.+20     	; 0x48e0 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    48cc:	8b 81       	ldd	r24, Y+3	; 0x03
    48ce:	9c 81       	ldd	r25, Y+4	; 0x04
    48d0:	9c 01       	movw	r18, r24
    48d2:	24 5f       	subi	r18, 0xF4	; 244
    48d4:	3f 4f       	sbci	r19, 0xFF	; 255
    48d6:	8e e9       	ldi	r24, 0x9E	; 158
    48d8:	97 e0       	ldi	r25, 0x07	; 7
    48da:	b9 01       	movw	r22, r18
    48dc:	0e 94 1a 06 	call	0xc34	; 0xc34 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    48e0:	eb 81       	ldd	r30, Y+3	; 0x03
    48e2:	fc 81       	ldd	r31, Y+4	; 0x04
    48e4:	96 89       	ldd	r25, Z+22	; 0x16
    48e6:	e0 91 54 07 	lds	r30, 0x0754
    48ea:	f0 91 55 07 	lds	r31, 0x0755
    48ee:	86 89       	ldd	r24, Z+22	; 0x16
    48f0:	89 17       	cp	r24, r25
    48f2:	58 f4       	brcc	.+22     	; 0x490a <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    48f4:	8f 81       	ldd	r24, Y+7	; 0x07
    48f6:	98 85       	ldd	r25, Y+8	; 0x08
    48f8:	00 97       	sbiw	r24, 0x00	; 0
    48fa:	21 f0       	breq	.+8      	; 0x4904 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    48fc:	ef 81       	ldd	r30, Y+7	; 0x07
    48fe:	f8 85       	ldd	r31, Y+8	; 0x08
    4900:	81 e0       	ldi	r24, 0x01	; 1
    4902:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4904:	81 e0       	ldi	r24, 0x01	; 1
    4906:	80 93 5c 07 	sts	0x075C, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    490a:	28 96       	adiw	r28, 0x08	; 8
    490c:	0f b6       	in	r0, 0x3f	; 63
    490e:	f8 94       	cli
    4910:	de bf       	out	0x3e, r29	; 62
    4912:	0f be       	out	0x3f, r0	; 63
    4914:	cd bf       	out	0x3d, r28	; 61
    4916:	cf 91       	pop	r28
    4918:	df 91       	pop	r29
    491a:	08 95       	ret

0000491c <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    491c:	df 93       	push	r29
    491e:	cf 93       	push	r28
    4920:	cd b7       	in	r28, 0x3d	; 61
    4922:	de b7       	in	r29, 0x3e	; 62
    4924:	27 97       	sbiw	r28, 0x07	; 7
    4926:	0f b6       	in	r0, 0x3f	; 63
    4928:	f8 94       	cli
    492a:	de bf       	out	0x3e, r29	; 62
    492c:	0f be       	out	0x3f, r0	; 63
    492e:	cd bf       	out	0x3d, r28	; 61
    4930:	9d 83       	std	Y+5, r25	; 0x05
    4932:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    4934:	8c 81       	ldd	r24, Y+4	; 0x04
    4936:	9d 81       	ldd	r25, Y+5	; 0x05
    4938:	00 97       	sbiw	r24, 0x00	; 0
    493a:	39 f4       	brne	.+14     	; 0x494a <xTaskNotifyStateClear+0x2e>
    493c:	80 91 54 07 	lds	r24, 0x0754
    4940:	90 91 55 07 	lds	r25, 0x0755
    4944:	9f 83       	std	Y+7, r25	; 0x07
    4946:	8e 83       	std	Y+6, r24	; 0x06
    4948:	04 c0       	rjmp	.+8      	; 0x4952 <xTaskNotifyStateClear+0x36>
    494a:	8c 81       	ldd	r24, Y+4	; 0x04
    494c:	9d 81       	ldd	r25, Y+5	; 0x05
    494e:	9f 83       	std	Y+7, r25	; 0x07
    4950:	8e 83       	std	Y+6, r24	; 0x06
    4952:	8e 81       	ldd	r24, Y+6	; 0x06
    4954:	9f 81       	ldd	r25, Y+7	; 0x07
    4956:	9b 83       	std	Y+3, r25	; 0x03
    4958:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    495a:	0f b6       	in	r0, 0x3f	; 63
    495c:	f8 94       	cli
    495e:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    4960:	ea 81       	ldd	r30, Y+2	; 0x02
    4962:	fb 81       	ldd	r31, Y+3	; 0x03
    4964:	85 a1       	ldd	r24, Z+37	; 0x25
    4966:	82 30       	cpi	r24, 0x02	; 2
    4968:	31 f4       	brne	.+12     	; 0x4976 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    496a:	ea 81       	ldd	r30, Y+2	; 0x02
    496c:	fb 81       	ldd	r31, Y+3	; 0x03
    496e:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    4970:	81 e0       	ldi	r24, 0x01	; 1
    4972:	89 83       	std	Y+1, r24	; 0x01
    4974:	01 c0       	rjmp	.+2      	; 0x4978 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    4976:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    4978:	0f 90       	pop	r0
    497a:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    497c:	89 81       	ldd	r24, Y+1	; 0x01
	}
    497e:	27 96       	adiw	r28, 0x07	; 7
    4980:	0f b6       	in	r0, 0x3f	; 63
    4982:	f8 94       	cli
    4984:	de bf       	out	0x3e, r29	; 62
    4986:	0f be       	out	0x3f, r0	; 63
    4988:	cd bf       	out	0x3d, r28	; 61
    498a:	cf 91       	pop	r28
    498c:	df 91       	pop	r29
    498e:	08 95       	ret

00004990 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    4990:	df 93       	push	r29
    4992:	cf 93       	push	r28
    4994:	cd b7       	in	r28, 0x3d	; 61
    4996:	de b7       	in	r29, 0x3e	; 62
    4998:	27 97       	sbiw	r28, 0x07	; 7
    499a:	0f b6       	in	r0, 0x3f	; 63
    499c:	f8 94       	cli
    499e:	de bf       	out	0x3e, r29	; 62
    49a0:	0f be       	out	0x3f, r0	; 63
    49a2:	cd bf       	out	0x3d, r28	; 61
    49a4:	9e 83       	std	Y+6, r25	; 0x06
    49a6:	8d 83       	std	Y+5, r24	; 0x05
    49a8:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    49aa:	80 91 57 07 	lds	r24, 0x0757
    49ae:	90 91 58 07 	lds	r25, 0x0758
    49b2:	9a 83       	std	Y+2, r25	; 0x02
    49b4:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    49b6:	80 91 54 07 	lds	r24, 0x0754
    49ba:	90 91 55 07 	lds	r25, 0x0755
    49be:	02 96       	adiw	r24, 0x02	; 2
    49c0:	0e 94 ca 06 	call	0xd94	; 0xd94 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    49c4:	8d 81       	ldd	r24, Y+5	; 0x05
    49c6:	9e 81       	ldd	r25, Y+6	; 0x06
    49c8:	2f ef       	ldi	r18, 0xFF	; 255
    49ca:	8f 3f       	cpi	r24, 0xFF	; 255
    49cc:	92 07       	cpc	r25, r18
    49ce:	81 f4       	brne	.+32     	; 0x49f0 <prvAddCurrentTaskToDelayedList+0x60>
    49d0:	8f 81       	ldd	r24, Y+7	; 0x07
    49d2:	88 23       	and	r24, r24
    49d4:	69 f0       	breq	.+26     	; 0x49f0 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    49d6:	80 91 54 07 	lds	r24, 0x0754
    49da:	90 91 55 07 	lds	r25, 0x0755
    49de:	9c 01       	movw	r18, r24
    49e0:	2e 5f       	subi	r18, 0xFE	; 254
    49e2:	3f 4f       	sbci	r19, 0xFF	; 255
    49e4:	87 ea       	ldi	r24, 0xA7	; 167
    49e6:	97 e0       	ldi	r25, 0x07	; 7
    49e8:	b9 01       	movw	r22, r18
    49ea:	0e 94 1a 06 	call	0xc34	; 0xc34 <vListInsertEnd>
    49ee:	43 c0       	rjmp	.+134    	; 0x4a76 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    49f0:	29 81       	ldd	r18, Y+1	; 0x01
    49f2:	3a 81       	ldd	r19, Y+2	; 0x02
    49f4:	8d 81       	ldd	r24, Y+5	; 0x05
    49f6:	9e 81       	ldd	r25, Y+6	; 0x06
    49f8:	82 0f       	add	r24, r18
    49fa:	93 1f       	adc	r25, r19
    49fc:	9c 83       	std	Y+4, r25	; 0x04
    49fe:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    4a00:	e0 91 54 07 	lds	r30, 0x0754
    4a04:	f0 91 55 07 	lds	r31, 0x0755
    4a08:	8b 81       	ldd	r24, Y+3	; 0x03
    4a0a:	9c 81       	ldd	r25, Y+4	; 0x04
    4a0c:	93 83       	std	Z+3, r25	; 0x03
    4a0e:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    4a10:	2b 81       	ldd	r18, Y+3	; 0x03
    4a12:	3c 81       	ldd	r19, Y+4	; 0x04
    4a14:	89 81       	ldd	r24, Y+1	; 0x01
    4a16:	9a 81       	ldd	r25, Y+2	; 0x02
    4a18:	28 17       	cp	r18, r24
    4a1a:	39 07       	cpc	r19, r25
    4a1c:	70 f4       	brcc	.+28     	; 0x4a3a <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4a1e:	80 91 9c 07 	lds	r24, 0x079C
    4a22:	90 91 9d 07 	lds	r25, 0x079D
    4a26:	20 91 54 07 	lds	r18, 0x0754
    4a2a:	30 91 55 07 	lds	r19, 0x0755
    4a2e:	2e 5f       	subi	r18, 0xFE	; 254
    4a30:	3f 4f       	sbci	r19, 0xFF	; 255
    4a32:	b9 01       	movw	r22, r18
    4a34:	0e 94 5e 06 	call	0xcbc	; 0xcbc <vListInsert>
    4a38:	1e c0       	rjmp	.+60     	; 0x4a76 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4a3a:	40 91 9a 07 	lds	r20, 0x079A
    4a3e:	50 91 9b 07 	lds	r21, 0x079B
    4a42:	80 91 54 07 	lds	r24, 0x0754
    4a46:	90 91 55 07 	lds	r25, 0x0755
    4a4a:	9c 01       	movw	r18, r24
    4a4c:	2e 5f       	subi	r18, 0xFE	; 254
    4a4e:	3f 4f       	sbci	r19, 0xFF	; 255
    4a50:	ca 01       	movw	r24, r20
    4a52:	b9 01       	movw	r22, r18
    4a54:	0e 94 5e 06 	call	0xcbc	; 0xcbc <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    4a58:	20 91 5f 07 	lds	r18, 0x075F
    4a5c:	30 91 60 07 	lds	r19, 0x0760
    4a60:	8b 81       	ldd	r24, Y+3	; 0x03
    4a62:	9c 81       	ldd	r25, Y+4	; 0x04
    4a64:	82 17       	cp	r24, r18
    4a66:	93 07       	cpc	r25, r19
    4a68:	30 f4       	brcc	.+12     	; 0x4a76 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    4a6a:	8b 81       	ldd	r24, Y+3	; 0x03
    4a6c:	9c 81       	ldd	r25, Y+4	; 0x04
    4a6e:	90 93 60 07 	sts	0x0760, r25
    4a72:	80 93 5f 07 	sts	0x075F, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    4a76:	27 96       	adiw	r28, 0x07	; 7
    4a78:	0f b6       	in	r0, 0x3f	; 63
    4a7a:	f8 94       	cli
    4a7c:	de bf       	out	0x3e, r29	; 62
    4a7e:	0f be       	out	0x3f, r0	; 63
    4a80:	cd bf       	out	0x3d, r28	; 61
    4a82:	cf 91       	pop	r28
    4a84:	df 91       	pop	r29
    4a86:	08 95       	ret

00004a88 <UART_TX_cbk>:
 *Output: No output
 *In/Out:
 *Description: This function excute the Interrupt service routine for uart tx interrupt .
 */
static void UART_TX_cbk(void)
{
    4a88:	df 93       	push	r29
    4a8a:	cf 93       	push	r28
    4a8c:	cd b7       	in	r28, 0x3d	; 61
    4a8e:	de b7       	in	r29, 0x3e	; 62
	if (gastr_BCM_PacketFormat[BCM_UART_ID].u8_PacketState == BCM_TX_STATE)
    4a90:	80 91 b8 07 	lds	r24, 0x07B8
    4a94:	81 30       	cpi	r24, 0x01	; 1
    4a96:	21 f4       	brne	.+8      	; 0x4aa0 <UART_TX_cbk+0x18>
	{
		gastr_BCM_PacketFormat[BCM_UART_ID].u8_PacketState =
    4a98:	82 e0       	ldi	r24, 0x02	; 2
    4a9a:	80 93 b8 07 	sts	0x07B8, r24
    4a9e:	0f c0       	rjmp	.+30     	; 0x4abe <UART_TX_cbk+0x36>
		BCM_TX_COMPLETE_STATE;
	}
	else if ((gastr_BCM_PacketFormat[BCM_UART_ID].u8_PacketState
    4aa0:	80 91 b8 07 	lds	r24, 0x07B8
    4aa4:	88 23       	and	r24, r24
    4aa6:	59 f4       	brne	.+22     	; 0x4abe <UART_TX_cbk+0x36>
    4aa8:	80 91 b0 07 	lds	r24, 0x07B0
    4aac:	81 30       	cpi	r24, 0x01	; 1
    4aae:	39 f4       	brne	.+14     	; 0x4abe <UART_TX_cbk+0x36>
			== BCM_IDLE_STATE) && (gu8_TxCbkStatusFlag == TRUE))
	{
		gastr_BCM_PacketFormat[BCM_UART_ID].BCM_Status_cbk();
    4ab0:	e0 91 be 07 	lds	r30, 0x07BE
    4ab4:	f0 91 bf 07 	lds	r31, 0x07BF
    4ab8:	09 95       	icall
		gu8_TxCbkStatusFlag = BCM_UNINTIALIZED;
    4aba:	10 92 b0 07 	sts	0x07B0, r1
	}
	else
	{
		/* DO NOTHING */
	}
}
    4abe:	cf 91       	pop	r28
    4ac0:	df 91       	pop	r29
    4ac2:	08 95       	ret

00004ac4 <UART_RX_cbk>:
 *Output: No output
 *In/Out:
 *Description: This function excute the Interrupt service routine for uart rx interrupt .
 */
static void UART_RX_cbk(void)
{
    4ac4:	df 93       	push	r29
    4ac6:	cf 93       	push	r28
    4ac8:	cd b7       	in	r28, 0x3d	; 61
    4aca:	de b7       	in	r29, 0x3e	; 62

	if (gastr_BCM_PacketFormat[BCM_UART_ID].u8_PacketState == BCM_IDLE_STATE)
    4acc:	80 91 b8 07 	lds	r24, 0x07B8
    4ad0:	88 23       	and	r24, r24
    4ad2:	e9 f4       	brne	.+58     	; 0x4b0e <UART_RX_cbk+0x4a>
	{
		if (gu8_RxCbkStatusFlag == TRUE)
    4ad4:	80 91 b1 07 	lds	r24, 0x07B1
    4ad8:	81 30       	cpi	r24, 0x01	; 1
    4ada:	41 f4       	brne	.+16     	; 0x4aec <UART_RX_cbk+0x28>
		{
			gastr_BCM_PacketFormat[BCM_UART_ID].BCM_Status_cbk();
    4adc:	e0 91 be 07 	lds	r30, 0x07BE
    4ae0:	f0 91 bf 07 	lds	r31, 0x07BF
    4ae4:	09 95       	icall
			gu8_RxCbkStatusFlag = BCM_UNINTIALIZED;
    4ae6:	10 92 b1 07 	sts	0x07B1, r1
    4aea:	1e c0       	rjmp	.+60     	; 0x4b28 <UART_RX_cbk+0x64>
		else
		{
			/*
			 * check for BCM ID
			 */
			UART_ReceiveByte(gastr_BCM_PacketFormat[BCM_UART_ID].u8_Data_ptr);
    4aec:	80 91 ba 07 	lds	r24, 0x07BA
    4af0:	90 91 bb 07 	lds	r25, 0x07BB
    4af4:	0e 94 79 2d 	call	0x5af2	; 0x5af2 <UART_ReceiveByte>
			if (*gastr_BCM_PacketFormat[BCM_UART_ID].u8_Data_ptr == BCM_UART_ID)
    4af8:	e0 91 ba 07 	lds	r30, 0x07BA
    4afc:	f0 91 bb 07 	lds	r31, 0x07BB
    4b00:	80 81       	ld	r24, Z
    4b02:	88 23       	and	r24, r24
    4b04:	89 f4       	brne	.+34     	; 0x4b28 <UART_RX_cbk+0x64>
			{
				gastr_BCM_PacketFormat[BCM_UART_ID].u8_PacketState =
    4b06:	83 e0       	ldi	r24, 0x03	; 3
    4b08:	80 93 b8 07 	sts	0x07B8, r24
    4b0c:	0d c0       	rjmp	.+26     	; 0x4b28 <UART_RX_cbk+0x64>
			{
				/* DO NOTHING */
			}
		}
	}
	else if (gastr_BCM_PacketFormat[BCM_UART_ID].u8_PacketState == BCM_RX_STATE)
    4b0e:	80 91 b8 07 	lds	r24, 0x07B8
    4b12:	83 30       	cpi	r24, 0x03	; 3
    4b14:	49 f4       	brne	.+18     	; 0x4b28 <UART_RX_cbk+0x64>
	{
		UART_ReceiveByte(gastr_BCM_PacketFormat[BCM_UART_ID].u8_Data_ptr);
    4b16:	80 91 ba 07 	lds	r24, 0x07BA
    4b1a:	90 91 bb 07 	lds	r25, 0x07BB
    4b1e:	0e 94 79 2d 	call	0x5af2	; 0x5af2 <UART_ReceiveByte>
		gastr_BCM_PacketFormat[BCM_UART_ID].u8_PacketState =
    4b22:	84 e0       	ldi	r24, 0x04	; 4
    4b24:	80 93 b8 07 	sts	0x07B8, r24
	}
	else
	{
		/* DO NOTHING */
	}
}
    4b28:	cf 91       	pop	r28
    4b2a:	df 91       	pop	r29
    4b2c:	08 95       	ret

00004b2e <BCM_Init>:
/* In/Out:	N/A																					*/
/* Return: The error status of the function.													*/
/* Description: Initiates the module.															*/
/************************************************************************************************/
BCM_ERROR_STATUS BCM_Init(void)
{
    4b2e:	df 93       	push	r29
    4b30:	cf 93       	push	r28
    4b32:	cd b7       	in	r28, 0x3d	; 61
    4b34:	de b7       	in	r29, 0x3e	; 62
    4b36:	66 97       	sbiw	r28, 0x16	; 22
    4b38:	0f b6       	in	r0, 0x3f	; 63
    4b3a:	f8 94       	cli
    4b3c:	de bf       	out	0x3e, r29	; 62
    4b3e:	0f be       	out	0x3f, r0	; 63
    4b40:	cd bf       	out	0x3d, r28	; 61
	/*
	 * Error state: No Error
	 */
	BCM_ERROR_STATUS u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_SUCCESS;
    4b42:	86 ea       	ldi	r24, 0xA6	; 166
    4b44:	89 83       	std	Y+1, r24	; 0x01
	 * UART configuration
	 */
	UART_cfg_s BCM_UART =
	{
	UART_INTERRUPT, TRANSCEIVER, UART_NO_DOUBLE_SPEED, UART_ONE_STOP_BIT,
	UART_NO_PARITY, UART_8_BIT, UART_BUDE_RATE, UART_TX_cbk, UART_RX_cbk, NULL };
    4b46:	ce 01       	movw	r24, r28
    4b48:	02 96       	adiw	r24, 0x02	; 2
    4b4a:	9b 8b       	std	Y+19, r25	; 0x13
    4b4c:	8a 8b       	std	Y+18, r24	; 0x12
    4b4e:	ed eb       	ldi	r30, 0xBD	; 189
    4b50:	f0 e0       	ldi	r31, 0x00	; 0
    4b52:	fd 8b       	std	Y+21, r31	; 0x15
    4b54:	ec 8b       	std	Y+20, r30	; 0x14
    4b56:	f0 e1       	ldi	r31, 0x10	; 16
    4b58:	fe 8b       	std	Y+22, r31	; 0x16
    4b5a:	ec 89       	ldd	r30, Y+20	; 0x14
    4b5c:	fd 89       	ldd	r31, Y+21	; 0x15
    4b5e:	00 80       	ld	r0, Z
    4b60:	8c 89       	ldd	r24, Y+20	; 0x14
    4b62:	9d 89       	ldd	r25, Y+21	; 0x15
    4b64:	01 96       	adiw	r24, 0x01	; 1
    4b66:	9d 8b       	std	Y+21, r25	; 0x15
    4b68:	8c 8b       	std	Y+20, r24	; 0x14
    4b6a:	ea 89       	ldd	r30, Y+18	; 0x12
    4b6c:	fb 89       	ldd	r31, Y+19	; 0x13
    4b6e:	00 82       	st	Z, r0
    4b70:	8a 89       	ldd	r24, Y+18	; 0x12
    4b72:	9b 89       	ldd	r25, Y+19	; 0x13
    4b74:	01 96       	adiw	r24, 0x01	; 1
    4b76:	9b 8b       	std	Y+19, r25	; 0x13
    4b78:	8a 8b       	std	Y+18, r24	; 0x12
    4b7a:	9e 89       	ldd	r25, Y+22	; 0x16
    4b7c:	91 50       	subi	r25, 0x01	; 1
    4b7e:	9e 8b       	std	Y+22, r25	; 0x16
    4b80:	ee 89       	ldd	r30, Y+22	; 0x16
    4b82:	ee 23       	and	r30, r30
    4b84:	51 f7       	brne	.-44     	; 0x4b5a <BCM_Init+0x2c>

	u8_BCM_ErrorStatus = UART_Init(&BCM_UART);
    4b86:	ce 01       	movw	r24, r28
    4b88:	02 96       	adiw	r24, 0x02	; 2
    4b8a:	0e 94 6c 2a 	call	0x54d8	; 0x54d8 <UART_Init>
    4b8e:	89 83       	std	Y+1, r24	; 0x01

	if (u8_BCM_ErrorStatus == UART_BASE_ERROR + ERR_SUCCESS)
    4b90:	89 81       	ldd	r24, Y+1	; 0x01
    4b92:	84 3c       	cpi	r24, 0xC4	; 196
    4b94:	21 f4       	brne	.+8      	; 0x4b9e <BCM_Init+0x70>
	{
		/*
		 * global variables intialization
		 */
		gu8_BCM_Status = BCM_INTIALIZED;
    4b96:	81 e0       	ldi	r24, 0x01	; 1
    4b98:	80 93 b2 07 	sts	0x07B2, r24
    4b9c:	02 c0       	rjmp	.+4      	; 0x4ba2 <BCM_Init+0x74>
	}
	else
	{
		gu8_BCM_Status = BCM_UNINTIALIZED;
    4b9e:	10 92 b2 07 	sts	0x07B2, r1
	}

	/*
	 * Function shall return the Error state
	 */
	return u8_BCM_ErrorStatus;
    4ba2:	89 81       	ldd	r24, Y+1	; 0x01
}
    4ba4:	66 96       	adiw	r28, 0x16	; 22
    4ba6:	0f b6       	in	r0, 0x3f	; 63
    4ba8:	f8 94       	cli
    4baa:	de bf       	out	0x3e, r29	; 62
    4bac:	0f be       	out	0x3f, r0	; 63
    4bae:	cd bf       	out	0x3d, r28	; 61
    4bb0:	cf 91       	pop	r28
    4bb2:	df 91       	pop	r29
    4bb4:	08 95       	ret

00004bb6 <BCM_DeInit>:
/* In/Out:	N/A																					*/
/* Return: The error status of the function.													*/
/* Description: Deinitiates the module.															*/
/************************************************************************************************/
BCM_ERROR_STATUS BCM_DeInit(void)
{
    4bb6:	df 93       	push	r29
    4bb8:	cf 93       	push	r28
    4bba:	0f 92       	push	r0
    4bbc:	cd b7       	in	r28, 0x3d	; 61
    4bbe:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Error state: No Error
	 */
	BCM_ERROR_STATUS u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_SUCCESS;
    4bc0:	86 ea       	ldi	r24, 0xA6	; 166
    4bc2:	89 83       	std	Y+1, r24	; 0x01

	}
	/*
	 * Function shall return the Error state
	 */
	return u8_BCM_ErrorStatus;
    4bc4:	89 81       	ldd	r24, Y+1	; 0x01
}
    4bc6:	0f 90       	pop	r0
    4bc8:	cf 91       	pop	r28
    4bca:	df 91       	pop	r29
    4bcc:	08 95       	ret

00004bce <BCM_Send>:
/* Return: The error status of the function.													*/
/* Description: Starts a new BCM task.															*/
/************************************************************************************************/
BCM_ERROR_STATUS BCM_Send(uint8 u8_BCM_Channel_ID, uint8 * u8_BCM_Data_ptr,
		gptrfu_Status_cbk_t BCM_Status_cbk_ptr, uint16 u16_BCM_DataSize)
{
    4bce:	df 93       	push	r29
    4bd0:	cf 93       	push	r28
    4bd2:	cd b7       	in	r28, 0x3d	; 61
    4bd4:	de b7       	in	r29, 0x3e	; 62
    4bd6:	2a 97       	sbiw	r28, 0x0a	; 10
    4bd8:	0f b6       	in	r0, 0x3f	; 63
    4bda:	f8 94       	cli
    4bdc:	de bf       	out	0x3e, r29	; 62
    4bde:	0f be       	out	0x3f, r0	; 63
    4be0:	cd bf       	out	0x3d, r28	; 61
    4be2:	8a 83       	std	Y+2, r24	; 0x02
    4be4:	7c 83       	std	Y+4, r23	; 0x04
    4be6:	6b 83       	std	Y+3, r22	; 0x03
    4be8:	5e 83       	std	Y+6, r21	; 0x06
    4bea:	4d 83       	std	Y+5, r20	; 0x05
    4bec:	38 87       	std	Y+8, r19	; 0x08
    4bee:	2f 83       	std	Y+7, r18	; 0x07
	/*
	 * Error state: No Error
	 */
	BCM_ERROR_STATUS u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_SUCCESS;
    4bf0:	86 ea       	ldi	r24, 0xA6	; 166
    4bf2:	89 83       	std	Y+1, r24	; 0x01

	if (gu8_BCM_Status == BCM_UNINTIALIZED)
    4bf4:	80 91 b2 07 	lds	r24, 0x07B2
    4bf8:	88 23       	and	r24, r24
    4bfa:	19 f4       	brne	.+6      	; 0x4c02 <BCM_Send+0x34>
	{
		/*
		 * try to use un initialized BCM
		 */
		u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_NOT_INITIALIZED;
    4bfc:	84 ea       	ldi	r24, 0xA4	; 164
    4bfe:	89 83       	std	Y+1, r24	; 0x01
    4c00:	a7 c0       	rjmp	.+334    	; 0x4d50 <BCM_Send+0x182>
	}
	else if (u8_BCM_Channel_ID >= BCM_MAX_CHANNEL_NUM)
    4c02:	8a 81       	ldd	r24, Y+2	; 0x02
    4c04:	82 30       	cpi	r24, 0x02	; 2
    4c06:	18 f0       	brcs	.+6      	; 0x4c0e <BCM_Send+0x40>
	{
		/*
		 * wrong channel ID
		 */
		u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_INVALID_ARGU;
    4c08:	85 ea       	ldi	r24, 0xA5	; 165
    4c0a:	89 83       	std	Y+1, r24	; 0x01
    4c0c:	a1 c0       	rjmp	.+322    	; 0x4d50 <BCM_Send+0x182>
	}
	/*
	 * check if channel ID unlocked
	 */
	else if (gastr_BCM_PacketFormat[u8_BCM_Channel_ID].u8_ChannelStatus
    4c0e:	8a 81       	ldd	r24, Y+2	; 0x02
    4c10:	28 2f       	mov	r18, r24
    4c12:	30 e0       	ldi	r19, 0x00	; 0
    4c14:	c9 01       	movw	r24, r18
    4c16:	88 0f       	add	r24, r24
    4c18:	99 1f       	adc	r25, r25
    4c1a:	88 0f       	add	r24, r24
    4c1c:	99 1f       	adc	r25, r25
    4c1e:	88 0f       	add	r24, r24
    4c20:	99 1f       	adc	r25, r25
    4c22:	82 0f       	add	r24, r18
    4c24:	93 1f       	adc	r25, r19
    4c26:	fc 01       	movw	r30, r24
    4c28:	e9 54       	subi	r30, 0x49	; 73
    4c2a:	f8 4f       	sbci	r31, 0xF8	; 248
    4c2c:	80 81       	ld	r24, Z
    4c2e:	81 30       	cpi	r24, 0x01	; 1
    4c30:	19 f4       	brne	.+6      	; 0x4c38 <BCM_Send+0x6a>
			== BCM_CHANNEL_LOCKED)
	{
		/*
		 *  channel ID is locked
		 */
		u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_BUFFER_FULL;
    4c32:	8f e9       	ldi	r24, 0x9F	; 159
    4c34:	89 83       	std	Y+1, r24	; 0x01
    4c36:	8c c0       	rjmp	.+280    	; 0x4d50 <BCM_Send+0x182>
	}
	else if ((u8_BCM_Data_ptr == NULL) || (BCM_Status_cbk_ptr == NULL))
    4c38:	8b 81       	ldd	r24, Y+3	; 0x03
    4c3a:	9c 81       	ldd	r25, Y+4	; 0x04
    4c3c:	00 97       	sbiw	r24, 0x00	; 0
    4c3e:	21 f0       	breq	.+8      	; 0x4c48 <BCM_Send+0x7a>
    4c40:	8d 81       	ldd	r24, Y+5	; 0x05
    4c42:	9e 81       	ldd	r25, Y+6	; 0x06
    4c44:	00 97       	sbiw	r24, 0x00	; 0
    4c46:	19 f4       	brne	.+6      	; 0x4c4e <BCM_Send+0x80>
	{
		/*
		 * trying to access a null pointer
		 */
		u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_NULL_PTR;
    4c48:	82 ea       	ldi	r24, 0xA2	; 162
    4c4a:	89 83       	std	Y+1, r24	; 0x01
    4c4c:	81 c0       	rjmp	.+258    	; 0x4d50 <BCM_Send+0x182>
	else
	{
		/*
		 * setup packet
		 */
		gastr_BCM_PacketFormat[u8_BCM_Channel_ID].u16_DataSize =
    4c4e:	8a 81       	ldd	r24, Y+2	; 0x02
    4c50:	28 2f       	mov	r18, r24
    4c52:	30 e0       	ldi	r19, 0x00	; 0
    4c54:	c9 01       	movw	r24, r18
    4c56:	88 0f       	add	r24, r24
    4c58:	99 1f       	adc	r25, r25
    4c5a:	88 0f       	add	r24, r24
    4c5c:	99 1f       	adc	r25, r25
    4c5e:	88 0f       	add	r24, r24
    4c60:	99 1f       	adc	r25, r25
    4c62:	82 0f       	add	r24, r18
    4c64:	93 1f       	adc	r25, r19
    4c66:	fc 01       	movw	r30, r24
    4c68:	e4 54       	subi	r30, 0x44	; 68
    4c6a:	f8 4f       	sbci	r31, 0xF8	; 248
    4c6c:	8f 81       	ldd	r24, Y+7	; 0x07
    4c6e:	98 85       	ldd	r25, Y+8	; 0x08
    4c70:	91 83       	std	Z+1, r25	; 0x01
    4c72:	80 83       	st	Z, r24
				u16_BCM_DataSize;
		gastr_BCM_PacketFormat[u8_BCM_Channel_ID].u8_Data_ptr = u8_BCM_Data_ptr;
    4c74:	8a 81       	ldd	r24, Y+2	; 0x02
    4c76:	28 2f       	mov	r18, r24
    4c78:	30 e0       	ldi	r19, 0x00	; 0
    4c7a:	c9 01       	movw	r24, r18
    4c7c:	88 0f       	add	r24, r24
    4c7e:	99 1f       	adc	r25, r25
    4c80:	88 0f       	add	r24, r24
    4c82:	99 1f       	adc	r25, r25
    4c84:	88 0f       	add	r24, r24
    4c86:	99 1f       	adc	r25, r25
    4c88:	82 0f       	add	r24, r18
    4c8a:	93 1f       	adc	r25, r19
    4c8c:	fc 01       	movw	r30, r24
    4c8e:	e6 54       	subi	r30, 0x46	; 70
    4c90:	f8 4f       	sbci	r31, 0xF8	; 248
    4c92:	8b 81       	ldd	r24, Y+3	; 0x03
    4c94:	9c 81       	ldd	r25, Y+4	; 0x04
    4c96:	91 83       	std	Z+1, r25	; 0x01
    4c98:	80 83       	st	Z, r24
		gastr_BCM_PacketFormat[u8_BCM_Channel_ID].BCM_Status_cbk =
    4c9a:	8a 81       	ldd	r24, Y+2	; 0x02
    4c9c:	28 2f       	mov	r18, r24
    4c9e:	30 e0       	ldi	r19, 0x00	; 0
    4ca0:	c9 01       	movw	r24, r18
    4ca2:	88 0f       	add	r24, r24
    4ca4:	99 1f       	adc	r25, r25
    4ca6:	88 0f       	add	r24, r24
    4ca8:	99 1f       	adc	r25, r25
    4caa:	88 0f       	add	r24, r24
    4cac:	99 1f       	adc	r25, r25
    4cae:	82 0f       	add	r24, r18
    4cb0:	93 1f       	adc	r25, r19
    4cb2:	fc 01       	movw	r30, r24
    4cb4:	e2 54       	subi	r30, 0x42	; 66
    4cb6:	f8 4f       	sbci	r31, 0xF8	; 248
    4cb8:	8d 81       	ldd	r24, Y+5	; 0x05
    4cba:	9e 81       	ldd	r25, Y+6	; 0x06
    4cbc:	91 83       	std	Z+1, r25	; 0x01
    4cbe:	80 83       	st	Z, r24
				BCM_Status_cbk_ptr;
		gastr_BCM_PacketFormat[u8_BCM_Channel_ID].u8_CheckSum =
    4cc0:	8a 81       	ldd	r24, Y+2	; 0x02
    4cc2:	28 2f       	mov	r18, r24
    4cc4:	30 e0       	ldi	r19, 0x00	; 0
    4cc6:	c9 01       	movw	r24, r18
    4cc8:	88 0f       	add	r24, r24
    4cca:	99 1f       	adc	r25, r25
    4ccc:	88 0f       	add	r24, r24
    4cce:	99 1f       	adc	r25, r25
    4cd0:	88 0f       	add	r24, r24
    4cd2:	99 1f       	adc	r25, r25
    4cd4:	82 0f       	add	r24, r18
    4cd6:	93 1f       	adc	r25, r19
    4cd8:	fc 01       	movw	r30, r24
    4cda:	e7 54       	subi	r30, 0x47	; 71
    4cdc:	f8 4f       	sbci	r31, 0xF8	; 248
    4cde:	10 82       	st	Z, r1
		BCM_UNINTIALIZED;
		gastr_BCM_PacketFormat[u8_BCM_Channel_ID].u8_ChannelStatus =
    4ce0:	8a 81       	ldd	r24, Y+2	; 0x02
    4ce2:	28 2f       	mov	r18, r24
    4ce4:	30 e0       	ldi	r19, 0x00	; 0
    4ce6:	c9 01       	movw	r24, r18
    4ce8:	88 0f       	add	r24, r24
    4cea:	99 1f       	adc	r25, r25
    4cec:	88 0f       	add	r24, r24
    4cee:	99 1f       	adc	r25, r25
    4cf0:	88 0f       	add	r24, r24
    4cf2:	99 1f       	adc	r25, r25
    4cf4:	82 0f       	add	r24, r18
    4cf6:	93 1f       	adc	r25, r19
    4cf8:	fc 01       	movw	r30, r24
    4cfa:	e9 54       	subi	r30, 0x49	; 73
    4cfc:	f8 4f       	sbci	r31, 0xF8	; 248
    4cfe:	81 e0       	ldi	r24, 0x01	; 1
    4d00:	80 83       	st	Z, r24
		BCM_CHANNEL_LOCKED;
		gastr_BCM_PacketFormat[u8_BCM_Channel_ID].u8_PacketState =
    4d02:	8a 81       	ldd	r24, Y+2	; 0x02
    4d04:	28 2f       	mov	r18, r24
    4d06:	30 e0       	ldi	r19, 0x00	; 0
    4d08:	c9 01       	movw	r24, r18
    4d0a:	88 0f       	add	r24, r24
    4d0c:	99 1f       	adc	r25, r25
    4d0e:	88 0f       	add	r24, r24
    4d10:	99 1f       	adc	r25, r25
    4d12:	88 0f       	add	r24, r24
    4d14:	99 1f       	adc	r25, r25
    4d16:	82 0f       	add	r24, r18
    4d18:	93 1f       	adc	r25, r19
    4d1a:	fc 01       	movw	r30, r24
    4d1c:	e8 54       	subi	r30, 0x48	; 72
    4d1e:	f8 4f       	sbci	r31, 0xF8	; 248
    4d20:	81 e0       	ldi	r24, 0x01	; 1
    4d22:	80 83       	st	Z, r24
		BCM_TX_STATE;
		/*
		 * check channel ID
		 */
		switch (u8_BCM_Channel_ID)
    4d24:	8a 81       	ldd	r24, Y+2	; 0x02
    4d26:	28 2f       	mov	r18, r24
    4d28:	30 e0       	ldi	r19, 0x00	; 0
    4d2a:	3a 87       	std	Y+10, r19	; 0x0a
    4d2c:	29 87       	std	Y+9, r18	; 0x09
    4d2e:	89 85       	ldd	r24, Y+9	; 0x09
    4d30:	9a 85       	ldd	r25, Y+10	; 0x0a
    4d32:	00 97       	sbiw	r24, 0x00	; 0
    4d34:	31 f0       	breq	.+12     	; 0x4d42 <BCM_Send+0x174>
    4d36:	29 85       	ldd	r18, Y+9	; 0x09
    4d38:	3a 85       	ldd	r19, Y+10	; 0x0a
    4d3a:	21 30       	cpi	r18, 0x01	; 1
    4d3c:	31 05       	cpc	r19, r1
    4d3e:	41 f0       	breq	.+16     	; 0x4d50 <BCM_Send+0x182>
    4d40:	05 c0       	rjmp	.+10     	; 0x4d4c <BCM_Send+0x17e>
		{
		case BCM_UART_ID:
			/*
			 * send ID to start packet transmition
			 */
			u8_BCM_ErrorStatus = UART_SendByte(u8_BCM_Channel_ID);
    4d42:	8a 81       	ldd	r24, Y+2	; 0x02
    4d44:	0e 94 0a 2d 	call	0x5a14	; 0x5a14 <UART_SendByte>
    4d48:	89 83       	std	Y+1, r24	; 0x01
    4d4a:	02 c0       	rjmp	.+4      	; 0x4d50 <BCM_Send+0x182>
			break;
		default:
			/*
			 * wrong channel ID
			 */
			u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_INVALID_ARGU;
    4d4c:	85 ea       	ldi	r24, 0xA5	; 165
    4d4e:	89 83       	std	Y+1, r24	; 0x01
	}

	/*
	 * Function shall return the Error state
	 */
	return u8_BCM_ErrorStatus;
    4d50:	89 81       	ldd	r24, Y+1	; 0x01
}
    4d52:	2a 96       	adiw	r28, 0x0a	; 10
    4d54:	0f b6       	in	r0, 0x3f	; 63
    4d56:	f8 94       	cli
    4d58:	de bf       	out	0x3e, r29	; 62
    4d5a:	0f be       	out	0x3f, r0	; 63
    4d5c:	cd bf       	out	0x3d, r28	; 61
    4d5e:	cf 91       	pop	r28
    4d60:	df 91       	pop	r29
    4d62:	08 95       	ret

00004d64 <BCM_TxDispatcher>:
/* Return: The error status of the function.													*/
/* Description: the BCM main operation "send data".												*/
/************************************************************************************************/

BCM_ERROR_STATUS BCM_TxDispatcher(void)
{
    4d64:	df 93       	push	r29
    4d66:	cf 93       	push	r28
    4d68:	00 d0       	rcall	.+0      	; 0x4d6a <BCM_TxDispatcher+0x6>
    4d6a:	0f 92       	push	r0
    4d6c:	cd b7       	in	r28, 0x3d	; 61
    4d6e:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Error state: No Error
	 */
	BCM_ERROR_STATUS u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_SUCCESS;
    4d70:	86 ea       	ldi	r24, 0xA6	; 166
    4d72:	8b 83       	std	Y+3, r24	; 0x03
	uint8 u8_counter = BCM_UNINTIALIZED, u8_Size;
    4d74:	1a 82       	std	Y+2, r1	; 0x02
	static uint8 u8_SizeSentFlag = SIZE_NOT_SENT;

	if (gu8_BCM_Status == BCM_INTIALIZED)
    4d76:	80 91 b2 07 	lds	r24, 0x07B2
    4d7a:	81 30       	cpi	r24, 0x01	; 1
    4d7c:	09 f0       	breq	.+2      	; 0x4d80 <BCM_TxDispatcher+0x1c>
    4d7e:	5a c1       	rjmp	.+692    	; 0x5034 <BCM_TxDispatcher+0x2d0>
	{
		for (u8_counter = BCM_UNINTIALIZED; u8_counter < BCM_MAX_CHANNEL_NUM;
    4d80:	1a 82       	std	Y+2, r1	; 0x02
    4d82:	53 c1       	rjmp	.+678    	; 0x502a <BCM_TxDispatcher+0x2c6>
				u8_counter++)
		{
			if (gastr_BCM_PacketFormat[u8_counter].u8_ChannelStatus
    4d84:	8a 81       	ldd	r24, Y+2	; 0x02
    4d86:	28 2f       	mov	r18, r24
    4d88:	30 e0       	ldi	r19, 0x00	; 0
    4d8a:	c9 01       	movw	r24, r18
    4d8c:	88 0f       	add	r24, r24
    4d8e:	99 1f       	adc	r25, r25
    4d90:	88 0f       	add	r24, r24
    4d92:	99 1f       	adc	r25, r25
    4d94:	88 0f       	add	r24, r24
    4d96:	99 1f       	adc	r25, r25
    4d98:	82 0f       	add	r24, r18
    4d9a:	93 1f       	adc	r25, r19
    4d9c:	fc 01       	movw	r30, r24
    4d9e:	e9 54       	subi	r30, 0x49	; 73
    4da0:	f8 4f       	sbci	r31, 0xF8	; 248
    4da2:	80 81       	ld	r24, Z
    4da4:	88 23       	and	r24, r24
    4da6:	19 f4       	brne	.+6      	; 0x4dae <BCM_TxDispatcher+0x4a>
					== BCM_CHANNEL_UNLOCKED)
			{
				/*
				 *  channel ID is unlocked
				 */
				u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_NOT_SUPPORTED;
    4da8:	8e e9       	ldi	r24, 0x9E	; 158
    4daa:	8b 83       	std	Y+3, r24	; 0x03
    4dac:	3b c1       	rjmp	.+630    	; 0x5024 <BCM_TxDispatcher+0x2c0>
			}
			else if (gastr_BCM_PacketFormat[u8_counter].u8_PacketState
    4dae:	8a 81       	ldd	r24, Y+2	; 0x02
    4db0:	28 2f       	mov	r18, r24
    4db2:	30 e0       	ldi	r19, 0x00	; 0
    4db4:	c9 01       	movw	r24, r18
    4db6:	88 0f       	add	r24, r24
    4db8:	99 1f       	adc	r25, r25
    4dba:	88 0f       	add	r24, r24
    4dbc:	99 1f       	adc	r25, r25
    4dbe:	88 0f       	add	r24, r24
    4dc0:	99 1f       	adc	r25, r25
    4dc2:	82 0f       	add	r24, r18
    4dc4:	93 1f       	adc	r25, r19
    4dc6:	fc 01       	movw	r30, r24
    4dc8:	e8 54       	subi	r30, 0x48	; 72
    4dca:	f8 4f       	sbci	r31, 0xF8	; 248
    4dcc:	80 81       	ld	r24, Z
    4dce:	82 30       	cpi	r24, 0x02	; 2
    4dd0:	19 f0       	breq	.+6      	; 0x4dd8 <BCM_TxDispatcher+0x74>
					!= BCM_TX_COMPLETE_STATE)
			{
				/*
				 *  wrong state
				 */
				u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_NOT_SUPPORTED;
    4dd2:	8e e9       	ldi	r24, 0x9E	; 158
    4dd4:	8b 83       	std	Y+3, r24	; 0x03
    4dd6:	26 c1       	rjmp	.+588    	; 0x5024 <BCM_TxDispatcher+0x2c0>
			}
			else
			{
				if (u8_SizeSentFlag != SIZE_SENT)
    4dd8:	80 91 b3 07 	lds	r24, 0x07B3
    4ddc:	80 31       	cpi	r24, 0x10	; 16
    4dde:	c1 f1       	breq	.+112    	; 0x4e50 <BCM_TxDispatcher+0xec>
				{
					/*
					 * send data size first
					 */
					u8_Size =
    4de0:	8a 81       	ldd	r24, Y+2	; 0x02
    4de2:	28 2f       	mov	r18, r24
    4de4:	30 e0       	ldi	r19, 0x00	; 0
    4de6:	c9 01       	movw	r24, r18
    4de8:	88 0f       	add	r24, r24
    4dea:	99 1f       	adc	r25, r25
    4dec:	88 0f       	add	r24, r24
    4dee:	99 1f       	adc	r25, r25
    4df0:	88 0f       	add	r24, r24
    4df2:	99 1f       	adc	r25, r25
    4df4:	82 0f       	add	r24, r18
    4df6:	93 1f       	adc	r25, r19
    4df8:	fc 01       	movw	r30, r24
    4dfa:	e4 54       	subi	r30, 0x44	; 68
    4dfc:	f8 4f       	sbci	r31, 0xF8	; 248
    4dfe:	20 81       	ld	r18, Z
    4e00:	31 81       	ldd	r19, Z+1	; 0x01
    4e02:	80 91 b3 07 	lds	r24, 0x07B3
    4e06:	88 2f       	mov	r24, r24
    4e08:	90 e0       	ldi	r25, 0x00	; 0
    4e0a:	a9 01       	movw	r20, r18
    4e0c:	02 c0       	rjmp	.+4      	; 0x4e12 <BCM_TxDispatcher+0xae>
    4e0e:	56 95       	lsr	r21
    4e10:	47 95       	ror	r20
    4e12:	8a 95       	dec	r24
    4e14:	e2 f7       	brpl	.-8      	; 0x4e0e <BCM_TxDispatcher+0xaa>
    4e16:	ca 01       	movw	r24, r20
    4e18:	89 83       	std	Y+1, r24	; 0x01
							(uint8) (gastr_BCM_PacketFormat[u8_counter].u16_DataSize
									>> u8_SizeSentFlag);
					u8_BCM_ErrorStatus = UART_SendByte(u8_Size);
    4e1a:	89 81       	ldd	r24, Y+1	; 0x01
    4e1c:	0e 94 0a 2d 	call	0x5a14	; 0x5a14 <UART_SendByte>
    4e20:	8b 83       	std	Y+3, r24	; 0x03
					u8_SizeSentFlag += ONE_BYTE;
    4e22:	80 91 b3 07 	lds	r24, 0x07B3
    4e26:	88 5f       	subi	r24, 0xF8	; 248
    4e28:	80 93 b3 07 	sts	0x07B3, r24
					gastr_BCM_PacketFormat[u8_counter].u8_PacketState =
    4e2c:	8a 81       	ldd	r24, Y+2	; 0x02
    4e2e:	28 2f       	mov	r18, r24
    4e30:	30 e0       	ldi	r19, 0x00	; 0
    4e32:	c9 01       	movw	r24, r18
    4e34:	88 0f       	add	r24, r24
    4e36:	99 1f       	adc	r25, r25
    4e38:	88 0f       	add	r24, r24
    4e3a:	99 1f       	adc	r25, r25
    4e3c:	88 0f       	add	r24, r24
    4e3e:	99 1f       	adc	r25, r25
    4e40:	82 0f       	add	r24, r18
    4e42:	93 1f       	adc	r25, r19
    4e44:	fc 01       	movw	r30, r24
    4e46:	e8 54       	subi	r30, 0x48	; 72
    4e48:	f8 4f       	sbci	r31, 0xF8	; 248
    4e4a:	81 e0       	ldi	r24, 0x01	; 1
    4e4c:	80 83       	st	Z, r24
    4e4e:	ea c0       	rjmp	.+468    	; 0x5024 <BCM_TxDispatcher+0x2c0>
					BCM_TX_STATE;
				}
				else if (gastr_BCM_PacketFormat[u8_counter].u16_DataSize
    4e50:	8a 81       	ldd	r24, Y+2	; 0x02
    4e52:	28 2f       	mov	r18, r24
    4e54:	30 e0       	ldi	r19, 0x00	; 0
    4e56:	c9 01       	movw	r24, r18
    4e58:	88 0f       	add	r24, r24
    4e5a:	99 1f       	adc	r25, r25
    4e5c:	88 0f       	add	r24, r24
    4e5e:	99 1f       	adc	r25, r25
    4e60:	88 0f       	add	r24, r24
    4e62:	99 1f       	adc	r25, r25
    4e64:	82 0f       	add	r24, r18
    4e66:	93 1f       	adc	r25, r19
    4e68:	fc 01       	movw	r30, r24
    4e6a:	e4 54       	subi	r30, 0x44	; 68
    4e6c:	f8 4f       	sbci	r31, 0xF8	; 248
    4e6e:	80 81       	ld	r24, Z
    4e70:	91 81       	ldd	r25, Z+1	; 0x01
    4e72:	00 97       	sbiw	r24, 0x00	; 0
    4e74:	b9 f5       	brne	.+110    	; 0x4ee4 <BCM_TxDispatcher+0x180>
						== DATA_EMPTY)
				{
					/*
					 * send checksum after data sent
					 */
					u8_BCM_ErrorStatus = UART_SendByte(
    4e76:	8a 81       	ldd	r24, Y+2	; 0x02
    4e78:	28 2f       	mov	r18, r24
    4e7a:	30 e0       	ldi	r19, 0x00	; 0
    4e7c:	c9 01       	movw	r24, r18
    4e7e:	88 0f       	add	r24, r24
    4e80:	99 1f       	adc	r25, r25
    4e82:	88 0f       	add	r24, r24
    4e84:	99 1f       	adc	r25, r25
    4e86:	88 0f       	add	r24, r24
    4e88:	99 1f       	adc	r25, r25
    4e8a:	82 0f       	add	r24, r18
    4e8c:	93 1f       	adc	r25, r19
    4e8e:	fc 01       	movw	r30, r24
    4e90:	e7 54       	subi	r30, 0x47	; 71
    4e92:	f8 4f       	sbci	r31, 0xF8	; 248
    4e94:	80 81       	ld	r24, Z
    4e96:	0e 94 0a 2d 	call	0x5a14	; 0x5a14 <UART_SendByte>
    4e9a:	8b 83       	std	Y+3, r24	; 0x03
							gastr_BCM_PacketFormat[u8_counter].u8_CheckSum);
					/*
					 * terminate the transmition
					 */
					gastr_BCM_PacketFormat[u8_counter].u8_PacketState =
    4e9c:	8a 81       	ldd	r24, Y+2	; 0x02
    4e9e:	28 2f       	mov	r18, r24
    4ea0:	30 e0       	ldi	r19, 0x00	; 0
    4ea2:	c9 01       	movw	r24, r18
    4ea4:	88 0f       	add	r24, r24
    4ea6:	99 1f       	adc	r25, r25
    4ea8:	88 0f       	add	r24, r24
    4eaa:	99 1f       	adc	r25, r25
    4eac:	88 0f       	add	r24, r24
    4eae:	99 1f       	adc	r25, r25
    4eb0:	82 0f       	add	r24, r18
    4eb2:	93 1f       	adc	r25, r19
    4eb4:	fc 01       	movw	r30, r24
    4eb6:	e8 54       	subi	r30, 0x48	; 72
    4eb8:	f8 4f       	sbci	r31, 0xF8	; 248
    4eba:	10 82       	st	Z, r1
					BCM_IDLE_STATE;
					gastr_BCM_PacketFormat[u8_counter].u8_ChannelStatus =
    4ebc:	8a 81       	ldd	r24, Y+2	; 0x02
    4ebe:	28 2f       	mov	r18, r24
    4ec0:	30 e0       	ldi	r19, 0x00	; 0
    4ec2:	c9 01       	movw	r24, r18
    4ec4:	88 0f       	add	r24, r24
    4ec6:	99 1f       	adc	r25, r25
    4ec8:	88 0f       	add	r24, r24
    4eca:	99 1f       	adc	r25, r25
    4ecc:	88 0f       	add	r24, r24
    4ece:	99 1f       	adc	r25, r25
    4ed0:	82 0f       	add	r24, r18
    4ed2:	93 1f       	adc	r25, r19
    4ed4:	fc 01       	movw	r30, r24
    4ed6:	e9 54       	subi	r30, 0x49	; 73
    4ed8:	f8 4f       	sbci	r31, 0xF8	; 248
    4eda:	10 82       	st	Z, r1
					BCM_CHANNEL_UNLOCKED;
					gu8_TxCbkStatusFlag = TRUE;
    4edc:	81 e0       	ldi	r24, 0x01	; 1
    4ede:	80 93 b0 07 	sts	0x07B0, r24
    4ee2:	a0 c0       	rjmp	.+320    	; 0x5024 <BCM_TxDispatcher+0x2c0>
				else
				{
					/*
					 * send new byte
					 */
					u8_BCM_ErrorStatus = UART_SendByte(
    4ee4:	8a 81       	ldd	r24, Y+2	; 0x02
    4ee6:	28 2f       	mov	r18, r24
    4ee8:	30 e0       	ldi	r19, 0x00	; 0
    4eea:	c9 01       	movw	r24, r18
    4eec:	88 0f       	add	r24, r24
    4eee:	99 1f       	adc	r25, r25
    4ef0:	88 0f       	add	r24, r24
    4ef2:	99 1f       	adc	r25, r25
    4ef4:	88 0f       	add	r24, r24
    4ef6:	99 1f       	adc	r25, r25
    4ef8:	82 0f       	add	r24, r18
    4efa:	93 1f       	adc	r25, r19
    4efc:	fc 01       	movw	r30, r24
    4efe:	e6 54       	subi	r30, 0x46	; 70
    4f00:	f8 4f       	sbci	r31, 0xF8	; 248
    4f02:	01 90       	ld	r0, Z+
    4f04:	f0 81       	ld	r31, Z
    4f06:	e0 2d       	mov	r30, r0
    4f08:	80 81       	ld	r24, Z
    4f0a:	0e 94 0a 2d 	call	0x5a14	; 0x5a14 <UART_SendByte>
    4f0e:	8b 83       	std	Y+3, r24	; 0x03
							*gastr_BCM_PacketFormat[u8_counter].u8_Data_ptr);

					gastr_BCM_PacketFormat[u8_counter].u16_DataSize--;
    4f10:	8a 81       	ldd	r24, Y+2	; 0x02
    4f12:	28 2f       	mov	r18, r24
    4f14:	30 e0       	ldi	r19, 0x00	; 0
    4f16:	c9 01       	movw	r24, r18
    4f18:	88 0f       	add	r24, r24
    4f1a:	99 1f       	adc	r25, r25
    4f1c:	88 0f       	add	r24, r24
    4f1e:	99 1f       	adc	r25, r25
    4f20:	88 0f       	add	r24, r24
    4f22:	99 1f       	adc	r25, r25
    4f24:	82 0f       	add	r24, r18
    4f26:	93 1f       	adc	r25, r19
    4f28:	fc 01       	movw	r30, r24
    4f2a:	e4 54       	subi	r30, 0x44	; 68
    4f2c:	f8 4f       	sbci	r31, 0xF8	; 248
    4f2e:	80 81       	ld	r24, Z
    4f30:	91 81       	ldd	r25, Z+1	; 0x01
    4f32:	ac 01       	movw	r20, r24
    4f34:	41 50       	subi	r20, 0x01	; 1
    4f36:	50 40       	sbci	r21, 0x00	; 0
    4f38:	c9 01       	movw	r24, r18
    4f3a:	88 0f       	add	r24, r24
    4f3c:	99 1f       	adc	r25, r25
    4f3e:	88 0f       	add	r24, r24
    4f40:	99 1f       	adc	r25, r25
    4f42:	88 0f       	add	r24, r24
    4f44:	99 1f       	adc	r25, r25
    4f46:	82 0f       	add	r24, r18
    4f48:	93 1f       	adc	r25, r19
    4f4a:	fc 01       	movw	r30, r24
    4f4c:	e4 54       	subi	r30, 0x44	; 68
    4f4e:	f8 4f       	sbci	r31, 0xF8	; 248
    4f50:	51 83       	std	Z+1, r21	; 0x01
    4f52:	40 83       	st	Z, r20

					gastr_BCM_PacketFormat[u8_counter].u8_CheckSum +=
    4f54:	8a 81       	ldd	r24, Y+2	; 0x02
    4f56:	48 2f       	mov	r20, r24
    4f58:	50 e0       	ldi	r21, 0x00	; 0
    4f5a:	8a 81       	ldd	r24, Y+2	; 0x02
    4f5c:	28 2f       	mov	r18, r24
    4f5e:	30 e0       	ldi	r19, 0x00	; 0
    4f60:	c9 01       	movw	r24, r18
    4f62:	88 0f       	add	r24, r24
    4f64:	99 1f       	adc	r25, r25
    4f66:	88 0f       	add	r24, r24
    4f68:	99 1f       	adc	r25, r25
    4f6a:	88 0f       	add	r24, r24
    4f6c:	99 1f       	adc	r25, r25
    4f6e:	82 0f       	add	r24, r18
    4f70:	93 1f       	adc	r25, r19
    4f72:	fc 01       	movw	r30, r24
    4f74:	e7 54       	subi	r30, 0x47	; 71
    4f76:	f8 4f       	sbci	r31, 0xF8	; 248
    4f78:	60 81       	ld	r22, Z
    4f7a:	8a 81       	ldd	r24, Y+2	; 0x02
    4f7c:	28 2f       	mov	r18, r24
    4f7e:	30 e0       	ldi	r19, 0x00	; 0
    4f80:	c9 01       	movw	r24, r18
    4f82:	88 0f       	add	r24, r24
    4f84:	99 1f       	adc	r25, r25
    4f86:	88 0f       	add	r24, r24
    4f88:	99 1f       	adc	r25, r25
    4f8a:	88 0f       	add	r24, r24
    4f8c:	99 1f       	adc	r25, r25
    4f8e:	82 0f       	add	r24, r18
    4f90:	93 1f       	adc	r25, r19
    4f92:	fc 01       	movw	r30, r24
    4f94:	e6 54       	subi	r30, 0x46	; 70
    4f96:	f8 4f       	sbci	r31, 0xF8	; 248
    4f98:	01 90       	ld	r0, Z+
    4f9a:	f0 81       	ld	r31, Z
    4f9c:	e0 2d       	mov	r30, r0
    4f9e:	80 81       	ld	r24, Z
    4fa0:	26 2f       	mov	r18, r22
    4fa2:	28 0f       	add	r18, r24
    4fa4:	ca 01       	movw	r24, r20
    4fa6:	88 0f       	add	r24, r24
    4fa8:	99 1f       	adc	r25, r25
    4faa:	88 0f       	add	r24, r24
    4fac:	99 1f       	adc	r25, r25
    4fae:	88 0f       	add	r24, r24
    4fb0:	99 1f       	adc	r25, r25
    4fb2:	84 0f       	add	r24, r20
    4fb4:	95 1f       	adc	r25, r21
    4fb6:	fc 01       	movw	r30, r24
    4fb8:	e7 54       	subi	r30, 0x47	; 71
    4fba:	f8 4f       	sbci	r31, 0xF8	; 248
    4fbc:	20 83       	st	Z, r18
							*gastr_BCM_PacketFormat[u8_counter].u8_Data_ptr;

					gastr_BCM_PacketFormat[u8_counter].u8_Data_ptr++;
    4fbe:	8a 81       	ldd	r24, Y+2	; 0x02
    4fc0:	28 2f       	mov	r18, r24
    4fc2:	30 e0       	ldi	r19, 0x00	; 0
    4fc4:	c9 01       	movw	r24, r18
    4fc6:	88 0f       	add	r24, r24
    4fc8:	99 1f       	adc	r25, r25
    4fca:	88 0f       	add	r24, r24
    4fcc:	99 1f       	adc	r25, r25
    4fce:	88 0f       	add	r24, r24
    4fd0:	99 1f       	adc	r25, r25
    4fd2:	82 0f       	add	r24, r18
    4fd4:	93 1f       	adc	r25, r19
    4fd6:	fc 01       	movw	r30, r24
    4fd8:	e6 54       	subi	r30, 0x46	; 70
    4fda:	f8 4f       	sbci	r31, 0xF8	; 248
    4fdc:	80 81       	ld	r24, Z
    4fde:	91 81       	ldd	r25, Z+1	; 0x01
    4fe0:	ac 01       	movw	r20, r24
    4fe2:	4f 5f       	subi	r20, 0xFF	; 255
    4fe4:	5f 4f       	sbci	r21, 0xFF	; 255
    4fe6:	c9 01       	movw	r24, r18
    4fe8:	88 0f       	add	r24, r24
    4fea:	99 1f       	adc	r25, r25
    4fec:	88 0f       	add	r24, r24
    4fee:	99 1f       	adc	r25, r25
    4ff0:	88 0f       	add	r24, r24
    4ff2:	99 1f       	adc	r25, r25
    4ff4:	82 0f       	add	r24, r18
    4ff6:	93 1f       	adc	r25, r19
    4ff8:	fc 01       	movw	r30, r24
    4ffa:	e6 54       	subi	r30, 0x46	; 70
    4ffc:	f8 4f       	sbci	r31, 0xF8	; 248
    4ffe:	51 83       	std	Z+1, r21	; 0x01
    5000:	40 83       	st	Z, r20

					gastr_BCM_PacketFormat[u8_counter].u8_PacketState =
    5002:	8a 81       	ldd	r24, Y+2	; 0x02
    5004:	28 2f       	mov	r18, r24
    5006:	30 e0       	ldi	r19, 0x00	; 0
    5008:	c9 01       	movw	r24, r18
    500a:	88 0f       	add	r24, r24
    500c:	99 1f       	adc	r25, r25
    500e:	88 0f       	add	r24, r24
    5010:	99 1f       	adc	r25, r25
    5012:	88 0f       	add	r24, r24
    5014:	99 1f       	adc	r25, r25
    5016:	82 0f       	add	r24, r18
    5018:	93 1f       	adc	r25, r19
    501a:	fc 01       	movw	r30, r24
    501c:	e8 54       	subi	r30, 0x48	; 72
    501e:	f8 4f       	sbci	r31, 0xF8	; 248
    5020:	81 e0       	ldi	r24, 0x01	; 1
    5022:	80 83       	st	Z, r24
	static uint8 u8_SizeSentFlag = SIZE_NOT_SENT;

	if (gu8_BCM_Status == BCM_INTIALIZED)
	{
		for (u8_counter = BCM_UNINTIALIZED; u8_counter < BCM_MAX_CHANNEL_NUM;
				u8_counter++)
    5024:	8a 81       	ldd	r24, Y+2	; 0x02
    5026:	8f 5f       	subi	r24, 0xFF	; 255
    5028:	8a 83       	std	Y+2, r24	; 0x02
	uint8 u8_counter = BCM_UNINTIALIZED, u8_Size;
	static uint8 u8_SizeSentFlag = SIZE_NOT_SENT;

	if (gu8_BCM_Status == BCM_INTIALIZED)
	{
		for (u8_counter = BCM_UNINTIALIZED; u8_counter < BCM_MAX_CHANNEL_NUM;
    502a:	8a 81       	ldd	r24, Y+2	; 0x02
    502c:	82 30       	cpi	r24, 0x02	; 2
    502e:	08 f4       	brcc	.+2      	; 0x5032 <BCM_TxDispatcher+0x2ce>
    5030:	a9 ce       	rjmp	.-686    	; 0x4d84 <BCM_TxDispatcher+0x20>
    5032:	02 c0       	rjmp	.+4      	; 0x5038 <BCM_TxDispatcher+0x2d4>
	else
	{
		/*
		 * try to use un initialized BCM
		 */
		u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_NOT_INITIALIZED;
    5034:	84 ea       	ldi	r24, 0xA4	; 164
    5036:	8b 83       	std	Y+3, r24	; 0x03
	}
	/*
	 * Function shall return the Error state
	 */
	return u8_BCM_ErrorStatus;
    5038:	8b 81       	ldd	r24, Y+3	; 0x03
}
    503a:	0f 90       	pop	r0
    503c:	0f 90       	pop	r0
    503e:	0f 90       	pop	r0
    5040:	cf 91       	pop	r28
    5042:	df 91       	pop	r29
    5044:	08 95       	ret

00005046 <BCM_Setup_Receive>:
/* Description: setup BCM reciever buffer .														*/
/************************************************************************************************/
BCM_ERROR_STATUS BCM_Setup_Receive(uint8 u8_BCM_Channel_ID,
		gptrfu_Status_cbk_t BCM_Status_cbk_ptr, uint8 * u8_BCM_Buffer_ptr,
		uint16 u16_BCM_BufferSize)
{
    5046:	df 93       	push	r29
    5048:	cf 93       	push	r28
    504a:	cd b7       	in	r28, 0x3d	; 61
    504c:	de b7       	in	r29, 0x3e	; 62
    504e:	28 97       	sbiw	r28, 0x08	; 8
    5050:	0f b6       	in	r0, 0x3f	; 63
    5052:	f8 94       	cli
    5054:	de bf       	out	0x3e, r29	; 62
    5056:	0f be       	out	0x3f, r0	; 63
    5058:	cd bf       	out	0x3d, r28	; 61
    505a:	8a 83       	std	Y+2, r24	; 0x02
    505c:	7c 83       	std	Y+4, r23	; 0x04
    505e:	6b 83       	std	Y+3, r22	; 0x03
    5060:	5e 83       	std	Y+6, r21	; 0x06
    5062:	4d 83       	std	Y+5, r20	; 0x05
    5064:	38 87       	std	Y+8, r19	; 0x08
    5066:	2f 83       	std	Y+7, r18	; 0x07
	/*
	 * Error state: No Error
	 */
	BCM_ERROR_STATUS u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_SUCCESS;
    5068:	86 ea       	ldi	r24, 0xA6	; 166
    506a:	89 83       	std	Y+1, r24	; 0x01

	if (gu8_BCM_Status == BCM_UNINTIALIZED)
    506c:	80 91 b2 07 	lds	r24, 0x07B2
    5070:	88 23       	and	r24, r24
    5072:	19 f4       	brne	.+6      	; 0x507a <BCM_Setup_Receive+0x34>
	{
		/*
		 * try to use un initialized BCM
		 */
		u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_NOT_INITIALIZED;
    5074:	84 ea       	ldi	r24, 0xA4	; 164
    5076:	89 83       	std	Y+1, r24	; 0x01
    5078:	90 c0       	rjmp	.+288    	; 0x519a <BCM_Setup_Receive+0x154>
	}
	else if (u8_BCM_Channel_ID >= BCM_MAX_CHANNEL_NUM)
    507a:	8a 81       	ldd	r24, Y+2	; 0x02
    507c:	82 30       	cpi	r24, 0x02	; 2
    507e:	18 f0       	brcs	.+6      	; 0x5086 <BCM_Setup_Receive+0x40>
	{
		/*
		 * wrong channel ID
		 */
		u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_INVALID_ARGU;
    5080:	85 ea       	ldi	r24, 0xA5	; 165
    5082:	89 83       	std	Y+1, r24	; 0x01
    5084:	8a c0       	rjmp	.+276    	; 0x519a <BCM_Setup_Receive+0x154>
	}
	/*
	 * check if channel ID unlocked
	 */
	else if (gastr_BCM_PacketFormat[u8_BCM_Channel_ID].u8_ChannelStatus
    5086:	8a 81       	ldd	r24, Y+2	; 0x02
    5088:	28 2f       	mov	r18, r24
    508a:	30 e0       	ldi	r19, 0x00	; 0
    508c:	c9 01       	movw	r24, r18
    508e:	88 0f       	add	r24, r24
    5090:	99 1f       	adc	r25, r25
    5092:	88 0f       	add	r24, r24
    5094:	99 1f       	adc	r25, r25
    5096:	88 0f       	add	r24, r24
    5098:	99 1f       	adc	r25, r25
    509a:	82 0f       	add	r24, r18
    509c:	93 1f       	adc	r25, r19
    509e:	fc 01       	movw	r30, r24
    50a0:	e9 54       	subi	r30, 0x49	; 73
    50a2:	f8 4f       	sbci	r31, 0xF8	; 248
    50a4:	80 81       	ld	r24, Z
    50a6:	81 30       	cpi	r24, 0x01	; 1
    50a8:	19 f4       	brne	.+6      	; 0x50b0 <BCM_Setup_Receive+0x6a>
			== BCM_CHANNEL_LOCKED)
	{
		/*
		 *  channel ID is locked
		 */
		u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_BUFFER_FULL;
    50aa:	8f e9       	ldi	r24, 0x9F	; 159
    50ac:	89 83       	std	Y+1, r24	; 0x01
    50ae:	75 c0       	rjmp	.+234    	; 0x519a <BCM_Setup_Receive+0x154>
	}
	else if ((u8_BCM_Buffer_ptr == NULL) || (BCM_Status_cbk_ptr == NULL))
    50b0:	8d 81       	ldd	r24, Y+5	; 0x05
    50b2:	9e 81       	ldd	r25, Y+6	; 0x06
    50b4:	00 97       	sbiw	r24, 0x00	; 0
    50b6:	21 f0       	breq	.+8      	; 0x50c0 <BCM_Setup_Receive+0x7a>
    50b8:	8b 81       	ldd	r24, Y+3	; 0x03
    50ba:	9c 81       	ldd	r25, Y+4	; 0x04
    50bc:	00 97       	sbiw	r24, 0x00	; 0
    50be:	19 f4       	brne	.+6      	; 0x50c6 <BCM_Setup_Receive+0x80>
	{
		/*
		 * trying to access a null pointer
		 */
		u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_NULL_PTR;
    50c0:	82 ea       	ldi	r24, 0xA2	; 162
    50c2:	89 83       	std	Y+1, r24	; 0x01
    50c4:	6a c0       	rjmp	.+212    	; 0x519a <BCM_Setup_Receive+0x154>
	else
	{
		/*
		 * setup packet
		 */
		gastr_BCM_PacketFormat[u8_BCM_Channel_ID].u16_DataSize =
    50c6:	8a 81       	ldd	r24, Y+2	; 0x02
    50c8:	28 2f       	mov	r18, r24
    50ca:	30 e0       	ldi	r19, 0x00	; 0
    50cc:	c9 01       	movw	r24, r18
    50ce:	88 0f       	add	r24, r24
    50d0:	99 1f       	adc	r25, r25
    50d2:	88 0f       	add	r24, r24
    50d4:	99 1f       	adc	r25, r25
    50d6:	88 0f       	add	r24, r24
    50d8:	99 1f       	adc	r25, r25
    50da:	82 0f       	add	r24, r18
    50dc:	93 1f       	adc	r25, r19
    50de:	fc 01       	movw	r30, r24
    50e0:	e4 54       	subi	r30, 0x44	; 68
    50e2:	f8 4f       	sbci	r31, 0xF8	; 248
    50e4:	8f 81       	ldd	r24, Y+7	; 0x07
    50e6:	98 85       	ldd	r25, Y+8	; 0x08
    50e8:	91 83       	std	Z+1, r25	; 0x01
    50ea:	80 83       	st	Z, r24
				u16_BCM_BufferSize;
		gastr_BCM_PacketFormat[u8_BCM_Channel_ID].u8_Data_ptr =
    50ec:	8a 81       	ldd	r24, Y+2	; 0x02
    50ee:	28 2f       	mov	r18, r24
    50f0:	30 e0       	ldi	r19, 0x00	; 0
    50f2:	c9 01       	movw	r24, r18
    50f4:	88 0f       	add	r24, r24
    50f6:	99 1f       	adc	r25, r25
    50f8:	88 0f       	add	r24, r24
    50fa:	99 1f       	adc	r25, r25
    50fc:	88 0f       	add	r24, r24
    50fe:	99 1f       	adc	r25, r25
    5100:	82 0f       	add	r24, r18
    5102:	93 1f       	adc	r25, r19
    5104:	fc 01       	movw	r30, r24
    5106:	e6 54       	subi	r30, 0x46	; 70
    5108:	f8 4f       	sbci	r31, 0xF8	; 248
    510a:	8d 81       	ldd	r24, Y+5	; 0x05
    510c:	9e 81       	ldd	r25, Y+6	; 0x06
    510e:	91 83       	std	Z+1, r25	; 0x01
    5110:	80 83       	st	Z, r24
				u8_BCM_Buffer_ptr;
		gastr_BCM_PacketFormat[u8_BCM_Channel_ID].BCM_Status_cbk =
    5112:	8a 81       	ldd	r24, Y+2	; 0x02
    5114:	28 2f       	mov	r18, r24
    5116:	30 e0       	ldi	r19, 0x00	; 0
    5118:	c9 01       	movw	r24, r18
    511a:	88 0f       	add	r24, r24
    511c:	99 1f       	adc	r25, r25
    511e:	88 0f       	add	r24, r24
    5120:	99 1f       	adc	r25, r25
    5122:	88 0f       	add	r24, r24
    5124:	99 1f       	adc	r25, r25
    5126:	82 0f       	add	r24, r18
    5128:	93 1f       	adc	r25, r19
    512a:	fc 01       	movw	r30, r24
    512c:	e2 54       	subi	r30, 0x42	; 66
    512e:	f8 4f       	sbci	r31, 0xF8	; 248
    5130:	8b 81       	ldd	r24, Y+3	; 0x03
    5132:	9c 81       	ldd	r25, Y+4	; 0x04
    5134:	91 83       	std	Z+1, r25	; 0x01
    5136:	80 83       	st	Z, r24
				BCM_Status_cbk_ptr;
		gastr_BCM_PacketFormat[u8_BCM_Channel_ID].u8_CheckSum =
    5138:	8a 81       	ldd	r24, Y+2	; 0x02
    513a:	28 2f       	mov	r18, r24
    513c:	30 e0       	ldi	r19, 0x00	; 0
    513e:	c9 01       	movw	r24, r18
    5140:	88 0f       	add	r24, r24
    5142:	99 1f       	adc	r25, r25
    5144:	88 0f       	add	r24, r24
    5146:	99 1f       	adc	r25, r25
    5148:	88 0f       	add	r24, r24
    514a:	99 1f       	adc	r25, r25
    514c:	82 0f       	add	r24, r18
    514e:	93 1f       	adc	r25, r19
    5150:	fc 01       	movw	r30, r24
    5152:	e7 54       	subi	r30, 0x47	; 71
    5154:	f8 4f       	sbci	r31, 0xF8	; 248
    5156:	10 82       	st	Z, r1
		BCM_UNINTIALIZED;
		gastr_BCM_PacketFormat[u8_BCM_Channel_ID].u8_ChannelStatus =
    5158:	8a 81       	ldd	r24, Y+2	; 0x02
    515a:	28 2f       	mov	r18, r24
    515c:	30 e0       	ldi	r19, 0x00	; 0
    515e:	c9 01       	movw	r24, r18
    5160:	88 0f       	add	r24, r24
    5162:	99 1f       	adc	r25, r25
    5164:	88 0f       	add	r24, r24
    5166:	99 1f       	adc	r25, r25
    5168:	88 0f       	add	r24, r24
    516a:	99 1f       	adc	r25, r25
    516c:	82 0f       	add	r24, r18
    516e:	93 1f       	adc	r25, r19
    5170:	fc 01       	movw	r30, r24
    5172:	e9 54       	subi	r30, 0x49	; 73
    5174:	f8 4f       	sbci	r31, 0xF8	; 248
    5176:	81 e0       	ldi	r24, 0x01	; 1
    5178:	80 83       	st	Z, r24
		BCM_CHANNEL_LOCKED;
		gastr_BCM_PacketFormat[u8_BCM_Channel_ID].u8_PacketState =
    517a:	8a 81       	ldd	r24, Y+2	; 0x02
    517c:	28 2f       	mov	r18, r24
    517e:	30 e0       	ldi	r19, 0x00	; 0
    5180:	c9 01       	movw	r24, r18
    5182:	88 0f       	add	r24, r24
    5184:	99 1f       	adc	r25, r25
    5186:	88 0f       	add	r24, r24
    5188:	99 1f       	adc	r25, r25
    518a:	88 0f       	add	r24, r24
    518c:	99 1f       	adc	r25, r25
    518e:	82 0f       	add	r24, r18
    5190:	93 1f       	adc	r25, r19
    5192:	fc 01       	movw	r30, r24
    5194:	e8 54       	subi	r30, 0x48	; 72
    5196:	f8 4f       	sbci	r31, 0xF8	; 248
    5198:	10 82       	st	Z, r1
		BCM_IDLE_STATE;
	}
	/*
	 * Function shall return the Error state
	 */
	return u8_BCM_ErrorStatus;
    519a:	89 81       	ldd	r24, Y+1	; 0x01
}
    519c:	28 96       	adiw	r28, 0x08	; 8
    519e:	0f b6       	in	r0, 0x3f	; 63
    51a0:	f8 94       	cli
    51a2:	de bf       	out	0x3e, r29	; 62
    51a4:	0f be       	out	0x3f, r0	; 63
    51a6:	cd bf       	out	0x3d, r28	; 61
    51a8:	cf 91       	pop	r28
    51aa:	df 91       	pop	r29
    51ac:	08 95       	ret

000051ae <BCM_RxDispatcher>:
/* In/Out:																						*/
/* Return: The error status of the function.													*/
/* Description: the BCM main operation "recieve data"						.					*/
/************************************************************************************************/
BCM_ERROR_STATUS BCM_RxDispatcher(void)
{
    51ae:	df 93       	push	r29
    51b0:	cf 93       	push	r28
    51b2:	00 d0       	rcall	.+0      	; 0x51b4 <BCM_RxDispatcher+0x6>
    51b4:	cd b7       	in	r28, 0x3d	; 61
    51b6:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Error state: No Error
	 */
	BCM_ERROR_STATUS u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_SUCCESS;
    51b8:	86 ea       	ldi	r24, 0xA6	; 166
    51ba:	8a 83       	std	Y+2, r24	; 0x02
	uint8 u8_counter = BCM_UNINTIALIZED;
    51bc:	19 82       	std	Y+1, r1	; 0x01
	static uint8 u8_SizeSentFlag = SIZE_NOT_RECEIVED;
	static uint16 u16_ReceivedSize = BCM_UNINTIALIZED;

	if (gu8_BCM_Status == BCM_INTIALIZED)
    51be:	80 91 b2 07 	lds	r24, 0x07B2
    51c2:	81 30       	cpi	r24, 0x01	; 1
    51c4:	09 f0       	breq	.+2      	; 0x51c8 <BCM_RxDispatcher+0x1a>
    51c6:	46 c1       	rjmp	.+652    	; 0x5454 <BCM_RxDispatcher+0x2a6>
	{
		for (u8_counter = BCM_UNINTIALIZED; u8_counter < BCM_MAX_CHANNEL_NUM;
    51c8:	19 82       	std	Y+1, r1	; 0x01
    51ca:	3f c1       	rjmp	.+638    	; 0x544a <BCM_RxDispatcher+0x29c>
				u8_counter++)
		{
			if (gastr_BCM_PacketFormat[u8_counter].u8_ChannelStatus
    51cc:	89 81       	ldd	r24, Y+1	; 0x01
    51ce:	28 2f       	mov	r18, r24
    51d0:	30 e0       	ldi	r19, 0x00	; 0
    51d2:	c9 01       	movw	r24, r18
    51d4:	88 0f       	add	r24, r24
    51d6:	99 1f       	adc	r25, r25
    51d8:	88 0f       	add	r24, r24
    51da:	99 1f       	adc	r25, r25
    51dc:	88 0f       	add	r24, r24
    51de:	99 1f       	adc	r25, r25
    51e0:	82 0f       	add	r24, r18
    51e2:	93 1f       	adc	r25, r19
    51e4:	fc 01       	movw	r30, r24
    51e6:	e9 54       	subi	r30, 0x49	; 73
    51e8:	f8 4f       	sbci	r31, 0xF8	; 248
    51ea:	80 81       	ld	r24, Z
    51ec:	88 23       	and	r24, r24
    51ee:	19 f4       	brne	.+6      	; 0x51f6 <BCM_RxDispatcher+0x48>
					== BCM_CHANNEL_UNLOCKED)
			{
				/*
				 *  channel ID is unlocked
				 */
				u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_NOT_SUPPORTED;
    51f0:	8e e9       	ldi	r24, 0x9E	; 158
    51f2:	8a 83       	std	Y+2, r24	; 0x02
    51f4:	27 c1       	rjmp	.+590    	; 0x5444 <BCM_RxDispatcher+0x296>
			}
			else if (gastr_BCM_PacketFormat[u8_counter].u8_PacketState
    51f6:	89 81       	ldd	r24, Y+1	; 0x01
    51f8:	28 2f       	mov	r18, r24
    51fa:	30 e0       	ldi	r19, 0x00	; 0
    51fc:	c9 01       	movw	r24, r18
    51fe:	88 0f       	add	r24, r24
    5200:	99 1f       	adc	r25, r25
    5202:	88 0f       	add	r24, r24
    5204:	99 1f       	adc	r25, r25
    5206:	88 0f       	add	r24, r24
    5208:	99 1f       	adc	r25, r25
    520a:	82 0f       	add	r24, r18
    520c:	93 1f       	adc	r25, r19
    520e:	fc 01       	movw	r30, r24
    5210:	e8 54       	subi	r30, 0x48	; 72
    5212:	f8 4f       	sbci	r31, 0xF8	; 248
    5214:	80 81       	ld	r24, Z
    5216:	84 30       	cpi	r24, 0x04	; 4
    5218:	19 f0       	breq	.+6      	; 0x5220 <BCM_RxDispatcher+0x72>
					!= BCM_RX_COMPLETE_STATE)
			{
				/*
				 *  wrong state
				 */
				u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_NOT_SUPPORTED;
    521a:	8e e9       	ldi	r24, 0x9E	; 158
    521c:	8a 83       	std	Y+2, r24	; 0x02
    521e:	12 c1       	rjmp	.+548    	; 0x5444 <BCM_RxDispatcher+0x296>
			}
			else
			{
				if (u8_SizeSentFlag != SIZE_RECEIVED)
    5220:	80 91 b6 07 	lds	r24, 0x07B6
    5224:	80 31       	cpi	r24, 0x10	; 16
    5226:	09 f4       	brne	.+2      	; 0x522a <BCM_RxDispatcher+0x7c>
    5228:	3f c0       	rjmp	.+126    	; 0x52a8 <BCM_RxDispatcher+0xfa>
				{
					/*
					 * receive data size first
					 */
					u16_ReceivedSize |=
    522a:	89 81       	ldd	r24, Y+1	; 0x01
    522c:	28 2f       	mov	r18, r24
    522e:	30 e0       	ldi	r19, 0x00	; 0
    5230:	c9 01       	movw	r24, r18
    5232:	88 0f       	add	r24, r24
    5234:	99 1f       	adc	r25, r25
    5236:	88 0f       	add	r24, r24
    5238:	99 1f       	adc	r25, r25
    523a:	88 0f       	add	r24, r24
    523c:	99 1f       	adc	r25, r25
    523e:	82 0f       	add	r24, r18
    5240:	93 1f       	adc	r25, r19
    5242:	fc 01       	movw	r30, r24
    5244:	e6 54       	subi	r30, 0x46	; 70
    5246:	f8 4f       	sbci	r31, 0xF8	; 248
    5248:	01 90       	ld	r0, Z+
    524a:	f0 81       	ld	r31, Z
    524c:	e0 2d       	mov	r30, r0
    524e:	80 81       	ld	r24, Z
    5250:	28 2f       	mov	r18, r24
    5252:	30 e0       	ldi	r19, 0x00	; 0
    5254:	80 91 b6 07 	lds	r24, 0x07B6
    5258:	88 2f       	mov	r24, r24
    525a:	90 e0       	ldi	r25, 0x00	; 0
    525c:	02 c0       	rjmp	.+4      	; 0x5262 <BCM_RxDispatcher+0xb4>
    525e:	22 0f       	add	r18, r18
    5260:	33 1f       	adc	r19, r19
    5262:	8a 95       	dec	r24
    5264:	e2 f7       	brpl	.-8      	; 0x525e <BCM_RxDispatcher+0xb0>
    5266:	80 91 b4 07 	lds	r24, 0x07B4
    526a:	90 91 b5 07 	lds	r25, 0x07B5
    526e:	82 2b       	or	r24, r18
    5270:	93 2b       	or	r25, r19
    5272:	90 93 b5 07 	sts	0x07B5, r25
    5276:	80 93 b4 07 	sts	0x07B4, r24
							((uint16) (*gastr_BCM_PacketFormat[u8_counter].u8_Data_ptr)
									<< u8_SizeSentFlag);
					u8_SizeSentFlag += ONE_BYTE;
    527a:	80 91 b6 07 	lds	r24, 0x07B6
    527e:	88 5f       	subi	r24, 0xF8	; 248
    5280:	80 93 b6 07 	sts	0x07B6, r24
					gastr_BCM_PacketFormat[u8_counter].u8_PacketState =
    5284:	89 81       	ldd	r24, Y+1	; 0x01
    5286:	28 2f       	mov	r18, r24
    5288:	30 e0       	ldi	r19, 0x00	; 0
    528a:	c9 01       	movw	r24, r18
    528c:	88 0f       	add	r24, r24
    528e:	99 1f       	adc	r25, r25
    5290:	88 0f       	add	r24, r24
    5292:	99 1f       	adc	r25, r25
    5294:	88 0f       	add	r24, r24
    5296:	99 1f       	adc	r25, r25
    5298:	82 0f       	add	r24, r18
    529a:	93 1f       	adc	r25, r19
    529c:	fc 01       	movw	r30, r24
    529e:	e8 54       	subi	r30, 0x48	; 72
    52a0:	f8 4f       	sbci	r31, 0xF8	; 248
    52a2:	83 e0       	ldi	r24, 0x03	; 3
    52a4:	80 83       	st	Z, r24
    52a6:	ce c0       	rjmp	.+412    	; 0x5444 <BCM_RxDispatcher+0x296>
					BCM_RX_STATE;
				}
				else if (u16_ReceivedSize == DATA_EMPTY)
    52a8:	80 91 b4 07 	lds	r24, 0x07B4
    52ac:	90 91 b5 07 	lds	r25, 0x07B5
    52b0:	00 97       	sbiw	r24, 0x00	; 0
    52b2:	e1 f5       	brne	.+120    	; 0x532c <BCM_RxDispatcher+0x17e>
				{
					/*
					 * check on checksum after data received
					 */
					if (*gastr_BCM_PacketFormat[u8_counter].u8_Data_ptr
    52b4:	89 81       	ldd	r24, Y+1	; 0x01
    52b6:	28 2f       	mov	r18, r24
    52b8:	30 e0       	ldi	r19, 0x00	; 0
    52ba:	c9 01       	movw	r24, r18
    52bc:	88 0f       	add	r24, r24
    52be:	99 1f       	adc	r25, r25
    52c0:	88 0f       	add	r24, r24
    52c2:	99 1f       	adc	r25, r25
    52c4:	88 0f       	add	r24, r24
    52c6:	99 1f       	adc	r25, r25
    52c8:	82 0f       	add	r24, r18
    52ca:	93 1f       	adc	r25, r19
    52cc:	fc 01       	movw	r30, r24
    52ce:	e6 54       	subi	r30, 0x46	; 70
    52d0:	f8 4f       	sbci	r31, 0xF8	; 248
    52d2:	01 90       	ld	r0, Z+
    52d4:	f0 81       	ld	r31, Z
    52d6:	e0 2d       	mov	r30, r0
    52d8:	40 81       	ld	r20, Z
    52da:	89 81       	ldd	r24, Y+1	; 0x01
    52dc:	28 2f       	mov	r18, r24
    52de:	30 e0       	ldi	r19, 0x00	; 0
    52e0:	c9 01       	movw	r24, r18
    52e2:	88 0f       	add	r24, r24
    52e4:	99 1f       	adc	r25, r25
    52e6:	88 0f       	add	r24, r24
    52e8:	99 1f       	adc	r25, r25
    52ea:	88 0f       	add	r24, r24
    52ec:	99 1f       	adc	r25, r25
    52ee:	82 0f       	add	r24, r18
    52f0:	93 1f       	adc	r25, r19
    52f2:	fc 01       	movw	r30, r24
    52f4:	e7 54       	subi	r30, 0x47	; 71
    52f6:	f8 4f       	sbci	r31, 0xF8	; 248
    52f8:	80 81       	ld	r24, Z
    52fa:	48 17       	cp	r20, r24
    52fc:	a1 f4       	brne	.+40     	; 0x5326 <BCM_RxDispatcher+0x178>
					{

						/*
						 * terminate the transmition
						 */
						gastr_BCM_PacketFormat[u8_counter].u8_PacketState =
    52fe:	89 81       	ldd	r24, Y+1	; 0x01
    5300:	28 2f       	mov	r18, r24
    5302:	30 e0       	ldi	r19, 0x00	; 0
    5304:	c9 01       	movw	r24, r18
    5306:	88 0f       	add	r24, r24
    5308:	99 1f       	adc	r25, r25
    530a:	88 0f       	add	r24, r24
    530c:	99 1f       	adc	r25, r25
    530e:	88 0f       	add	r24, r24
    5310:	99 1f       	adc	r25, r25
    5312:	82 0f       	add	r24, r18
    5314:	93 1f       	adc	r25, r19
    5316:	fc 01       	movw	r30, r24
    5318:	e8 54       	subi	r30, 0x48	; 72
    531a:	f8 4f       	sbci	r31, 0xF8	; 248
    531c:	10 82       	st	Z, r1
						BCM_IDLE_STATE;
						gu8_RxCbkStatusFlag = TRUE;
    531e:	81 e0       	ldi	r24, 0x01	; 1
    5320:	80 93 b1 07 	sts	0x07B1, r24
    5324:	8f c0       	rjmp	.+286    	; 0x5444 <BCM_RxDispatcher+0x296>
					else
					{
						/*
						 * data corrupted
						 */
						u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_BUFFER_FULL;
    5326:	8f e9       	ldi	r24, 0x9F	; 159
    5328:	8a 83       	std	Y+2, r24	; 0x02
    532a:	8c c0       	rjmp	.+280    	; 0x5444 <BCM_RxDispatcher+0x296>
				else
				{
					/*
					 * check if buffer size is sufficient
					 */
					if (u16_ReceivedSize
    532c:	89 81       	ldd	r24, Y+1	; 0x01
    532e:	28 2f       	mov	r18, r24
    5330:	30 e0       	ldi	r19, 0x00	; 0
    5332:	c9 01       	movw	r24, r18
    5334:	88 0f       	add	r24, r24
    5336:	99 1f       	adc	r25, r25
    5338:	88 0f       	add	r24, r24
    533a:	99 1f       	adc	r25, r25
    533c:	88 0f       	add	r24, r24
    533e:	99 1f       	adc	r25, r25
    5340:	82 0f       	add	r24, r18
    5342:	93 1f       	adc	r25, r19
    5344:	fc 01       	movw	r30, r24
    5346:	e4 54       	subi	r30, 0x44	; 68
    5348:	f8 4f       	sbci	r31, 0xF8	; 248
    534a:	20 81       	ld	r18, Z
    534c:	31 81       	ldd	r19, Z+1	; 0x01
    534e:	80 91 b4 07 	lds	r24, 0x07B4
    5352:	90 91 b5 07 	lds	r25, 0x07B5
    5356:	28 17       	cp	r18, r24
    5358:	39 07       	cpc	r19, r25
    535a:	18 f4       	brcc	.+6      	; 0x5362 <BCM_RxDispatcher+0x1b4>
							> gastr_BCM_PacketFormat[u8_counter].u16_DataSize)
					{
						/*
						 * insufficient buffer size
						 */
						u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_INVALID_ARGU;
    535c:	85 ea       	ldi	r24, 0xA5	; 165
    535e:	8a 83       	std	Y+2, r24	; 0x02
    5360:	71 c0       	rjmp	.+226    	; 0x5444 <BCM_RxDispatcher+0x296>
					else
					{
						/*
						 * receive new byte
						 */
						gastr_BCM_PacketFormat[u8_counter].u8_CheckSum +=
    5362:	89 81       	ldd	r24, Y+1	; 0x01
    5364:	48 2f       	mov	r20, r24
    5366:	50 e0       	ldi	r21, 0x00	; 0
    5368:	89 81       	ldd	r24, Y+1	; 0x01
    536a:	28 2f       	mov	r18, r24
    536c:	30 e0       	ldi	r19, 0x00	; 0
    536e:	c9 01       	movw	r24, r18
    5370:	88 0f       	add	r24, r24
    5372:	99 1f       	adc	r25, r25
    5374:	88 0f       	add	r24, r24
    5376:	99 1f       	adc	r25, r25
    5378:	88 0f       	add	r24, r24
    537a:	99 1f       	adc	r25, r25
    537c:	82 0f       	add	r24, r18
    537e:	93 1f       	adc	r25, r19
    5380:	fc 01       	movw	r30, r24
    5382:	e7 54       	subi	r30, 0x47	; 71
    5384:	f8 4f       	sbci	r31, 0xF8	; 248
    5386:	60 81       	ld	r22, Z
    5388:	89 81       	ldd	r24, Y+1	; 0x01
    538a:	28 2f       	mov	r18, r24
    538c:	30 e0       	ldi	r19, 0x00	; 0
    538e:	c9 01       	movw	r24, r18
    5390:	88 0f       	add	r24, r24
    5392:	99 1f       	adc	r25, r25
    5394:	88 0f       	add	r24, r24
    5396:	99 1f       	adc	r25, r25
    5398:	88 0f       	add	r24, r24
    539a:	99 1f       	adc	r25, r25
    539c:	82 0f       	add	r24, r18
    539e:	93 1f       	adc	r25, r19
    53a0:	fc 01       	movw	r30, r24
    53a2:	e6 54       	subi	r30, 0x46	; 70
    53a4:	f8 4f       	sbci	r31, 0xF8	; 248
    53a6:	01 90       	ld	r0, Z+
    53a8:	f0 81       	ld	r31, Z
    53aa:	e0 2d       	mov	r30, r0
    53ac:	80 81       	ld	r24, Z
    53ae:	26 2f       	mov	r18, r22
    53b0:	28 0f       	add	r18, r24
    53b2:	ca 01       	movw	r24, r20
    53b4:	88 0f       	add	r24, r24
    53b6:	99 1f       	adc	r25, r25
    53b8:	88 0f       	add	r24, r24
    53ba:	99 1f       	adc	r25, r25
    53bc:	88 0f       	add	r24, r24
    53be:	99 1f       	adc	r25, r25
    53c0:	84 0f       	add	r24, r20
    53c2:	95 1f       	adc	r25, r21
    53c4:	fc 01       	movw	r30, r24
    53c6:	e7 54       	subi	r30, 0x47	; 71
    53c8:	f8 4f       	sbci	r31, 0xF8	; 248
    53ca:	20 83       	st	Z, r18
								*gastr_BCM_PacketFormat[u8_counter].u8_Data_ptr;

						gastr_BCM_PacketFormat[u8_counter].u8_Data_ptr++;
    53cc:	89 81       	ldd	r24, Y+1	; 0x01
    53ce:	28 2f       	mov	r18, r24
    53d0:	30 e0       	ldi	r19, 0x00	; 0
    53d2:	c9 01       	movw	r24, r18
    53d4:	88 0f       	add	r24, r24
    53d6:	99 1f       	adc	r25, r25
    53d8:	88 0f       	add	r24, r24
    53da:	99 1f       	adc	r25, r25
    53dc:	88 0f       	add	r24, r24
    53de:	99 1f       	adc	r25, r25
    53e0:	82 0f       	add	r24, r18
    53e2:	93 1f       	adc	r25, r19
    53e4:	fc 01       	movw	r30, r24
    53e6:	e6 54       	subi	r30, 0x46	; 70
    53e8:	f8 4f       	sbci	r31, 0xF8	; 248
    53ea:	80 81       	ld	r24, Z
    53ec:	91 81       	ldd	r25, Z+1	; 0x01
    53ee:	ac 01       	movw	r20, r24
    53f0:	4f 5f       	subi	r20, 0xFF	; 255
    53f2:	5f 4f       	sbci	r21, 0xFF	; 255
    53f4:	c9 01       	movw	r24, r18
    53f6:	88 0f       	add	r24, r24
    53f8:	99 1f       	adc	r25, r25
    53fa:	88 0f       	add	r24, r24
    53fc:	99 1f       	adc	r25, r25
    53fe:	88 0f       	add	r24, r24
    5400:	99 1f       	adc	r25, r25
    5402:	82 0f       	add	r24, r18
    5404:	93 1f       	adc	r25, r19
    5406:	fc 01       	movw	r30, r24
    5408:	e6 54       	subi	r30, 0x46	; 70
    540a:	f8 4f       	sbci	r31, 0xF8	; 248
    540c:	51 83       	std	Z+1, r21	; 0x01
    540e:	40 83       	st	Z, r20

						u16_ReceivedSize--;
    5410:	80 91 b4 07 	lds	r24, 0x07B4
    5414:	90 91 b5 07 	lds	r25, 0x07B5
    5418:	01 97       	sbiw	r24, 0x01	; 1
    541a:	90 93 b5 07 	sts	0x07B5, r25
    541e:	80 93 b4 07 	sts	0x07B4, r24

						gastr_BCM_PacketFormat[u8_counter].u8_PacketState =
    5422:	89 81       	ldd	r24, Y+1	; 0x01
    5424:	28 2f       	mov	r18, r24
    5426:	30 e0       	ldi	r19, 0x00	; 0
    5428:	c9 01       	movw	r24, r18
    542a:	88 0f       	add	r24, r24
    542c:	99 1f       	adc	r25, r25
    542e:	88 0f       	add	r24, r24
    5430:	99 1f       	adc	r25, r25
    5432:	88 0f       	add	r24, r24
    5434:	99 1f       	adc	r25, r25
    5436:	82 0f       	add	r24, r18
    5438:	93 1f       	adc	r25, r19
    543a:	fc 01       	movw	r30, r24
    543c:	e8 54       	subi	r30, 0x48	; 72
    543e:	f8 4f       	sbci	r31, 0xF8	; 248
    5440:	83 e0       	ldi	r24, 0x03	; 3
    5442:	80 83       	st	Z, r24
	static uint16 u16_ReceivedSize = BCM_UNINTIALIZED;

	if (gu8_BCM_Status == BCM_INTIALIZED)
	{
		for (u8_counter = BCM_UNINTIALIZED; u8_counter < BCM_MAX_CHANNEL_NUM;
				u8_counter++)
    5444:	89 81       	ldd	r24, Y+1	; 0x01
    5446:	8f 5f       	subi	r24, 0xFF	; 255
    5448:	89 83       	std	Y+1, r24	; 0x01
	static uint8 u8_SizeSentFlag = SIZE_NOT_RECEIVED;
	static uint16 u16_ReceivedSize = BCM_UNINTIALIZED;

	if (gu8_BCM_Status == BCM_INTIALIZED)
	{
		for (u8_counter = BCM_UNINTIALIZED; u8_counter < BCM_MAX_CHANNEL_NUM;
    544a:	89 81       	ldd	r24, Y+1	; 0x01
    544c:	82 30       	cpi	r24, 0x02	; 2
    544e:	08 f4       	brcc	.+2      	; 0x5452 <BCM_RxDispatcher+0x2a4>
    5450:	bd ce       	rjmp	.-646    	; 0x51cc <BCM_RxDispatcher+0x1e>
    5452:	02 c0       	rjmp	.+4      	; 0x5458 <BCM_RxDispatcher+0x2aa>
	else
	{
		/*
		 * try to use un initialized BCM
		 */
		u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_NOT_INITIALIZED;
    5454:	84 ea       	ldi	r24, 0xA4	; 164
    5456:	8a 83       	std	Y+2, r24	; 0x02
	}
	/*
	 * Function shall return the Error state
	 */
	return u8_BCM_ErrorStatus;
    5458:	8a 81       	ldd	r24, Y+2	; 0x02
}
    545a:	0f 90       	pop	r0
    545c:	0f 90       	pop	r0
    545e:	cf 91       	pop	r28
    5460:	df 91       	pop	r29
    5462:	08 95       	ret

00005464 <BCM_RxUnlock>:
/* In/Out:	N/A																					*/
/* Return: The error status of the function.													*/
/* Description: Unlocks the data buffer so we can recieve something else .						*/
/************************************************************************************************/
BCM_ERROR_STATUS BCM_RxUnlock(uint8 u8_BCM_Channel_ID)
{
    5464:	df 93       	push	r29
    5466:	cf 93       	push	r28
    5468:	00 d0       	rcall	.+0      	; 0x546a <BCM_RxUnlock+0x6>
    546a:	cd b7       	in	r28, 0x3d	; 61
    546c:	de b7       	in	r29, 0x3e	; 62
    546e:	8a 83       	std	Y+2, r24	; 0x02
	/*
	 * Error state: No Error
	 */
	BCM_ERROR_STATUS u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_SUCCESS;
    5470:	86 ea       	ldi	r24, 0xA6	; 166
    5472:	89 83       	std	Y+1, r24	; 0x01
	if (gu8_BCM_Status == BCM_UNINTIALIZED)
    5474:	80 91 b2 07 	lds	r24, 0x07B2
    5478:	88 23       	and	r24, r24
    547a:	19 f4       	brne	.+6      	; 0x5482 <BCM_RxUnlock+0x1e>
	{
		/*
		 * try to use un initialized BCM
		 */
		u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_NOT_INITIALIZED;
    547c:	84 ea       	ldi	r24, 0xA4	; 164
    547e:	89 83       	std	Y+1, r24	; 0x01
    5480:	25 c0       	rjmp	.+74     	; 0x54cc <BCM_RxUnlock+0x68>
	}
	else if (gastr_BCM_PacketFormat[u8_BCM_Channel_ID].u8_ChannelStatus
    5482:	8a 81       	ldd	r24, Y+2	; 0x02
    5484:	28 2f       	mov	r18, r24
    5486:	30 e0       	ldi	r19, 0x00	; 0
    5488:	c9 01       	movw	r24, r18
    548a:	88 0f       	add	r24, r24
    548c:	99 1f       	adc	r25, r25
    548e:	88 0f       	add	r24, r24
    5490:	99 1f       	adc	r25, r25
    5492:	88 0f       	add	r24, r24
    5494:	99 1f       	adc	r25, r25
    5496:	82 0f       	add	r24, r18
    5498:	93 1f       	adc	r25, r19
    549a:	fc 01       	movw	r30, r24
    549c:	e9 54       	subi	r30, 0x49	; 73
    549e:	f8 4f       	sbci	r31, 0xF8	; 248
    54a0:	80 81       	ld	r24, Z
    54a2:	81 30       	cpi	r24, 0x01	; 1
    54a4:	19 f0       	breq	.+6      	; 0x54ac <BCM_RxUnlock+0x48>
			!= BCM_CHANNEL_LOCKED)
	{
		/*
		 * channel already unlocked
		 */
		u8_BCM_ErrorStatus = BCM_BASE_ERROR + ERR_ALREADY_INITIALIZED;
    54a6:	83 ea       	ldi	r24, 0xA3	; 163
    54a8:	89 83       	std	Y+1, r24	; 0x01
    54aa:	10 c0       	rjmp	.+32     	; 0x54cc <BCM_RxUnlock+0x68>
	}
	else
	{
		gastr_BCM_PacketFormat[u8_BCM_Channel_ID].u8_ChannelStatus =
    54ac:	8a 81       	ldd	r24, Y+2	; 0x02
    54ae:	28 2f       	mov	r18, r24
    54b0:	30 e0       	ldi	r19, 0x00	; 0
    54b2:	c9 01       	movw	r24, r18
    54b4:	88 0f       	add	r24, r24
    54b6:	99 1f       	adc	r25, r25
    54b8:	88 0f       	add	r24, r24
    54ba:	99 1f       	adc	r25, r25
    54bc:	88 0f       	add	r24, r24
    54be:	99 1f       	adc	r25, r25
    54c0:	82 0f       	add	r24, r18
    54c2:	93 1f       	adc	r25, r19
    54c4:	fc 01       	movw	r30, r24
    54c6:	e9 54       	subi	r30, 0x49	; 73
    54c8:	f8 4f       	sbci	r31, 0xF8	; 248
    54ca:	10 82       	st	Z, r1
		BCM_CHANNEL_UNLOCKED;
	}
	/*
	 * Function shall return the Error state
	 */
	return u8_BCM_ErrorStatus;
    54cc:	89 81       	ldd	r24, Y+1	; 0x01
}
    54ce:	0f 90       	pop	r0
    54d0:	0f 90       	pop	r0
    54d2:	cf 91       	pop	r28
    54d4:	df 91       	pop	r29
    54d6:	08 95       	ret

000054d8 <UART_Init>:
 * \param *pUART_cfg_s : A pointer to a struct that holds the desired UART configuration
 * \return ERROR_STATUS : Indication to the function execution
 *
 **/
extern ERROR_STATUS UART_Init(UART_cfg_s *pUART_cfg_s)
{
    54d8:	df 93       	push	r29
    54da:	cf 93       	push	r28
    54dc:	cd b7       	in	r28, 0x3d	; 61
    54de:	de b7       	in	r29, 0x3e	; 62
    54e0:	69 97       	sbiw	r28, 0x19	; 25
    54e2:	0f b6       	in	r0, 0x3f	; 63
    54e4:	f8 94       	cli
    54e6:	de bf       	out	0x3e, r29	; 62
    54e8:	0f be       	out	0x3f, r0	; 63
    54ea:	cd bf       	out	0x3d, r28	; 61
    54ec:	9d 87       	std	Y+13, r25	; 0x0d
    54ee:	8c 87       	std	Y+12, r24	; 0x0c
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS u8_ErrorStatus = UART_BASE_ERROR + ERR_SUCCESS;
    54f0:	84 ec       	ldi	r24, 0xC4	; 196
    54f2:	8d 83       	std	Y+5, r24	; 0x05
	uint8 u8_UART_BudeRateMode = UART_UNINTIALIZED;
    54f4:	1c 82       	std	Y+4, r1	; 0x04
	uint8 UART_CSRC_Buffer = UART_RSEL;
    54f6:	80 e8       	ldi	r24, 0x80	; 128
    54f8:	8b 83       	std	Y+3, r24	; 0x03
	uint16 u16_BaudRate = UART_UNINTIALIZED;
    54fa:	1a 82       	std	Y+2, r1	; 0x02
    54fc:	19 82       	std	Y+1, r1	; 0x01

	if (pUART_cfg_s == NULL || gu8_UART_Status != UART_UNINTIALIZED)
    54fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    5500:	9d 85       	ldd	r25, Y+13	; 0x0d
    5502:	00 97       	sbiw	r24, 0x00	; 0
    5504:	21 f0       	breq	.+8      	; 0x550e <UART_Init+0x36>
    5506:	80 91 c9 07 	lds	r24, 0x07C9
    550a:	88 23       	and	r24, r24
    550c:	19 f0       	breq	.+6      	; 0x5514 <UART_Init+0x3c>
	{
		/*
		 * trying to access a null pointer
		 */
		u8_ErrorStatus = UART_BASE_ERROR + ERR_NULL_PTR;
    550e:	80 ec       	ldi	r24, 0xC0	; 192
    5510:	8d 83       	std	Y+5, r24	; 0x05
    5512:	61 c2       	rjmp	.+1218   	; 0x59d6 <UART_Init+0x4fe>
		/*
		 * DIO initialization
		 */
		DIO_Cfg_s UART_TX_DIO =
		{
		UART_TX_GPIO, UART_TX_BIT, OUTPUT };
    5514:	9e 01       	movw	r18, r28
    5516:	2a 5f       	subi	r18, 0xFA	; 250
    5518:	3f 4f       	sbci	r19, 0xFF	; 255
    551a:	39 8b       	std	Y+17, r19	; 0x11
    551c:	28 8b       	std	Y+16, r18	; 0x10
    551e:	83 ee       	ldi	r24, 0xE3	; 227
    5520:	90 e0       	ldi	r25, 0x00	; 0
    5522:	9b 8b       	std	Y+19, r25	; 0x13
    5524:	8a 8b       	std	Y+18, r24	; 0x12
    5526:	93 e0       	ldi	r25, 0x03	; 3
    5528:	9c 8b       	std	Y+20, r25	; 0x14
    552a:	ea 89       	ldd	r30, Y+18	; 0x12
    552c:	fb 89       	ldd	r31, Y+19	; 0x13
    552e:	00 80       	ld	r0, Z
    5530:	2a 89       	ldd	r18, Y+18	; 0x12
    5532:	3b 89       	ldd	r19, Y+19	; 0x13
    5534:	2f 5f       	subi	r18, 0xFF	; 255
    5536:	3f 4f       	sbci	r19, 0xFF	; 255
    5538:	3b 8b       	std	Y+19, r19	; 0x13
    553a:	2a 8b       	std	Y+18, r18	; 0x12
    553c:	e8 89       	ldd	r30, Y+16	; 0x10
    553e:	f9 89       	ldd	r31, Y+17	; 0x11
    5540:	00 82       	st	Z, r0
    5542:	28 89       	ldd	r18, Y+16	; 0x10
    5544:	39 89       	ldd	r19, Y+17	; 0x11
    5546:	2f 5f       	subi	r18, 0xFF	; 255
    5548:	3f 4f       	sbci	r19, 0xFF	; 255
    554a:	39 8b       	std	Y+17, r19	; 0x11
    554c:	28 8b       	std	Y+16, r18	; 0x10
    554e:	3c 89       	ldd	r19, Y+20	; 0x14
    5550:	31 50       	subi	r19, 0x01	; 1
    5552:	3c 8b       	std	Y+20, r19	; 0x14
    5554:	8c 89       	ldd	r24, Y+20	; 0x14
    5556:	88 23       	and	r24, r24
    5558:	41 f7       	brne	.-48     	; 0x552a <UART_Init+0x52>
		DIO_init(&UART_TX_DIO);
    555a:	ce 01       	movw	r24, r28
    555c:	06 96       	adiw	r24, 0x06	; 6
    555e:	0e 94 90 33 	call	0x6720	; 0x6720 <DIO_init>

		DIO_Cfg_s UART_RX_DIO =
		{
		UART_RX_GPIO, UART_RX_BIT, INPUT };
    5562:	fe 01       	movw	r30, r28
    5564:	39 96       	adiw	r30, 0x09	; 9
    5566:	fe 8b       	std	Y+22, r31	; 0x16
    5568:	ed 8b       	std	Y+21, r30	; 0x15
    556a:	20 ee       	ldi	r18, 0xE0	; 224
    556c:	30 e0       	ldi	r19, 0x00	; 0
    556e:	38 8f       	std	Y+24, r19	; 0x18
    5570:	2f 8b       	std	Y+23, r18	; 0x17
    5572:	33 e0       	ldi	r19, 0x03	; 3
    5574:	39 8f       	std	Y+25, r19	; 0x19
    5576:	ef 89       	ldd	r30, Y+23	; 0x17
    5578:	f8 8d       	ldd	r31, Y+24	; 0x18
    557a:	00 80       	ld	r0, Z
    557c:	2f 89       	ldd	r18, Y+23	; 0x17
    557e:	38 8d       	ldd	r19, Y+24	; 0x18
    5580:	2f 5f       	subi	r18, 0xFF	; 255
    5582:	3f 4f       	sbci	r19, 0xFF	; 255
    5584:	38 8f       	std	Y+24, r19	; 0x18
    5586:	2f 8b       	std	Y+23, r18	; 0x17
    5588:	ed 89       	ldd	r30, Y+21	; 0x15
    558a:	fe 89       	ldd	r31, Y+22	; 0x16
    558c:	00 82       	st	Z, r0
    558e:	2d 89       	ldd	r18, Y+21	; 0x15
    5590:	3e 89       	ldd	r19, Y+22	; 0x16
    5592:	2f 5f       	subi	r18, 0xFF	; 255
    5594:	3f 4f       	sbci	r19, 0xFF	; 255
    5596:	3e 8b       	std	Y+22, r19	; 0x16
    5598:	2d 8b       	std	Y+21, r18	; 0x15
    559a:	39 8d       	ldd	r19, Y+25	; 0x19
    559c:	31 50       	subi	r19, 0x01	; 1
    559e:	39 8f       	std	Y+25, r19	; 0x19
    55a0:	89 8d       	ldd	r24, Y+25	; 0x19
    55a2:	88 23       	and	r24, r24
    55a4:	41 f7       	brne	.-48     	; 0x5576 <UART_Init+0x9e>
		DIO_init(&UART_RX_DIO);
    55a6:	ce 01       	movw	r24, r28
    55a8:	09 96       	adiw	r24, 0x09	; 9
    55aa:	0e 94 90 33 	call	0x6720	; 0x6720 <DIO_init>

		/*
		 *	Set Operation Speed
		 */
		if (pUART_cfg_s->u8_DoubleSpeed == UART_NO_DOUBLE_SPEED)
    55ae:	ec 85       	ldd	r30, Y+12	; 0x0c
    55b0:	fd 85       	ldd	r31, Y+13	; 0x0d
    55b2:	82 81       	ldd	r24, Z+2	; 0x02
    55b4:	88 23       	and	r24, r24
    55b6:	b1 f4       	brne	.+44     	; 0x55e4 <UART_Init+0x10c>
		{
			ASSIGN_BIT(UART_CSRA, UART_U2X,
    55b8:	ab e2       	ldi	r26, 0x2B	; 43
    55ba:	b0 e0       	ldi	r27, 0x00	; 0
    55bc:	eb e2       	ldi	r30, 0x2B	; 43
    55be:	f0 e0       	ldi	r31, 0x00	; 0
    55c0:	80 81       	ld	r24, Z
    55c2:	28 2f       	mov	r18, r24
    55c4:	2d 7f       	andi	r18, 0xFD	; 253
    55c6:	ec 85       	ldd	r30, Y+12	; 0x0c
    55c8:	fd 85       	ldd	r31, Y+13	; 0x0d
    55ca:	82 81       	ldd	r24, Z+2	; 0x02
    55cc:	88 2f       	mov	r24, r24
    55ce:	90 e0       	ldi	r25, 0x00	; 0
    55d0:	fc 01       	movw	r30, r24
    55d2:	e0 53       	subi	r30, 0x30	; 48
    55d4:	ff 4f       	sbci	r31, 0xFF	; 255
    55d6:	80 81       	ld	r24, Z
    55d8:	82 70       	andi	r24, 0x02	; 2
    55da:	82 2b       	or	r24, r18
    55dc:	8c 93       	st	X, r24
					gau8_UART_Speed[pUART_cfg_s->u8_DoubleSpeed]);
			u8_UART_BudeRateMode = NORMAL_BUDERATE;
    55de:	80 e1       	ldi	r24, 0x10	; 16
    55e0:	8c 83       	std	Y+4, r24	; 0x04
    55e2:	1d c0       	rjmp	.+58     	; 0x561e <UART_Init+0x146>
		}
		else if (pUART_cfg_s->u8_DoubleSpeed == UART_DOUBLE_SPEED)
    55e4:	ec 85       	ldd	r30, Y+12	; 0x0c
    55e6:	fd 85       	ldd	r31, Y+13	; 0x0d
    55e8:	82 81       	ldd	r24, Z+2	; 0x02
    55ea:	81 30       	cpi	r24, 0x01	; 1
    55ec:	b1 f4       	brne	.+44     	; 0x561a <UART_Init+0x142>
		{
			ASSIGN_BIT(UART_CSRA, UART_U2X,
    55ee:	ab e2       	ldi	r26, 0x2B	; 43
    55f0:	b0 e0       	ldi	r27, 0x00	; 0
    55f2:	eb e2       	ldi	r30, 0x2B	; 43
    55f4:	f0 e0       	ldi	r31, 0x00	; 0
    55f6:	80 81       	ld	r24, Z
    55f8:	28 2f       	mov	r18, r24
    55fa:	2d 7f       	andi	r18, 0xFD	; 253
    55fc:	ec 85       	ldd	r30, Y+12	; 0x0c
    55fe:	fd 85       	ldd	r31, Y+13	; 0x0d
    5600:	82 81       	ldd	r24, Z+2	; 0x02
    5602:	88 2f       	mov	r24, r24
    5604:	90 e0       	ldi	r25, 0x00	; 0
    5606:	fc 01       	movw	r30, r24
    5608:	e0 53       	subi	r30, 0x30	; 48
    560a:	ff 4f       	sbci	r31, 0xFF	; 255
    560c:	80 81       	ld	r24, Z
    560e:	82 70       	andi	r24, 0x02	; 2
    5610:	82 2b       	or	r24, r18
    5612:	8c 93       	st	X, r24
					gau8_UART_Speed[pUART_cfg_s->u8_DoubleSpeed]);
			u8_UART_BudeRateMode = DOUBLE_BAUDRATE;
    5614:	88 e0       	ldi	r24, 0x08	; 8
    5616:	8c 83       	std	Y+4, r24	; 0x04
    5618:	02 c0       	rjmp	.+4      	; 0x561e <UART_Init+0x146>
		else
		{
			/*
			 *  Wrong Operation speed
			 */
			u8_ErrorStatus = UART_BASE_ERROR + ERR_INVALID_ARGU;
    561a:	83 ec       	ldi	r24, 0xC3	; 195
    561c:	8d 83       	std	Y+5, r24	; 0x05
		}
		/*
		 *	Set Data Size
		 */
		if (pUART_cfg_s->u8_DataSize >= UART_5_BIT
    561e:	ec 85       	ldd	r30, Y+12	; 0x0c
    5620:	fd 85       	ldd	r31, Y+13	; 0x0d
    5622:	85 81       	ldd	r24, Z+5	; 0x05
    5624:	84 30       	cpi	r24, 0x04	; 4
    5626:	b8 f4       	brcc	.+46     	; 0x5656 <UART_Init+0x17e>
				&& pUART_cfg_s->u8_DataSize <= UART_8_BIT)
		{
			ASSIGN_BIT(UART_CSRC_Buffer, (UART_CSZ1|UART_CSZ0),
    5628:	8b 81       	ldd	r24, Y+3	; 0x03
    562a:	28 2f       	mov	r18, r24
    562c:	29 7f       	andi	r18, 0xF9	; 249
    562e:	ec 85       	ldd	r30, Y+12	; 0x0c
    5630:	fd 85       	ldd	r31, Y+13	; 0x0d
    5632:	85 81       	ldd	r24, Z+5	; 0x05
    5634:	88 2f       	mov	r24, r24
    5636:	90 e0       	ldi	r25, 0x00	; 0
    5638:	fc 01       	movw	r30, r24
    563a:	e8 52       	subi	r30, 0x28	; 40
    563c:	ff 4f       	sbci	r31, 0xFF	; 255
    563e:	80 81       	ld	r24, Z
    5640:	86 70       	andi	r24, 0x06	; 6
    5642:	82 2b       	or	r24, r18
    5644:	8b 83       	std	Y+3, r24	; 0x03
					(gau8_UART_DataSize[(pUART_cfg_s->u8_DataSize)]));
			UART_CSRB &= ~(UART_CSZ2);
    5646:	aa e2       	ldi	r26, 0x2A	; 42
    5648:	b0 e0       	ldi	r27, 0x00	; 0
    564a:	ea e2       	ldi	r30, 0x2A	; 42
    564c:	f0 e0       	ldi	r31, 0x00	; 0
    564e:	80 81       	ld	r24, Z
    5650:	8b 7f       	andi	r24, 0xFB	; 251
    5652:	8c 93       	st	X, r24
    5654:	2a c0       	rjmp	.+84     	; 0x56aa <UART_Init+0x1d2>
		}
		else if (pUART_cfg_s->u8_DataSize == UART_9_BIT)
    5656:	ec 85       	ldd	r30, Y+12	; 0x0c
    5658:	fd 85       	ldd	r31, Y+13	; 0x0d
    565a:	85 81       	ldd	r24, Z+5	; 0x05
    565c:	87 30       	cpi	r24, 0x07	; 7
    565e:	19 f5       	brne	.+70     	; 0x56a6 <UART_Init+0x1ce>
		{
			ASSIGN_BIT(UART_CSRC_Buffer, (UART_CSZ1|UART_CSZ0),
    5660:	8b 81       	ldd	r24, Y+3	; 0x03
    5662:	28 2f       	mov	r18, r24
    5664:	29 7f       	andi	r18, 0xF9	; 249
    5666:	ec 85       	ldd	r30, Y+12	; 0x0c
    5668:	fd 85       	ldd	r31, Y+13	; 0x0d
    566a:	85 81       	ldd	r24, Z+5	; 0x05
    566c:	88 2f       	mov	r24, r24
    566e:	90 e0       	ldi	r25, 0x00	; 0
    5670:	fc 01       	movw	r30, r24
    5672:	e8 52       	subi	r30, 0x28	; 40
    5674:	ff 4f       	sbci	r31, 0xFF	; 255
    5676:	80 81       	ld	r24, Z
    5678:	86 70       	andi	r24, 0x06	; 6
    567a:	82 2b       	or	r24, r18
    567c:	8b 83       	std	Y+3, r24	; 0x03
					(gau8_UART_DataSize[pUART_cfg_s->u8_DataSize]));
			ASSIGN_BIT(UART_CSRB, UART_CSZ2,
    567e:	aa e2       	ldi	r26, 0x2A	; 42
    5680:	b0 e0       	ldi	r27, 0x00	; 0
    5682:	ea e2       	ldi	r30, 0x2A	; 42
    5684:	f0 e0       	ldi	r31, 0x00	; 0
    5686:	80 81       	ld	r24, Z
    5688:	28 2f       	mov	r18, r24
    568a:	2b 7f       	andi	r18, 0xFB	; 251
    568c:	ec 85       	ldd	r30, Y+12	; 0x0c
    568e:	fd 85       	ldd	r31, Y+13	; 0x0d
    5690:	85 81       	ldd	r24, Z+5	; 0x05
    5692:	88 2f       	mov	r24, r24
    5694:	90 e0       	ldi	r25, 0x00	; 0
    5696:	fc 01       	movw	r30, r24
    5698:	e8 52       	subi	r30, 0x28	; 40
    569a:	ff 4f       	sbci	r31, 0xFF	; 255
    569c:	80 81       	ld	r24, Z
    569e:	84 70       	andi	r24, 0x04	; 4
    56a0:	82 2b       	or	r24, r18
    56a2:	8c 93       	st	X, r24
    56a4:	02 c0       	rjmp	.+4      	; 0x56aa <UART_Init+0x1d2>
		else
		{
			/*
			 *  Wrong Data Size
			 */
			u8_ErrorStatus = UART_BASE_ERROR + ERR_INVALID_ARGU;
    56a6:	83 ec       	ldi	r24, 0xC3	; 195
    56a8:	8d 83       	std	Y+5, r24	; 0x05
		}
		/*
		 *	Set Stop bit
		 */
		if (pUART_cfg_s->u8_StopBit == UART_ONE_STOP_BIT
    56aa:	ec 85       	ldd	r30, Y+12	; 0x0c
    56ac:	fd 85       	ldd	r31, Y+13	; 0x0d
    56ae:	83 81       	ldd	r24, Z+3	; 0x03
    56b0:	88 23       	and	r24, r24
    56b2:	29 f0       	breq	.+10     	; 0x56be <UART_Init+0x1e6>
    56b4:	ec 85       	ldd	r30, Y+12	; 0x0c
    56b6:	fd 85       	ldd	r31, Y+13	; 0x0d
    56b8:	83 81       	ldd	r24, Z+3	; 0x03
    56ba:	81 30       	cpi	r24, 0x01	; 1
    56bc:	81 f4       	brne	.+32     	; 0x56de <UART_Init+0x206>
				|| (pUART_cfg_s->u8_StopBit == UART_TWO_STOP_BIT))
		{
			ASSIGN_BIT(UART_CSRC_Buffer, (UART_SBS),
    56be:	8b 81       	ldd	r24, Y+3	; 0x03
    56c0:	28 2f       	mov	r18, r24
    56c2:	27 7f       	andi	r18, 0xF7	; 247
    56c4:	ec 85       	ldd	r30, Y+12	; 0x0c
    56c6:	fd 85       	ldd	r31, Y+13	; 0x0d
    56c8:	83 81       	ldd	r24, Z+3	; 0x03
    56ca:	88 2f       	mov	r24, r24
    56cc:	90 e0       	ldi	r25, 0x00	; 0
    56ce:	fc 01       	movw	r30, r24
    56d0:	ee 52       	subi	r30, 0x2E	; 46
    56d2:	ff 4f       	sbci	r31, 0xFF	; 255
    56d4:	80 81       	ld	r24, Z
    56d6:	88 70       	andi	r24, 0x08	; 8
    56d8:	82 2b       	or	r24, r18
    56da:	8b 83       	std	Y+3, r24	; 0x03
    56dc:	02 c0       	rjmp	.+4      	; 0x56e2 <UART_Init+0x20a>
		else
		{
			/*
			 *  Wrong Stop bit
			 */
			u8_ErrorStatus = UART_BASE_ERROR + ERR_INVALID_ARGU;
    56de:	83 ec       	ldi	r24, 0xC3	; 195
    56e0:	8d 83       	std	Y+5, r24	; 0x05
		}
		/*
		 *	Set Parity bit
		 */
		if (pUART_cfg_s->u8_ParityBit == UART_NO_PARITY
    56e2:	ec 85       	ldd	r30, Y+12	; 0x0c
    56e4:	fd 85       	ldd	r31, Y+13	; 0x0d
    56e6:	84 81       	ldd	r24, Z+4	; 0x04
    56e8:	88 23       	and	r24, r24
    56ea:	51 f0       	breq	.+20     	; 0x5700 <UART_Init+0x228>
    56ec:	ec 85       	ldd	r30, Y+12	; 0x0c
    56ee:	fd 85       	ldd	r31, Y+13	; 0x0d
    56f0:	84 81       	ldd	r24, Z+4	; 0x04
    56f2:	82 30       	cpi	r24, 0x02	; 2
    56f4:	29 f0       	breq	.+10     	; 0x5700 <UART_Init+0x228>
    56f6:	ec 85       	ldd	r30, Y+12	; 0x0c
    56f8:	fd 85       	ldd	r31, Y+13	; 0x0d
    56fa:	84 81       	ldd	r24, Z+4	; 0x04
    56fc:	83 30       	cpi	r24, 0x03	; 3
    56fe:	81 f4       	brne	.+32     	; 0x5720 <UART_Init+0x248>
				|| (pUART_cfg_s->u8_ParityBit == UART_EVEN_PARITY)
				|| (pUART_cfg_s->u8_ParityBit == UART_ODD_PARITY))
		{
			ASSIGN_BIT(UART_CSRC_Buffer, (UART_PM0|UART_PM1),
    5700:	8b 81       	ldd	r24, Y+3	; 0x03
    5702:	28 2f       	mov	r18, r24
    5704:	2f 7c       	andi	r18, 0xCF	; 207
    5706:	ec 85       	ldd	r30, Y+12	; 0x0c
    5708:	fd 85       	ldd	r31, Y+13	; 0x0d
    570a:	84 81       	ldd	r24, Z+4	; 0x04
    570c:	88 2f       	mov	r24, r24
    570e:	90 e0       	ldi	r25, 0x00	; 0
    5710:	fc 01       	movw	r30, r24
    5712:	ec 52       	subi	r30, 0x2C	; 44
    5714:	ff 4f       	sbci	r31, 0xFF	; 255
    5716:	80 81       	ld	r24, Z
    5718:	80 73       	andi	r24, 0x30	; 48
    571a:	82 2b       	or	r24, r18
    571c:	8b 83       	std	Y+3, r24	; 0x03
    571e:	02 c0       	rjmp	.+4      	; 0x5724 <UART_Init+0x24c>
		else
		{
			/*
			 *  Wrong Parity bit
			 */
			u8_ErrorStatus = UART_BASE_ERROR + ERR_INVALID_ARGU;
    5720:	83 ec       	ldi	r24, 0xC3	; 195
    5722:	8d 83       	std	Y+5, r24	; 0x05
		}
		/*
		 * Set Baud Rate
		 */
		u16_BaudRate = (uint16) ((uint32) UART_CLK
    5724:	8c 81       	ldd	r24, Y+4	; 0x04
    5726:	88 2f       	mov	r24, r24
    5728:	90 e0       	ldi	r25, 0x00	; 0
    572a:	a0 e0       	ldi	r26, 0x00	; 0
    572c:	b0 e0       	ldi	r27, 0x00	; 0
    572e:	ec 85       	ldd	r30, Y+12	; 0x0c
    5730:	fd 85       	ldd	r31, Y+13	; 0x0d
    5732:	26 81       	ldd	r18, Z+6	; 0x06
    5734:	37 81       	ldd	r19, Z+7	; 0x07
    5736:	40 85       	ldd	r20, Z+8	; 0x08
    5738:	51 85       	ldd	r21, Z+9	; 0x09
    573a:	bc 01       	movw	r22, r24
    573c:	cd 01       	movw	r24, r26
    573e:	0e 94 0c 3c 	call	0x7818	; 0x7818 <__mulsi3>
    5742:	9b 01       	movw	r18, r22
    5744:	ac 01       	movw	r20, r24
    5746:	80 e0       	ldi	r24, 0x00	; 0
    5748:	94 e2       	ldi	r25, 0x24	; 36
    574a:	a4 ef       	ldi	r26, 0xF4	; 244
    574c:	b0 e0       	ldi	r27, 0x00	; 0
    574e:	bc 01       	movw	r22, r24
    5750:	cd 01       	movw	r24, r26
    5752:	0e 94 3f 3c 	call	0x787e	; 0x787e <__udivmodsi4>
    5756:	da 01       	movw	r26, r20
    5758:	c9 01       	movw	r24, r18
    575a:	01 97       	sbiw	r24, 0x01	; 1
    575c:	9a 83       	std	Y+2, r25	; 0x02
    575e:	89 83       	std	Y+1, r24	; 0x01
				/ ((uint32) u8_UART_BudeRateMode * pUART_cfg_s->u32_BaudRate))
				- 1;
		if ((pUART_cfg_s->u32_BaudRate >= 2400)
    5760:	ec 85       	ldd	r30, Y+12	; 0x0c
    5762:	fd 85       	ldd	r31, Y+13	; 0x0d
    5764:	86 81       	ldd	r24, Z+6	; 0x06
    5766:	97 81       	ldd	r25, Z+7	; 0x07
    5768:	a0 85       	ldd	r26, Z+8	; 0x08
    576a:	b1 85       	ldd	r27, Z+9	; 0x09
    576c:	80 36       	cpi	r24, 0x60	; 96
    576e:	e9 e0       	ldi	r30, 0x09	; 9
    5770:	9e 07       	cpc	r25, r30
    5772:	e0 e0       	ldi	r30, 0x00	; 0
    5774:	ae 07       	cpc	r26, r30
    5776:	e0 e0       	ldi	r30, 0x00	; 0
    5778:	be 07       	cpc	r27, r30
    577a:	08 f1       	brcs	.+66     	; 0x57be <UART_Init+0x2e6>
    577c:	ec 85       	ldd	r30, Y+12	; 0x0c
    577e:	fd 85       	ldd	r31, Y+13	; 0x0d
    5780:	86 81       	ldd	r24, Z+6	; 0x06
    5782:	97 81       	ldd	r25, Z+7	; 0x07
    5784:	a0 85       	ldd	r26, Z+8	; 0x08
    5786:	b1 85       	ldd	r27, Z+9	; 0x09
    5788:	81 3c       	cpi	r24, 0xC1	; 193
    578a:	f2 e1       	ldi	r31, 0x12	; 18
    578c:	9f 07       	cpc	r25, r31
    578e:	f0 e0       	ldi	r31, 0x00	; 0
    5790:	af 07       	cpc	r26, r31
    5792:	f0 e0       	ldi	r31, 0x00	; 0
    5794:	bf 07       	cpc	r27, r31
    5796:	98 f4       	brcc	.+38     	; 0x57be <UART_Init+0x2e6>
				&& (pUART_cfg_s->u32_BaudRate <= 4800))
		{
			ASSIGN_BIT(UART_BRRH, BRRH, (u16_BaudRate >> 8));
    5798:	a0 e4       	ldi	r26, 0x40	; 64
    579a:	b0 e0       	ldi	r27, 0x00	; 0
    579c:	e0 e4       	ldi	r30, 0x40	; 64
    579e:	f0 e0       	ldi	r31, 0x00	; 0
    57a0:	80 81       	ld	r24, Z
    57a2:	28 2f       	mov	r18, r24
    57a4:	20 7f       	andi	r18, 0xF0	; 240
    57a6:	89 81       	ldd	r24, Y+1	; 0x01
    57a8:	9a 81       	ldd	r25, Y+2	; 0x02
    57aa:	89 2f       	mov	r24, r25
    57ac:	99 27       	eor	r25, r25
    57ae:	8f 70       	andi	r24, 0x0F	; 15
    57b0:	82 2b       	or	r24, r18
    57b2:	8c 93       	st	X, r24
			UART_BRRL = (uint8) u16_BaudRate;
    57b4:	e9 e2       	ldi	r30, 0x29	; 41
    57b6:	f0 e0       	ldi	r31, 0x00	; 0
    57b8:	89 81       	ldd	r24, Y+1	; 0x01
    57ba:	80 83       	st	Z, r24
    57bc:	23 c0       	rjmp	.+70     	; 0x5804 <UART_Init+0x32c>
		}
		else if ((pUART_cfg_s->u32_BaudRate >= 9600)
    57be:	ec 85       	ldd	r30, Y+12	; 0x0c
    57c0:	fd 85       	ldd	r31, Y+13	; 0x0d
    57c2:	86 81       	ldd	r24, Z+6	; 0x06
    57c4:	97 81       	ldd	r25, Z+7	; 0x07
    57c6:	a0 85       	ldd	r26, Z+8	; 0x08
    57c8:	b1 85       	ldd	r27, Z+9	; 0x09
    57ca:	80 38       	cpi	r24, 0x80	; 128
    57cc:	25 e2       	ldi	r18, 0x25	; 37
    57ce:	92 07       	cpc	r25, r18
    57d0:	20 e0       	ldi	r18, 0x00	; 0
    57d2:	a2 07       	cpc	r26, r18
    57d4:	20 e0       	ldi	r18, 0x00	; 0
    57d6:	b2 07       	cpc	r27, r18
    57d8:	98 f0       	brcs	.+38     	; 0x5800 <UART_Init+0x328>
    57da:	ec 85       	ldd	r30, Y+12	; 0x0c
    57dc:	fd 85       	ldd	r31, Y+13	; 0x0d
    57de:	86 81       	ldd	r24, Z+6	; 0x06
    57e0:	97 81       	ldd	r25, Z+7	; 0x07
    57e2:	a0 85       	ldd	r26, Z+8	; 0x08
    57e4:	b1 85       	ldd	r27, Z+9	; 0x09
    57e6:	81 34       	cpi	r24, 0x41	; 65
    57e8:	32 e4       	ldi	r19, 0x42	; 66
    57ea:	93 07       	cpc	r25, r19
    57ec:	3f e0       	ldi	r19, 0x0F	; 15
    57ee:	a3 07       	cpc	r26, r19
    57f0:	30 e0       	ldi	r19, 0x00	; 0
    57f2:	b3 07       	cpc	r27, r19
    57f4:	28 f4       	brcc	.+10     	; 0x5800 <UART_Init+0x328>
				&& (pUART_cfg_s->u32_BaudRate <= 1000000))
		{
			UART_BRRL = (uint8) u16_BaudRate;
    57f6:	e9 e2       	ldi	r30, 0x29	; 41
    57f8:	f0 e0       	ldi	r31, 0x00	; 0
    57fa:	89 81       	ldd	r24, Y+1	; 0x01
    57fc:	80 83       	st	Z, r24
    57fe:	02 c0       	rjmp	.+4      	; 0x5804 <UART_Init+0x32c>
		else
		{
			/*
			 *  Wrong Bude Rate
			 */
			u8_ErrorStatus = UART_BASE_ERROR + ERR_INVALID_ARGU;
    5800:	83 ec       	ldi	r24, 0xC3	; 195
    5802:	8d 83       	std	Y+5, r24	; 0x05
		}
		/*
		 *	check on Desired Operation
		 */
		switch (pUART_cfg_s->u8_DesiredOperation)
    5804:	ec 85       	ldd	r30, Y+12	; 0x0c
    5806:	fd 85       	ldd	r31, Y+13	; 0x0d
    5808:	81 81       	ldd	r24, Z+1	; 0x01
    580a:	e8 2f       	mov	r30, r24
    580c:	f0 e0       	ldi	r31, 0x00	; 0
    580e:	ff 87       	std	Y+15, r31	; 0x0f
    5810:	ee 87       	std	Y+14, r30	; 0x0e
    5812:	2e 85       	ldd	r18, Y+14	; 0x0e
    5814:	3f 85       	ldd	r19, Y+15	; 0x0f
    5816:	21 30       	cpi	r18, 0x01	; 1
    5818:	31 05       	cpc	r19, r1
    581a:	09 f1       	breq	.+66     	; 0x585e <UART_Init+0x386>
    581c:	8e 85       	ldd	r24, Y+14	; 0x0e
    581e:	9f 85       	ldd	r25, Y+15	; 0x0f
    5820:	82 30       	cpi	r24, 0x02	; 2
    5822:	91 05       	cpc	r25, r1
    5824:	99 f1       	breq	.+102    	; 0x588c <UART_Init+0x3b4>
    5826:	ee 85       	ldd	r30, Y+14	; 0x0e
    5828:	ff 85       	ldd	r31, Y+15	; 0x0f
    582a:	30 97       	sbiw	r30, 0x00	; 0
    582c:	09 f0       	breq	.+2      	; 0x5830 <UART_Init+0x358>
    582e:	58 c0       	rjmp	.+176    	; 0x58e0 <UART_Init+0x408>
		{
		case TRANSMITTER:
			ASSIGN_BIT(UART_CSRB, UART_TXEN,
    5830:	aa e2       	ldi	r26, 0x2A	; 42
    5832:	b0 e0       	ldi	r27, 0x00	; 0
    5834:	ea e2       	ldi	r30, 0x2A	; 42
    5836:	f0 e0       	ldi	r31, 0x00	; 0
    5838:	80 81       	ld	r24, Z
    583a:	28 2f       	mov	r18, r24
    583c:	27 7f       	andi	r18, 0xF7	; 247
    583e:	ec 85       	ldd	r30, Y+12	; 0x0c
    5840:	fd 85       	ldd	r31, Y+13	; 0x0d
    5842:	81 81       	ldd	r24, Z+1	; 0x01
    5844:	88 2f       	mov	r24, r24
    5846:	90 e0       	ldi	r25, 0x00	; 0
    5848:	fc 01       	movw	r30, r24
    584a:	e3 53       	subi	r30, 0x33	; 51
    584c:	ff 4f       	sbci	r31, 0xFF	; 255
    584e:	80 81       	ld	r24, Z
    5850:	88 70       	andi	r24, 0x08	; 8
    5852:	82 2b       	or	r24, r18
    5854:	8c 93       	st	X, r24
					gau8_UART_DesiredOperation[pUART_cfg_s->u8_DesiredOperation]);
			gu8_UART_Status = UART_TRANSMITTER;
    5856:	81 e0       	ldi	r24, 0x01	; 1
    5858:	80 93 c9 07 	sts	0x07C9, r24
    585c:	45 c0       	rjmp	.+138    	; 0x58e8 <UART_Init+0x410>
			break;
		case RECEIVER:
			ASSIGN_BIT(UART_CSRB, UART_RXEN,
    585e:	aa e2       	ldi	r26, 0x2A	; 42
    5860:	b0 e0       	ldi	r27, 0x00	; 0
    5862:	ea e2       	ldi	r30, 0x2A	; 42
    5864:	f0 e0       	ldi	r31, 0x00	; 0
    5866:	80 81       	ld	r24, Z
    5868:	28 2f       	mov	r18, r24
    586a:	2f 7e       	andi	r18, 0xEF	; 239
    586c:	ec 85       	ldd	r30, Y+12	; 0x0c
    586e:	fd 85       	ldd	r31, Y+13	; 0x0d
    5870:	81 81       	ldd	r24, Z+1	; 0x01
    5872:	88 2f       	mov	r24, r24
    5874:	90 e0       	ldi	r25, 0x00	; 0
    5876:	fc 01       	movw	r30, r24
    5878:	e3 53       	subi	r30, 0x33	; 51
    587a:	ff 4f       	sbci	r31, 0xFF	; 255
    587c:	80 81       	ld	r24, Z
    587e:	80 71       	andi	r24, 0x10	; 16
    5880:	82 2b       	or	r24, r18
    5882:	8c 93       	st	X, r24
					gau8_UART_DesiredOperation[pUART_cfg_s->u8_DesiredOperation]);
			gu8_UART_Status = UART_RESCEIVER;
    5884:	82 e0       	ldi	r24, 0x02	; 2
    5886:	80 93 c9 07 	sts	0x07C9, r24
    588a:	2e c0       	rjmp	.+92     	; 0x58e8 <UART_Init+0x410>
			break;
		case TRANSCEIVER:
			ASSIGN_BIT(UART_CSRB, UART_TXEN,
    588c:	aa e2       	ldi	r26, 0x2A	; 42
    588e:	b0 e0       	ldi	r27, 0x00	; 0
    5890:	ea e2       	ldi	r30, 0x2A	; 42
    5892:	f0 e0       	ldi	r31, 0x00	; 0
    5894:	80 81       	ld	r24, Z
    5896:	28 2f       	mov	r18, r24
    5898:	27 7f       	andi	r18, 0xF7	; 247
    589a:	ec 85       	ldd	r30, Y+12	; 0x0c
    589c:	fd 85       	ldd	r31, Y+13	; 0x0d
    589e:	81 81       	ldd	r24, Z+1	; 0x01
    58a0:	88 2f       	mov	r24, r24
    58a2:	90 e0       	ldi	r25, 0x00	; 0
    58a4:	fc 01       	movw	r30, r24
    58a6:	e3 53       	subi	r30, 0x33	; 51
    58a8:	ff 4f       	sbci	r31, 0xFF	; 255
    58aa:	80 81       	ld	r24, Z
    58ac:	88 70       	andi	r24, 0x08	; 8
    58ae:	82 2b       	or	r24, r18
    58b0:	8c 93       	st	X, r24
					gau8_UART_DesiredOperation[pUART_cfg_s->u8_DesiredOperation]);
			ASSIGN_BIT(UART_CSRB, UART_RXEN,
    58b2:	aa e2       	ldi	r26, 0x2A	; 42
    58b4:	b0 e0       	ldi	r27, 0x00	; 0
    58b6:	ea e2       	ldi	r30, 0x2A	; 42
    58b8:	f0 e0       	ldi	r31, 0x00	; 0
    58ba:	80 81       	ld	r24, Z
    58bc:	28 2f       	mov	r18, r24
    58be:	2f 7e       	andi	r18, 0xEF	; 239
    58c0:	ec 85       	ldd	r30, Y+12	; 0x0c
    58c2:	fd 85       	ldd	r31, Y+13	; 0x0d
    58c4:	81 81       	ldd	r24, Z+1	; 0x01
    58c6:	88 2f       	mov	r24, r24
    58c8:	90 e0       	ldi	r25, 0x00	; 0
    58ca:	fc 01       	movw	r30, r24
    58cc:	e3 53       	subi	r30, 0x33	; 51
    58ce:	ff 4f       	sbci	r31, 0xFF	; 255
    58d0:	80 81       	ld	r24, Z
    58d2:	80 71       	andi	r24, 0x10	; 16
    58d4:	82 2b       	or	r24, r18
    58d6:	8c 93       	st	X, r24
					gau8_UART_DesiredOperation[pUART_cfg_s->u8_DesiredOperation]);
			gu8_UART_Status = UART_TRANSCEIVER;
    58d8:	83 e0       	ldi	r24, 0x03	; 3
    58da:	80 93 c9 07 	sts	0x07C9, r24
    58de:	04 c0       	rjmp	.+8      	; 0x58e8 <UART_Init+0x410>
			break;
		default:
			/*
			 *  Wrong Operation
			 */
			u8_ErrorStatus = UART_BASE_ERROR + ERR_INVALID_ARGU;
    58e0:	83 ec       	ldi	r24, 0xC3	; 195
    58e2:	8d 83       	std	Y+5, r24	; 0x05
			gu8_UART_Status = UART_UNINTIALIZED;
    58e4:	10 92 c9 07 	sts	0x07C9, r1
			break;
		}
		/*
		 *	Set Interrupt Mode
		 */
		if (pUART_cfg_s->u8_InterruptMode == UART_POLLING)
    58e8:	ec 85       	ldd	r30, Y+12	; 0x0c
    58ea:	fd 85       	ldd	r31, Y+13	; 0x0d
    58ec:	80 81       	ld	r24, Z
    58ee:	88 23       	and	r24, r24
    58f0:	81 f4       	brne	.+32     	; 0x5912 <UART_Init+0x43a>
		{
			gu8_UART_Interrupt = UART_POLLING;
    58f2:	10 92 ca 07 	sts	0x07CA, r1
			ASSIGN_BIT(UART_CSRB, (UART_TXCIE|UART_RXCIE|UART_DRIE),
    58f6:	aa e2       	ldi	r26, 0x2A	; 42
    58f8:	b0 e0       	ldi	r27, 0x00	; 0
    58fa:	ea e2       	ldi	r30, 0x2A	; 42
    58fc:	f0 e0       	ldi	r31, 0x00	; 0
    58fe:	80 81       	ld	r24, Z
    5900:	98 2f       	mov	r25, r24
    5902:	9f 71       	andi	r25, 0x1F	; 31
    5904:	ec 85       	ldd	r30, Y+12	; 0x0c
    5906:	fd 85       	ldd	r31, Y+13	; 0x0d
    5908:	80 81       	ld	r24, Z
    590a:	80 7e       	andi	r24, 0xE0	; 224
    590c:	89 2b       	or	r24, r25
    590e:	8c 93       	st	X, r24
    5910:	58 c0       	rjmp	.+176    	; 0x59c2 <UART_Init+0x4ea>
					pUART_cfg_s->u8_InterruptMode);
		}
		else if (pUART_cfg_s->u8_InterruptMode == UART_INTERRUPT)
    5912:	ec 85       	ldd	r30, Y+12	; 0x0c
    5914:	fd 85       	ldd	r31, Y+13	; 0x0d
    5916:	80 81       	ld	r24, Z
    5918:	81 30       	cpi	r24, 0x01	; 1
    591a:	09 f0       	breq	.+2      	; 0x591e <UART_Init+0x446>
    591c:	52 c0       	rjmp	.+164    	; 0x59c2 <UART_Init+0x4ea>
		{
			gu8_UART_Interrupt = UART_INTERRUPT;
    591e:	81 e0       	ldi	r24, 0x01	; 1
    5920:	80 93 ca 07 	sts	0x07CA, r24

			/*
			 * interrupt transmitter handling
			 */
			if (gu8_UART_Status == UART_TRANSMITTER
    5924:	80 91 c9 07 	lds	r24, 0x07C9
    5928:	81 30       	cpi	r24, 0x01	; 1
    592a:	21 f0       	breq	.+8      	; 0x5934 <UART_Init+0x45c>
    592c:	80 91 c9 07 	lds	r24, 0x07C9
    5930:	83 30       	cpi	r24, 0x03	; 3
    5932:	a9 f4       	brne	.+42     	; 0x595e <UART_Init+0x486>
					|| gu8_UART_Status == UART_TRANSCEIVER)
			{
				/*
				 * set Transmit callback pointer
				 */
				if (NULL == pUART_cfg_s->Transmit_Cbk_ptr)
    5934:	ec 85       	ldd	r30, Y+12	; 0x0c
    5936:	fd 85       	ldd	r31, Y+13	; 0x0d
    5938:	82 85       	ldd	r24, Z+10	; 0x0a
    593a:	93 85       	ldd	r25, Z+11	; 0x0b
    593c:	00 97       	sbiw	r24, 0x00	; 0
    593e:	41 f0       	breq	.+16     	; 0x5950 <UART_Init+0x478>
					 */
//					u8_ErrorStatus = E_NOK;
				}
				else
				{
					UART_Transmit_Cbk_ptr = pUART_cfg_s->Transmit_Cbk_ptr;
    5940:	ec 85       	ldd	r30, Y+12	; 0x0c
    5942:	fd 85       	ldd	r31, Y+13	; 0x0d
    5944:	82 85       	ldd	r24, Z+10	; 0x0a
    5946:	93 85       	ldd	r25, Z+11	; 0x0b
    5948:	90 93 cc 07 	sts	0x07CC, r25
    594c:	80 93 cb 07 	sts	0x07CB, r24
				}
				ASSIGN_BIT(UART_CSRB, UART_TXCIE, HIGH);
    5950:	aa e2       	ldi	r26, 0x2A	; 42
    5952:	b0 e0       	ldi	r27, 0x00	; 0
    5954:	ea e2       	ldi	r30, 0x2A	; 42
    5956:	f0 e0       	ldi	r31, 0x00	; 0
    5958:	80 81       	ld	r24, Z
    595a:	80 64       	ori	r24, 0x40	; 64
    595c:	8c 93       	st	X, r24
			}

			/*
			 * interrupt resceiver handling
			 */
			if (gu8_UART_Status == UART_RESCEIVER
    595e:	80 91 c9 07 	lds	r24, 0x07C9
    5962:	82 30       	cpi	r24, 0x02	; 2
    5964:	21 f0       	breq	.+8      	; 0x596e <UART_Init+0x496>
    5966:	80 91 c9 07 	lds	r24, 0x07C9
    596a:	83 30       	cpi	r24, 0x03	; 3
    596c:	a9 f4       	brne	.+42     	; 0x5998 <UART_Init+0x4c0>
					|| gu8_UART_Status == UART_TRANSCEIVER)
			{
				/*
				 * set Resceive callback pointer
				 */
				if (NULL == pUART_cfg_s->Resceive_Cbk_ptr)
    596e:	ec 85       	ldd	r30, Y+12	; 0x0c
    5970:	fd 85       	ldd	r31, Y+13	; 0x0d
    5972:	84 85       	ldd	r24, Z+12	; 0x0c
    5974:	95 85       	ldd	r25, Z+13	; 0x0d
    5976:	00 97       	sbiw	r24, 0x00	; 0
    5978:	41 f0       	breq	.+16     	; 0x598a <UART_Init+0x4b2>
					 */
//					u8_ErrorStatus = E_NOK;
				}
				else
				{
					UART_Resceive_Cbk_ptr = pUART_cfg_s->Resceive_Cbk_ptr;
    597a:	ec 85       	ldd	r30, Y+12	; 0x0c
    597c:	fd 85       	ldd	r31, Y+13	; 0x0d
    597e:	84 85       	ldd	r24, Z+12	; 0x0c
    5980:	95 85       	ldd	r25, Z+13	; 0x0d
    5982:	90 93 ce 07 	sts	0x07CE, r25
    5986:	80 93 cd 07 	sts	0x07CD, r24
				}
				ASSIGN_BIT(UART_CSRB, UART_RXCIE, HIGH);
    598a:	aa e2       	ldi	r26, 0x2A	; 42
    598c:	b0 e0       	ldi	r27, 0x00	; 0
    598e:	ea e2       	ldi	r30, 0x2A	; 42
    5990:	f0 e0       	ldi	r31, 0x00	; 0
    5992:	80 81       	ld	r24, Z
    5994:	80 68       	ori	r24, 0x80	; 128
    5996:	8c 93       	st	X, r24
//				u8_ErrorStatus = UART_BASE_ERROR + ERR_NOT_SUPPORTED;
			}
			/*
			 * set Data Register Empty callback pointer
			 */
			if (NULL == pUART_cfg_s->DataRegisterEmpty_Cbk_ptr)
    5998:	ec 85       	ldd	r30, Y+12	; 0x0c
    599a:	fd 85       	ldd	r31, Y+13	; 0x0d
    599c:	86 85       	ldd	r24, Z+14	; 0x0e
    599e:	97 85       	ldd	r25, Z+15	; 0x0f
    59a0:	00 97       	sbiw	r24, 0x00	; 0
    59a2:	79 f0       	breq	.+30     	; 0x59c2 <UART_Init+0x4ea>
				 */
//				u8_ErrorStatus = E_NOK;
			}
			else
			{
				UART_DataRegisterEmpty_Cbk_ptr =
    59a4:	ec 85       	ldd	r30, Y+12	; 0x0c
    59a6:	fd 85       	ldd	r31, Y+13	; 0x0d
    59a8:	86 85       	ldd	r24, Z+14	; 0x0e
    59aa:	97 85       	ldd	r25, Z+15	; 0x0f
    59ac:	90 93 d0 07 	sts	0x07D0, r25
    59b0:	80 93 cf 07 	sts	0x07CF, r24
						pUART_cfg_s->DataRegisterEmpty_Cbk_ptr;
				ASSIGN_BIT(UART_CSRB, UART_DRIE, HIGH);
    59b4:	aa e2       	ldi	r26, 0x2A	; 42
    59b6:	b0 e0       	ldi	r27, 0x00	; 0
    59b8:	ea e2       	ldi	r30, 0x2A	; 42
    59ba:	f0 e0       	ldi	r31, 0x00	; 0
    59bc:	80 81       	ld	r24, Z
    59be:	80 62       	ori	r24, 0x20	; 32
    59c0:	8c 93       	st	X, r24
			 *  Wrong Interrupt Mode
			 */
//			u8_ErrorStatus = UART_BASE_ERROR + ERR_NOT_SUPPORTED;
		}

		if (u8_ErrorStatus != UART_BASE_ERROR + ERR_SUCCESS)
    59c2:	8d 81       	ldd	r24, Y+5	; 0x05
    59c4:	84 3c       	cpi	r24, 0xC4	; 196
    59c6:	19 f0       	breq	.+6      	; 0x59ce <UART_Init+0x4f6>
		{
			gu8_UART_Status = UART_UNINTIALIZED;
    59c8:	10 92 c9 07 	sts	0x07C9, r1
    59cc:	04 c0       	rjmp	.+8      	; 0x59d6 <UART_Init+0x4fe>
		}
		else
		{
			UART_CSRC = UART_CSRC_Buffer;
    59ce:	e0 e4       	ldi	r30, 0x40	; 64
    59d0:	f0 e0       	ldi	r31, 0x00	; 0
    59d2:	8b 81       	ldd	r24, Y+3	; 0x03
    59d4:	80 83       	st	Z, r24
		}
	}
	/*
	 * Function shall return the Error state
	 */
	return u8_ErrorStatus;
    59d6:	8d 81       	ldd	r24, Y+5	; 0x05
}
    59d8:	69 96       	adiw	r28, 0x19	; 25
    59da:	0f b6       	in	r0, 0x3f	; 63
    59dc:	f8 94       	cli
    59de:	de bf       	out	0x3e, r29	; 62
    59e0:	0f be       	out	0x3f, r0	; 63
    59e2:	cd bf       	out	0x3d, r28	; 61
    59e4:	cf 91       	pop	r28
    59e6:	df 91       	pop	r29
    59e8:	08 95       	ret

000059ea <UART_Deinit>:
 * \param void
 * \return ERROR_STATUS : Indication to the function execution
 *
 **/
extern ERROR_STATUS UART_Deinit(void)
{
    59ea:	df 93       	push	r29
    59ec:	cf 93       	push	r28
    59ee:	0f 92       	push	r0
    59f0:	cd b7       	in	r28, 0x3d	; 61
    59f2:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS u8_ErrorStatus = UART_BASE_ERROR + ERR_SUCCESS;
    59f4:	84 ec       	ldi	r24, 0xC4	; 196
    59f6:	89 83       	std	Y+1, r24	; 0x01
	if (gu8_UART_Status == UART_UNINTIALIZED)
    59f8:	80 91 c9 07 	lds	r24, 0x07C9
    59fc:	88 23       	and	r24, r24
    59fe:	19 f4       	brne	.+6      	; 0x5a06 <UART_Deinit+0x1c>
	{
		/*
		 * tryint to unintialize unintialized module
		 */
		u8_ErrorStatus = UART_BASE_ERROR + ERR_NOT_INITIALIZED;
    5a00:	82 ec       	ldi	r24, 0xC2	; 194
    5a02:	89 83       	std	Y+1, r24	; 0x01
    5a04:	02 c0       	rjmp	.+4      	; 0x5a0a <UART_Deinit+0x20>
	else
	{
		/*
		 * clear control registers
		 */
		gu8_UART_Status = UART_UNINTIALIZED;
    5a06:	10 92 c9 07 	sts	0x07C9, r1
	}
	/*
	 * Function shall return the Error state
	 */
	return u8_ErrorStatus;
    5a0a:	89 81       	ldd	r24, Y+1	; 0x01
}
    5a0c:	0f 90       	pop	r0
    5a0e:	cf 91       	pop	r28
    5a10:	df 91       	pop	r29
    5a12:	08 95       	ret

00005a14 <UART_SendByte>:
 * \param u8_Data : The byte the user wants to send
 * \return ERROR_STATUS : Indication to the function execution
 *
 **/
extern ERROR_STATUS UART_SendByte(uint8 u8_Data)
{
    5a14:	df 93       	push	r29
    5a16:	cf 93       	push	r28
    5a18:	cd b7       	in	r28, 0x3d	; 61
    5a1a:	de b7       	in	r29, 0x3e	; 62
    5a1c:	27 97       	sbiw	r28, 0x07	; 7
    5a1e:	0f b6       	in	r0, 0x3f	; 63
    5a20:	f8 94       	cli
    5a22:	de bf       	out	0x3e, r29	; 62
    5a24:	0f be       	out	0x3f, r0	; 63
    5a26:	cd bf       	out	0x3d, r28	; 61
    5a28:	8b 83       	std	Y+3, r24	; 0x03
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS u8_ErrorStatus = UART_BASE_ERROR + ERR_SUCCESS;
    5a2a:	84 ec       	ldi	r24, 0xC4	; 196
    5a2c:	8a 83       	std	Y+2, r24	; 0x02
	uint8 TransmitterFlag = GET_BIT(UART_CSRA, UART_TXC);
    5a2e:	eb e2       	ldi	r30, 0x2B	; 43
    5a30:	f0 e0       	ldi	r31, 0x00	; 0
    5a32:	80 81       	ld	r24, Z
    5a34:	88 2f       	mov	r24, r24
    5a36:	90 e0       	ldi	r25, 0x00	; 0
    5a38:	80 74       	andi	r24, 0x40	; 64
    5a3a:	90 70       	andi	r25, 0x00	; 0
    5a3c:	9d 83       	std	Y+5, r25	; 0x05
    5a3e:	8c 83       	std	Y+4, r24	; 0x04
    5a40:	8c 81       	ldd	r24, Y+4	; 0x04
    5a42:	9d 81       	ldd	r25, Y+5	; 0x05
    5a44:	99 23       	and	r25, r25
    5a46:	2c f4       	brge	.+10     	; 0x5a52 <UART_SendByte+0x3e>
    5a48:	8c 81       	ldd	r24, Y+4	; 0x04
    5a4a:	9d 81       	ldd	r25, Y+5	; 0x05
    5a4c:	cf 96       	adiw	r24, 0x3f	; 63
    5a4e:	9d 83       	std	Y+5, r25	; 0x05
    5a50:	8c 83       	std	Y+4, r24	; 0x04
    5a52:	8c 81       	ldd	r24, Y+4	; 0x04
    5a54:	9d 81       	ldd	r25, Y+5	; 0x05
    5a56:	08 2e       	mov	r0, r24
    5a58:	89 2f       	mov	r24, r25
    5a5a:	00 0c       	add	r0, r0
    5a5c:	88 1f       	adc	r24, r24
    5a5e:	99 0b       	sbc	r25, r25
    5a60:	00 0c       	add	r0, r0
    5a62:	88 1f       	adc	r24, r24
    5a64:	99 1f       	adc	r25, r25
    5a66:	89 83       	std	Y+1, r24	; 0x01

	if (((gu8_UART_Status == UART_TRANSMITTER)
    5a68:	80 91 c9 07 	lds	r24, 0x07C9
    5a6c:	81 30       	cpi	r24, 0x01	; 1
    5a6e:	21 f0       	breq	.+8      	; 0x5a78 <UART_SendByte+0x64>
    5a70:	80 91 c9 07 	lds	r24, 0x07C9
    5a74:	83 30       	cpi	r24, 0x03	; 3
    5a76:	89 f5       	brne	.+98     	; 0x5ada <UART_SendByte+0xc6>
			|| (gu8_UART_Status == UART_TRANSCEIVER)))
	{

		UART_DR = u8_Data;
    5a78:	ec e2       	ldi	r30, 0x2C	; 44
    5a7a:	f0 e0       	ldi	r31, 0x00	; 0
    5a7c:	8b 81       	ldd	r24, Y+3	; 0x03
    5a7e:	80 83       	st	Z, r24

		/*
		 * wait till Transmision is done if interrupt mode is polling
		 */
		if (gu8_UART_Interrupt == UART_POLLING)
    5a80:	80 91 ca 07 	lds	r24, 0x07CA
    5a84:	88 23       	and	r24, r24
    5a86:	59 f5       	brne	.+86     	; 0x5ade <UART_SendByte+0xca>
    5a88:	1d c0       	rjmp	.+58     	; 0x5ac4 <UART_SendByte+0xb0>
		{
			while (TransmitterFlag == FALSE)
			{
				TransmitterFlag = GET_BIT(UART_CSRA, UART_TXC);
    5a8a:	eb e2       	ldi	r30, 0x2B	; 43
    5a8c:	f0 e0       	ldi	r31, 0x00	; 0
    5a8e:	80 81       	ld	r24, Z
    5a90:	88 2f       	mov	r24, r24
    5a92:	90 e0       	ldi	r25, 0x00	; 0
    5a94:	80 74       	andi	r24, 0x40	; 64
    5a96:	90 70       	andi	r25, 0x00	; 0
    5a98:	9f 83       	std	Y+7, r25	; 0x07
    5a9a:	8e 83       	std	Y+6, r24	; 0x06
    5a9c:	8e 81       	ldd	r24, Y+6	; 0x06
    5a9e:	9f 81       	ldd	r25, Y+7	; 0x07
    5aa0:	99 23       	and	r25, r25
    5aa2:	2c f4       	brge	.+10     	; 0x5aae <UART_SendByte+0x9a>
    5aa4:	8e 81       	ldd	r24, Y+6	; 0x06
    5aa6:	9f 81       	ldd	r25, Y+7	; 0x07
    5aa8:	cf 96       	adiw	r24, 0x3f	; 63
    5aaa:	9f 83       	std	Y+7, r25	; 0x07
    5aac:	8e 83       	std	Y+6, r24	; 0x06
    5aae:	8e 81       	ldd	r24, Y+6	; 0x06
    5ab0:	9f 81       	ldd	r25, Y+7	; 0x07
    5ab2:	08 2e       	mov	r0, r24
    5ab4:	89 2f       	mov	r24, r25
    5ab6:	00 0c       	add	r0, r0
    5ab8:	88 1f       	adc	r24, r24
    5aba:	99 0b       	sbc	r25, r25
    5abc:	00 0c       	add	r0, r0
    5abe:	88 1f       	adc	r24, r24
    5ac0:	99 1f       	adc	r25, r25
    5ac2:	89 83       	std	Y+1, r24	; 0x01
		/*
		 * wait till Transmision is done if interrupt mode is polling
		 */
		if (gu8_UART_Interrupt == UART_POLLING)
		{
			while (TransmitterFlag == FALSE)
    5ac4:	89 81       	ldd	r24, Y+1	; 0x01
    5ac6:	88 23       	and	r24, r24
    5ac8:	01 f3       	breq	.-64     	; 0x5a8a <UART_SendByte+0x76>
				TransmitterFlag = GET_BIT(UART_CSRA, UART_TXC);
			}
			/*
			 * clear Transmision Flag
			 */
			SET_BIT(UART_CSRA, UART_TXC);
    5aca:	ab e2       	ldi	r26, 0x2B	; 43
    5acc:	b0 e0       	ldi	r27, 0x00	; 0
    5ace:	eb e2       	ldi	r30, 0x2B	; 43
    5ad0:	f0 e0       	ldi	r31, 0x00	; 0
    5ad2:	80 81       	ld	r24, Z
    5ad4:	80 64       	ori	r24, 0x40	; 64
    5ad6:	8c 93       	st	X, r24
    5ad8:	02 c0       	rjmp	.+4      	; 0x5ade <UART_SendByte+0xca>
	else
	{
		/*
		 * tryint to use unintialized module
		 */
		u8_ErrorStatus = UART_BASE_ERROR + ERR_NOT_INITIALIZED;
    5ada:	82 ec       	ldi	r24, 0xC2	; 194
    5adc:	8a 83       	std	Y+2, r24	; 0x02

	}
	/*
	 * Function shall return the Error state
	 */
	return u8_ErrorStatus;
    5ade:	8a 81       	ldd	r24, Y+2	; 0x02
}
    5ae0:	27 96       	adiw	r28, 0x07	; 7
    5ae2:	0f b6       	in	r0, 0x3f	; 63
    5ae4:	f8 94       	cli
    5ae6:	de bf       	out	0x3e, r29	; 62
    5ae8:	0f be       	out	0x3f, r0	; 63
    5aea:	cd bf       	out	0x3d, r28	; 61
    5aec:	cf 91       	pop	r28
    5aee:	df 91       	pop	r29
    5af0:	08 95       	ret

00005af2 <UART_ReceiveByte>:
 * \param pu8_ReceivedData : The sent byte will be stored in the passed pointer
 * \return ERROR_STATUS : Indication to the function execution
 *
 **/
extern ERROR_STATUS UART_ReceiveByte(uint8 *pu8_ReceivedData)
{
    5af2:	df 93       	push	r29
    5af4:	cf 93       	push	r28
    5af6:	cd b7       	in	r28, 0x3d	; 61
    5af8:	de b7       	in	r29, 0x3e	; 62
    5afa:	28 97       	sbiw	r28, 0x08	; 8
    5afc:	0f b6       	in	r0, 0x3f	; 63
    5afe:	f8 94       	cli
    5b00:	de bf       	out	0x3e, r29	; 62
    5b02:	0f be       	out	0x3f, r0	; 63
    5b04:	cd bf       	out	0x3d, r28	; 61
    5b06:	9c 83       	std	Y+4, r25	; 0x04
    5b08:	8b 83       	std	Y+3, r24	; 0x03
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS u8_ErrorStatus = UART_BASE_ERROR + ERR_SUCCESS;
    5b0a:	84 ec       	ldi	r24, 0xC4	; 196
    5b0c:	8a 83       	std	Y+2, r24	; 0x02
	uint8 ResceiverFlag = GET_BIT(UART_CSRA, UART_RXC);
    5b0e:	eb e2       	ldi	r30, 0x2B	; 43
    5b10:	f0 e0       	ldi	r31, 0x00	; 0
    5b12:	80 81       	ld	r24, Z
    5b14:	88 2f       	mov	r24, r24
    5b16:	90 e0       	ldi	r25, 0x00	; 0
    5b18:	80 78       	andi	r24, 0x80	; 128
    5b1a:	90 70       	andi	r25, 0x00	; 0
    5b1c:	9e 83       	std	Y+6, r25	; 0x06
    5b1e:	8d 83       	std	Y+5, r24	; 0x05
    5b20:	8d 81       	ldd	r24, Y+5	; 0x05
    5b22:	9e 81       	ldd	r25, Y+6	; 0x06
    5b24:	99 23       	and	r25, r25
    5b26:	34 f4       	brge	.+12     	; 0x5b34 <UART_ReceiveByte+0x42>
    5b28:	8d 81       	ldd	r24, Y+5	; 0x05
    5b2a:	9e 81       	ldd	r25, Y+6	; 0x06
    5b2c:	81 58       	subi	r24, 0x81	; 129
    5b2e:	9f 4f       	sbci	r25, 0xFF	; 255
    5b30:	9e 83       	std	Y+6, r25	; 0x06
    5b32:	8d 83       	std	Y+5, r24	; 0x05
    5b34:	8d 81       	ldd	r24, Y+5	; 0x05
    5b36:	9e 81       	ldd	r25, Y+6	; 0x06
    5b38:	88 0f       	add	r24, r24
    5b3a:	89 2f       	mov	r24, r25
    5b3c:	88 1f       	adc	r24, r24
    5b3e:	99 0b       	sbc	r25, r25
    5b40:	89 83       	std	Y+1, r24	; 0x01

	if ((gu8_UART_Status == UART_RESCEIVER)
    5b42:	80 91 c9 07 	lds	r24, 0x07C9
    5b46:	82 30       	cpi	r24, 0x02	; 2
    5b48:	21 f0       	breq	.+8      	; 0x5b52 <UART_ReceiveByte+0x60>
    5b4a:	80 91 c9 07 	lds	r24, 0x07C9
    5b4e:	83 30       	cpi	r24, 0x03	; 3
    5b50:	b9 f5       	brne	.+110    	; 0x5bc0 <UART_ReceiveByte+0xce>
			|| (gu8_UART_Status == UART_TRANSCEIVER))
	{
		/*
		 * wait till Transmision is done if interrupt mode is polling
		 */
		if (gu8_UART_Interrupt == UART_POLLING)
    5b52:	80 91 ca 07 	lds	r24, 0x07CA
    5b56:	88 23       	and	r24, r24
    5b58:	29 f5       	brne	.+74     	; 0x5ba4 <UART_ReceiveByte+0xb2>
    5b5a:	1a c0       	rjmp	.+52     	; 0x5b90 <UART_ReceiveByte+0x9e>
			/*
			 * wait to Resceive data
			 */
			while (ResceiverFlag == FALSE)
			{
				ResceiverFlag = GET_BIT(UART_CSRA, UART_RXC);
    5b5c:	eb e2       	ldi	r30, 0x2B	; 43
    5b5e:	f0 e0       	ldi	r31, 0x00	; 0
    5b60:	80 81       	ld	r24, Z
    5b62:	88 2f       	mov	r24, r24
    5b64:	90 e0       	ldi	r25, 0x00	; 0
    5b66:	80 78       	andi	r24, 0x80	; 128
    5b68:	90 70       	andi	r25, 0x00	; 0
    5b6a:	98 87       	std	Y+8, r25	; 0x08
    5b6c:	8f 83       	std	Y+7, r24	; 0x07
    5b6e:	8f 81       	ldd	r24, Y+7	; 0x07
    5b70:	98 85       	ldd	r25, Y+8	; 0x08
    5b72:	99 23       	and	r25, r25
    5b74:	34 f4       	brge	.+12     	; 0x5b82 <UART_ReceiveByte+0x90>
    5b76:	8f 81       	ldd	r24, Y+7	; 0x07
    5b78:	98 85       	ldd	r25, Y+8	; 0x08
    5b7a:	81 58       	subi	r24, 0x81	; 129
    5b7c:	9f 4f       	sbci	r25, 0xFF	; 255
    5b7e:	98 87       	std	Y+8, r25	; 0x08
    5b80:	8f 83       	std	Y+7, r24	; 0x07
    5b82:	8f 81       	ldd	r24, Y+7	; 0x07
    5b84:	98 85       	ldd	r25, Y+8	; 0x08
    5b86:	88 0f       	add	r24, r24
    5b88:	89 2f       	mov	r24, r25
    5b8a:	88 1f       	adc	r24, r24
    5b8c:	99 0b       	sbc	r25, r25
    5b8e:	89 83       	std	Y+1, r24	; 0x01
		if (gu8_UART_Interrupt == UART_POLLING)
		{
			/*
			 * wait to Resceive data
			 */
			while (ResceiverFlag == FALSE)
    5b90:	89 81       	ldd	r24, Y+1	; 0x01
    5b92:	88 23       	and	r24, r24
    5b94:	19 f3       	breq	.-58     	; 0x5b5c <UART_ReceiveByte+0x6a>
				ResceiverFlag = GET_BIT(UART_CSRA, UART_RXC);
			}
			/*
			 * clear Transmision Flag
			 */
			SET_BIT(UART_CSRA, UART_RXC);
    5b96:	ab e2       	ldi	r26, 0x2B	; 43
    5b98:	b0 e0       	ldi	r27, 0x00	; 0
    5b9a:	eb e2       	ldi	r30, 0x2B	; 43
    5b9c:	f0 e0       	ldi	r31, 0x00	; 0
    5b9e:	80 81       	ld	r24, Z
    5ba0:	80 68       	ori	r24, 0x80	; 128
    5ba2:	8c 93       	st	X, r24
		}
		else
		{
			/* DO NOTHING */
		}
		if (pu8_ReceivedData == NULL)
    5ba4:	8b 81       	ldd	r24, Y+3	; 0x03
    5ba6:	9c 81       	ldd	r25, Y+4	; 0x04
    5ba8:	00 97       	sbiw	r24, 0x00	; 0
    5baa:	19 f4       	brne	.+6      	; 0x5bb2 <UART_ReceiveByte+0xc0>
		{
			/*
			 * trying to access a null pointer
			 */
			u8_ErrorStatus = UART_BASE_ERROR + ERR_NULL_PTR;
    5bac:	80 ec       	ldi	r24, 0xC0	; 192
    5bae:	8a 83       	std	Y+2, r24	; 0x02
    5bb0:	09 c0       	rjmp	.+18     	; 0x5bc4 <UART_ReceiveByte+0xd2>
		}
		else
		{
			*pu8_ReceivedData = UART_DR;
    5bb2:	ec e2       	ldi	r30, 0x2C	; 44
    5bb4:	f0 e0       	ldi	r31, 0x00	; 0
    5bb6:	80 81       	ld	r24, Z
    5bb8:	eb 81       	ldd	r30, Y+3	; 0x03
    5bba:	fc 81       	ldd	r31, Y+4	; 0x04
    5bbc:	80 83       	st	Z, r24
    5bbe:	02 c0       	rjmp	.+4      	; 0x5bc4 <UART_ReceiveByte+0xd2>
		}
	}
	else
	{
		u8_ErrorStatus = UART_BASE_ERROR + ERR_NOT_SUPPORTED;
    5bc0:	8c eb       	ldi	r24, 0xBC	; 188
    5bc2:	8a 83       	std	Y+2, r24	; 0x02
	}
	/*
	 * Function shall return the Error state
	 */
	return u8_ErrorStatus;
    5bc4:	8a 81       	ldd	r24, Y+2	; 0x02
}
    5bc6:	28 96       	adiw	r28, 0x08	; 8
    5bc8:	0f b6       	in	r0, 0x3f	; 63
    5bca:	f8 94       	cli
    5bcc:	de bf       	out	0x3e, r29	; 62
    5bce:	0f be       	out	0x3f, r0	; 63
    5bd0:	cd bf       	out	0x3d, r28	; 61
    5bd2:	cf 91       	pop	r28
    5bd4:	df 91       	pop	r29
    5bd6:	08 95       	ret

00005bd8 <__vector_14>:

/*
 * data register empty interrupt service routine
 */
ISR(USART_UDRE_vect)
{
    5bd8:	1f 92       	push	r1
    5bda:	0f 92       	push	r0
    5bdc:	0f b6       	in	r0, 0x3f	; 63
    5bde:	0f 92       	push	r0
    5be0:	11 24       	eor	r1, r1
    5be2:	2f 93       	push	r18
    5be4:	3f 93       	push	r19
    5be6:	4f 93       	push	r20
    5be8:	5f 93       	push	r21
    5bea:	6f 93       	push	r22
    5bec:	7f 93       	push	r23
    5bee:	8f 93       	push	r24
    5bf0:	9f 93       	push	r25
    5bf2:	af 93       	push	r26
    5bf4:	bf 93       	push	r27
    5bf6:	ef 93       	push	r30
    5bf8:	ff 93       	push	r31
    5bfa:	df 93       	push	r29
    5bfc:	cf 93       	push	r28
    5bfe:	cd b7       	in	r28, 0x3d	; 61
    5c00:	de b7       	in	r29, 0x3e	; 62
	if (NULL != UART_DataRegisterEmpty_Cbk_ptr)
    5c02:	80 91 cf 07 	lds	r24, 0x07CF
    5c06:	90 91 d0 07 	lds	r25, 0x07D0
    5c0a:	00 97       	sbiw	r24, 0x00	; 0
    5c0c:	29 f0       	breq	.+10     	; 0x5c18 <__vector_14+0x40>
	{
		UART_DataRegisterEmpty_Cbk_ptr();
    5c0e:	e0 91 cf 07 	lds	r30, 0x07CF
    5c12:	f0 91 d0 07 	lds	r31, 0x07D0
    5c16:	09 95       	icall
	}
	else
	{
		/* DO NOTHING */
	}
}
    5c18:	cf 91       	pop	r28
    5c1a:	df 91       	pop	r29
    5c1c:	ff 91       	pop	r31
    5c1e:	ef 91       	pop	r30
    5c20:	bf 91       	pop	r27
    5c22:	af 91       	pop	r26
    5c24:	9f 91       	pop	r25
    5c26:	8f 91       	pop	r24
    5c28:	7f 91       	pop	r23
    5c2a:	6f 91       	pop	r22
    5c2c:	5f 91       	pop	r21
    5c2e:	4f 91       	pop	r20
    5c30:	3f 91       	pop	r19
    5c32:	2f 91       	pop	r18
    5c34:	0f 90       	pop	r0
    5c36:	0f be       	out	0x3f, r0	; 63
    5c38:	0f 90       	pop	r0
    5c3a:	1f 90       	pop	r1
    5c3c:	18 95       	reti

00005c3e <__vector_15>:

/*
 *  transmitter interrupt service routine
 */
ISR(USART_TXC_vect)
{
    5c3e:	1f 92       	push	r1
    5c40:	0f 92       	push	r0
    5c42:	0f b6       	in	r0, 0x3f	; 63
    5c44:	0f 92       	push	r0
    5c46:	11 24       	eor	r1, r1
    5c48:	2f 93       	push	r18
    5c4a:	3f 93       	push	r19
    5c4c:	4f 93       	push	r20
    5c4e:	5f 93       	push	r21
    5c50:	6f 93       	push	r22
    5c52:	7f 93       	push	r23
    5c54:	8f 93       	push	r24
    5c56:	9f 93       	push	r25
    5c58:	af 93       	push	r26
    5c5a:	bf 93       	push	r27
    5c5c:	ef 93       	push	r30
    5c5e:	ff 93       	push	r31
    5c60:	df 93       	push	r29
    5c62:	cf 93       	push	r28
    5c64:	cd b7       	in	r28, 0x3d	; 61
    5c66:	de b7       	in	r29, 0x3e	; 62
	if (NULL != UART_Transmit_Cbk_ptr)
    5c68:	80 91 cb 07 	lds	r24, 0x07CB
    5c6c:	90 91 cc 07 	lds	r25, 0x07CC
    5c70:	00 97       	sbiw	r24, 0x00	; 0
    5c72:	29 f0       	breq	.+10     	; 0x5c7e <__vector_15+0x40>
	{
		UART_Transmit_Cbk_ptr();
    5c74:	e0 91 cb 07 	lds	r30, 0x07CB
    5c78:	f0 91 cc 07 	lds	r31, 0x07CC
    5c7c:	09 95       	icall
	}
	else
	{
		/* DO NOTHING */
	}
}
    5c7e:	cf 91       	pop	r28
    5c80:	df 91       	pop	r29
    5c82:	ff 91       	pop	r31
    5c84:	ef 91       	pop	r30
    5c86:	bf 91       	pop	r27
    5c88:	af 91       	pop	r26
    5c8a:	9f 91       	pop	r25
    5c8c:	8f 91       	pop	r24
    5c8e:	7f 91       	pop	r23
    5c90:	6f 91       	pop	r22
    5c92:	5f 91       	pop	r21
    5c94:	4f 91       	pop	r20
    5c96:	3f 91       	pop	r19
    5c98:	2f 91       	pop	r18
    5c9a:	0f 90       	pop	r0
    5c9c:	0f be       	out	0x3f, r0	; 63
    5c9e:	0f 90       	pop	r0
    5ca0:	1f 90       	pop	r1
    5ca2:	18 95       	reti

00005ca4 <__vector_13>:
/*
 * reciever interrupt service routine
 */
ISR(USART_RXC_vect)
{
    5ca4:	1f 92       	push	r1
    5ca6:	0f 92       	push	r0
    5ca8:	0f b6       	in	r0, 0x3f	; 63
    5caa:	0f 92       	push	r0
    5cac:	11 24       	eor	r1, r1
    5cae:	2f 93       	push	r18
    5cb0:	3f 93       	push	r19
    5cb2:	4f 93       	push	r20
    5cb4:	5f 93       	push	r21
    5cb6:	6f 93       	push	r22
    5cb8:	7f 93       	push	r23
    5cba:	8f 93       	push	r24
    5cbc:	9f 93       	push	r25
    5cbe:	af 93       	push	r26
    5cc0:	bf 93       	push	r27
    5cc2:	ef 93       	push	r30
    5cc4:	ff 93       	push	r31
    5cc6:	df 93       	push	r29
    5cc8:	cf 93       	push	r28
    5cca:	cd b7       	in	r28, 0x3d	; 61
    5ccc:	de b7       	in	r29, 0x3e	; 62
	if (NULL != UART_Resceive_Cbk_ptr)
    5cce:	80 91 cd 07 	lds	r24, 0x07CD
    5cd2:	90 91 ce 07 	lds	r25, 0x07CE
    5cd6:	00 97       	sbiw	r24, 0x00	; 0
    5cd8:	29 f0       	breq	.+10     	; 0x5ce4 <__vector_13+0x40>
	{
		UART_Resceive_Cbk_ptr();
    5cda:	e0 91 cd 07 	lds	r30, 0x07CD
    5cde:	f0 91 ce 07 	lds	r31, 0x07CE
    5ce2:	09 95       	icall
	}
	else
	{
		/* DO NOTHING */
	}
}
    5ce4:	cf 91       	pop	r28
    5ce6:	df 91       	pop	r29
    5ce8:	ff 91       	pop	r31
    5cea:	ef 91       	pop	r30
    5cec:	bf 91       	pop	r27
    5cee:	af 91       	pop	r26
    5cf0:	9f 91       	pop	r25
    5cf2:	8f 91       	pop	r24
    5cf4:	7f 91       	pop	r23
    5cf6:	6f 91       	pop	r22
    5cf8:	5f 91       	pop	r21
    5cfa:	4f 91       	pop	r20
    5cfc:	3f 91       	pop	r19
    5cfe:	2f 91       	pop	r18
    5d00:	0f 90       	pop	r0
    5d02:	0f be       	out	0x3f, r0	; 63
    5d04:	0f 90       	pop	r0
    5d06:	1f 90       	pop	r1
    5d08:	18 95       	reti

00005d0a <Timer_Init>:
 * Return: The error status of the function.
 * Description: Initiates the module.
 *
 */
ERROR_STATUS Timer_Init(Timer_cfg_s* Timer_cfg)
{
    5d0a:	df 93       	push	r29
    5d0c:	cf 93       	push	r28
    5d0e:	cd b7       	in	r28, 0x3d	; 61
    5d10:	de b7       	in	r29, 0x3e	; 62
    5d12:	65 97       	sbiw	r28, 0x15	; 21
    5d14:	0f b6       	in	r0, 0x3f	; 63
    5d16:	f8 94       	cli
    5d18:	de bf       	out	0x3e, r29	; 62
    5d1a:	0f be       	out	0x3f, r0	; 63
    5d1c:	cd bf       	out	0x3d, r28	; 61
    5d1e:	9b 83       	std	Y+3, r25	; 0x03
    5d20:	8a 83       	std	Y+2, r24	; 0x02
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = TIMER_BASE_ERROR + ERR_SUCCESS;
    5d22:	82 ee       	ldi	r24, 0xE2	; 226
    5d24:	89 83       	std	Y+1, r24	; 0x01

	if (Timer_cfg == NULL)
    5d26:	8a 81       	ldd	r24, Y+2	; 0x02
    5d28:	9b 81       	ldd	r25, Y+3	; 0x03
    5d2a:	00 97       	sbiw	r24, 0x00	; 0
    5d2c:	19 f4       	brne	.+6      	; 0x5d34 <Timer_Init+0x2a>
	{
		/*
		 * trying to access a null pointer
		 */
		s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NULL_PTR;
    5d2e:	8e ed       	ldi	r24, 0xDE	; 222
    5d30:	89 83       	std	Y+1, r24	; 0x01
    5d32:	7b c1       	rjmp	.+758    	; 0x602a <Timer_Init+0x320>
	{

		/*
		 * check on Timer0 channel
		 */
		switch (Timer_cfg->Timer_CH_NO)
    5d34:	ea 81       	ldd	r30, Y+2	; 0x02
    5d36:	fb 81       	ldd	r31, Y+3	; 0x03
    5d38:	80 81       	ld	r24, Z
    5d3a:	28 2f       	mov	r18, r24
    5d3c:	30 e0       	ldi	r19, 0x00	; 0
    5d3e:	3d 8b       	std	Y+21, r19	; 0x15
    5d40:	2c 8b       	std	Y+20, r18	; 0x14
    5d42:	8c 89       	ldd	r24, Y+20	; 0x14
    5d44:	9d 89       	ldd	r25, Y+21	; 0x15
    5d46:	81 30       	cpi	r24, 0x01	; 1
    5d48:	91 05       	cpc	r25, r1
    5d4a:	09 f4       	brne	.+2      	; 0x5d4e <Timer_Init+0x44>
    5d4c:	82 c0       	rjmp	.+260    	; 0x5e52 <Timer_Init+0x148>
    5d4e:	2c 89       	ldd	r18, Y+20	; 0x14
    5d50:	3d 89       	ldd	r19, Y+21	; 0x15
    5d52:	22 30       	cpi	r18, 0x02	; 2
    5d54:	31 05       	cpc	r19, r1
    5d56:	09 f4       	brne	.+2      	; 0x5d5a <Timer_Init+0x50>
    5d58:	f8 c0       	rjmp	.+496    	; 0x5f4a <Timer_Init+0x240>
    5d5a:	8c 89       	ldd	r24, Y+20	; 0x14
    5d5c:	9d 89       	ldd	r25, Y+21	; 0x15
    5d5e:	00 97       	sbiw	r24, 0x00	; 0
    5d60:	09 f0       	breq	.+2      	; 0x5d64 <Timer_Init+0x5a>
    5d62:	61 c1       	rjmp	.+706    	; 0x6026 <Timer_Init+0x31c>
		{
		case TIMER_CH0:
			/*
			 * check on Timer0 mode
			 */
			switch (Timer_cfg->Timer_Mode)
    5d64:	ea 81       	ldd	r30, Y+2	; 0x02
    5d66:	fb 81       	ldd	r31, Y+3	; 0x03
    5d68:	81 81       	ldd	r24, Z+1	; 0x01
    5d6a:	28 2f       	mov	r18, r24
    5d6c:	30 e0       	ldi	r19, 0x00	; 0
    5d6e:	3b 8b       	std	Y+19, r19	; 0x13
    5d70:	2a 8b       	std	Y+18, r18	; 0x12
    5d72:	8a 89       	ldd	r24, Y+18	; 0x12
    5d74:	9b 89       	ldd	r25, Y+19	; 0x13
    5d76:	81 30       	cpi	r24, 0x01	; 1
    5d78:	91 05       	cpc	r25, r1
    5d7a:	19 f1       	breq	.+70     	; 0x5dc2 <Timer_Init+0xb8>
    5d7c:	2a 89       	ldd	r18, Y+18	; 0x12
    5d7e:	3b 89       	ldd	r19, Y+19	; 0x13
    5d80:	22 30       	cpi	r18, 0x02	; 2
    5d82:	31 05       	cpc	r19, r1
    5d84:	11 f1       	breq	.+68     	; 0x5dca <Timer_Init+0xc0>
    5d86:	8a 89       	ldd	r24, Y+18	; 0x12
    5d88:	9b 89       	ldd	r25, Y+19	; 0x13
    5d8a:	00 97       	sbiw	r24, 0x00	; 0
    5d8c:	11 f5       	brne	.+68     	; 0x5dd2 <Timer_Init+0xc8>
			{
			case TIMER_MODE:
				if (gau8_Timer0Prescaler[Timer_cfg->Timer_Prescaler] == FALSE)
    5d8e:	ea 81       	ldd	r30, Y+2	; 0x02
    5d90:	fb 81       	ldd	r31, Y+3	; 0x03
    5d92:	82 81       	ldd	r24, Z+2	; 0x02
    5d94:	88 2f       	mov	r24, r24
    5d96:	90 e0       	ldi	r25, 0x00	; 0
    5d98:	fc 01       	movw	r30, r24
    5d9a:	ea 51       	subi	r30, 0x1A	; 26
    5d9c:	ff 4f       	sbci	r31, 0xFF	; 255
    5d9e:	80 81       	ld	r24, Z
    5da0:	88 23       	and	r24, r24
    5da2:	19 f4       	brne	.+6      	; 0x5daa <Timer_Init+0xa0>
				{
					/*
					 *  Wrong Timer0 Prescaler
					 */
					s8_ErrorStatus = TIMER_BASE_ERROR + ERR_INVALID_ARGU;
    5da4:	81 ee       	ldi	r24, 0xE1	; 225
    5da6:	89 83       	std	Y+1, r24	; 0x01
    5da8:	16 c0       	rjmp	.+44     	; 0x5dd6 <Timer_Init+0xcc>
				}
				else
				{
					gu8_TimerPrescaler[TIMER_CH0] =
    5daa:	ea 81       	ldd	r30, Y+2	; 0x02
    5dac:	fb 81       	ldd	r31, Y+3	; 0x03
    5dae:	82 81       	ldd	r24, Z+2	; 0x02
    5db0:	88 2f       	mov	r24, r24
    5db2:	90 e0       	ldi	r25, 0x00	; 0
    5db4:	fc 01       	movw	r30, r24
    5db6:	ea 51       	subi	r30, 0x1A	; 26
    5db8:	ff 4f       	sbci	r31, 0xFF	; 255
    5dba:	80 81       	ld	r24, Z
    5dbc:	80 93 d1 07 	sts	0x07D1, r24
    5dc0:	0a c0       	rjmp	.+20     	; 0x5dd6 <Timer_Init+0xcc>
							gau8_Timer0Prescaler[Timer_cfg->Timer_Prescaler];
				}
				break;
			case COUNTER_RISING_MODE:
				gu8_TimerPrescaler[TIMER_CH0] = COUNTER_RISING;
    5dc2:	86 e0       	ldi	r24, 0x06	; 6
    5dc4:	80 93 d1 07 	sts	0x07D1, r24
    5dc8:	06 c0       	rjmp	.+12     	; 0x5dd6 <Timer_Init+0xcc>
				break;
			case COUNTER_FALLING_MODE:
				gu8_TimerPrescaler[TIMER_CH0] = COUNTER_FALLING;
    5dca:	87 e0       	ldi	r24, 0x07	; 7
    5dcc:	80 93 d1 07 	sts	0x07D1, r24
    5dd0:	02 c0       	rjmp	.+4      	; 0x5dd6 <Timer_Init+0xcc>
				break;
			default:
				/*
				 *  Wrong Timer0 mode
				 */
				s8_ErrorStatus = TIMER_BASE_ERROR + ERR_INVALID_ARGU;
    5dd2:	81 ee       	ldi	r24, 0xE1	; 225
    5dd4:	89 83       	std	Y+1, r24	; 0x01
				break;
			}
			/*
			 * check on Timer0 Interrupt
			 */
			switch (Timer_cfg->Timer_Polling_Or_Interrupt)
    5dd6:	ea 81       	ldd	r30, Y+2	; 0x02
    5dd8:	fb 81       	ldd	r31, Y+3	; 0x03
    5dda:	83 81       	ldd	r24, Z+3	; 0x03
    5ddc:	28 2f       	mov	r18, r24
    5dde:	30 e0       	ldi	r19, 0x00	; 0
    5de0:	39 8b       	std	Y+17, r19	; 0x11
    5de2:	28 8b       	std	Y+16, r18	; 0x10
    5de4:	88 89       	ldd	r24, Y+16	; 0x10
    5de6:	99 89       	ldd	r25, Y+17	; 0x11
    5de8:	00 97       	sbiw	r24, 0x00	; 0
    5dea:	31 f0       	breq	.+12     	; 0x5df8 <Timer_Init+0xee>
    5dec:	28 89       	ldd	r18, Y+16	; 0x10
    5dee:	39 89       	ldd	r19, Y+17	; 0x11
    5df0:	21 30       	cpi	r18, 0x01	; 1
    5df2:	31 05       	cpc	r19, r1
    5df4:	41 f0       	breq	.+16     	; 0x5e06 <Timer_Init+0xfc>
    5df6:	17 c0       	rjmp	.+46     	; 0x5e26 <Timer_Init+0x11c>
			{
			case TIMER_POLLING_MODE:
				TIMSK |= T0_POLLING;
    5df8:	e9 e5       	ldi	r30, 0x59	; 89
    5dfa:	f0 e0       	ldi	r31, 0x00	; 0
    5dfc:	a9 e5       	ldi	r26, 0x59	; 89
    5dfe:	b0 e0       	ldi	r27, 0x00	; 0
    5e00:	8c 91       	ld	r24, X
    5e02:	80 83       	st	Z, r24
    5e04:	12 c0       	rjmp	.+36     	; 0x5e2a <Timer_Init+0x120>
				break;
			case TIMER_INTERRUPT_MODE:
				TIMSK |= T0_INTERRUPT_NORMAL;
    5e06:	a9 e5       	ldi	r26, 0x59	; 89
    5e08:	b0 e0       	ldi	r27, 0x00	; 0
    5e0a:	e9 e5       	ldi	r30, 0x59	; 89
    5e0c:	f0 e0       	ldi	r31, 0x00	; 0
    5e0e:	80 81       	ld	r24, Z
    5e10:	81 60       	ori	r24, 0x01	; 1
    5e12:	8c 93       	st	X, r24
				/*
				 * set callback pointer
				 */
				Timer_OV_Cbk_ptr[TIMER_CH0] = Timer_cfg->Timer_Cbk_ptr;
    5e14:	ea 81       	ldd	r30, Y+2	; 0x02
    5e16:	fb 81       	ldd	r31, Y+3	; 0x03
    5e18:	84 81       	ldd	r24, Z+4	; 0x04
    5e1a:	95 81       	ldd	r25, Z+5	; 0x05
    5e1c:	90 93 de 07 	sts	0x07DE, r25
    5e20:	80 93 dd 07 	sts	0x07DD, r24
    5e24:	02 c0       	rjmp	.+4      	; 0x5e2a <Timer_Init+0x120>
				break;
			default:
				/*
				 *  Wrong Timer0 Interrupt
				 */
				s8_ErrorStatus = TIMER_BASE_ERROR + ERR_INVALID_ARGU;
    5e26:	81 ee       	ldi	r24, 0xE1	; 225
    5e28:	89 83       	std	Y+1, r24	; 0x01
				break;
			}
			/*
			 * set Timer0 control register
			 */
			if (s8_ErrorStatus == TIMER_BASE_ERROR + ERR_SUCCESS)
    5e2a:	89 81       	ldd	r24, Y+1	; 0x01
    5e2c:	82 3e       	cpi	r24, 0xE2	; 226
    5e2e:	09 f0       	breq	.+2      	; 0x5e32 <Timer_Init+0x128>
    5e30:	fc c0       	rjmp	.+504    	; 0x602a <Timer_Init+0x320>
			{
				/*
				 * clear timer TCCR0
				 */
				TCCR0 &= LOW;
    5e32:	e3 e5       	ldi	r30, 0x53	; 83
    5e34:	f0 e0       	ldi	r31, 0x00	; 0
    5e36:	30 81       	ld	r19, Z
    5e38:	e3 e5       	ldi	r30, 0x53	; 83
    5e3a:	f0 e0       	ldi	r31, 0x00	; 0
    5e3c:	10 82       	st	Z, r1
				/*
				 * set Timer0 mode
				 */
				TCCR0 |= (T0_NORMAL_MODE | T0_OC0_DIS);
    5e3e:	a3 e5       	ldi	r26, 0x53	; 83
    5e40:	b0 e0       	ldi	r27, 0x00	; 0
    5e42:	e3 e5       	ldi	r30, 0x53	; 83
    5e44:	f0 e0       	ldi	r31, 0x00	; 0
    5e46:	80 81       	ld	r24, Z
    5e48:	8c 93       	st	X, r24
				/*
				 * set timer0 status
				 */
				gau8_TimerStatus[TIMER_CH0] = TIMER_INTIALIZED;
    5e4a:	81 e0       	ldi	r24, 0x01	; 1
    5e4c:	80 93 d4 07 	sts	0x07D4, r24
    5e50:	ec c0       	rjmp	.+472    	; 0x602a <Timer_Init+0x320>
			break;
		case TIMER_CH1:
			/*
			 * check on Timer1 mode
			 */
			switch (Timer_cfg->Timer_Mode)
    5e52:	ea 81       	ldd	r30, Y+2	; 0x02
    5e54:	fb 81       	ldd	r31, Y+3	; 0x03
    5e56:	81 81       	ldd	r24, Z+1	; 0x01
    5e58:	28 2f       	mov	r18, r24
    5e5a:	30 e0       	ldi	r19, 0x00	; 0
    5e5c:	3e 87       	std	Y+14, r19	; 0x0e
    5e5e:	2d 87       	std	Y+13, r18	; 0x0d
    5e60:	8d 85       	ldd	r24, Y+13	; 0x0d
    5e62:	9e 85       	ldd	r25, Y+14	; 0x0e
    5e64:	81 30       	cpi	r24, 0x01	; 1
    5e66:	91 05       	cpc	r25, r1
    5e68:	19 f1       	breq	.+70     	; 0x5eb0 <Timer_Init+0x1a6>
    5e6a:	2d 85       	ldd	r18, Y+13	; 0x0d
    5e6c:	3e 85       	ldd	r19, Y+14	; 0x0e
    5e6e:	22 30       	cpi	r18, 0x02	; 2
    5e70:	31 05       	cpc	r19, r1
    5e72:	11 f1       	breq	.+68     	; 0x5eb8 <Timer_Init+0x1ae>
    5e74:	8d 85       	ldd	r24, Y+13	; 0x0d
    5e76:	9e 85       	ldd	r25, Y+14	; 0x0e
    5e78:	00 97       	sbiw	r24, 0x00	; 0
    5e7a:	11 f5       	brne	.+68     	; 0x5ec0 <Timer_Init+0x1b6>
			{
			case TIMER_MODE:
				if (gau8_Timer1Prescaler[Timer_cfg->Timer_Prescaler] == FALSE)
    5e7c:	ea 81       	ldd	r30, Y+2	; 0x02
    5e7e:	fb 81       	ldd	r31, Y+3	; 0x03
    5e80:	82 81       	ldd	r24, Z+2	; 0x02
    5e82:	88 2f       	mov	r24, r24
    5e84:	90 e0       	ldi	r25, 0x00	; 0
    5e86:	fc 01       	movw	r30, r24
    5e88:	e2 51       	subi	r30, 0x12	; 18
    5e8a:	ff 4f       	sbci	r31, 0xFF	; 255
    5e8c:	80 81       	ld	r24, Z
    5e8e:	88 23       	and	r24, r24
    5e90:	19 f4       	brne	.+6      	; 0x5e98 <Timer_Init+0x18e>
				{
					/*
					 *  Wrong Timer1 Prescaler
					 */
					s8_ErrorStatus = TIMER_BASE_ERROR + ERR_INVALID_ARGU;
    5e92:	81 ee       	ldi	r24, 0xE1	; 225
    5e94:	89 83       	std	Y+1, r24	; 0x01
    5e96:	16 c0       	rjmp	.+44     	; 0x5ec4 <Timer_Init+0x1ba>
				}
				else
				{
					gu8_TimerPrescaler[TIMER_CH1] =
    5e98:	ea 81       	ldd	r30, Y+2	; 0x02
    5e9a:	fb 81       	ldd	r31, Y+3	; 0x03
    5e9c:	82 81       	ldd	r24, Z+2	; 0x02
    5e9e:	88 2f       	mov	r24, r24
    5ea0:	90 e0       	ldi	r25, 0x00	; 0
    5ea2:	fc 01       	movw	r30, r24
    5ea4:	e2 51       	subi	r30, 0x12	; 18
    5ea6:	ff 4f       	sbci	r31, 0xFF	; 255
    5ea8:	80 81       	ld	r24, Z
    5eaa:	80 93 d2 07 	sts	0x07D2, r24
    5eae:	0a c0       	rjmp	.+20     	; 0x5ec4 <Timer_Init+0x1ba>
							gau8_Timer1Prescaler[Timer_cfg->Timer_Prescaler];
				}
				break;
			case COUNTER_RISING_MODE:
				gu8_TimerPrescaler[TIMER_CH1] = COUNTER_RISING;
    5eb0:	86 e0       	ldi	r24, 0x06	; 6
    5eb2:	80 93 d2 07 	sts	0x07D2, r24
    5eb6:	06 c0       	rjmp	.+12     	; 0x5ec4 <Timer_Init+0x1ba>
				break;
			case COUNTER_FALLING_MODE:
				gu8_TimerPrescaler[TIMER_CH1] = COUNTER_FALLING;
    5eb8:	87 e0       	ldi	r24, 0x07	; 7
    5eba:	80 93 d2 07 	sts	0x07D2, r24
    5ebe:	02 c0       	rjmp	.+4      	; 0x5ec4 <Timer_Init+0x1ba>
				break;
			default:
				/*
				 *  Wrong Timer1 mode
				 */
				s8_ErrorStatus = TIMER_BASE_ERROR + ERR_INVALID_ARGU;
    5ec0:	81 ee       	ldi	r24, 0xE1	; 225
    5ec2:	89 83       	std	Y+1, r24	; 0x01
				break;
			}
			/*
			 * check on Timer1 Interrupt
			 */
			switch (Timer_cfg->Timer_Polling_Or_Interrupt)
    5ec4:	ea 81       	ldd	r30, Y+2	; 0x02
    5ec6:	fb 81       	ldd	r31, Y+3	; 0x03
    5ec8:	83 81       	ldd	r24, Z+3	; 0x03
    5eca:	28 2f       	mov	r18, r24
    5ecc:	30 e0       	ldi	r19, 0x00	; 0
    5ece:	3c 87       	std	Y+12, r19	; 0x0c
    5ed0:	2b 87       	std	Y+11, r18	; 0x0b
    5ed2:	8b 85       	ldd	r24, Y+11	; 0x0b
    5ed4:	9c 85       	ldd	r25, Y+12	; 0x0c
    5ed6:	00 97       	sbiw	r24, 0x00	; 0
    5ed8:	31 f0       	breq	.+12     	; 0x5ee6 <Timer_Init+0x1dc>
    5eda:	2b 85       	ldd	r18, Y+11	; 0x0b
    5edc:	3c 85       	ldd	r19, Y+12	; 0x0c
    5ede:	21 30       	cpi	r18, 0x01	; 1
    5ee0:	31 05       	cpc	r19, r1
    5ee2:	41 f0       	breq	.+16     	; 0x5ef4 <Timer_Init+0x1ea>
    5ee4:	17 c0       	rjmp	.+46     	; 0x5f14 <Timer_Init+0x20a>
			{
			case TIMER_POLLING_MODE:
				TIMSK |= T1_POLLING;
    5ee6:	e9 e5       	ldi	r30, 0x59	; 89
    5ee8:	f0 e0       	ldi	r31, 0x00	; 0
    5eea:	a9 e5       	ldi	r26, 0x59	; 89
    5eec:	b0 e0       	ldi	r27, 0x00	; 0
    5eee:	8c 91       	ld	r24, X
    5ef0:	80 83       	st	Z, r24
    5ef2:	12 c0       	rjmp	.+36     	; 0x5f18 <Timer_Init+0x20e>
				break;
			case TIMER_INTERRUPT_MODE:
				TIMSK |= T1_INTERRUPT_NORMAL;
    5ef4:	a9 e5       	ldi	r26, 0x59	; 89
    5ef6:	b0 e0       	ldi	r27, 0x00	; 0
    5ef8:	e9 e5       	ldi	r30, 0x59	; 89
    5efa:	f0 e0       	ldi	r31, 0x00	; 0
    5efc:	80 81       	ld	r24, Z
    5efe:	84 60       	ori	r24, 0x04	; 4
    5f00:	8c 93       	st	X, r24
				Timer_OV_Cbk_ptr[TIMER_CH1] = Timer_cfg->Timer_Cbk_ptr;
    5f02:	ea 81       	ldd	r30, Y+2	; 0x02
    5f04:	fb 81       	ldd	r31, Y+3	; 0x03
    5f06:	84 81       	ldd	r24, Z+4	; 0x04
    5f08:	95 81       	ldd	r25, Z+5	; 0x05
    5f0a:	90 93 e0 07 	sts	0x07E0, r25
    5f0e:	80 93 df 07 	sts	0x07DF, r24
    5f12:	02 c0       	rjmp	.+4      	; 0x5f18 <Timer_Init+0x20e>
				break;
			default:
				/*
				 *  Wrong Timer1 Interrupt
				 */
				s8_ErrorStatus = TIMER_BASE_ERROR + ERR_INVALID_ARGU;
    5f14:	81 ee       	ldi	r24, 0xE1	; 225
    5f16:	89 83       	std	Y+1, r24	; 0x01
				break;
			}
			/*
			 * set Timer1 control register
			 */
			if (s8_ErrorStatus == TIMER_BASE_ERROR + ERR_SUCCESS)
    5f18:	89 81       	ldd	r24, Y+1	; 0x01
    5f1a:	82 3e       	cpi	r24, 0xE2	; 226
    5f1c:	09 f0       	breq	.+2      	; 0x5f20 <Timer_Init+0x216>
    5f1e:	85 c0       	rjmp	.+266    	; 0x602a <Timer_Init+0x320>
			{
				/*
				 * clear timer TCCR1
				 */
				TCCR1 &= LOW;
    5f20:	ee e4       	ldi	r30, 0x4E	; 78
    5f22:	f0 e0       	ldi	r31, 0x00	; 0
    5f24:	80 81       	ld	r24, Z
    5f26:	91 81       	ldd	r25, Z+1	; 0x01
    5f28:	ee e4       	ldi	r30, 0x4E	; 78
    5f2a:	f0 e0       	ldi	r31, 0x00	; 0
    5f2c:	11 82       	std	Z+1, r1	; 0x01
    5f2e:	10 82       	st	Z, r1
				/*
				 * set Timer1 mode
				 */
				TCCR1 |= (T1_NORMAL_MODE | T1_OC1_DIS);
    5f30:	ae e4       	ldi	r26, 0x4E	; 78
    5f32:	b0 e0       	ldi	r27, 0x00	; 0
    5f34:	ee e4       	ldi	r30, 0x4E	; 78
    5f36:	f0 e0       	ldi	r31, 0x00	; 0
    5f38:	80 81       	ld	r24, Z
    5f3a:	91 81       	ldd	r25, Z+1	; 0x01
    5f3c:	11 96       	adiw	r26, 0x01	; 1
    5f3e:	9c 93       	st	X, r25
    5f40:	8e 93       	st	-X, r24
				/*
				 * set timer1 status
				 */
				gau8_TimerStatus[TIMER_CH1] = TIMER_INTIALIZED;
    5f42:	81 e0       	ldi	r24, 0x01	; 1
    5f44:	80 93 d5 07 	sts	0x07D5, r24
    5f48:	70 c0       	rjmp	.+224    	; 0x602a <Timer_Init+0x320>
			break;
		case TIMER_CH2:
			/*
			 * check on Timer2 mode
			 */
			switch (Timer_cfg->Timer_Mode)
    5f4a:	ea 81       	ldd	r30, Y+2	; 0x02
    5f4c:	fb 81       	ldd	r31, Y+3	; 0x03
    5f4e:	81 81       	ldd	r24, Z+1	; 0x01
    5f50:	28 2f       	mov	r18, r24
    5f52:	30 e0       	ldi	r19, 0x00	; 0
    5f54:	38 87       	std	Y+8, r19	; 0x08
    5f56:	2f 83       	std	Y+7, r18	; 0x07
    5f58:	8f 81       	ldd	r24, Y+7	; 0x07
    5f5a:	98 85       	ldd	r25, Y+8	; 0x08
    5f5c:	81 30       	cpi	r24, 0x01	; 1
    5f5e:	91 05       	cpc	r25, r1
    5f60:	29 f1       	breq	.+74     	; 0x5fac <Timer_Init+0x2a2>
    5f62:	2f 81       	ldd	r18, Y+7	; 0x07
    5f64:	38 85       	ldd	r19, Y+8	; 0x08
    5f66:	22 30       	cpi	r18, 0x02	; 2
    5f68:	31 05       	cpc	r19, r1
    5f6a:	01 f1       	breq	.+64     	; 0x5fac <Timer_Init+0x2a2>
    5f6c:	8f 81       	ldd	r24, Y+7	; 0x07
    5f6e:	98 85       	ldd	r25, Y+8	; 0x08
    5f70:	00 97       	sbiw	r24, 0x00	; 0
    5f72:	d1 f4       	brne	.+52     	; 0x5fa8 <Timer_Init+0x29e>
			{
			case TIMER_MODE:
				if (gau8_Timer2Prescaler[Timer_cfg->Timer_Prescaler] == FALSE)
    5f74:	ea 81       	ldd	r30, Y+2	; 0x02
    5f76:	fb 81       	ldd	r31, Y+3	; 0x03
    5f78:	82 81       	ldd	r24, Z+2	; 0x02
    5f7a:	88 2f       	mov	r24, r24
    5f7c:	90 e0       	ldi	r25, 0x00	; 0
    5f7e:	fc 01       	movw	r30, r24
    5f80:	ea 50       	subi	r30, 0x0A	; 10
    5f82:	ff 4f       	sbci	r31, 0xFF	; 255
    5f84:	80 81       	ld	r24, Z
    5f86:	88 23       	and	r24, r24
    5f88:	19 f4       	brne	.+6      	; 0x5f90 <Timer_Init+0x286>
				{
					/*
					 *  Wrong Timer2 Prescaler
					 */
					s8_ErrorStatus = TIMER_BASE_ERROR + ERR_INVALID_ARGU;
    5f8a:	81 ee       	ldi	r24, 0xE1	; 225
    5f8c:	89 83       	std	Y+1, r24	; 0x01
    5f8e:	0e c0       	rjmp	.+28     	; 0x5fac <Timer_Init+0x2a2>
				}
				else
				{
					gu8_TimerPrescaler[TIMER_CH2] =
    5f90:	ea 81       	ldd	r30, Y+2	; 0x02
    5f92:	fb 81       	ldd	r31, Y+3	; 0x03
    5f94:	82 81       	ldd	r24, Z+2	; 0x02
    5f96:	88 2f       	mov	r24, r24
    5f98:	90 e0       	ldi	r25, 0x00	; 0
    5f9a:	fc 01       	movw	r30, r24
    5f9c:	ea 50       	subi	r30, 0x0A	; 10
    5f9e:	ff 4f       	sbci	r31, 0xFF	; 255
    5fa0:	80 81       	ld	r24, Z
    5fa2:	80 93 d3 07 	sts	0x07D3, r24
    5fa6:	02 c0       	rjmp	.+4      	; 0x5fac <Timer_Init+0x2a2>
				break;
			default:
				/*
				 *  Wrong Timer2 mode
				 */
				s8_ErrorStatus = TIMER_BASE_ERROR + ERR_INVALID_ARGU;
    5fa8:	81 ee       	ldi	r24, 0xE1	; 225
    5faa:	89 83       	std	Y+1, r24	; 0x01
				break;
			}
			/*
			 * check on Timer2 Interrupt
			 */
			switch (Timer_cfg->Timer_Polling_Or_Interrupt)
    5fac:	ea 81       	ldd	r30, Y+2	; 0x02
    5fae:	fb 81       	ldd	r31, Y+3	; 0x03
    5fb0:	83 81       	ldd	r24, Z+3	; 0x03
    5fb2:	28 2f       	mov	r18, r24
    5fb4:	30 e0       	ldi	r19, 0x00	; 0
    5fb6:	3e 83       	std	Y+6, r19	; 0x06
    5fb8:	2d 83       	std	Y+5, r18	; 0x05
    5fba:	8d 81       	ldd	r24, Y+5	; 0x05
    5fbc:	9e 81       	ldd	r25, Y+6	; 0x06
    5fbe:	00 97       	sbiw	r24, 0x00	; 0
    5fc0:	31 f0       	breq	.+12     	; 0x5fce <Timer_Init+0x2c4>
    5fc2:	2d 81       	ldd	r18, Y+5	; 0x05
    5fc4:	3e 81       	ldd	r19, Y+6	; 0x06
    5fc6:	21 30       	cpi	r18, 0x01	; 1
    5fc8:	31 05       	cpc	r19, r1
    5fca:	41 f0       	breq	.+16     	; 0x5fdc <Timer_Init+0x2d2>
    5fcc:	17 c0       	rjmp	.+46     	; 0x5ffc <Timer_Init+0x2f2>
			{
			case TIMER_POLLING_MODE:
				TIMSK |= T2_POLLING;
    5fce:	e9 e5       	ldi	r30, 0x59	; 89
    5fd0:	f0 e0       	ldi	r31, 0x00	; 0
    5fd2:	a9 e5       	ldi	r26, 0x59	; 89
    5fd4:	b0 e0       	ldi	r27, 0x00	; 0
    5fd6:	8c 91       	ld	r24, X
    5fd8:	80 83       	st	Z, r24
    5fda:	12 c0       	rjmp	.+36     	; 0x6000 <Timer_Init+0x2f6>
				break;
			case TIMER_INTERRUPT_MODE:
				TIMSK |= T2_INTERRUPT_NORMAL;
    5fdc:	a9 e5       	ldi	r26, 0x59	; 89
    5fde:	b0 e0       	ldi	r27, 0x00	; 0
    5fe0:	e9 e5       	ldi	r30, 0x59	; 89
    5fe2:	f0 e0       	ldi	r31, 0x00	; 0
    5fe4:	80 81       	ld	r24, Z
    5fe6:	80 64       	ori	r24, 0x40	; 64
    5fe8:	8c 93       	st	X, r24
				Timer_OV_Cbk_ptr[TIMER_CH2] = Timer_cfg->Timer_Cbk_ptr;
    5fea:	ea 81       	ldd	r30, Y+2	; 0x02
    5fec:	fb 81       	ldd	r31, Y+3	; 0x03
    5fee:	84 81       	ldd	r24, Z+4	; 0x04
    5ff0:	95 81       	ldd	r25, Z+5	; 0x05
    5ff2:	90 93 e2 07 	sts	0x07E2, r25
    5ff6:	80 93 e1 07 	sts	0x07E1, r24
    5ffa:	02 c0       	rjmp	.+4      	; 0x6000 <Timer_Init+0x2f6>
				break;
			default:
				/*
				 *  Wrong Timer2 Interrupt
				 */
				s8_ErrorStatus = TIMER_BASE_ERROR + ERR_INVALID_ARGU;
    5ffc:	81 ee       	ldi	r24, 0xE1	; 225
    5ffe:	89 83       	std	Y+1, r24	; 0x01
				break;
			}
			/*
			 * set Timer2 control register
			 */
			if (s8_ErrorStatus == TIMER_BASE_ERROR + ERR_SUCCESS)
    6000:	89 81       	ldd	r24, Y+1	; 0x01
    6002:	82 3e       	cpi	r24, 0xE2	; 226
    6004:	91 f4       	brne	.+36     	; 0x602a <Timer_Init+0x320>
			{
				/*
				 * clear Timer2 TCCR0
				 */
				TCCR2 &= LOW;
    6006:	e5 e4       	ldi	r30, 0x45	; 69
    6008:	f0 e0       	ldi	r31, 0x00	; 0
    600a:	30 81       	ld	r19, Z
    600c:	e5 e4       	ldi	r30, 0x45	; 69
    600e:	f0 e0       	ldi	r31, 0x00	; 0
    6010:	10 82       	st	Z, r1
				/*
				 * set Timer2 mode
				 */
				TCCR2 |= (T2_NORMAL_MODE | T2_OC0_DIS);
    6012:	a5 e4       	ldi	r26, 0x45	; 69
    6014:	b0 e0       	ldi	r27, 0x00	; 0
    6016:	e5 e4       	ldi	r30, 0x45	; 69
    6018:	f0 e0       	ldi	r31, 0x00	; 0
    601a:	80 81       	ld	r24, Z
    601c:	8c 93       	st	X, r24
				/*
				 * set timer status
				 */
				gau8_TimerStatus[TIMER_CH2] = TIMER_INTIALIZED;
    601e:	81 e0       	ldi	r24, 0x01	; 1
    6020:	80 93 d6 07 	sts	0x07D6, r24
    6024:	02 c0       	rjmp	.+4      	; 0x602a <Timer_Init+0x320>
			break;
		default:
			/*
			 *  Wrong Timer channel
			 */
			s8_ErrorStatus = TIMER_BASE_ERROR + ERR_INVALID_ARGU;
    6026:	81 ee       	ldi	r24, 0xE1	; 225
    6028:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	/*
	 * Function shall return the Error state
	 */
	return s8_ErrorStatus;
    602a:	89 81       	ldd	r24, Y+1	; 0x01
}
    602c:	65 96       	adiw	r28, 0x15	; 21
    602e:	0f b6       	in	r0, 0x3f	; 63
    6030:	f8 94       	cli
    6032:	de bf       	out	0x3e, r29	; 62
    6034:	0f be       	out	0x3f, r0	; 63
    6036:	cd bf       	out	0x3d, r28	; 61
    6038:	cf 91       	pop	r28
    603a:	df 91       	pop	r29
    603c:	08 95       	ret

0000603e <Timer_Start>:
 * Return: The error status of the function.
 * Description: This function strats the needed timer.
 *
 */
ERROR_STATUS Timer_Start(uint8 Timer_CH_NO, uint16 Timer_Count)
{
    603e:	df 93       	push	r29
    6040:	cf 93       	push	r28
    6042:	00 d0       	rcall	.+0      	; 0x6044 <Timer_Start+0x6>
    6044:	00 d0       	rcall	.+0      	; 0x6046 <Timer_Start+0x8>
    6046:	00 d0       	rcall	.+0      	; 0x6048 <Timer_Start+0xa>
    6048:	cd b7       	in	r28, 0x3d	; 61
    604a:	de b7       	in	r29, 0x3e	; 62
    604c:	8a 83       	std	Y+2, r24	; 0x02
    604e:	7c 83       	std	Y+4, r23	; 0x04
    6050:	6b 83       	std	Y+3, r22	; 0x03
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = TIMER_BASE_ERROR + ERR_SUCCESS;
    6052:	82 ee       	ldi	r24, 0xE2	; 226
    6054:	89 83       	std	Y+1, r24	; 0x01

	/*
	 * check on Timer channel
	 */
	switch (Timer_CH_NO)
    6056:	8a 81       	ldd	r24, Y+2	; 0x02
    6058:	28 2f       	mov	r18, r24
    605a:	30 e0       	ldi	r19, 0x00	; 0
    605c:	3e 83       	std	Y+6, r19	; 0x06
    605e:	2d 83       	std	Y+5, r18	; 0x05
    6060:	8d 81       	ldd	r24, Y+5	; 0x05
    6062:	9e 81       	ldd	r25, Y+6	; 0x06
    6064:	81 30       	cpi	r24, 0x01	; 1
    6066:	91 05       	cpc	r25, r1
    6068:	e9 f1       	breq	.+122    	; 0x60e4 <Timer_Start+0xa6>
    606a:	2d 81       	ldd	r18, Y+5	; 0x05
    606c:	3e 81       	ldd	r19, Y+6	; 0x06
    606e:	22 30       	cpi	r18, 0x02	; 2
    6070:	31 05       	cpc	r19, r1
    6072:	09 f4       	brne	.+2      	; 0x6076 <Timer_Start+0x38>
    6074:	66 c0       	rjmp	.+204    	; 0x6142 <Timer_Start+0x104>
    6076:	8d 81       	ldd	r24, Y+5	; 0x05
    6078:	9e 81       	ldd	r25, Y+6	; 0x06
    607a:	00 97       	sbiw	r24, 0x00	; 0
    607c:	09 f0       	breq	.+2      	; 0x6080 <Timer_Start+0x42>
    607e:	93 c0       	rjmp	.+294    	; 0x61a6 <Timer_Start+0x168>
	{
	case TIMER_CH0:
		if (Timer_Count > TIMER0_MAX)
    6080:	8b 81       	ldd	r24, Y+3	; 0x03
    6082:	9c 81       	ldd	r25, Y+4	; 0x04
    6084:	21 e0       	ldi	r18, 0x01	; 1
    6086:	81 30       	cpi	r24, 0x01	; 1
    6088:	92 07       	cpc	r25, r18
    608a:	18 f0       	brcs	.+6      	; 0x6092 <Timer_Start+0x54>
		{
			/*
			 *  Wrong Timer counts
			 */
			s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NOT_SUPPORTED;
    608c:	8a ed       	ldi	r24, 0xDA	; 218
    608e:	89 83       	std	Y+1, r24	; 0x01
    6090:	8c c0       	rjmp	.+280    	; 0x61aa <Timer_Start+0x16c>
		}
		else if (gau8_TimerStatus[TIMER_CH0] == TIMER_UNINTIALIZED)
    6092:	80 91 d4 07 	lds	r24, 0x07D4
    6096:	88 23       	and	r24, r24
    6098:	19 f4       	brne	.+6      	; 0x60a0 <Timer_Start+0x62>
		{
			/*
			 *  Wrong Timer status
			 */
			s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NOT_INITIALIZED;
    609a:	80 ee       	ldi	r24, 0xE0	; 224
    609c:	89 83       	std	Y+1, r24	; 0x01
    609e:	85 c0       	rjmp	.+266    	; 0x61aa <Timer_Start+0x16c>
		else
		{
			/*
			 * set timer0 register initial value
			 */
			gau16_TimerPreload[TIMER_CH0] = TIMER0_MAX - (uint8) Timer_Count;
    60a0:	8b 81       	ldd	r24, Y+3	; 0x03
    60a2:	28 2f       	mov	r18, r24
    60a4:	30 e0       	ldi	r19, 0x00	; 0
    60a6:	80 e0       	ldi	r24, 0x00	; 0
    60a8:	91 e0       	ldi	r25, 0x01	; 1
    60aa:	82 1b       	sub	r24, r18
    60ac:	93 0b       	sbc	r25, r19
    60ae:	90 93 d8 07 	sts	0x07D8, r25
    60b2:	80 93 d7 07 	sts	0x07D7, r24
			TCNT0 = (uint8) gau16_TimerPreload[TIMER_CH0];
    60b6:	e2 e5       	ldi	r30, 0x52	; 82
    60b8:	f0 e0       	ldi	r31, 0x00	; 0
    60ba:	80 91 d7 07 	lds	r24, 0x07D7
    60be:	90 91 d8 07 	lds	r25, 0x07D8
    60c2:	80 83       	st	Z, r24
			/*
			 *  start T0 with prescaler
			 */
			ASSIGN_BIT(TCCR0, TIMER_PRESCALER_MASK,
    60c4:	a3 e5       	ldi	r26, 0x53	; 83
    60c6:	b0 e0       	ldi	r27, 0x00	; 0
    60c8:	e3 e5       	ldi	r30, 0x53	; 83
    60ca:	f0 e0       	ldi	r31, 0x00	; 0
    60cc:	80 81       	ld	r24, Z
    60ce:	98 2f       	mov	r25, r24
    60d0:	98 7f       	andi	r25, 0xF8	; 248
    60d2:	80 91 d1 07 	lds	r24, 0x07D1
    60d6:	87 70       	andi	r24, 0x07	; 7
    60d8:	89 2b       	or	r24, r25
    60da:	8c 93       	st	X, r24
					gu8_TimerPrescaler[TIMER_CH0]);
			/*
			 * set timer status
			 */
			gau8_TimerStatus[TIMER_CH0] = TIMER_RUNNING;
    60dc:	82 e0       	ldi	r24, 0x02	; 2
    60de:	80 93 d4 07 	sts	0x07D4, r24
    60e2:	63 c0       	rjmp	.+198    	; 0x61aa <Timer_Start+0x16c>
			/*
			 *  Wrong Timer1 counts
			 */
			s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NOT_SUPPORTED;
		}
		else if (gau8_TimerStatus[TIMER_CH1] == TIMER_UNINTIALIZED)
    60e4:	80 91 d5 07 	lds	r24, 0x07D5
    60e8:	88 23       	and	r24, r24
    60ea:	19 f4       	brne	.+6      	; 0x60f2 <Timer_Start+0xb4>
		{
			/*
			 *  Wrong Timer1 status
			 */
			s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NOT_INITIALIZED;
    60ec:	80 ee       	ldi	r24, 0xE0	; 224
    60ee:	89 83       	std	Y+1, r24	; 0x01
    60f0:	5c c0       	rjmp	.+184    	; 0x61aa <Timer_Start+0x16c>
		else
		{
			/*
			 * set timer1 register initial value
			 */
			gau16_TimerPreload[TIMER_CH1] = TIMER1_MAX - Timer_Count;
    60f2:	8b 81       	ldd	r24, Y+3	; 0x03
    60f4:	9c 81       	ldd	r25, Y+4	; 0x04
    60f6:	90 95       	com	r25
    60f8:	81 95       	neg	r24
    60fa:	9f 4f       	sbci	r25, 0xFF	; 255
    60fc:	90 93 da 07 	sts	0x07DA, r25
    6100:	80 93 d9 07 	sts	0x07D9, r24
			TCNT1 = gau16_TimerPreload[TIMER_CH1];
    6104:	ec e4       	ldi	r30, 0x4C	; 76
    6106:	f0 e0       	ldi	r31, 0x00	; 0
    6108:	80 91 d9 07 	lds	r24, 0x07D9
    610c:	90 91 da 07 	lds	r25, 0x07DA
    6110:	91 83       	std	Z+1, r25	; 0x01
    6112:	80 83       	st	Z, r24
			/*
			 *  start Timer1 with prescaler
			 */
			ASSIGN_BIT(TCCR1, TIMER_PRESCALER_MASK,
    6114:	ae e4       	ldi	r26, 0x4E	; 78
    6116:	b0 e0       	ldi	r27, 0x00	; 0
    6118:	ee e4       	ldi	r30, 0x4E	; 78
    611a:	f0 e0       	ldi	r31, 0x00	; 0
    611c:	80 81       	ld	r24, Z
    611e:	91 81       	ldd	r25, Z+1	; 0x01
    6120:	9c 01       	movw	r18, r24
    6122:	28 7f       	andi	r18, 0xF8	; 248
    6124:	80 91 d2 07 	lds	r24, 0x07D2
    6128:	88 2f       	mov	r24, r24
    612a:	90 e0       	ldi	r25, 0x00	; 0
    612c:	87 70       	andi	r24, 0x07	; 7
    612e:	90 70       	andi	r25, 0x00	; 0
    6130:	82 2b       	or	r24, r18
    6132:	93 2b       	or	r25, r19
    6134:	11 96       	adiw	r26, 0x01	; 1
    6136:	9c 93       	st	X, r25
    6138:	8e 93       	st	-X, r24
					(uint16) gu8_TimerPrescaler[TIMER_CH1]);
			/*
			 * set Timer1 status
			 */
			gau8_TimerStatus[TIMER_CH1] = TIMER_RUNNING;
    613a:	82 e0       	ldi	r24, 0x02	; 2
    613c:	80 93 d5 07 	sts	0x07D5, r24
    6140:	34 c0       	rjmp	.+104    	; 0x61aa <Timer_Start+0x16c>
		}
		break;
	case TIMER_CH2:
		if (Timer_Count > TIMER2_MAX)
    6142:	8b 81       	ldd	r24, Y+3	; 0x03
    6144:	9c 81       	ldd	r25, Y+4	; 0x04
    6146:	31 e0       	ldi	r19, 0x01	; 1
    6148:	81 30       	cpi	r24, 0x01	; 1
    614a:	93 07       	cpc	r25, r19
    614c:	18 f0       	brcs	.+6      	; 0x6154 <Timer_Start+0x116>
		{
			/*
			 *  Wrong Timer2 counts
			 */
			s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NOT_SUPPORTED;
    614e:	8a ed       	ldi	r24, 0xDA	; 218
    6150:	89 83       	std	Y+1, r24	; 0x01
    6152:	2b c0       	rjmp	.+86     	; 0x61aa <Timer_Start+0x16c>
		}
		else if (gau8_TimerStatus[TIMER_CH2] == TIMER_UNINTIALIZED)
    6154:	80 91 d6 07 	lds	r24, 0x07D6
    6158:	88 23       	and	r24, r24
    615a:	19 f4       	brne	.+6      	; 0x6162 <Timer_Start+0x124>
		{
			/*
			 *  Wrong Timer2 status
			 */
			s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NOT_INITIALIZED;
    615c:	80 ee       	ldi	r24, 0xE0	; 224
    615e:	89 83       	std	Y+1, r24	; 0x01
    6160:	24 c0       	rjmp	.+72     	; 0x61aa <Timer_Start+0x16c>
		else
		{
			/*
			 * set timer2 register initial value
			 */
			gau16_TimerPreload[TIMER_CH2] = TIMER2_MAX - (uint8) Timer_Count;
    6162:	8b 81       	ldd	r24, Y+3	; 0x03
    6164:	28 2f       	mov	r18, r24
    6166:	30 e0       	ldi	r19, 0x00	; 0
    6168:	80 e0       	ldi	r24, 0x00	; 0
    616a:	91 e0       	ldi	r25, 0x01	; 1
    616c:	82 1b       	sub	r24, r18
    616e:	93 0b       	sbc	r25, r19
    6170:	90 93 dc 07 	sts	0x07DC, r25
    6174:	80 93 db 07 	sts	0x07DB, r24
			TCNT2 = (uint8) gau16_TimerPreload[TIMER_CH2];
    6178:	e4 e4       	ldi	r30, 0x44	; 68
    617a:	f0 e0       	ldi	r31, 0x00	; 0
    617c:	80 91 db 07 	lds	r24, 0x07DB
    6180:	90 91 dc 07 	lds	r25, 0x07DC
    6184:	80 83       	st	Z, r24
			/*
			 *  start Timer2 with prescaler
			 */
			ASSIGN_BIT(TCCR2, TIMER_PRESCALER_MASK,
    6186:	a5 e4       	ldi	r26, 0x45	; 69
    6188:	b0 e0       	ldi	r27, 0x00	; 0
    618a:	e5 e4       	ldi	r30, 0x45	; 69
    618c:	f0 e0       	ldi	r31, 0x00	; 0
    618e:	80 81       	ld	r24, Z
    6190:	98 2f       	mov	r25, r24
    6192:	98 7f       	andi	r25, 0xF8	; 248
    6194:	80 91 d3 07 	lds	r24, 0x07D3
    6198:	87 70       	andi	r24, 0x07	; 7
    619a:	89 2b       	or	r24, r25
    619c:	8c 93       	st	X, r24
					gu8_TimerPrescaler[TIMER_CH2]);
			/*
			 * set Timer2 status
			 */
			gau8_TimerStatus[TIMER_CH2] = TIMER_RUNNING;
    619e:	82 e0       	ldi	r24, 0x02	; 2
    61a0:	80 93 d6 07 	sts	0x07D6, r24
    61a4:	02 c0       	rjmp	.+4      	; 0x61aa <Timer_Start+0x16c>
		break;
	default:
		/*
		 *  Wrong Timer channel
		 */
		s8_ErrorStatus = TIMER_BASE_ERROR + ERR_INVALID_ARGU;
    61a6:	81 ee       	ldi	r24, 0xE1	; 225
    61a8:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	/*
	 * Function shall return the Error state
	 */
	return s8_ErrorStatus;
    61aa:	89 81       	ldd	r24, Y+1	; 0x01
}
    61ac:	26 96       	adiw	r28, 0x06	; 6
    61ae:	0f b6       	in	r0, 0x3f	; 63
    61b0:	f8 94       	cli
    61b2:	de bf       	out	0x3e, r29	; 62
    61b4:	0f be       	out	0x3f, r0	; 63
    61b6:	cd bf       	out	0x3d, r28	; 61
    61b8:	cf 91       	pop	r28
    61ba:	df 91       	pop	r29
    61bc:	08 95       	ret

000061be <Timer_Stop>:
 * Return: The error status of the function.
 * Description: This function stops the needed timer.
 *
 */
ERROR_STATUS Timer_Stop(uint8 Timer_CH_NO)
{
    61be:	df 93       	push	r29
    61c0:	cf 93       	push	r28
    61c2:	00 d0       	rcall	.+0      	; 0x61c4 <Timer_Stop+0x6>
    61c4:	00 d0       	rcall	.+0      	; 0x61c6 <Timer_Stop+0x8>
    61c6:	cd b7       	in	r28, 0x3d	; 61
    61c8:	de b7       	in	r29, 0x3e	; 62
    61ca:	8a 83       	std	Y+2, r24	; 0x02
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = TIMER_BASE_ERROR + ERR_SUCCESS;
    61cc:	82 ee       	ldi	r24, 0xE2	; 226
    61ce:	89 83       	std	Y+1, r24	; 0x01

	/*
	 * check on Timer channel
	 */
	switch (Timer_CH_NO)
    61d0:	8a 81       	ldd	r24, Y+2	; 0x02
    61d2:	28 2f       	mov	r18, r24
    61d4:	30 e0       	ldi	r19, 0x00	; 0
    61d6:	3c 83       	std	Y+4, r19	; 0x04
    61d8:	2b 83       	std	Y+3, r18	; 0x03
    61da:	8b 81       	ldd	r24, Y+3	; 0x03
    61dc:	9c 81       	ldd	r25, Y+4	; 0x04
    61de:	81 30       	cpi	r24, 0x01	; 1
    61e0:	91 05       	cpc	r25, r1
    61e2:	d9 f0       	breq	.+54     	; 0x621a <Timer_Stop+0x5c>
    61e4:	2b 81       	ldd	r18, Y+3	; 0x03
    61e6:	3c 81       	ldd	r19, Y+4	; 0x04
    61e8:	22 30       	cpi	r18, 0x02	; 2
    61ea:	31 05       	cpc	r19, r1
    61ec:	59 f1       	breq	.+86     	; 0x6244 <Timer_Stop+0x86>
    61ee:	8b 81       	ldd	r24, Y+3	; 0x03
    61f0:	9c 81       	ldd	r25, Y+4	; 0x04
    61f2:	00 97       	sbiw	r24, 0x00	; 0
    61f4:	c9 f5       	brne	.+114    	; 0x6268 <Timer_Stop+0xaa>
	{
	case TIMER_CH0:
		if (gau8_TimerStatus[TIMER_CH0] != TIMER_RUNNING)
    61f6:	80 91 d4 07 	lds	r24, 0x07D4
    61fa:	82 30       	cpi	r24, 0x02	; 2
    61fc:	19 f0       	breq	.+6      	; 0x6204 <Timer_Stop+0x46>
		{
			/*
			 *  Wrong Timer status
			 */
			s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NOT_INITIALIZED;
    61fe:	80 ee       	ldi	r24, 0xE0	; 224
    6200:	89 83       	std	Y+1, r24	; 0x01
    6202:	34 c0       	rjmp	.+104    	; 0x626c <Timer_Stop+0xae>
		else
		{
			/*
			 *  start T0 with prescaler no clock
			 */
			ASSIGN_BIT(TCCR0, TIMER_PRESCALER_MASK, TIMER_NO_CLOCK);
    6204:	a3 e5       	ldi	r26, 0x53	; 83
    6206:	b0 e0       	ldi	r27, 0x00	; 0
    6208:	e3 e5       	ldi	r30, 0x53	; 83
    620a:	f0 e0       	ldi	r31, 0x00	; 0
    620c:	80 81       	ld	r24, Z
    620e:	88 7f       	andi	r24, 0xF8	; 248
    6210:	8c 93       	st	X, r24
			/*
			 * set timer status
			 */
			gau8_TimerStatus[TIMER_CH0] = TIMER_INTIALIZED;
    6212:	81 e0       	ldi	r24, 0x01	; 1
    6214:	80 93 d4 07 	sts	0x07D4, r24
    6218:	29 c0       	rjmp	.+82     	; 0x626c <Timer_Stop+0xae>
		}
		break;
	case TIMER_CH1:
		if (gau8_TimerStatus[TIMER_CH1] != TIMER_RUNNING)
    621a:	80 91 d5 07 	lds	r24, 0x07D5
    621e:	82 30       	cpi	r24, 0x02	; 2
    6220:	19 f0       	breq	.+6      	; 0x6228 <Timer_Stop+0x6a>
		{
			/*
			 *  Wrong Timer1 status
			 */
			s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NOT_INITIALIZED;
    6222:	80 ee       	ldi	r24, 0xE0	; 224
    6224:	89 83       	std	Y+1, r24	; 0x01
    6226:	22 c0       	rjmp	.+68     	; 0x626c <Timer_Stop+0xae>
		else
		{
			/*
			 *  start Timer1 with prescaler no clock
			 */
			ASSIGN_BIT(TCCR1, TIMER_PRESCALER_MASK, TIMER_NO_CLOCK);
    6228:	ae e4       	ldi	r26, 0x4E	; 78
    622a:	b0 e0       	ldi	r27, 0x00	; 0
    622c:	ee e4       	ldi	r30, 0x4E	; 78
    622e:	f0 e0       	ldi	r31, 0x00	; 0
    6230:	80 81       	ld	r24, Z
    6232:	91 81       	ldd	r25, Z+1	; 0x01
    6234:	88 7f       	andi	r24, 0xF8	; 248
    6236:	11 96       	adiw	r26, 0x01	; 1
    6238:	9c 93       	st	X, r25
    623a:	8e 93       	st	-X, r24
			/*
			 * set Timer1 status
			 */
			gau8_TimerStatus[TIMER_CH1] = TIMER_INTIALIZED;
    623c:	81 e0       	ldi	r24, 0x01	; 1
    623e:	80 93 d5 07 	sts	0x07D5, r24
    6242:	14 c0       	rjmp	.+40     	; 0x626c <Timer_Stop+0xae>
		}
		break;
	case TIMER_CH2:
		if (gau8_TimerStatus[TIMER_CH2] != TIMER_RUNNING)
    6244:	80 91 d6 07 	lds	r24, 0x07D6
    6248:	82 30       	cpi	r24, 0x02	; 2
    624a:	19 f0       	breq	.+6      	; 0x6252 <Timer_Stop+0x94>
		{
			/*
			 *  Wrong Timer status
			 */
			s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NOT_INITIALIZED;
    624c:	80 ee       	ldi	r24, 0xE0	; 224
    624e:	89 83       	std	Y+1, r24	; 0x01
    6250:	0d c0       	rjmp	.+26     	; 0x626c <Timer_Stop+0xae>
		else
		{
			/*
			 *  start Timer2 with prescaler no clock
			 */
			ASSIGN_BIT(TCCR2, TIMER_PRESCALER_MASK, TIMER_NO_CLOCK);
    6252:	a5 e4       	ldi	r26, 0x45	; 69
    6254:	b0 e0       	ldi	r27, 0x00	; 0
    6256:	e5 e4       	ldi	r30, 0x45	; 69
    6258:	f0 e0       	ldi	r31, 0x00	; 0
    625a:	80 81       	ld	r24, Z
    625c:	88 7f       	andi	r24, 0xF8	; 248
    625e:	8c 93       	st	X, r24
			/*
			 * set Timer2 status
			 */
			gau8_TimerStatus[TIMER_CH2] = TIMER_INTIALIZED;
    6260:	81 e0       	ldi	r24, 0x01	; 1
    6262:	80 93 d6 07 	sts	0x07D6, r24
    6266:	02 c0       	rjmp	.+4      	; 0x626c <Timer_Stop+0xae>
		break;
	default:
		/*
		 *  Wrong Timer2 channel
		 */
		s8_ErrorStatus = TIMER_BASE_ERROR + ERR_INVALID_ARGU;
    6268:	81 ee       	ldi	r24, 0xE1	; 225
    626a:	89 83       	std	Y+1, r24	; 0x01
	}

	/*
	 * Function shall return the Error state
	 */
	return s8_ErrorStatus;
    626c:	89 81       	ldd	r24, Y+1	; 0x01
}
    626e:	0f 90       	pop	r0
    6270:	0f 90       	pop	r0
    6272:	0f 90       	pop	r0
    6274:	0f 90       	pop	r0
    6276:	cf 91       	pop	r28
    6278:	df 91       	pop	r29
    627a:	08 95       	ret

0000627c <Timer_GetStatus>:
 * Return: The error status of the function.
 * Description: This function is used to return if the flag of the timer is raised or not.
 *
 */
ERROR_STATUS Timer_GetStatus(uint8 Timer_CH_NO, bool* Data)
{
    627c:	df 93       	push	r29
    627e:	cf 93       	push	r28
    6280:	cd b7       	in	r28, 0x3d	; 61
    6282:	de b7       	in	r29, 0x3e	; 62
    6284:	2a 97       	sbiw	r28, 0x0a	; 10
    6286:	0f b6       	in	r0, 0x3f	; 63
    6288:	f8 94       	cli
    628a:	de bf       	out	0x3e, r29	; 62
    628c:	0f be       	out	0x3f, r0	; 63
    628e:	cd bf       	out	0x3d, r28	; 61
    6290:	8a 83       	std	Y+2, r24	; 0x02
    6292:	7c 83       	std	Y+4, r23	; 0x04
    6294:	6b 83       	std	Y+3, r22	; 0x03
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = TIMER_BASE_ERROR + ERR_SUCCESS;
    6296:	82 ee       	ldi	r24, 0xE2	; 226
    6298:	89 83       	std	Y+1, r24	; 0x01

	if (Data == NULL)
    629a:	8b 81       	ldd	r24, Y+3	; 0x03
    629c:	9c 81       	ldd	r25, Y+4	; 0x04
    629e:	00 97       	sbiw	r24, 0x00	; 0
    62a0:	19 f4       	brne	.+6      	; 0x62a8 <Timer_GetStatus+0x2c>
	{
		/*
		 * trying to access a null pointer
		 */
		s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NULL_PTR;
    62a2:	8e ed       	ldi	r24, 0xDE	; 222
    62a4:	89 83       	std	Y+1, r24	; 0x01
    62a6:	6f c0       	rjmp	.+222    	; 0x6386 <Timer_GetStatus+0x10a>
	else
	{
		/*
		 * check on Timer channel
		 */
		switch (Timer_CH_NO)
    62a8:	8a 81       	ldd	r24, Y+2	; 0x02
    62aa:	28 2f       	mov	r18, r24
    62ac:	30 e0       	ldi	r19, 0x00	; 0
    62ae:	3e 83       	std	Y+6, r19	; 0x06
    62b0:	2d 83       	std	Y+5, r18	; 0x05
    62b2:	8d 81       	ldd	r24, Y+5	; 0x05
    62b4:	9e 81       	ldd	r25, Y+6	; 0x06
    62b6:	81 30       	cpi	r24, 0x01	; 1
    62b8:	91 05       	cpc	r25, r1
    62ba:	c9 f0       	breq	.+50     	; 0x62ee <Timer_GetStatus+0x72>
    62bc:	2d 81       	ldd	r18, Y+5	; 0x05
    62be:	3e 81       	ldd	r19, Y+6	; 0x06
    62c0:	22 30       	cpi	r18, 0x02	; 2
    62c2:	31 05       	cpc	r19, r1
    62c4:	b9 f1       	breq	.+110    	; 0x6334 <Timer_GetStatus+0xb8>
    62c6:	8d 81       	ldd	r24, Y+5	; 0x05
    62c8:	9e 81       	ldd	r25, Y+6	; 0x06
    62ca:	00 97       	sbiw	r24, 0x00	; 0
    62cc:	09 f0       	breq	.+2      	; 0x62d0 <Timer_GetStatus+0x54>
    62ce:	59 c0       	rjmp	.+178    	; 0x6382 <Timer_GetStatus+0x106>
		{
		case TIMER_CH0:
			if (gau8_TimerStatus[TIMER_CH0] == TIMER_UNINTIALIZED)
    62d0:	80 91 d4 07 	lds	r24, 0x07D4
    62d4:	88 23       	and	r24, r24
    62d6:	19 f4       	brne	.+6      	; 0x62de <Timer_GetStatus+0x62>
			{
				/*
				 *  Wrong Timer status
				 */
				s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NOT_INITIALIZED;
    62d8:	80 ee       	ldi	r24, 0xE0	; 224
    62da:	89 83       	std	Y+1, r24	; 0x01
    62dc:	54 c0       	rjmp	.+168    	; 0x6386 <Timer_GetStatus+0x10a>
			else
			{
				/*
				 * read T0 overflow flag
				 */
				*Data = GET_BIT(TIFR, T0_INTERRUPT_NORMAL);
    62de:	e8 e5       	ldi	r30, 0x58	; 88
    62e0:	f0 e0       	ldi	r31, 0x00	; 0
    62e2:	80 81       	ld	r24, Z
    62e4:	81 70       	andi	r24, 0x01	; 1
    62e6:	eb 81       	ldd	r30, Y+3	; 0x03
    62e8:	fc 81       	ldd	r31, Y+4	; 0x04
    62ea:	80 83       	st	Z, r24
    62ec:	4c c0       	rjmp	.+152    	; 0x6386 <Timer_GetStatus+0x10a>
				 */
				/*ASSIGN_BIT(TIFR,T0_INTERRUPT_NORMAL,HIGH);*/
			}
			break;
		case TIMER_CH1:
			if (gau8_TimerStatus[TIMER_CH1] == TIMER_UNINTIALIZED)
    62ee:	80 91 d5 07 	lds	r24, 0x07D5
    62f2:	88 23       	and	r24, r24
    62f4:	19 f4       	brne	.+6      	; 0x62fc <Timer_GetStatus+0x80>
			{
				/*
				 *  Wrong Timer1 status
				 */
				s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NOT_INITIALIZED;
    62f6:	80 ee       	ldi	r24, 0xE0	; 224
    62f8:	89 83       	std	Y+1, r24	; 0x01
    62fa:	45 c0       	rjmp	.+138    	; 0x6386 <Timer_GetStatus+0x10a>
			else
			{
				/*
				 * read Timer1 overflow flag
				 */
				*Data = GET_BIT(TIFR, T1_INTERRUPT_NORMAL);
    62fc:	e8 e5       	ldi	r30, 0x58	; 88
    62fe:	f0 e0       	ldi	r31, 0x00	; 0
    6300:	80 81       	ld	r24, Z
    6302:	88 2f       	mov	r24, r24
    6304:	90 e0       	ldi	r25, 0x00	; 0
    6306:	84 70       	andi	r24, 0x04	; 4
    6308:	90 70       	andi	r25, 0x00	; 0
    630a:	98 87       	std	Y+8, r25	; 0x08
    630c:	8f 83       	std	Y+7, r24	; 0x07
    630e:	2f 81       	ldd	r18, Y+7	; 0x07
    6310:	38 85       	ldd	r19, Y+8	; 0x08
    6312:	33 23       	and	r19, r19
    6314:	2c f4       	brge	.+10     	; 0x6320 <Timer_GetStatus+0xa4>
    6316:	8f 81       	ldd	r24, Y+7	; 0x07
    6318:	98 85       	ldd	r25, Y+8	; 0x08
    631a:	03 96       	adiw	r24, 0x03	; 3
    631c:	98 87       	std	Y+8, r25	; 0x08
    631e:	8f 83       	std	Y+7, r24	; 0x07
    6320:	8f 81       	ldd	r24, Y+7	; 0x07
    6322:	98 85       	ldd	r25, Y+8	; 0x08
    6324:	95 95       	asr	r25
    6326:	87 95       	ror	r24
    6328:	95 95       	asr	r25
    632a:	87 95       	ror	r24
    632c:	eb 81       	ldd	r30, Y+3	; 0x03
    632e:	fc 81       	ldd	r31, Y+4	; 0x04
    6330:	80 83       	st	Z, r24
    6332:	29 c0       	rjmp	.+82     	; 0x6386 <Timer_GetStatus+0x10a>
				 */
				/*ASSIGN_BIT(TIFR,T0_INTERRUPT_NORMAL,HIGH);*/
			}
			break;
		case TIMER_CH2:
			if (gau8_TimerStatus[TIMER_CH2] == TIMER_UNINTIALIZED)
    6334:	80 91 d6 07 	lds	r24, 0x07D6
    6338:	88 23       	and	r24, r24
    633a:	19 f4       	brne	.+6      	; 0x6342 <Timer_GetStatus+0xc6>
			{
				/*
				 *  Wrong Timer status
				 */
				s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NOT_INITIALIZED;
    633c:	80 ee       	ldi	r24, 0xE0	; 224
    633e:	89 83       	std	Y+1, r24	; 0x01
    6340:	22 c0       	rjmp	.+68     	; 0x6386 <Timer_GetStatus+0x10a>
			else
			{
				/*
				 * read Timer2 overflow flag
				 */
				*Data = GET_BIT(TIFR, T2_INTERRUPT_NORMAL);
    6342:	e8 e5       	ldi	r30, 0x58	; 88
    6344:	f0 e0       	ldi	r31, 0x00	; 0
    6346:	80 81       	ld	r24, Z
    6348:	88 2f       	mov	r24, r24
    634a:	90 e0       	ldi	r25, 0x00	; 0
    634c:	80 74       	andi	r24, 0x40	; 64
    634e:	90 70       	andi	r25, 0x00	; 0
    6350:	9a 87       	std	Y+10, r25	; 0x0a
    6352:	89 87       	std	Y+9, r24	; 0x09
    6354:	29 85       	ldd	r18, Y+9	; 0x09
    6356:	3a 85       	ldd	r19, Y+10	; 0x0a
    6358:	33 23       	and	r19, r19
    635a:	2c f4       	brge	.+10     	; 0x6366 <Timer_GetStatus+0xea>
    635c:	89 85       	ldd	r24, Y+9	; 0x09
    635e:	9a 85       	ldd	r25, Y+10	; 0x0a
    6360:	cf 96       	adiw	r24, 0x3f	; 63
    6362:	9a 87       	std	Y+10, r25	; 0x0a
    6364:	89 87       	std	Y+9, r24	; 0x09
    6366:	89 85       	ldd	r24, Y+9	; 0x09
    6368:	9a 85       	ldd	r25, Y+10	; 0x0a
    636a:	08 2e       	mov	r0, r24
    636c:	89 2f       	mov	r24, r25
    636e:	00 0c       	add	r0, r0
    6370:	88 1f       	adc	r24, r24
    6372:	99 0b       	sbc	r25, r25
    6374:	00 0c       	add	r0, r0
    6376:	88 1f       	adc	r24, r24
    6378:	99 1f       	adc	r25, r25
    637a:	eb 81       	ldd	r30, Y+3	; 0x03
    637c:	fc 81       	ldd	r31, Y+4	; 0x04
    637e:	80 83       	st	Z, r24
    6380:	02 c0       	rjmp	.+4      	; 0x6386 <Timer_GetStatus+0x10a>
			break;
		default:
			/*
			 *  Wrong Timer channel
			 */
			s8_ErrorStatus = TIMER_BASE_ERROR + ERR_INVALID_ARGU;
    6382:	81 ee       	ldi	r24, 0xE1	; 225
    6384:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	/*
	 * Function shall return the Error state
	 */
	return s8_ErrorStatus;
    6386:	89 81       	ldd	r24, Y+1	; 0x01
}
    6388:	2a 96       	adiw	r28, 0x0a	; 10
    638a:	0f b6       	in	r0, 0x3f	; 63
    638c:	f8 94       	cli
    638e:	de bf       	out	0x3e, r29	; 62
    6390:	0f be       	out	0x3f, r0	; 63
    6392:	cd bf       	out	0x3d, r28	; 61
    6394:	cf 91       	pop	r28
    6396:	df 91       	pop	r29
    6398:	08 95       	ret

0000639a <Timer_GetValue>:
 * Return: The error status of the function.
 * Description: This function is used to return the value of the timer.
 *
 */
ERROR_STATUS Timer_GetValue(uint8 Timer_CH_NO, uint16* Data)
{
    639a:	df 93       	push	r29
    639c:	cf 93       	push	r28
    639e:	00 d0       	rcall	.+0      	; 0x63a0 <Timer_GetValue+0x6>
    63a0:	00 d0       	rcall	.+0      	; 0x63a2 <Timer_GetValue+0x8>
    63a2:	00 d0       	rcall	.+0      	; 0x63a4 <Timer_GetValue+0xa>
    63a4:	cd b7       	in	r28, 0x3d	; 61
    63a6:	de b7       	in	r29, 0x3e	; 62
    63a8:	8a 83       	std	Y+2, r24	; 0x02
    63aa:	7c 83       	std	Y+4, r23	; 0x04
    63ac:	6b 83       	std	Y+3, r22	; 0x03
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = TIMER_BASE_ERROR + ERR_SUCCESS;
    63ae:	82 ee       	ldi	r24, 0xE2	; 226
    63b0:	89 83       	std	Y+1, r24	; 0x01

	if (Data == NULL)
    63b2:	8b 81       	ldd	r24, Y+3	; 0x03
    63b4:	9c 81       	ldd	r25, Y+4	; 0x04
    63b6:	00 97       	sbiw	r24, 0x00	; 0
    63b8:	19 f4       	brne	.+6      	; 0x63c0 <Timer_GetValue+0x26>
	{
		/*
		 * trying to access a null pointer
		 */
		s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NULL_PTR;
    63ba:	8e ed       	ldi	r24, 0xDE	; 222
    63bc:	89 83       	std	Y+1, r24	; 0x01
    63be:	47 c0       	rjmp	.+142    	; 0x644e <Timer_GetValue+0xb4>
	else
	{
		/*
		 * check on Timer channel
		 */
		switch (Timer_CH_NO)
    63c0:	8a 81       	ldd	r24, Y+2	; 0x02
    63c2:	28 2f       	mov	r18, r24
    63c4:	30 e0       	ldi	r19, 0x00	; 0
    63c6:	3e 83       	std	Y+6, r19	; 0x06
    63c8:	2d 83       	std	Y+5, r18	; 0x05
    63ca:	8d 81       	ldd	r24, Y+5	; 0x05
    63cc:	9e 81       	ldd	r25, Y+6	; 0x06
    63ce:	81 30       	cpi	r24, 0x01	; 1
    63d0:	91 05       	cpc	r25, r1
    63d2:	d1 f0       	breq	.+52     	; 0x6408 <Timer_GetValue+0x6e>
    63d4:	2d 81       	ldd	r18, Y+5	; 0x05
    63d6:	3e 81       	ldd	r19, Y+6	; 0x06
    63d8:	22 30       	cpi	r18, 0x02	; 2
    63da:	31 05       	cpc	r19, r1
    63dc:	29 f1       	breq	.+74     	; 0x6428 <Timer_GetValue+0x8e>
    63de:	8d 81       	ldd	r24, Y+5	; 0x05
    63e0:	9e 81       	ldd	r25, Y+6	; 0x06
    63e2:	00 97       	sbiw	r24, 0x00	; 0
    63e4:	91 f5       	brne	.+100    	; 0x644a <Timer_GetValue+0xb0>
		{
		case TIMER_CH0:
			if (gau8_TimerStatus[TIMER_CH0] == TIMER_UNINTIALIZED)
    63e6:	80 91 d4 07 	lds	r24, 0x07D4
    63ea:	88 23       	and	r24, r24
    63ec:	19 f4       	brne	.+6      	; 0x63f4 <Timer_GetValue+0x5a>
			{
				/*
				 *  Wrong Timer status
				 */
				s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NOT_INITIALIZED;
    63ee:	80 ee       	ldi	r24, 0xE0	; 224
    63f0:	89 83       	std	Y+1, r24	; 0x01
    63f2:	2d c0       	rjmp	.+90     	; 0x644e <Timer_GetValue+0xb4>
			else
			{
				/*
				 * read T0 Value
				 */
				*Data = (uint16) TCNT0;
    63f4:	e2 e5       	ldi	r30, 0x52	; 82
    63f6:	f0 e0       	ldi	r31, 0x00	; 0
    63f8:	80 81       	ld	r24, Z
    63fa:	88 2f       	mov	r24, r24
    63fc:	90 e0       	ldi	r25, 0x00	; 0
    63fe:	eb 81       	ldd	r30, Y+3	; 0x03
    6400:	fc 81       	ldd	r31, Y+4	; 0x04
    6402:	91 83       	std	Z+1, r25	; 0x01
    6404:	80 83       	st	Z, r24
    6406:	23 c0       	rjmp	.+70     	; 0x644e <Timer_GetValue+0xb4>
			}
			break;
		case TIMER_CH1:
			if (gau8_TimerStatus[TIMER_CH1] == TIMER_UNINTIALIZED)
    6408:	80 91 d5 07 	lds	r24, 0x07D5
    640c:	88 23       	and	r24, r24
    640e:	19 f4       	brne	.+6      	; 0x6416 <Timer_GetValue+0x7c>
			{
				/*
				 *  Wrong Timer1 status
				 */
				s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NOT_INITIALIZED;
    6410:	80 ee       	ldi	r24, 0xE0	; 224
    6412:	89 83       	std	Y+1, r24	; 0x01
    6414:	1c c0       	rjmp	.+56     	; 0x644e <Timer_GetValue+0xb4>
			else
			{
				/*
				 * read Timer1 Value
				 */
				*Data = TCNT1;
    6416:	ec e4       	ldi	r30, 0x4C	; 76
    6418:	f0 e0       	ldi	r31, 0x00	; 0
    641a:	80 81       	ld	r24, Z
    641c:	91 81       	ldd	r25, Z+1	; 0x01
    641e:	eb 81       	ldd	r30, Y+3	; 0x03
    6420:	fc 81       	ldd	r31, Y+4	; 0x04
    6422:	91 83       	std	Z+1, r25	; 0x01
    6424:	80 83       	st	Z, r24
    6426:	13 c0       	rjmp	.+38     	; 0x644e <Timer_GetValue+0xb4>
			}
			break;
		case TIMER_CH2:
			if (gau8_TimerStatus[TIMER_CH2] == TIMER_UNINTIALIZED)
    6428:	80 91 d6 07 	lds	r24, 0x07D6
    642c:	88 23       	and	r24, r24
    642e:	19 f4       	brne	.+6      	; 0x6436 <Timer_GetValue+0x9c>
			{
				/*
				 *  Wrong Timer status
				 */
				s8_ErrorStatus = TIMER_BASE_ERROR + ERR_NOT_INITIALIZED;
    6430:	80 ee       	ldi	r24, 0xE0	; 224
    6432:	89 83       	std	Y+1, r24	; 0x01
    6434:	0c c0       	rjmp	.+24     	; 0x644e <Timer_GetValue+0xb4>
			else
			{
				/*
				 * read Timer2 Value
				 */
				*Data = (uint16) TCNT2;
    6436:	e4 e4       	ldi	r30, 0x44	; 68
    6438:	f0 e0       	ldi	r31, 0x00	; 0
    643a:	80 81       	ld	r24, Z
    643c:	88 2f       	mov	r24, r24
    643e:	90 e0       	ldi	r25, 0x00	; 0
    6440:	eb 81       	ldd	r30, Y+3	; 0x03
    6442:	fc 81       	ldd	r31, Y+4	; 0x04
    6444:	91 83       	std	Z+1, r25	; 0x01
    6446:	80 83       	st	Z, r24
    6448:	02 c0       	rjmp	.+4      	; 0x644e <Timer_GetValue+0xb4>
			break;
		default:
			/*
			 *  Wrong Timer channel
			 */
			s8_ErrorStatus = TIMER_BASE_ERROR + ERR_INVALID_ARGU;
    644a:	81 ee       	ldi	r24, 0xE1	; 225
    644c:	89 83       	std	Y+1, r24	; 0x01
	}

	/*
	 * Function shall return the Error state
	 */
	return s8_ErrorStatus;
    644e:	89 81       	ldd	r24, Y+1	; 0x01
}
    6450:	26 96       	adiw	r28, 0x06	; 6
    6452:	0f b6       	in	r0, 0x3f	; 63
    6454:	f8 94       	cli
    6456:	de bf       	out	0x3e, r29	; 62
    6458:	0f be       	out	0x3f, r0	; 63
    645a:	cd bf       	out	0x3d, r28	; 61
    645c:	cf 91       	pop	r28
    645e:	df 91       	pop	r29
    6460:	08 95       	ret

00006462 <__vector_11>:
/*
 *	Interrupt service routine for timer 0 over flow
 */
ISR(TIMER0_OVF_vect)
{
    6462:	1f 92       	push	r1
    6464:	0f 92       	push	r0
    6466:	0f b6       	in	r0, 0x3f	; 63
    6468:	0f 92       	push	r0
    646a:	11 24       	eor	r1, r1
    646c:	2f 93       	push	r18
    646e:	3f 93       	push	r19
    6470:	4f 93       	push	r20
    6472:	5f 93       	push	r21
    6474:	6f 93       	push	r22
    6476:	7f 93       	push	r23
    6478:	8f 93       	push	r24
    647a:	9f 93       	push	r25
    647c:	af 93       	push	r26
    647e:	bf 93       	push	r27
    6480:	ef 93       	push	r30
    6482:	ff 93       	push	r31
    6484:	df 93       	push	r29
    6486:	cf 93       	push	r28
    6488:	cd b7       	in	r28, 0x3d	; 61
    648a:	de b7       	in	r29, 0x3e	; 62
	/*
	 * set timer0 register initial value
	 */
	TCNT0 = (uint8) gau16_TimerPreload[TIMER_CH0];
    648c:	e2 e5       	ldi	r30, 0x52	; 82
    648e:	f0 e0       	ldi	r31, 0x00	; 0
    6490:	80 91 d7 07 	lds	r24, 0x07D7
    6494:	90 91 d8 07 	lds	r25, 0x07D8
    6498:	80 83       	st	Z, r24
	if (NULL != Timer_OV_Cbk_ptr[TIMER_CH0])
    649a:	80 91 dd 07 	lds	r24, 0x07DD
    649e:	90 91 de 07 	lds	r25, 0x07DE
    64a2:	00 97       	sbiw	r24, 0x00	; 0
    64a4:	29 f0       	breq	.+10     	; 0x64b0 <__vector_11+0x4e>
	{
		Timer_OV_Cbk_ptr[TIMER_CH0]();
    64a6:	e0 91 dd 07 	lds	r30, 0x07DD
    64aa:	f0 91 de 07 	lds	r31, 0x07DE
    64ae:	09 95       	icall
	}
	else
	{

	}
}
    64b0:	cf 91       	pop	r28
    64b2:	df 91       	pop	r29
    64b4:	ff 91       	pop	r31
    64b6:	ef 91       	pop	r30
    64b8:	bf 91       	pop	r27
    64ba:	af 91       	pop	r26
    64bc:	9f 91       	pop	r25
    64be:	8f 91       	pop	r24
    64c0:	7f 91       	pop	r23
    64c2:	6f 91       	pop	r22
    64c4:	5f 91       	pop	r21
    64c6:	4f 91       	pop	r20
    64c8:	3f 91       	pop	r19
    64ca:	2f 91       	pop	r18
    64cc:	0f 90       	pop	r0
    64ce:	0f be       	out	0x3f, r0	; 63
    64d0:	0f 90       	pop	r0
    64d2:	1f 90       	pop	r1
    64d4:	18 95       	reti

000064d6 <__vector_9>:

/*
 *	Interrupt service routine for timer 1 over flow
 */
ISR(TIMER1_OVF_vect)
{
    64d6:	1f 92       	push	r1
    64d8:	0f 92       	push	r0
    64da:	0f b6       	in	r0, 0x3f	; 63
    64dc:	0f 92       	push	r0
    64de:	11 24       	eor	r1, r1
    64e0:	2f 93       	push	r18
    64e2:	3f 93       	push	r19
    64e4:	4f 93       	push	r20
    64e6:	5f 93       	push	r21
    64e8:	6f 93       	push	r22
    64ea:	7f 93       	push	r23
    64ec:	8f 93       	push	r24
    64ee:	9f 93       	push	r25
    64f0:	af 93       	push	r26
    64f2:	bf 93       	push	r27
    64f4:	ef 93       	push	r30
    64f6:	ff 93       	push	r31
    64f8:	df 93       	push	r29
    64fa:	cf 93       	push	r28
    64fc:	cd b7       	in	r28, 0x3d	; 61
    64fe:	de b7       	in	r29, 0x3e	; 62
	/*
	 * set timer1 register initial value
	 */
	TCNT1 = gau16_TimerPreload[TIMER_CH1];
    6500:	ec e4       	ldi	r30, 0x4C	; 76
    6502:	f0 e0       	ldi	r31, 0x00	; 0
    6504:	80 91 d9 07 	lds	r24, 0x07D9
    6508:	90 91 da 07 	lds	r25, 0x07DA
    650c:	91 83       	std	Z+1, r25	; 0x01
    650e:	80 83       	st	Z, r24
	if (NULL != Timer_OV_Cbk_ptr[TIMER_CH1])
    6510:	80 91 df 07 	lds	r24, 0x07DF
    6514:	90 91 e0 07 	lds	r25, 0x07E0
    6518:	00 97       	sbiw	r24, 0x00	; 0
    651a:	29 f0       	breq	.+10     	; 0x6526 <__vector_9+0x50>
	{
		Timer_OV_Cbk_ptr[TIMER_CH1]();
    651c:	e0 91 df 07 	lds	r30, 0x07DF
    6520:	f0 91 e0 07 	lds	r31, 0x07E0
    6524:	09 95       	icall
	}
	else
	{

	}
}
    6526:	cf 91       	pop	r28
    6528:	df 91       	pop	r29
    652a:	ff 91       	pop	r31
    652c:	ef 91       	pop	r30
    652e:	bf 91       	pop	r27
    6530:	af 91       	pop	r26
    6532:	9f 91       	pop	r25
    6534:	8f 91       	pop	r24
    6536:	7f 91       	pop	r23
    6538:	6f 91       	pop	r22
    653a:	5f 91       	pop	r21
    653c:	4f 91       	pop	r20
    653e:	3f 91       	pop	r19
    6540:	2f 91       	pop	r18
    6542:	0f 90       	pop	r0
    6544:	0f be       	out	0x3f, r0	; 63
    6546:	0f 90       	pop	r0
    6548:	1f 90       	pop	r1
    654a:	18 95       	reti

0000654c <__vector_5>:

/*
 *	Interrupt service routine for timer 2 over flow
 */
ISR(TIMER2_OVF_vect)
{
    654c:	1f 92       	push	r1
    654e:	0f 92       	push	r0
    6550:	0f b6       	in	r0, 0x3f	; 63
    6552:	0f 92       	push	r0
    6554:	11 24       	eor	r1, r1
    6556:	2f 93       	push	r18
    6558:	3f 93       	push	r19
    655a:	4f 93       	push	r20
    655c:	5f 93       	push	r21
    655e:	6f 93       	push	r22
    6560:	7f 93       	push	r23
    6562:	8f 93       	push	r24
    6564:	9f 93       	push	r25
    6566:	af 93       	push	r26
    6568:	bf 93       	push	r27
    656a:	ef 93       	push	r30
    656c:	ff 93       	push	r31
    656e:	df 93       	push	r29
    6570:	cf 93       	push	r28
    6572:	cd b7       	in	r28, 0x3d	; 61
    6574:	de b7       	in	r29, 0x3e	; 62
	/*
	 * set timer2 register initial value
	 */
	TCNT2 = (uint8) gau16_TimerPreload[TIMER_CH2];
    6576:	e4 e4       	ldi	r30, 0x44	; 68
    6578:	f0 e0       	ldi	r31, 0x00	; 0
    657a:	80 91 db 07 	lds	r24, 0x07DB
    657e:	90 91 dc 07 	lds	r25, 0x07DC
    6582:	80 83       	st	Z, r24
	if (NULL != Timer_OV_Cbk_ptr[TIMER_CH2])
    6584:	80 91 e1 07 	lds	r24, 0x07E1
    6588:	90 91 e2 07 	lds	r25, 0x07E2
    658c:	00 97       	sbiw	r24, 0x00	; 0
    658e:	29 f0       	breq	.+10     	; 0x659a <__vector_5+0x4e>
	{
		Timer_OV_Cbk_ptr[TIMER_CH2]();
    6590:	e0 91 e1 07 	lds	r30, 0x07E1
    6594:	f0 91 e2 07 	lds	r31, 0x07E2
    6598:	09 95       	icall
	}
	else
	{

	}
}
    659a:	cf 91       	pop	r28
    659c:	df 91       	pop	r29
    659e:	ff 91       	pop	r31
    65a0:	ef 91       	pop	r30
    65a2:	bf 91       	pop	r27
    65a4:	af 91       	pop	r26
    65a6:	9f 91       	pop	r25
    65a8:	8f 91       	pop	r24
    65aa:	7f 91       	pop	r23
    65ac:	6f 91       	pop	r22
    65ae:	5f 91       	pop	r21
    65b0:	4f 91       	pop	r20
    65b2:	3f 91       	pop	r19
    65b4:	2f 91       	pop	r18
    65b6:	0f 90       	pop	r0
    65b8:	0f be       	out	0x3f, r0	; 63
    65ba:	0f 90       	pop	r0
    65bc:	1f 90       	pop	r1
    65be:	18 95       	reti

000065c0 <CPU_Sleep>:
* Input : E_SleepMode_t
* Output: None
* @return: void
*/
void CPU_Sleep(E_SleepMode_t e_mode)
{
    65c0:	df 93       	push	r29
    65c2:	cf 93       	push	r28
    65c4:	00 d0       	rcall	.+0      	; 0x65c6 <CPU_Sleep+0x6>
    65c6:	0f 92       	push	r0
    65c8:	cd b7       	in	r28, 0x3d	; 61
    65ca:	de b7       	in	r29, 0x3e	; 62
    65cc:	89 83       	std	Y+1, r24	; 0x01
  switch (e_mode) {
    65ce:	89 81       	ldd	r24, Y+1	; 0x01
    65d0:	28 2f       	mov	r18, r24
    65d2:	30 e0       	ldi	r19, 0x00	; 0
    65d4:	3b 83       	std	Y+3, r19	; 0x03
    65d6:	2a 83       	std	Y+2, r18	; 0x02
    65d8:	8a 81       	ldd	r24, Y+2	; 0x02
    65da:	9b 81       	ldd	r25, Y+3	; 0x03
    65dc:	82 30       	cpi	r24, 0x02	; 2
    65de:	91 05       	cpc	r25, r1
    65e0:	09 f4       	brne	.+2      	; 0x65e4 <CPU_Sleep+0x24>
    65e2:	47 c0       	rjmp	.+142    	; 0x6672 <CPU_Sleep+0xb2>
    65e4:	2a 81       	ldd	r18, Y+2	; 0x02
    65e6:	3b 81       	ldd	r19, Y+3	; 0x03
    65e8:	23 30       	cpi	r18, 0x03	; 3
    65ea:	31 05       	cpc	r19, r1
    65ec:	54 f4       	brge	.+20     	; 0x6602 <CPU_Sleep+0x42>
    65ee:	8a 81       	ldd	r24, Y+2	; 0x02
    65f0:	9b 81       	ldd	r25, Y+3	; 0x03
    65f2:	00 97       	sbiw	r24, 0x00	; 0
    65f4:	c9 f0       	breq	.+50     	; 0x6628 <CPU_Sleep+0x68>
    65f6:	2a 81       	ldd	r18, Y+2	; 0x02
    65f8:	3b 81       	ldd	r19, Y+3	; 0x03
    65fa:	21 30       	cpi	r18, 0x01	; 1
    65fc:	31 05       	cpc	r19, r1
    65fe:	19 f1       	breq	.+70     	; 0x6646 <CPU_Sleep+0x86>
    6600:	88 c0       	rjmp	.+272    	; 0x6712 <CPU_Sleep+0x152>
    6602:	8a 81       	ldd	r24, Y+2	; 0x02
    6604:	9b 81       	ldd	r25, Y+3	; 0x03
    6606:	84 30       	cpi	r24, 0x04	; 4
    6608:	91 05       	cpc	r25, r1
    660a:	09 f4       	brne	.+2      	; 0x660e <CPU_Sleep+0x4e>
    660c:	5e c0       	rjmp	.+188    	; 0x66ca <CPU_Sleep+0x10a>
    660e:	2a 81       	ldd	r18, Y+2	; 0x02
    6610:	3b 81       	ldd	r19, Y+3	; 0x03
    6612:	24 30       	cpi	r18, 0x04	; 4
    6614:	31 05       	cpc	r19, r1
    6616:	0c f4       	brge	.+2      	; 0x661a <CPU_Sleep+0x5a>
    6618:	42 c0       	rjmp	.+132    	; 0x669e <CPU_Sleep+0xde>
    661a:	8a 81       	ldd	r24, Y+2	; 0x02
    661c:	9b 81       	ldd	r25, Y+3	; 0x03
    661e:	85 30       	cpi	r24, 0x05	; 5
    6620:	91 05       	cpc	r25, r1
    6622:	09 f4       	brne	.+2      	; 0x6626 <CPU_Sleep+0x66>
    6624:	68 c0       	rjmp	.+208    	; 0x66f6 <CPU_Sleep+0x136>
    6626:	75 c0       	rjmp	.+234    	; 0x6712 <CPU_Sleep+0x152>
    case (IDLE):
      /* Set IDLE sleep mode */
      MCUCR &= ~(SM2 | SM1 | SM0);
    6628:	a5 e5       	ldi	r26, 0x55	; 85
    662a:	b0 e0       	ldi	r27, 0x00	; 0
    662c:	e5 e5       	ldi	r30, 0x55	; 85
    662e:	f0 e0       	ldi	r31, 0x00	; 0
    6630:	80 81       	ld	r24, Z
    6632:	8f 78       	andi	r24, 0x8F	; 143
    6634:	8c 93       	st	X, r24
      /* Enter sleep mode */
      MCUCR |= SE;
    6636:	a5 e5       	ldi	r26, 0x55	; 85
    6638:	b0 e0       	ldi	r27, 0x00	; 0
    663a:	e5 e5       	ldi	r30, 0x55	; 85
    663c:	f0 e0       	ldi	r31, 0x00	; 0
    663e:	80 81       	ld	r24, Z
    6640:	80 68       	ori	r24, 0x80	; 128
    6642:	8c 93       	st	X, r24
    6644:	66 c0       	rjmp	.+204    	; 0x6712 <CPU_Sleep+0x152>
      break;
    case (ADC_NOISE_REDUC):
      /* Set ADC noise reduction sleep mode */
      MCUCR &= ~(SM2 | SM1);
    6646:	a5 e5       	ldi	r26, 0x55	; 85
    6648:	b0 e0       	ldi	r27, 0x00	; 0
    664a:	e5 e5       	ldi	r30, 0x55	; 85
    664c:	f0 e0       	ldi	r31, 0x00	; 0
    664e:	80 81       	ld	r24, Z
    6650:	8f 79       	andi	r24, 0x9F	; 159
    6652:	8c 93       	st	X, r24
      MCUCR |= SM0;
    6654:	a5 e5       	ldi	r26, 0x55	; 85
    6656:	b0 e0       	ldi	r27, 0x00	; 0
    6658:	e5 e5       	ldi	r30, 0x55	; 85
    665a:	f0 e0       	ldi	r31, 0x00	; 0
    665c:	80 81       	ld	r24, Z
    665e:	80 61       	ori	r24, 0x10	; 16
    6660:	8c 93       	st	X, r24
      /* Enter sleep mode */
      MCUCR |= SE;
    6662:	a5 e5       	ldi	r26, 0x55	; 85
    6664:	b0 e0       	ldi	r27, 0x00	; 0
    6666:	e5 e5       	ldi	r30, 0x55	; 85
    6668:	f0 e0       	ldi	r31, 0x00	; 0
    666a:	80 81       	ld	r24, Z
    666c:	80 68       	ori	r24, 0x80	; 128
    666e:	8c 93       	st	X, r24
    6670:	50 c0       	rjmp	.+160    	; 0x6712 <CPU_Sleep+0x152>
      break;
    case (POWER_DOWN):
      /* Set Power-down sleep mode */
      MCUCR &= ~(SM2 | SM0);
    6672:	a5 e5       	ldi	r26, 0x55	; 85
    6674:	b0 e0       	ldi	r27, 0x00	; 0
    6676:	e5 e5       	ldi	r30, 0x55	; 85
    6678:	f0 e0       	ldi	r31, 0x00	; 0
    667a:	80 81       	ld	r24, Z
    667c:	8f 7a       	andi	r24, 0xAF	; 175
    667e:	8c 93       	st	X, r24
      MCUCR |= SM1;
    6680:	a5 e5       	ldi	r26, 0x55	; 85
    6682:	b0 e0       	ldi	r27, 0x00	; 0
    6684:	e5 e5       	ldi	r30, 0x55	; 85
    6686:	f0 e0       	ldi	r31, 0x00	; 0
    6688:	80 81       	ld	r24, Z
    668a:	80 62       	ori	r24, 0x20	; 32
    668c:	8c 93       	st	X, r24
      /* Enter sleep mode */
      MCUCR |= SE;
    668e:	a5 e5       	ldi	r26, 0x55	; 85
    6690:	b0 e0       	ldi	r27, 0x00	; 0
    6692:	e5 e5       	ldi	r30, 0x55	; 85
    6694:	f0 e0       	ldi	r31, 0x00	; 0
    6696:	80 81       	ld	r24, Z
    6698:	80 68       	ori	r24, 0x80	; 128
    669a:	8c 93       	st	X, r24
    669c:	3a c0       	rjmp	.+116    	; 0x6712 <CPU_Sleep+0x152>
      break;
    case (POWER_SAVE):
      /* Set Power-save sleep mode */
      MCUCR |= (SM1 | SM0);
    669e:	a5 e5       	ldi	r26, 0x55	; 85
    66a0:	b0 e0       	ldi	r27, 0x00	; 0
    66a2:	e5 e5       	ldi	r30, 0x55	; 85
    66a4:	f0 e0       	ldi	r31, 0x00	; 0
    66a6:	80 81       	ld	r24, Z
    66a8:	80 63       	ori	r24, 0x30	; 48
    66aa:	8c 93       	st	X, r24
      MCUCR &= ~SM2;
    66ac:	a5 e5       	ldi	r26, 0x55	; 85
    66ae:	b0 e0       	ldi	r27, 0x00	; 0
    66b0:	e5 e5       	ldi	r30, 0x55	; 85
    66b2:	f0 e0       	ldi	r31, 0x00	; 0
    66b4:	80 81       	ld	r24, Z
    66b6:	8f 7b       	andi	r24, 0xBF	; 191
    66b8:	8c 93       	st	X, r24
      /* Enter sleep mode */
      MCUCR |= SE;
    66ba:	a5 e5       	ldi	r26, 0x55	; 85
    66bc:	b0 e0       	ldi	r27, 0x00	; 0
    66be:	e5 e5       	ldi	r30, 0x55	; 85
    66c0:	f0 e0       	ldi	r31, 0x00	; 0
    66c2:	80 81       	ld	r24, Z
    66c4:	80 68       	ori	r24, 0x80	; 128
    66c6:	8c 93       	st	X, r24
    66c8:	24 c0       	rjmp	.+72     	; 0x6712 <CPU_Sleep+0x152>
      break;
    case (STANDBY):
      /* Set Standby sleep mode */
      MCUCR |= (SM2 | SM1);
    66ca:	a5 e5       	ldi	r26, 0x55	; 85
    66cc:	b0 e0       	ldi	r27, 0x00	; 0
    66ce:	e5 e5       	ldi	r30, 0x55	; 85
    66d0:	f0 e0       	ldi	r31, 0x00	; 0
    66d2:	80 81       	ld	r24, Z
    66d4:	80 66       	ori	r24, 0x60	; 96
    66d6:	8c 93       	st	X, r24
      MCUCR &= ~SM0;
    66d8:	a5 e5       	ldi	r26, 0x55	; 85
    66da:	b0 e0       	ldi	r27, 0x00	; 0
    66dc:	e5 e5       	ldi	r30, 0x55	; 85
    66de:	f0 e0       	ldi	r31, 0x00	; 0
    66e0:	80 81       	ld	r24, Z
    66e2:	8f 7e       	andi	r24, 0xEF	; 239
    66e4:	8c 93       	st	X, r24
      /* Enter sleep mode */
      MCUCR |= SE;
    66e6:	a5 e5       	ldi	r26, 0x55	; 85
    66e8:	b0 e0       	ldi	r27, 0x00	; 0
    66ea:	e5 e5       	ldi	r30, 0x55	; 85
    66ec:	f0 e0       	ldi	r31, 0x00	; 0
    66ee:	80 81       	ld	r24, Z
    66f0:	80 68       	ori	r24, 0x80	; 128
    66f2:	8c 93       	st	X, r24
    66f4:	0e c0       	rjmp	.+28     	; 0x6712 <CPU_Sleep+0x152>
      break;
    case (EXT_STANDBY):
      /* Set Extended standby sleep mode */
      MCUCR |= (SM2 | SM1 | SM0);
    66f6:	a5 e5       	ldi	r26, 0x55	; 85
    66f8:	b0 e0       	ldi	r27, 0x00	; 0
    66fa:	e5 e5       	ldi	r30, 0x55	; 85
    66fc:	f0 e0       	ldi	r31, 0x00	; 0
    66fe:	80 81       	ld	r24, Z
    6700:	80 67       	ori	r24, 0x70	; 112
    6702:	8c 93       	st	X, r24
      /* Enter sleep mode */
      MCUCR |= SE;
    6704:	a5 e5       	ldi	r26, 0x55	; 85
    6706:	b0 e0       	ldi	r27, 0x00	; 0
    6708:	e5 e5       	ldi	r30, 0x55	; 85
    670a:	f0 e0       	ldi	r31, 0x00	; 0
    670c:	80 81       	ld	r24, Z
    670e:	80 68       	ori	r24, 0x80	; 128
    6710:	8c 93       	st	X, r24
      break;
    default:
      break;
  }
  /* Execute SLEEP instruction to put device in selected sleep mode */
  asm("SLEEP");
    6712:	88 95       	sleep
}
    6714:	0f 90       	pop	r0
    6716:	0f 90       	pop	r0
    6718:	0f 90       	pop	r0
    671a:	cf 91       	pop	r28
    671c:	df 91       	pop	r29
    671e:	08 95       	ret

00006720 <DIO_init>:
 *In/Out:
 *Description: This function can set the direction of a full port, a nibble
 * 			  or even one pin.
 */
ERROR_STATUS DIO_init(DIO_Cfg_s *DIO_info)
{
    6720:	df 93       	push	r29
    6722:	cf 93       	push	r28
    6724:	00 d0       	rcall	.+0      	; 0x6726 <DIO_init+0x6>
    6726:	00 d0       	rcall	.+0      	; 0x6728 <DIO_init+0x8>
    6728:	0f 92       	push	r0
    672a:	cd b7       	in	r28, 0x3d	; 61
    672c:	de b7       	in	r29, 0x3e	; 62
    672e:	9b 83       	std	Y+3, r25	; 0x03
    6730:	8a 83       	std	Y+2, r24	; 0x02
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = DIO_BASE_ERROR + ERR_SUCCESS;
    6732:	86 ef       	ldi	r24, 0xF6	; 246
    6734:	89 83       	std	Y+1, r24	; 0x01

	if (DIO_info == NULL)
    6736:	8a 81       	ldd	r24, Y+2	; 0x02
    6738:	9b 81       	ldd	r25, Y+3	; 0x03
    673a:	00 97       	sbiw	r24, 0x00	; 0
    673c:	19 f4       	brne	.+6      	; 0x6744 <DIO_init+0x24>
	{
		/*
		 * trying to access a null pointer
		 */
		s8_ErrorStatus = DIO_BASE_ERROR + ERR_NULL_PTR;
    673e:	82 ef       	ldi	r24, 0xF2	; 242
    6740:	89 83       	std	Y+1, r24	; 0x01
    6742:	8a c0       	rjmp	.+276    	; 0x6858 <DIO_init+0x138>
	}
	/*
	 * 	check Direction
	 */
	else if (DIO_info->dir == INPUT || DIO_info->dir == OUTPUT)
    6744:	ea 81       	ldd	r30, Y+2	; 0x02
    6746:	fb 81       	ldd	r31, Y+3	; 0x03
    6748:	82 81       	ldd	r24, Z+2	; 0x02
    674a:	88 23       	and	r24, r24
    674c:	31 f0       	breq	.+12     	; 0x675a <DIO_init+0x3a>
    674e:	ea 81       	ldd	r30, Y+2	; 0x02
    6750:	fb 81       	ldd	r31, Y+3	; 0x03
    6752:	82 81       	ldd	r24, Z+2	; 0x02
    6754:	8f 3f       	cpi	r24, 0xFF	; 255
    6756:	09 f0       	breq	.+2      	; 0x675a <DIO_init+0x3a>
    6758:	7d c0       	rjmp	.+250    	; 0x6854 <DIO_init+0x134>
	{
		/*
		 * Check on the Required PORT Number
		 */
		switch (DIO_info->GPIO)
    675a:	ea 81       	ldd	r30, Y+2	; 0x02
    675c:	fb 81       	ldd	r31, Y+3	; 0x03
    675e:	80 81       	ld	r24, Z
    6760:	28 2f       	mov	r18, r24
    6762:	30 e0       	ldi	r19, 0x00	; 0
    6764:	3d 83       	std	Y+5, r19	; 0x05
    6766:	2c 83       	std	Y+4, r18	; 0x04
    6768:	8c 81       	ldd	r24, Y+4	; 0x04
    676a:	9d 81       	ldd	r25, Y+5	; 0x05
    676c:	81 30       	cpi	r24, 0x01	; 1
    676e:	91 05       	cpc	r25, r1
    6770:	61 f1       	breq	.+88     	; 0x67ca <DIO_init+0xaa>
    6772:	2c 81       	ldd	r18, Y+4	; 0x04
    6774:	3d 81       	ldd	r19, Y+5	; 0x05
    6776:	22 30       	cpi	r18, 0x02	; 2
    6778:	31 05       	cpc	r19, r1
    677a:	2c f4       	brge	.+10     	; 0x6786 <DIO_init+0x66>
    677c:	8c 81       	ldd	r24, Y+4	; 0x04
    677e:	9d 81       	ldd	r25, Y+5	; 0x05
    6780:	00 97       	sbiw	r24, 0x00	; 0
    6782:	69 f0       	breq	.+26     	; 0x679e <DIO_init+0x7e>
    6784:	64 c0       	rjmp	.+200    	; 0x684e <DIO_init+0x12e>
    6786:	2c 81       	ldd	r18, Y+4	; 0x04
    6788:	3d 81       	ldd	r19, Y+5	; 0x05
    678a:	22 30       	cpi	r18, 0x02	; 2
    678c:	31 05       	cpc	r19, r1
    678e:	99 f1       	breq	.+102    	; 0x67f6 <DIO_init+0xd6>
    6790:	8c 81       	ldd	r24, Y+4	; 0x04
    6792:	9d 81       	ldd	r25, Y+5	; 0x05
    6794:	83 30       	cpi	r24, 0x03	; 3
    6796:	91 05       	cpc	r25, r1
    6798:	09 f4       	brne	.+2      	; 0x679c <DIO_init+0x7c>
    679a:	43 c0       	rjmp	.+134    	; 0x6822 <DIO_init+0x102>
    679c:	58 c0       	rjmp	.+176    	; 0x684e <DIO_init+0x12e>
		{
		case GPIOA:
			ASSIGN_BIT(PORTA_DIR, DIO_info->pins, DIO_info->dir);
    679e:	aa e3       	ldi	r26, 0x3A	; 58
    67a0:	b0 e0       	ldi	r27, 0x00	; 0
    67a2:	ea e3       	ldi	r30, 0x3A	; 58
    67a4:	f0 e0       	ldi	r31, 0x00	; 0
    67a6:	80 81       	ld	r24, Z
    67a8:	98 2f       	mov	r25, r24
    67aa:	ea 81       	ldd	r30, Y+2	; 0x02
    67ac:	fb 81       	ldd	r31, Y+3	; 0x03
    67ae:	81 81       	ldd	r24, Z+1	; 0x01
    67b0:	80 95       	com	r24
    67b2:	29 2f       	mov	r18, r25
    67b4:	28 23       	and	r18, r24
    67b6:	ea 81       	ldd	r30, Y+2	; 0x02
    67b8:	fb 81       	ldd	r31, Y+3	; 0x03
    67ba:	92 81       	ldd	r25, Z+2	; 0x02
    67bc:	ea 81       	ldd	r30, Y+2	; 0x02
    67be:	fb 81       	ldd	r31, Y+3	; 0x03
    67c0:	81 81       	ldd	r24, Z+1	; 0x01
    67c2:	89 23       	and	r24, r25
    67c4:	82 2b       	or	r24, r18
    67c6:	8c 93       	st	X, r24
    67c8:	47 c0       	rjmp	.+142    	; 0x6858 <DIO_init+0x138>
			break;
		case GPIOB:
			ASSIGN_BIT(PORTB_DIR, DIO_info->pins, DIO_info->dir);
    67ca:	a7 e3       	ldi	r26, 0x37	; 55
    67cc:	b0 e0       	ldi	r27, 0x00	; 0
    67ce:	e7 e3       	ldi	r30, 0x37	; 55
    67d0:	f0 e0       	ldi	r31, 0x00	; 0
    67d2:	80 81       	ld	r24, Z
    67d4:	98 2f       	mov	r25, r24
    67d6:	ea 81       	ldd	r30, Y+2	; 0x02
    67d8:	fb 81       	ldd	r31, Y+3	; 0x03
    67da:	81 81       	ldd	r24, Z+1	; 0x01
    67dc:	80 95       	com	r24
    67de:	29 2f       	mov	r18, r25
    67e0:	28 23       	and	r18, r24
    67e2:	ea 81       	ldd	r30, Y+2	; 0x02
    67e4:	fb 81       	ldd	r31, Y+3	; 0x03
    67e6:	92 81       	ldd	r25, Z+2	; 0x02
    67e8:	ea 81       	ldd	r30, Y+2	; 0x02
    67ea:	fb 81       	ldd	r31, Y+3	; 0x03
    67ec:	81 81       	ldd	r24, Z+1	; 0x01
    67ee:	89 23       	and	r24, r25
    67f0:	82 2b       	or	r24, r18
    67f2:	8c 93       	st	X, r24
    67f4:	31 c0       	rjmp	.+98     	; 0x6858 <DIO_init+0x138>
			break;
		case GPIOC:
			ASSIGN_BIT(PORTC_DIR, DIO_info->pins, DIO_info->dir);
    67f6:	a4 e3       	ldi	r26, 0x34	; 52
    67f8:	b0 e0       	ldi	r27, 0x00	; 0
    67fa:	e4 e3       	ldi	r30, 0x34	; 52
    67fc:	f0 e0       	ldi	r31, 0x00	; 0
    67fe:	80 81       	ld	r24, Z
    6800:	98 2f       	mov	r25, r24
    6802:	ea 81       	ldd	r30, Y+2	; 0x02
    6804:	fb 81       	ldd	r31, Y+3	; 0x03
    6806:	81 81       	ldd	r24, Z+1	; 0x01
    6808:	80 95       	com	r24
    680a:	29 2f       	mov	r18, r25
    680c:	28 23       	and	r18, r24
    680e:	ea 81       	ldd	r30, Y+2	; 0x02
    6810:	fb 81       	ldd	r31, Y+3	; 0x03
    6812:	92 81       	ldd	r25, Z+2	; 0x02
    6814:	ea 81       	ldd	r30, Y+2	; 0x02
    6816:	fb 81       	ldd	r31, Y+3	; 0x03
    6818:	81 81       	ldd	r24, Z+1	; 0x01
    681a:	89 23       	and	r24, r25
    681c:	82 2b       	or	r24, r18
    681e:	8c 93       	st	X, r24
    6820:	1b c0       	rjmp	.+54     	; 0x6858 <DIO_init+0x138>
			break;
		case GPIOD:
			ASSIGN_BIT(PORTD_DIR, DIO_info->pins, DIO_info->dir);
    6822:	a1 e3       	ldi	r26, 0x31	; 49
    6824:	b0 e0       	ldi	r27, 0x00	; 0
    6826:	e1 e3       	ldi	r30, 0x31	; 49
    6828:	f0 e0       	ldi	r31, 0x00	; 0
    682a:	80 81       	ld	r24, Z
    682c:	98 2f       	mov	r25, r24
    682e:	ea 81       	ldd	r30, Y+2	; 0x02
    6830:	fb 81       	ldd	r31, Y+3	; 0x03
    6832:	81 81       	ldd	r24, Z+1	; 0x01
    6834:	80 95       	com	r24
    6836:	29 2f       	mov	r18, r25
    6838:	28 23       	and	r18, r24
    683a:	ea 81       	ldd	r30, Y+2	; 0x02
    683c:	fb 81       	ldd	r31, Y+3	; 0x03
    683e:	92 81       	ldd	r25, Z+2	; 0x02
    6840:	ea 81       	ldd	r30, Y+2	; 0x02
    6842:	fb 81       	ldd	r31, Y+3	; 0x03
    6844:	81 81       	ldd	r24, Z+1	; 0x01
    6846:	89 23       	and	r24, r25
    6848:	82 2b       	or	r24, r18
    684a:	8c 93       	st	X, r24
    684c:	05 c0       	rjmp	.+10     	; 0x6858 <DIO_init+0x138>
			break;
		default:
			/*
			 *  Wrong Port Number
			 */
			s8_ErrorStatus = DIO_BASE_ERROR + ERR_INVALID_ARGU;
    684e:	85 ef       	ldi	r24, 0xF5	; 245
    6850:	89 83       	std	Y+1, r24	; 0x01
    6852:	02 c0       	rjmp	.+4      	; 0x6858 <DIO_init+0x138>
	else
	{
		/*
		 *  Wrong Direction
		 */
		s8_ErrorStatus = DIO_BASE_ERROR + ERR_INVALID_ARGU;
    6854:	85 ef       	ldi	r24, 0xF5	; 245
    6856:	89 83       	std	Y+1, r24	; 0x01
	}
	/*
	 * Function shall return the Error state
	 */
	return s8_ErrorStatus;
    6858:	89 81       	ldd	r24, Y+1	; 0x01
}
    685a:	0f 90       	pop	r0
    685c:	0f 90       	pop	r0
    685e:	0f 90       	pop	r0
    6860:	0f 90       	pop	r0
    6862:	0f 90       	pop	r0
    6864:	cf 91       	pop	r28
    6866:	df 91       	pop	r29
    6868:	08 95       	ret

0000686a <DIO_Write>:
 *In/Out: No In/Out
 *Description: This function can set the value of a full port, a nibble
 * 			  or even one pin.
 */
ERROR_STATUS DIO_Write(uint8 GPIO, uint8 pins, uint8 value)
{
    686a:	df 93       	push	r29
    686c:	cf 93       	push	r28
    686e:	00 d0       	rcall	.+0      	; 0x6870 <DIO_Write+0x6>
    6870:	00 d0       	rcall	.+0      	; 0x6872 <DIO_Write+0x8>
    6872:	00 d0       	rcall	.+0      	; 0x6874 <DIO_Write+0xa>
    6874:	cd b7       	in	r28, 0x3d	; 61
    6876:	de b7       	in	r29, 0x3e	; 62
    6878:	8a 83       	std	Y+2, r24	; 0x02
    687a:	6b 83       	std	Y+3, r22	; 0x03
    687c:	4c 83       	std	Y+4, r20	; 0x04
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = DIO_BASE_ERROR + ERR_SUCCESS;
    687e:	86 ef       	ldi	r24, 0xF6	; 246
    6880:	89 83       	std	Y+1, r24	; 0x01
	/*
	 * 	check Value
	 */
	if (value == HIGH || value == LOW)
    6882:	8c 81       	ldd	r24, Y+4	; 0x04
    6884:	8f 3f       	cpi	r24, 0xFF	; 255
    6886:	21 f0       	breq	.+8      	; 0x6890 <DIO_Write+0x26>
    6888:	8c 81       	ldd	r24, Y+4	; 0x04
    688a:	88 23       	and	r24, r24
    688c:	09 f0       	breq	.+2      	; 0x6890 <DIO_Write+0x26>
    688e:	62 c0       	rjmp	.+196    	; 0x6954 <DIO_Write+0xea>
	{
		/*
		 * Check on the Required PORT Number
		 */
		switch (GPIO)
    6890:	8a 81       	ldd	r24, Y+2	; 0x02
    6892:	28 2f       	mov	r18, r24
    6894:	30 e0       	ldi	r19, 0x00	; 0
    6896:	3e 83       	std	Y+6, r19	; 0x06
    6898:	2d 83       	std	Y+5, r18	; 0x05
    689a:	8d 81       	ldd	r24, Y+5	; 0x05
    689c:	9e 81       	ldd	r25, Y+6	; 0x06
    689e:	81 30       	cpi	r24, 0x01	; 1
    68a0:	91 05       	cpc	r25, r1
    68a2:	29 f1       	breq	.+74     	; 0x68ee <DIO_Write+0x84>
    68a4:	2d 81       	ldd	r18, Y+5	; 0x05
    68a6:	3e 81       	ldd	r19, Y+6	; 0x06
    68a8:	22 30       	cpi	r18, 0x02	; 2
    68aa:	31 05       	cpc	r19, r1
    68ac:	2c f4       	brge	.+10     	; 0x68b8 <DIO_Write+0x4e>
    68ae:	8d 81       	ldd	r24, Y+5	; 0x05
    68b0:	9e 81       	ldd	r25, Y+6	; 0x06
    68b2:	00 97       	sbiw	r24, 0x00	; 0
    68b4:	61 f0       	breq	.+24     	; 0x68ce <DIO_Write+0x64>
    68b6:	4b c0       	rjmp	.+150    	; 0x694e <DIO_Write+0xe4>
    68b8:	2d 81       	ldd	r18, Y+5	; 0x05
    68ba:	3e 81       	ldd	r19, Y+6	; 0x06
    68bc:	22 30       	cpi	r18, 0x02	; 2
    68be:	31 05       	cpc	r19, r1
    68c0:	31 f1       	breq	.+76     	; 0x690e <DIO_Write+0xa4>
    68c2:	8d 81       	ldd	r24, Y+5	; 0x05
    68c4:	9e 81       	ldd	r25, Y+6	; 0x06
    68c6:	83 30       	cpi	r24, 0x03	; 3
    68c8:	91 05       	cpc	r25, r1
    68ca:	89 f1       	breq	.+98     	; 0x692e <DIO_Write+0xc4>
    68cc:	40 c0       	rjmp	.+128    	; 0x694e <DIO_Write+0xe4>
		{
		case GPIOA:
			ASSIGN_BIT(PORTA_DATA, pins, value);
    68ce:	ab e3       	ldi	r26, 0x3B	; 59
    68d0:	b0 e0       	ldi	r27, 0x00	; 0
    68d2:	eb e3       	ldi	r30, 0x3B	; 59
    68d4:	f0 e0       	ldi	r31, 0x00	; 0
    68d6:	80 81       	ld	r24, Z
    68d8:	98 2f       	mov	r25, r24
    68da:	8b 81       	ldd	r24, Y+3	; 0x03
    68dc:	80 95       	com	r24
    68de:	29 2f       	mov	r18, r25
    68e0:	28 23       	and	r18, r24
    68e2:	9c 81       	ldd	r25, Y+4	; 0x04
    68e4:	8b 81       	ldd	r24, Y+3	; 0x03
    68e6:	89 23       	and	r24, r25
    68e8:	82 2b       	or	r24, r18
    68ea:	8c 93       	st	X, r24
    68ec:	35 c0       	rjmp	.+106    	; 0x6958 <DIO_Write+0xee>
			break;
		case GPIOB:
			ASSIGN_BIT(PORTB_DATA, pins, value);
    68ee:	a8 e3       	ldi	r26, 0x38	; 56
    68f0:	b0 e0       	ldi	r27, 0x00	; 0
    68f2:	e8 e3       	ldi	r30, 0x38	; 56
    68f4:	f0 e0       	ldi	r31, 0x00	; 0
    68f6:	80 81       	ld	r24, Z
    68f8:	98 2f       	mov	r25, r24
    68fa:	8b 81       	ldd	r24, Y+3	; 0x03
    68fc:	80 95       	com	r24
    68fe:	29 2f       	mov	r18, r25
    6900:	28 23       	and	r18, r24
    6902:	9c 81       	ldd	r25, Y+4	; 0x04
    6904:	8b 81       	ldd	r24, Y+3	; 0x03
    6906:	89 23       	and	r24, r25
    6908:	82 2b       	or	r24, r18
    690a:	8c 93       	st	X, r24
    690c:	25 c0       	rjmp	.+74     	; 0x6958 <DIO_Write+0xee>
			break;
		case GPIOC:
			ASSIGN_BIT(PORTC_DATA, pins, value);
    690e:	a5 e3       	ldi	r26, 0x35	; 53
    6910:	b0 e0       	ldi	r27, 0x00	; 0
    6912:	e5 e3       	ldi	r30, 0x35	; 53
    6914:	f0 e0       	ldi	r31, 0x00	; 0
    6916:	80 81       	ld	r24, Z
    6918:	98 2f       	mov	r25, r24
    691a:	8b 81       	ldd	r24, Y+3	; 0x03
    691c:	80 95       	com	r24
    691e:	29 2f       	mov	r18, r25
    6920:	28 23       	and	r18, r24
    6922:	9c 81       	ldd	r25, Y+4	; 0x04
    6924:	8b 81       	ldd	r24, Y+3	; 0x03
    6926:	89 23       	and	r24, r25
    6928:	82 2b       	or	r24, r18
    692a:	8c 93       	st	X, r24
    692c:	15 c0       	rjmp	.+42     	; 0x6958 <DIO_Write+0xee>
			break;
		case GPIOD:
			ASSIGN_BIT(PORTD_DATA, pins, value);
    692e:	a2 e3       	ldi	r26, 0x32	; 50
    6930:	b0 e0       	ldi	r27, 0x00	; 0
    6932:	e2 e3       	ldi	r30, 0x32	; 50
    6934:	f0 e0       	ldi	r31, 0x00	; 0
    6936:	80 81       	ld	r24, Z
    6938:	98 2f       	mov	r25, r24
    693a:	8b 81       	ldd	r24, Y+3	; 0x03
    693c:	80 95       	com	r24
    693e:	29 2f       	mov	r18, r25
    6940:	28 23       	and	r18, r24
    6942:	9c 81       	ldd	r25, Y+4	; 0x04
    6944:	8b 81       	ldd	r24, Y+3	; 0x03
    6946:	89 23       	and	r24, r25
    6948:	82 2b       	or	r24, r18
    694a:	8c 93       	st	X, r24
    694c:	05 c0       	rjmp	.+10     	; 0x6958 <DIO_Write+0xee>
			break;
		default:
			/*
			 *  Wrong Port Number
			 */
			s8_ErrorStatus = DIO_BASE_ERROR + ERR_INVALID_ARGU;
    694e:	85 ef       	ldi	r24, 0xF5	; 245
    6950:	89 83       	std	Y+1, r24	; 0x01
    6952:	02 c0       	rjmp	.+4      	; 0x6958 <DIO_Write+0xee>
	else
	{
		/*
		 *  Wrong Direction
		 */
		s8_ErrorStatus = DIO_BASE_ERROR + ERR_INVALID_ARGU;
    6954:	85 ef       	ldi	r24, 0xF5	; 245
    6956:	89 83       	std	Y+1, r24	; 0x01
	}
	/*
	 * Function shall return the Error state
	 */
	return s8_ErrorStatus;
    6958:	89 81       	ldd	r24, Y+1	; 0x01
}
    695a:	26 96       	adiw	r28, 0x06	; 6
    695c:	0f b6       	in	r0, 0x3f	; 63
    695e:	f8 94       	cli
    6960:	de bf       	out	0x3e, r29	; 62
    6962:	0f be       	out	0x3f, r0	; 63
    6964:	cd bf       	out	0x3d, r28	; 61
    6966:	cf 91       	pop	r28
    6968:	df 91       	pop	r29
    696a:	08 95       	ret

0000696c <DIO_Read>:
 *In/Out:
 *Description: This function gets the value of a full port, a nibble
 * 			  or even one pin.
 */
ERROR_STATUS DIO_Read(uint8 GPIO, uint8 pins, uint8 *data)
{
    696c:	df 93       	push	r29
    696e:	cf 93       	push	r28
    6970:	cd b7       	in	r28, 0x3d	; 61
    6972:	de b7       	in	r29, 0x3e	; 62
    6974:	27 97       	sbiw	r28, 0x07	; 7
    6976:	0f b6       	in	r0, 0x3f	; 63
    6978:	f8 94       	cli
    697a:	de bf       	out	0x3e, r29	; 62
    697c:	0f be       	out	0x3f, r0	; 63
    697e:	cd bf       	out	0x3d, r28	; 61
    6980:	8a 83       	std	Y+2, r24	; 0x02
    6982:	6b 83       	std	Y+3, r22	; 0x03
    6984:	5d 83       	std	Y+5, r21	; 0x05
    6986:	4c 83       	std	Y+4, r20	; 0x04
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = DIO_BASE_ERROR + ERR_SUCCESS;
    6988:	86 ef       	ldi	r24, 0xF6	; 246
    698a:	89 83       	std	Y+1, r24	; 0x01

	if (data == NULL)
    698c:	8c 81       	ldd	r24, Y+4	; 0x04
    698e:	9d 81       	ldd	r25, Y+5	; 0x05
    6990:	00 97       	sbiw	r24, 0x00	; 0
    6992:	19 f4       	brne	.+6      	; 0x699a <DIO_Read+0x2e>
	{
		/*
		 * trying to access a null pointer
		 */
		s8_ErrorStatus = DIO_BASE_ERROR + ERR_NULL_PTR;
    6994:	82 ef       	ldi	r24, 0xF2	; 242
    6996:	89 83       	std	Y+1, r24	; 0x01
    6998:	45 c0       	rjmp	.+138    	; 0x6a24 <DIO_Read+0xb8>
	else
	{
		/*
		 * Check on the Required PORT Number
		 */
		switch (GPIO)
    699a:	8a 81       	ldd	r24, Y+2	; 0x02
    699c:	28 2f       	mov	r18, r24
    699e:	30 e0       	ldi	r19, 0x00	; 0
    69a0:	3f 83       	std	Y+7, r19	; 0x07
    69a2:	2e 83       	std	Y+6, r18	; 0x06
    69a4:	8e 81       	ldd	r24, Y+6	; 0x06
    69a6:	9f 81       	ldd	r25, Y+7	; 0x07
    69a8:	81 30       	cpi	r24, 0x01	; 1
    69aa:	91 05       	cpc	r25, r1
    69ac:	f1 f0       	breq	.+60     	; 0x69ea <DIO_Read+0x7e>
    69ae:	2e 81       	ldd	r18, Y+6	; 0x06
    69b0:	3f 81       	ldd	r19, Y+7	; 0x07
    69b2:	22 30       	cpi	r18, 0x02	; 2
    69b4:	31 05       	cpc	r19, r1
    69b6:	2c f4       	brge	.+10     	; 0x69c2 <DIO_Read+0x56>
    69b8:	8e 81       	ldd	r24, Y+6	; 0x06
    69ba:	9f 81       	ldd	r25, Y+7	; 0x07
    69bc:	00 97       	sbiw	r24, 0x00	; 0
    69be:	61 f0       	breq	.+24     	; 0x69d8 <DIO_Read+0x6c>
    69c0:	2f c0       	rjmp	.+94     	; 0x6a20 <DIO_Read+0xb4>
    69c2:	2e 81       	ldd	r18, Y+6	; 0x06
    69c4:	3f 81       	ldd	r19, Y+7	; 0x07
    69c6:	22 30       	cpi	r18, 0x02	; 2
    69c8:	31 05       	cpc	r19, r1
    69ca:	c1 f0       	breq	.+48     	; 0x69fc <DIO_Read+0x90>
    69cc:	8e 81       	ldd	r24, Y+6	; 0x06
    69ce:	9f 81       	ldd	r25, Y+7	; 0x07
    69d0:	83 30       	cpi	r24, 0x03	; 3
    69d2:	91 05       	cpc	r25, r1
    69d4:	e1 f0       	breq	.+56     	; 0x6a0e <DIO_Read+0xa2>
    69d6:	24 c0       	rjmp	.+72     	; 0x6a20 <DIO_Read+0xb4>
		{
		case GPIOA:
			*data = (PORTA_PIN & pins);
    69d8:	e9 e3       	ldi	r30, 0x39	; 57
    69da:	f0 e0       	ldi	r31, 0x00	; 0
    69dc:	90 81       	ld	r25, Z
    69de:	8b 81       	ldd	r24, Y+3	; 0x03
    69e0:	89 23       	and	r24, r25
    69e2:	ec 81       	ldd	r30, Y+4	; 0x04
    69e4:	fd 81       	ldd	r31, Y+5	; 0x05
    69e6:	80 83       	st	Z, r24
    69e8:	1d c0       	rjmp	.+58     	; 0x6a24 <DIO_Read+0xb8>
			break;
		case GPIOB:
			*data = (PORTB_PIN & pins);
    69ea:	e6 e3       	ldi	r30, 0x36	; 54
    69ec:	f0 e0       	ldi	r31, 0x00	; 0
    69ee:	90 81       	ld	r25, Z
    69f0:	8b 81       	ldd	r24, Y+3	; 0x03
    69f2:	89 23       	and	r24, r25
    69f4:	ec 81       	ldd	r30, Y+4	; 0x04
    69f6:	fd 81       	ldd	r31, Y+5	; 0x05
    69f8:	80 83       	st	Z, r24
    69fa:	14 c0       	rjmp	.+40     	; 0x6a24 <DIO_Read+0xb8>
			break;
		case GPIOC:
			*data = (PORTC_PIN & pins);
    69fc:	e3 e3       	ldi	r30, 0x33	; 51
    69fe:	f0 e0       	ldi	r31, 0x00	; 0
    6a00:	90 81       	ld	r25, Z
    6a02:	8b 81       	ldd	r24, Y+3	; 0x03
    6a04:	89 23       	and	r24, r25
    6a06:	ec 81       	ldd	r30, Y+4	; 0x04
    6a08:	fd 81       	ldd	r31, Y+5	; 0x05
    6a0a:	80 83       	st	Z, r24
    6a0c:	0b c0       	rjmp	.+22     	; 0x6a24 <DIO_Read+0xb8>
			break;
		case GPIOD:
			*data = (PORTD_PIN & pins);
    6a0e:	e0 e3       	ldi	r30, 0x30	; 48
    6a10:	f0 e0       	ldi	r31, 0x00	; 0
    6a12:	90 81       	ld	r25, Z
    6a14:	8b 81       	ldd	r24, Y+3	; 0x03
    6a16:	89 23       	and	r24, r25
    6a18:	ec 81       	ldd	r30, Y+4	; 0x04
    6a1a:	fd 81       	ldd	r31, Y+5	; 0x05
    6a1c:	80 83       	st	Z, r24
    6a1e:	02 c0       	rjmp	.+4      	; 0x6a24 <DIO_Read+0xb8>
			break;
		default:
			/*
			 *  Wrong Port Number
			 */
			s8_ErrorStatus = DIO_BASE_ERROR + ERR_INVALID_ARGU;
    6a20:	85 ef       	ldi	r24, 0xF5	; 245
    6a22:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	/*
	 * Function shall return the Error state
	 */
	return s8_ErrorStatus;
    6a24:	89 81       	ldd	r24, Y+1	; 0x01
}
    6a26:	27 96       	adiw	r28, 0x07	; 7
    6a28:	0f b6       	in	r0, 0x3f	; 63
    6a2a:	f8 94       	cli
    6a2c:	de bf       	out	0x3e, r29	; 62
    6a2e:	0f be       	out	0x3f, r0	; 63
    6a30:	cd bf       	out	0x3d, r28	; 61
    6a32:	cf 91       	pop	r28
    6a34:	df 91       	pop	r29
    6a36:	08 95       	ret

00006a38 <DIO_Toggle>:
 *In/Out:
 *Description: This function toggles the value of a full port, a nibble
 * 			  or even one pin.
 */
ERROR_STATUS DIO_Toggle(uint8 GPIO, uint8 pins)
{
    6a38:	df 93       	push	r29
    6a3a:	cf 93       	push	r28
    6a3c:	00 d0       	rcall	.+0      	; 0x6a3e <DIO_Toggle+0x6>
    6a3e:	00 d0       	rcall	.+0      	; 0x6a40 <DIO_Toggle+0x8>
    6a40:	0f 92       	push	r0
    6a42:	cd b7       	in	r28, 0x3d	; 61
    6a44:	de b7       	in	r29, 0x3e	; 62
    6a46:	8a 83       	std	Y+2, r24	; 0x02
    6a48:	6b 83       	std	Y+3, r22	; 0x03
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = DIO_BASE_ERROR + ERR_SUCCESS;
    6a4a:	86 ef       	ldi	r24, 0xF6	; 246
    6a4c:	89 83       	std	Y+1, r24	; 0x01

	/*
	 * Check on the Required PORT Number
	 */
	switch (GPIO)
    6a4e:	8a 81       	ldd	r24, Y+2	; 0x02
    6a50:	28 2f       	mov	r18, r24
    6a52:	30 e0       	ldi	r19, 0x00	; 0
    6a54:	3d 83       	std	Y+5, r19	; 0x05
    6a56:	2c 83       	std	Y+4, r18	; 0x04
    6a58:	8c 81       	ldd	r24, Y+4	; 0x04
    6a5a:	9d 81       	ldd	r25, Y+5	; 0x05
    6a5c:	81 30       	cpi	r24, 0x01	; 1
    6a5e:	91 05       	cpc	r25, r1
    6a60:	f1 f0       	breq	.+60     	; 0x6a9e <DIO_Toggle+0x66>
    6a62:	2c 81       	ldd	r18, Y+4	; 0x04
    6a64:	3d 81       	ldd	r19, Y+5	; 0x05
    6a66:	22 30       	cpi	r18, 0x02	; 2
    6a68:	31 05       	cpc	r19, r1
    6a6a:	2c f4       	brge	.+10     	; 0x6a76 <DIO_Toggle+0x3e>
    6a6c:	8c 81       	ldd	r24, Y+4	; 0x04
    6a6e:	9d 81       	ldd	r25, Y+5	; 0x05
    6a70:	00 97       	sbiw	r24, 0x00	; 0
    6a72:	61 f0       	breq	.+24     	; 0x6a8c <DIO_Toggle+0x54>
    6a74:	2f c0       	rjmp	.+94     	; 0x6ad4 <DIO_Toggle+0x9c>
    6a76:	2c 81       	ldd	r18, Y+4	; 0x04
    6a78:	3d 81       	ldd	r19, Y+5	; 0x05
    6a7a:	22 30       	cpi	r18, 0x02	; 2
    6a7c:	31 05       	cpc	r19, r1
    6a7e:	c1 f0       	breq	.+48     	; 0x6ab0 <DIO_Toggle+0x78>
    6a80:	8c 81       	ldd	r24, Y+4	; 0x04
    6a82:	9d 81       	ldd	r25, Y+5	; 0x05
    6a84:	83 30       	cpi	r24, 0x03	; 3
    6a86:	91 05       	cpc	r25, r1
    6a88:	e1 f0       	breq	.+56     	; 0x6ac2 <DIO_Toggle+0x8a>
    6a8a:	24 c0       	rjmp	.+72     	; 0x6ad4 <DIO_Toggle+0x9c>
	{
	case GPIOA:
		PORTA_DATA ^= (pins);
    6a8c:	ab e3       	ldi	r26, 0x3B	; 59
    6a8e:	b0 e0       	ldi	r27, 0x00	; 0
    6a90:	eb e3       	ldi	r30, 0x3B	; 59
    6a92:	f0 e0       	ldi	r31, 0x00	; 0
    6a94:	90 81       	ld	r25, Z
    6a96:	8b 81       	ldd	r24, Y+3	; 0x03
    6a98:	89 27       	eor	r24, r25
    6a9a:	8c 93       	st	X, r24
    6a9c:	1d c0       	rjmp	.+58     	; 0x6ad8 <DIO_Toggle+0xa0>
		break;
	case GPIOB:
		PORTB_DATA ^= (pins);
    6a9e:	a8 e3       	ldi	r26, 0x38	; 56
    6aa0:	b0 e0       	ldi	r27, 0x00	; 0
    6aa2:	e8 e3       	ldi	r30, 0x38	; 56
    6aa4:	f0 e0       	ldi	r31, 0x00	; 0
    6aa6:	90 81       	ld	r25, Z
    6aa8:	8b 81       	ldd	r24, Y+3	; 0x03
    6aaa:	89 27       	eor	r24, r25
    6aac:	8c 93       	st	X, r24
    6aae:	14 c0       	rjmp	.+40     	; 0x6ad8 <DIO_Toggle+0xa0>
		break;
	case GPIOC:
		PORTC_DATA ^= (pins);
    6ab0:	a5 e3       	ldi	r26, 0x35	; 53
    6ab2:	b0 e0       	ldi	r27, 0x00	; 0
    6ab4:	e5 e3       	ldi	r30, 0x35	; 53
    6ab6:	f0 e0       	ldi	r31, 0x00	; 0
    6ab8:	90 81       	ld	r25, Z
    6aba:	8b 81       	ldd	r24, Y+3	; 0x03
    6abc:	89 27       	eor	r24, r25
    6abe:	8c 93       	st	X, r24
    6ac0:	0b c0       	rjmp	.+22     	; 0x6ad8 <DIO_Toggle+0xa0>
		break;
	case GPIOD:
		PORTD_DATA ^= (pins);
    6ac2:	a2 e3       	ldi	r26, 0x32	; 50
    6ac4:	b0 e0       	ldi	r27, 0x00	; 0
    6ac6:	e2 e3       	ldi	r30, 0x32	; 50
    6ac8:	f0 e0       	ldi	r31, 0x00	; 0
    6aca:	90 81       	ld	r25, Z
    6acc:	8b 81       	ldd	r24, Y+3	; 0x03
    6ace:	89 27       	eor	r24, r25
    6ad0:	8c 93       	st	X, r24
    6ad2:	02 c0       	rjmp	.+4      	; 0x6ad8 <DIO_Toggle+0xa0>
		break;
	default:
		/*
		 *  Wrong Port Number
		 */
		s8_ErrorStatus = DIO_BASE_ERROR + ERR_INVALID_ARGU;
    6ad4:	85 ef       	ldi	r24, 0xF5	; 245
    6ad6:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	/*
	 * Function shall return the Error state
	 */
	return s8_ErrorStatus;
    6ad8:	89 81       	ldd	r24, Y+1	; 0x01
}
    6ada:	0f 90       	pop	r0
    6adc:	0f 90       	pop	r0
    6ade:	0f 90       	pop	r0
    6ae0:	0f 90       	pop	r0
    6ae2:	0f 90       	pop	r0
    6ae4:	cf 91       	pop	r28
    6ae6:	df 91       	pop	r29
    6ae8:	08 95       	ret

00006aea <pushButton_Init>:
 * 				  one of the enum (En_buttonId) parameters
 *
 */

void pushButton_Init(En_buttonId btn_id)
{
    6aea:	df 93       	push	r29
    6aec:	cf 93       	push	r28
    6aee:	00 d0       	rcall	.+0      	; 0x6af0 <pushButton_Init+0x6>
    6af0:	00 d0       	rcall	.+0      	; 0x6af2 <pushButton_Init+0x8>
    6af2:	00 d0       	rcall	.+0      	; 0x6af4 <pushButton_Init+0xa>
    6af4:	cd b7       	in	r28, 0x3d	; 61
    6af6:	de b7       	in	r29, 0x3e	; 62
    6af8:	8c 83       	std	Y+4, r24	; 0x04
	avrbuttons[buttonNo].buttonID = btn_id;
    6afa:	80 91 e3 07 	lds	r24, 0x07E3
    6afe:	88 2f       	mov	r24, r24
    6b00:	90 e0       	ldi	r25, 0x00	; 0
    6b02:	88 0f       	add	r24, r24
    6b04:	99 1f       	adc	r25, r25
    6b06:	88 0f       	add	r24, r24
    6b08:	99 1f       	adc	r25, r25
    6b0a:	fc 01       	movw	r30, r24
    6b0c:	ec 51       	subi	r30, 0x1C	; 28
    6b0e:	f8 4f       	sbci	r31, 0xF8	; 248
    6b10:	8c 81       	ldd	r24, Y+4	; 0x04
    6b12:	80 83       	st	Z, r24
	DIO_Cfg_s DIO_Cfg;
	switch (btn_id)
    6b14:	8c 81       	ldd	r24, Y+4	; 0x04
    6b16:	28 2f       	mov	r18, r24
    6b18:	30 e0       	ldi	r19, 0x00	; 0
    6b1a:	3e 83       	std	Y+6, r19	; 0x06
    6b1c:	2d 83       	std	Y+5, r18	; 0x05
    6b1e:	8d 81       	ldd	r24, Y+5	; 0x05
    6b20:	9e 81       	ldd	r25, Y+6	; 0x06
    6b22:	00 97       	sbiw	r24, 0x00	; 0
    6b24:	31 f0       	breq	.+12     	; 0x6b32 <pushButton_Init+0x48>
    6b26:	2d 81       	ldd	r18, Y+5	; 0x05
    6b28:	3e 81       	ldd	r19, Y+6	; 0x06
    6b2a:	21 30       	cpi	r18, 0x01	; 1
    6b2c:	31 05       	cpc	r19, r1
    6b2e:	31 f1       	breq	.+76     	; 0x6b7c <pushButton_Init+0x92>
    6b30:	49 c0       	rjmp	.+146    	; 0x6bc4 <pushButton_Init+0xda>
	{
	case BTN_0:
		DIO_Cfg.GPIO = BTN_0_GPIO;
    6b32:	82 e0       	ldi	r24, 0x02	; 2
    6b34:	89 83       	std	Y+1, r24	; 0x01
		DIO_Cfg.pins = BTN_0_BIT;
    6b36:	80 e1       	ldi	r24, 0x10	; 16
    6b38:	8a 83       	std	Y+2, r24	; 0x02
		DIO_Cfg.dir = INPUT;
    6b3a:	1b 82       	std	Y+3, r1	; 0x03
		DIO_init(&DIO_Cfg);
    6b3c:	ce 01       	movw	r24, r28
    6b3e:	01 96       	adiw	r24, 0x01	; 1
    6b40:	0e 94 90 33 	call	0x6720	; 0x6720 <DIO_init>
		avrbuttons[buttonNo].GPIOPort = BTN_0_GPIO;
    6b44:	80 91 e3 07 	lds	r24, 0x07E3
    6b48:	88 2f       	mov	r24, r24
    6b4a:	90 e0       	ldi	r25, 0x00	; 0
    6b4c:	88 0f       	add	r24, r24
    6b4e:	99 1f       	adc	r25, r25
    6b50:	88 0f       	add	r24, r24
    6b52:	99 1f       	adc	r25, r25
    6b54:	fc 01       	movw	r30, r24
    6b56:	eb 51       	subi	r30, 0x1B	; 27
    6b58:	f8 4f       	sbci	r31, 0xF8	; 248
    6b5a:	82 e0       	ldi	r24, 0x02	; 2
    6b5c:	80 83       	st	Z, r24
		avrbuttons[buttonNo].buttonBit = BTN_0_BIT;
    6b5e:	80 91 e3 07 	lds	r24, 0x07E3
    6b62:	88 2f       	mov	r24, r24
    6b64:	90 e0       	ldi	r25, 0x00	; 0
    6b66:	88 0f       	add	r24, r24
    6b68:	99 1f       	adc	r25, r25
    6b6a:	01 96       	adiw	r24, 0x01	; 1
    6b6c:	88 0f       	add	r24, r24
    6b6e:	99 1f       	adc	r25, r25
    6b70:	fc 01       	movw	r30, r24
    6b72:	ec 51       	subi	r30, 0x1C	; 28
    6b74:	f8 4f       	sbci	r31, 0xF8	; 248
    6b76:	80 e1       	ldi	r24, 0x10	; 16
    6b78:	80 83       	st	Z, r24
    6b7a:	24 c0       	rjmp	.+72     	; 0x6bc4 <pushButton_Init+0xda>
		break;
	case BTN_1:
		DIO_Cfg.GPIO = BTN_1_GPIO;
    6b7c:	81 e0       	ldi	r24, 0x01	; 1
    6b7e:	89 83       	std	Y+1, r24	; 0x01
		DIO_Cfg.pins = BTN_1_BIT;
    6b80:	84 e0       	ldi	r24, 0x04	; 4
    6b82:	8a 83       	std	Y+2, r24	; 0x02
		DIO_Cfg.dir = INPUT;
    6b84:	1b 82       	std	Y+3, r1	; 0x03
		DIO_init(&DIO_Cfg);
    6b86:	ce 01       	movw	r24, r28
    6b88:	01 96       	adiw	r24, 0x01	; 1
    6b8a:	0e 94 90 33 	call	0x6720	; 0x6720 <DIO_init>
		avrbuttons[buttonNo].GPIOPort = BTN_1_GPIO;
    6b8e:	80 91 e3 07 	lds	r24, 0x07E3
    6b92:	88 2f       	mov	r24, r24
    6b94:	90 e0       	ldi	r25, 0x00	; 0
    6b96:	88 0f       	add	r24, r24
    6b98:	99 1f       	adc	r25, r25
    6b9a:	88 0f       	add	r24, r24
    6b9c:	99 1f       	adc	r25, r25
    6b9e:	fc 01       	movw	r30, r24
    6ba0:	eb 51       	subi	r30, 0x1B	; 27
    6ba2:	f8 4f       	sbci	r31, 0xF8	; 248
    6ba4:	81 e0       	ldi	r24, 0x01	; 1
    6ba6:	80 83       	st	Z, r24
		avrbuttons[buttonNo].buttonBit = BTN_1_BIT;
    6ba8:	80 91 e3 07 	lds	r24, 0x07E3
    6bac:	88 2f       	mov	r24, r24
    6bae:	90 e0       	ldi	r25, 0x00	; 0
    6bb0:	88 0f       	add	r24, r24
    6bb2:	99 1f       	adc	r25, r25
    6bb4:	01 96       	adiw	r24, 0x01	; 1
    6bb6:	88 0f       	add	r24, r24
    6bb8:	99 1f       	adc	r25, r25
    6bba:	fc 01       	movw	r30, r24
    6bbc:	ec 51       	subi	r30, 0x1C	; 28
    6bbe:	f8 4f       	sbci	r31, 0xF8	; 248
    6bc0:	84 e0       	ldi	r24, 0x04	; 4
    6bc2:	80 83       	st	Z, r24
		break;
	default:
		break;
	}
	buttonNo++;
    6bc4:	80 91 e3 07 	lds	r24, 0x07E3
    6bc8:	8f 5f       	subi	r24, 0xFF	; 255
    6bca:	80 93 e3 07 	sts	0x07E3, r24

}
    6bce:	26 96       	adiw	r28, 0x06	; 6
    6bd0:	0f b6       	in	r0, 0x3f	; 63
    6bd2:	f8 94       	cli
    6bd4:	de bf       	out	0x3e, r29	; 62
    6bd6:	0f be       	out	0x3f, r0	; 63
    6bd8:	cd bf       	out	0x3d, r28	; 61
    6bda:	cf 91       	pop	r28
    6bdc:	df 91       	pop	r29
    6bde:	08 95       	ret

00006be0 <pushButton_Update>:
 * Description: read all BTN_x (where x 0, 1, 2, 3) states and store it in the program
 *
 * @note : this function must be called in the system tick hundler or in the super loop hundler
 */
void pushButton_Update(void)
{
    6be0:	df 93       	push	r29
    6be2:	cf 93       	push	r28
    6be4:	00 d0       	rcall	.+0      	; 0x6be6 <pushButton_Update+0x6>
    6be6:	cd b7       	in	r28, 0x3d	; 61
    6be8:	de b7       	in	r29, 0x3e	; 62
	uint8 READData;
	for (uint8 i = 0; i < buttonNo; i++)
    6bea:	19 82       	std	Y+1, r1	; 0x01
    6bec:	98 c0       	rjmp	.+304    	; 0x6d1e <pushButton_Update+0x13e>
	{

		DIO_Read(avrbuttons[i].GPIOPort, avrbuttons[i].buttonBit, &READData);
    6bee:	89 81       	ldd	r24, Y+1	; 0x01
    6bf0:	88 2f       	mov	r24, r24
    6bf2:	90 e0       	ldi	r25, 0x00	; 0
    6bf4:	88 0f       	add	r24, r24
    6bf6:	99 1f       	adc	r25, r25
    6bf8:	88 0f       	add	r24, r24
    6bfa:	99 1f       	adc	r25, r25
    6bfc:	fc 01       	movw	r30, r24
    6bfe:	eb 51       	subi	r30, 0x1B	; 27
    6c00:	f8 4f       	sbci	r31, 0xF8	; 248
    6c02:	40 81       	ld	r20, Z
    6c04:	89 81       	ldd	r24, Y+1	; 0x01
    6c06:	88 2f       	mov	r24, r24
    6c08:	90 e0       	ldi	r25, 0x00	; 0
    6c0a:	88 0f       	add	r24, r24
    6c0c:	99 1f       	adc	r25, r25
    6c0e:	01 96       	adiw	r24, 0x01	; 1
    6c10:	88 0f       	add	r24, r24
    6c12:	99 1f       	adc	r25, r25
    6c14:	fc 01       	movw	r30, r24
    6c16:	ec 51       	subi	r30, 0x1C	; 28
    6c18:	f8 4f       	sbci	r31, 0xF8	; 248
    6c1a:	90 81       	ld	r25, Z
    6c1c:	9e 01       	movw	r18, r28
    6c1e:	2e 5f       	subi	r18, 0xFE	; 254
    6c20:	3f 4f       	sbci	r19, 0xFF	; 255
    6c22:	84 2f       	mov	r24, r20
    6c24:	69 2f       	mov	r22, r25
    6c26:	a9 01       	movw	r20, r18
    6c28:	0e 94 b6 34 	call	0x696c	; 0x696c <DIO_Read>
		if (READData == avrbuttons[i].buttonBit)
    6c2c:	89 81       	ldd	r24, Y+1	; 0x01
    6c2e:	88 2f       	mov	r24, r24
    6c30:	90 e0       	ldi	r25, 0x00	; 0
    6c32:	88 0f       	add	r24, r24
    6c34:	99 1f       	adc	r25, r25
    6c36:	01 96       	adiw	r24, 0x01	; 1
    6c38:	88 0f       	add	r24, r24
    6c3a:	99 1f       	adc	r25, r25
    6c3c:	fc 01       	movw	r30, r24
    6c3e:	ec 51       	subi	r30, 0x1C	; 28
    6c40:	f8 4f       	sbci	r31, 0xF8	; 248
    6c42:	90 81       	ld	r25, Z
    6c44:	8a 81       	ldd	r24, Y+2	; 0x02
    6c46:	98 17       	cp	r25, r24
    6c48:	a9 f5       	brne	.+106    	; 0x6cb4 <pushButton_Update+0xd4>
		{
			if (avrbuttons[i].buttonStatus == Released)
    6c4a:	89 81       	ldd	r24, Y+1	; 0x01
    6c4c:	88 2f       	mov	r24, r24
    6c4e:	90 e0       	ldi	r25, 0x00	; 0
    6c50:	88 0f       	add	r24, r24
    6c52:	99 1f       	adc	r25, r25
    6c54:	88 0f       	add	r24, r24
    6c56:	99 1f       	adc	r25, r25
    6c58:	fc 01       	movw	r30, r24
    6c5a:	e9 51       	subi	r30, 0x19	; 25
    6c5c:	f8 4f       	sbci	r31, 0xF8	; 248
    6c5e:	80 81       	ld	r24, Z
    6c60:	88 23       	and	r24, r24
    6c62:	69 f4       	brne	.+26     	; 0x6c7e <pushButton_Update+0x9e>
			{
				avrbuttons[i].buttonStatus = Prepressed;
    6c64:	89 81       	ldd	r24, Y+1	; 0x01
    6c66:	88 2f       	mov	r24, r24
    6c68:	90 e0       	ldi	r25, 0x00	; 0
    6c6a:	88 0f       	add	r24, r24
    6c6c:	99 1f       	adc	r25, r25
    6c6e:	88 0f       	add	r24, r24
    6c70:	99 1f       	adc	r25, r25
    6c72:	fc 01       	movw	r30, r24
    6c74:	e9 51       	subi	r30, 0x19	; 25
    6c76:	f8 4f       	sbci	r31, 0xF8	; 248
    6c78:	81 e0       	ldi	r24, 0x01	; 1
    6c7a:	80 83       	st	Z, r24
    6c7c:	4d c0       	rjmp	.+154    	; 0x6d18 <pushButton_Update+0x138>
			}
			else if (avrbuttons[i].buttonStatus == Prepressed)
    6c7e:	89 81       	ldd	r24, Y+1	; 0x01
    6c80:	88 2f       	mov	r24, r24
    6c82:	90 e0       	ldi	r25, 0x00	; 0
    6c84:	88 0f       	add	r24, r24
    6c86:	99 1f       	adc	r25, r25
    6c88:	88 0f       	add	r24, r24
    6c8a:	99 1f       	adc	r25, r25
    6c8c:	fc 01       	movw	r30, r24
    6c8e:	e9 51       	subi	r30, 0x19	; 25
    6c90:	f8 4f       	sbci	r31, 0xF8	; 248
    6c92:	80 81       	ld	r24, Z
    6c94:	81 30       	cpi	r24, 0x01	; 1
    6c96:	09 f0       	breq	.+2      	; 0x6c9a <pushButton_Update+0xba>
    6c98:	3f c0       	rjmp	.+126    	; 0x6d18 <pushButton_Update+0x138>
			{
				avrbuttons[i].buttonStatus = Pressed;
    6c9a:	89 81       	ldd	r24, Y+1	; 0x01
    6c9c:	88 2f       	mov	r24, r24
    6c9e:	90 e0       	ldi	r25, 0x00	; 0
    6ca0:	88 0f       	add	r24, r24
    6ca2:	99 1f       	adc	r25, r25
    6ca4:	88 0f       	add	r24, r24
    6ca6:	99 1f       	adc	r25, r25
    6ca8:	fc 01       	movw	r30, r24
    6caa:	e9 51       	subi	r30, 0x19	; 25
    6cac:	f8 4f       	sbci	r31, 0xF8	; 248
    6cae:	82 e0       	ldi	r24, 0x02	; 2
    6cb0:	80 83       	st	Z, r24
    6cb2:	32 c0       	rjmp	.+100    	; 0x6d18 <pushButton_Update+0x138>
			}
		}
		else
		{
			if (avrbuttons[i].buttonStatus == Pressed)
    6cb4:	89 81       	ldd	r24, Y+1	; 0x01
    6cb6:	88 2f       	mov	r24, r24
    6cb8:	90 e0       	ldi	r25, 0x00	; 0
    6cba:	88 0f       	add	r24, r24
    6cbc:	99 1f       	adc	r25, r25
    6cbe:	88 0f       	add	r24, r24
    6cc0:	99 1f       	adc	r25, r25
    6cc2:	fc 01       	movw	r30, r24
    6cc4:	e9 51       	subi	r30, 0x19	; 25
    6cc6:	f8 4f       	sbci	r31, 0xF8	; 248
    6cc8:	80 81       	ld	r24, Z
    6cca:	82 30       	cpi	r24, 0x02	; 2
    6ccc:	69 f4       	brne	.+26     	; 0x6ce8 <pushButton_Update+0x108>
			{
				avrbuttons[i].buttonStatus = Prereleased;
    6cce:	89 81       	ldd	r24, Y+1	; 0x01
    6cd0:	88 2f       	mov	r24, r24
    6cd2:	90 e0       	ldi	r25, 0x00	; 0
    6cd4:	88 0f       	add	r24, r24
    6cd6:	99 1f       	adc	r25, r25
    6cd8:	88 0f       	add	r24, r24
    6cda:	99 1f       	adc	r25, r25
    6cdc:	fc 01       	movw	r30, r24
    6cde:	e9 51       	subi	r30, 0x19	; 25
    6ce0:	f8 4f       	sbci	r31, 0xF8	; 248
    6ce2:	83 e0       	ldi	r24, 0x03	; 3
    6ce4:	80 83       	st	Z, r24
    6ce6:	18 c0       	rjmp	.+48     	; 0x6d18 <pushButton_Update+0x138>
			}
			else if (avrbuttons[i].buttonStatus == Prereleased)
    6ce8:	89 81       	ldd	r24, Y+1	; 0x01
    6cea:	88 2f       	mov	r24, r24
    6cec:	90 e0       	ldi	r25, 0x00	; 0
    6cee:	88 0f       	add	r24, r24
    6cf0:	99 1f       	adc	r25, r25
    6cf2:	88 0f       	add	r24, r24
    6cf4:	99 1f       	adc	r25, r25
    6cf6:	fc 01       	movw	r30, r24
    6cf8:	e9 51       	subi	r30, 0x19	; 25
    6cfa:	f8 4f       	sbci	r31, 0xF8	; 248
    6cfc:	80 81       	ld	r24, Z
    6cfe:	83 30       	cpi	r24, 0x03	; 3
    6d00:	59 f4       	brne	.+22     	; 0x6d18 <pushButton_Update+0x138>
			{
				avrbuttons[i].buttonStatus = Released;
    6d02:	89 81       	ldd	r24, Y+1	; 0x01
    6d04:	88 2f       	mov	r24, r24
    6d06:	90 e0       	ldi	r25, 0x00	; 0
    6d08:	88 0f       	add	r24, r24
    6d0a:	99 1f       	adc	r25, r25
    6d0c:	88 0f       	add	r24, r24
    6d0e:	99 1f       	adc	r25, r25
    6d10:	fc 01       	movw	r30, r24
    6d12:	e9 51       	subi	r30, 0x19	; 25
    6d14:	f8 4f       	sbci	r31, 0xF8	; 248
    6d16:	10 82       	st	Z, r1
 * @note : this function must be called in the system tick hundler or in the super loop hundler
 */
void pushButton_Update(void)
{
	uint8 READData;
	for (uint8 i = 0; i < buttonNo; i++)
    6d18:	89 81       	ldd	r24, Y+1	; 0x01
    6d1a:	8f 5f       	subi	r24, 0xFF	; 255
    6d1c:	89 83       	std	Y+1, r24	; 0x01
    6d1e:	90 91 e3 07 	lds	r25, 0x07E3
    6d22:	89 81       	ldd	r24, Y+1	; 0x01
    6d24:	89 17       	cp	r24, r25
    6d26:	08 f4       	brcc	.+2      	; 0x6d2a <pushButton_Update+0x14a>
    6d28:	62 cf       	rjmp	.-316    	; 0x6bee <pushButton_Update+0xe>
			{
				avrbuttons[i].buttonStatus = Released;
			}
		}
	}
}
    6d2a:	0f 90       	pop	r0
    6d2c:	0f 90       	pop	r0
    6d2e:	cf 91       	pop	r28
    6d30:	df 91       	pop	r29
    6d32:	08 95       	ret

00006d34 <pushButton_GetStatus>:
 * Description: read BTN_x (where x 0, 1, 2, 3) state which is stored in the program
 * 				in the update function
 *
 */
En_buttonStatus_t pushButton_GetStatus(En_buttonId btn_id)
{
    6d34:	df 93       	push	r29
    6d36:	cf 93       	push	r28
    6d38:	00 d0       	rcall	.+0      	; 0x6d3a <pushButton_GetStatus+0x6>
    6d3a:	0f 92       	push	r0
    6d3c:	cd b7       	in	r28, 0x3d	; 61
    6d3e:	de b7       	in	r29, 0x3e	; 62
    6d40:	8b 83       	std	Y+3, r24	; 0x03
	En_buttonStatus_t outStatus;
	for (uint8 i = 0; i < buttonNo; i++)
    6d42:	19 82       	std	Y+1, r1	; 0x01
    6d44:	1d c0       	rjmp	.+58     	; 0x6d80 <pushButton_GetStatus+0x4c>
	{
		if (btn_id == avrbuttons[i].buttonID)
    6d46:	89 81       	ldd	r24, Y+1	; 0x01
    6d48:	88 2f       	mov	r24, r24
    6d4a:	90 e0       	ldi	r25, 0x00	; 0
    6d4c:	88 0f       	add	r24, r24
    6d4e:	99 1f       	adc	r25, r25
    6d50:	88 0f       	add	r24, r24
    6d52:	99 1f       	adc	r25, r25
    6d54:	fc 01       	movw	r30, r24
    6d56:	ec 51       	subi	r30, 0x1C	; 28
    6d58:	f8 4f       	sbci	r31, 0xF8	; 248
    6d5a:	90 81       	ld	r25, Z
    6d5c:	8b 81       	ldd	r24, Y+3	; 0x03
    6d5e:	98 17       	cp	r25, r24
    6d60:	61 f4       	brne	.+24     	; 0x6d7a <pushButton_GetStatus+0x46>
		{
			outStatus = avrbuttons[i].buttonStatus;
    6d62:	89 81       	ldd	r24, Y+1	; 0x01
    6d64:	88 2f       	mov	r24, r24
    6d66:	90 e0       	ldi	r25, 0x00	; 0
    6d68:	88 0f       	add	r24, r24
    6d6a:	99 1f       	adc	r25, r25
    6d6c:	88 0f       	add	r24, r24
    6d6e:	99 1f       	adc	r25, r25
    6d70:	fc 01       	movw	r30, r24
    6d72:	e9 51       	subi	r30, 0x19	; 25
    6d74:	f8 4f       	sbci	r31, 0xF8	; 248
    6d76:	80 81       	ld	r24, Z
    6d78:	8a 83       	std	Y+2, r24	; 0x02
 *
 */
En_buttonStatus_t pushButton_GetStatus(En_buttonId btn_id)
{
	En_buttonStatus_t outStatus;
	for (uint8 i = 0; i < buttonNo; i++)
    6d7a:	89 81       	ldd	r24, Y+1	; 0x01
    6d7c:	8f 5f       	subi	r24, 0xFF	; 255
    6d7e:	89 83       	std	Y+1, r24	; 0x01
    6d80:	90 91 e3 07 	lds	r25, 0x07E3
    6d84:	89 81       	ldd	r24, Y+1	; 0x01
    6d86:	89 17       	cp	r24, r25
    6d88:	f0 f2       	brcs	.-68     	; 0x6d46 <pushButton_GetStatus+0x12>
		{
			outStatus = avrbuttons[i].buttonStatus;
		}
	}

	return outStatus;
    6d8a:	8a 81       	ldd	r24, Y+2	; 0x02

}
    6d8c:	0f 90       	pop	r0
    6d8e:	0f 90       	pop	r0
    6d90:	0f 90       	pop	r0
    6d92:	cf 91       	pop	r28
    6d94:	df 91       	pop	r29
    6d96:	08 95       	ret

00006d98 <delay>:
//
//*****************************************************************************
#include "lcd.h"

static void delay(void)
{
    6d98:	df 93       	push	r29
    6d9a:	cf 93       	push	r28
    6d9c:	00 d0       	rcall	.+0      	; 0x6d9e <delay+0x6>
    6d9e:	cd b7       	in	r28, 0x3d	; 61
    6da0:	de b7       	in	r29, 0x3e	; 62
	/* 40 uS delay loop */
	uint16 u16_i;
	for (u16_i = 0; u16_i < 640; u16_i++)
    6da2:	1a 82       	std	Y+2, r1	; 0x02
    6da4:	19 82       	std	Y+1, r1	; 0x01
    6da6:	06 c0       	rjmp	.+12     	; 0x6db4 <delay+0x1c>
	{
		asm("nop");
    6da8:	00 00       	nop

static void delay(void)
{
	/* 40 uS delay loop */
	uint16 u16_i;
	for (u16_i = 0; u16_i < 640; u16_i++)
    6daa:	89 81       	ldd	r24, Y+1	; 0x01
    6dac:	9a 81       	ldd	r25, Y+2	; 0x02
    6dae:	01 96       	adiw	r24, 0x01	; 1
    6db0:	9a 83       	std	Y+2, r25	; 0x02
    6db2:	89 83       	std	Y+1, r24	; 0x01
    6db4:	89 81       	ldd	r24, Y+1	; 0x01
    6db6:	9a 81       	ldd	r25, Y+2	; 0x02
    6db8:	22 e0       	ldi	r18, 0x02	; 2
    6dba:	80 38       	cpi	r24, 0x80	; 128
    6dbc:	92 07       	cpc	r25, r18
    6dbe:	a0 f3       	brcs	.-24     	; 0x6da8 <delay+0x10>
	{
		asm("nop");
	}
}
    6dc0:	0f 90       	pop	r0
    6dc2:	0f 90       	pop	r0
    6dc4:	cf 91       	pop	r28
    6dc6:	df 91       	pop	r29
    6dc8:	08 95       	ret

00006dca <LCD_EN_pulse>:

void LCD_EN_pulse(void)
{
    6dca:	df 93       	push	r29
    6dcc:	cf 93       	push	r28
    6dce:	cd b7       	in	r28, 0x3d	; 61
    6dd0:	de b7       	in	r29, 0x3e	; 62
	DIO_Write(LCD_EN_GPIO, LCD_EN_PIN, HIGH);
    6dd2:	80 e0       	ldi	r24, 0x00	; 0
    6dd4:	68 e0       	ldi	r22, 0x08	; 8
    6dd6:	4f ef       	ldi	r20, 0xFF	; 255
    6dd8:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>
	...
	asm("nop");
	asm("nop");
	asm("nop");
	asm("nop");
	DIO_Write(LCD_EN_GPIO, LCD_EN_PIN, LOW);
    6de4:	80 e0       	ldi	r24, 0x00	; 0
    6de6:	68 e0       	ldi	r22, 0x08	; 8
    6de8:	40 e0       	ldi	r20, 0x00	; 0
    6dea:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>
}
    6dee:	cf 91       	pop	r28
    6df0:	df 91       	pop	r29
    6df2:	08 95       	ret

00006df4 <LCD_config_pins>:

void LCD_config_pins(void)
{
    6df4:	df 93       	push	r29
    6df6:	cf 93       	push	r28
    6df8:	00 d0       	rcall	.+0      	; 0x6dfa <LCD_config_pins+0x6>
    6dfa:	0f 92       	push	r0
    6dfc:	cd b7       	in	r28, 0x3d	; 61
    6dfe:	de b7       	in	r29, 0x3e	; 62
	/* set LCD pins as outputs */
	DIO_Cfg_s ST_dio =
	{ 0 };
    6e00:	83 e0       	ldi	r24, 0x03	; 3
    6e02:	fe 01       	movw	r30, r28
    6e04:	31 96       	adiw	r30, 0x01	; 1
    6e06:	df 01       	movw	r26, r30
    6e08:	98 2f       	mov	r25, r24
    6e0a:	1d 92       	st	X+, r1
    6e0c:	9a 95       	dec	r25
    6e0e:	e9 f7       	brne	.-6      	; 0x6e0a <LCD_config_pins+0x16>
	ST_dio.GPIO = LCD_RS_GPIO;
    6e10:	19 82       	std	Y+1, r1	; 0x01
	ST_dio.dir = OUTPUT;
    6e12:	8f ef       	ldi	r24, 0xFF	; 255
    6e14:	8b 83       	std	Y+3, r24	; 0x03
	ST_dio.pins = LCD_RS_PIN;
    6e16:	82 e0       	ldi	r24, 0x02	; 2
    6e18:	8a 83       	std	Y+2, r24	; 0x02
	DIO_init(&ST_dio);
    6e1a:	ce 01       	movw	r24, r28
    6e1c:	01 96       	adiw	r24, 0x01	; 1
    6e1e:	0e 94 90 33 	call	0x6720	; 0x6720 <DIO_init>

	ST_dio.GPIO = LCD_RW_GPIO;
    6e22:	19 82       	std	Y+1, r1	; 0x01
	ST_dio.pins = LCD_RW_PIN;
    6e24:	84 e0       	ldi	r24, 0x04	; 4
    6e26:	8a 83       	std	Y+2, r24	; 0x02
	DIO_init(&ST_dio);
    6e28:	ce 01       	movw	r24, r28
    6e2a:	01 96       	adiw	r24, 0x01	; 1
    6e2c:	0e 94 90 33 	call	0x6720	; 0x6720 <DIO_init>

	ST_dio.GPIO = LCD_EN_GPIO;
    6e30:	19 82       	std	Y+1, r1	; 0x01
	ST_dio.pins = LCD_EN_PIN;
    6e32:	88 e0       	ldi	r24, 0x08	; 8
    6e34:	8a 83       	std	Y+2, r24	; 0x02
	DIO_init(&ST_dio);
    6e36:	ce 01       	movw	r24, r28
    6e38:	01 96       	adiw	r24, 0x01	; 1
    6e3a:	0e 94 90 33 	call	0x6720	; 0x6720 <DIO_init>

	ST_dio.GPIO = LCD_D4_GPIO;
    6e3e:	19 82       	std	Y+1, r1	; 0x01
	ST_dio.pins = LCD_D4_PIN;
    6e40:	80 e1       	ldi	r24, 0x10	; 16
    6e42:	8a 83       	std	Y+2, r24	; 0x02
	DIO_init(&ST_dio);
    6e44:	ce 01       	movw	r24, r28
    6e46:	01 96       	adiw	r24, 0x01	; 1
    6e48:	0e 94 90 33 	call	0x6720	; 0x6720 <DIO_init>

	ST_dio.GPIO = LCD_D5_GPIO;
    6e4c:	19 82       	std	Y+1, r1	; 0x01
	ST_dio.pins = LCD_D5_PIN;
    6e4e:	80 e2       	ldi	r24, 0x20	; 32
    6e50:	8a 83       	std	Y+2, r24	; 0x02
	DIO_init(&ST_dio);
    6e52:	ce 01       	movw	r24, r28
    6e54:	01 96       	adiw	r24, 0x01	; 1
    6e56:	0e 94 90 33 	call	0x6720	; 0x6720 <DIO_init>

	ST_dio.GPIO = LCD_D6_GPIO;
    6e5a:	19 82       	std	Y+1, r1	; 0x01
	ST_dio.pins = LCD_D6_PIN;
    6e5c:	80 e4       	ldi	r24, 0x40	; 64
    6e5e:	8a 83       	std	Y+2, r24	; 0x02
	DIO_init(&ST_dio);
    6e60:	ce 01       	movw	r24, r28
    6e62:	01 96       	adiw	r24, 0x01	; 1
    6e64:	0e 94 90 33 	call	0x6720	; 0x6720 <DIO_init>

	ST_dio.GPIO = LCD_D7_GPIO;
    6e68:	19 82       	std	Y+1, r1	; 0x01
	ST_dio.pins = LCD_D7_PIN;
    6e6a:	80 e8       	ldi	r24, 0x80	; 128
    6e6c:	8a 83       	std	Y+2, r24	; 0x02
	DIO_init(&ST_dio);
    6e6e:	ce 01       	movw	r24, r28
    6e70:	01 96       	adiw	r24, 0x01	; 1
    6e72:	0e 94 90 33 	call	0x6720	; 0x6720 <DIO_init>
}
    6e76:	0f 90       	pop	r0
    6e78:	0f 90       	pop	r0
    6e7a:	0f 90       	pop	r0
    6e7c:	cf 91       	pop	r28
    6e7e:	df 91       	pop	r29
    6e80:	08 95       	ret

00006e82 <LCD_send_nibble>:

void LCD_send_nibble(uint8 data)
{
    6e82:	df 93       	push	r29
    6e84:	cf 93       	push	r28
    6e86:	00 d0       	rcall	.+0      	; 0x6e88 <LCD_send_nibble+0x6>
    6e88:	cd b7       	in	r28, 0x3d	; 61
    6e8a:	de b7       	in	r29, 0x3e	; 62
    6e8c:	8a 83       	std	Y+2, r24	; 0x02
	uint8 mask = 1;
    6e8e:	81 e0       	ldi	r24, 0x01	; 1
    6e90:	89 83       	std	Y+1, r24	; 0x01
	data >>= 4;
    6e92:	8a 81       	ldd	r24, Y+2	; 0x02
    6e94:	82 95       	swap	r24
    6e96:	8f 70       	andi	r24, 0x0F	; 15
    6e98:	8a 83       	std	Y+2, r24	; 0x02
	if (data & mask)
    6e9a:	9a 81       	ldd	r25, Y+2	; 0x02
    6e9c:	89 81       	ldd	r24, Y+1	; 0x01
    6e9e:	89 23       	and	r24, r25
    6ea0:	88 23       	and	r24, r24
    6ea2:	31 f0       	breq	.+12     	; 0x6eb0 <LCD_send_nibble+0x2e>
		DIO_Write(LCD_D4_GPIO, LCD_D4_PIN, HIGH);
    6ea4:	80 e0       	ldi	r24, 0x00	; 0
    6ea6:	60 e1       	ldi	r22, 0x10	; 16
    6ea8:	4f ef       	ldi	r20, 0xFF	; 255
    6eaa:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>
    6eae:	05 c0       	rjmp	.+10     	; 0x6eba <LCD_send_nibble+0x38>
	else
		DIO_Write(LCD_D4_GPIO, LCD_D4_PIN, LOW);
    6eb0:	80 e0       	ldi	r24, 0x00	; 0
    6eb2:	60 e1       	ldi	r22, 0x10	; 16
    6eb4:	40 e0       	ldi	r20, 0x00	; 0
    6eb6:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>

	mask *= 2;
    6eba:	89 81       	ldd	r24, Y+1	; 0x01
    6ebc:	88 2f       	mov	r24, r24
    6ebe:	90 e0       	ldi	r25, 0x00	; 0
    6ec0:	88 0f       	add	r24, r24
    6ec2:	99 1f       	adc	r25, r25
    6ec4:	89 83       	std	Y+1, r24	; 0x01
	if (data & mask)
    6ec6:	9a 81       	ldd	r25, Y+2	; 0x02
    6ec8:	89 81       	ldd	r24, Y+1	; 0x01
    6eca:	89 23       	and	r24, r25
    6ecc:	88 23       	and	r24, r24
    6ece:	31 f0       	breq	.+12     	; 0x6edc <LCD_send_nibble+0x5a>
		DIO_Write(LCD_D5_GPIO, LCD_D5_PIN, HIGH);
    6ed0:	80 e0       	ldi	r24, 0x00	; 0
    6ed2:	60 e2       	ldi	r22, 0x20	; 32
    6ed4:	4f ef       	ldi	r20, 0xFF	; 255
    6ed6:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>
    6eda:	05 c0       	rjmp	.+10     	; 0x6ee6 <LCD_send_nibble+0x64>
	else
		DIO_Write(LCD_D5_GPIO, LCD_D5_PIN, LOW);
    6edc:	80 e0       	ldi	r24, 0x00	; 0
    6ede:	60 e2       	ldi	r22, 0x20	; 32
    6ee0:	40 e0       	ldi	r20, 0x00	; 0
    6ee2:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>

	mask *= 2;
    6ee6:	89 81       	ldd	r24, Y+1	; 0x01
    6ee8:	88 2f       	mov	r24, r24
    6eea:	90 e0       	ldi	r25, 0x00	; 0
    6eec:	88 0f       	add	r24, r24
    6eee:	99 1f       	adc	r25, r25
    6ef0:	89 83       	std	Y+1, r24	; 0x01
	if (data & mask)
    6ef2:	9a 81       	ldd	r25, Y+2	; 0x02
    6ef4:	89 81       	ldd	r24, Y+1	; 0x01
    6ef6:	89 23       	and	r24, r25
    6ef8:	88 23       	and	r24, r24
    6efa:	31 f0       	breq	.+12     	; 0x6f08 <LCD_send_nibble+0x86>
		DIO_Write(LCD_D6_GPIO, LCD_D6_PIN, HIGH);
    6efc:	80 e0       	ldi	r24, 0x00	; 0
    6efe:	60 e4       	ldi	r22, 0x40	; 64
    6f00:	4f ef       	ldi	r20, 0xFF	; 255
    6f02:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>
    6f06:	05 c0       	rjmp	.+10     	; 0x6f12 <LCD_send_nibble+0x90>
	else
		DIO_Write(LCD_D6_GPIO, LCD_D6_PIN, LOW);
    6f08:	80 e0       	ldi	r24, 0x00	; 0
    6f0a:	60 e4       	ldi	r22, 0x40	; 64
    6f0c:	40 e0       	ldi	r20, 0x00	; 0
    6f0e:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>

	mask *= 2;
    6f12:	89 81       	ldd	r24, Y+1	; 0x01
    6f14:	88 2f       	mov	r24, r24
    6f16:	90 e0       	ldi	r25, 0x00	; 0
    6f18:	88 0f       	add	r24, r24
    6f1a:	99 1f       	adc	r25, r25
    6f1c:	89 83       	std	Y+1, r24	; 0x01
	if (data & mask)
    6f1e:	9a 81       	ldd	r25, Y+2	; 0x02
    6f20:	89 81       	ldd	r24, Y+1	; 0x01
    6f22:	89 23       	and	r24, r25
    6f24:	88 23       	and	r24, r24
    6f26:	31 f0       	breq	.+12     	; 0x6f34 <LCD_send_nibble+0xb2>
		DIO_Write(LCD_D7_GPIO, LCD_D7_PIN, HIGH);
    6f28:	80 e0       	ldi	r24, 0x00	; 0
    6f2a:	60 e8       	ldi	r22, 0x80	; 128
    6f2c:	4f ef       	ldi	r20, 0xFF	; 255
    6f2e:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>
    6f32:	05 c0       	rjmp	.+10     	; 0x6f3e <LCD_send_nibble+0xbc>
	else
		DIO_Write(LCD_D7_GPIO, LCD_D7_PIN, LOW);
    6f34:	80 e0       	ldi	r24, 0x00	; 0
    6f36:	60 e8       	ldi	r22, 0x80	; 128
    6f38:	40 e0       	ldi	r20, 0x00	; 0
    6f3a:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>
}
    6f3e:	0f 90       	pop	r0
    6f40:	0f 90       	pop	r0
    6f42:	cf 91       	pop	r28
    6f44:	df 91       	pop	r29
    6f46:	08 95       	ret

00006f48 <LCD_send_char>:

void LCD_send_char(char data)
{
    6f48:	df 93       	push	r29
    6f4a:	cf 93       	push	r28
    6f4c:	0f 92       	push	r0
    6f4e:	cd b7       	in	r28, 0x3d	; 61
    6f50:	de b7       	in	r29, 0x3e	; 62
    6f52:	89 83       	std	Y+1, r24	; 0x01
	DIO_Write(LCD_RS_GPIO, LCD_RS_PIN, HIGH);
    6f54:	80 e0       	ldi	r24, 0x00	; 0
    6f56:	62 e0       	ldi	r22, 0x02	; 2
    6f58:	4f ef       	ldi	r20, 0xFF	; 255
    6f5a:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>

	LCD_send_nibble(data);
    6f5e:	89 81       	ldd	r24, Y+1	; 0x01
    6f60:	0e 94 41 37 	call	0x6e82	; 0x6e82 <LCD_send_nibble>
	LCD_EN_pulse();
    6f64:	0e 94 e5 36 	call	0x6dca	; 0x6dca <LCD_EN_pulse>
	delay();
    6f68:	0e 94 cc 36 	call	0x6d98	; 0x6d98 <delay>

	LCD_send_nibble(data << 4);
    6f6c:	89 81       	ldd	r24, Y+1	; 0x01
    6f6e:	82 95       	swap	r24
    6f70:	80 7f       	andi	r24, 0xF0	; 240
    6f72:	0e 94 41 37 	call	0x6e82	; 0x6e82 <LCD_send_nibble>
	LCD_EN_pulse();
    6f76:	0e 94 e5 36 	call	0x6dca	; 0x6dca <LCD_EN_pulse>
	delay();
    6f7a:	0e 94 cc 36 	call	0x6d98	; 0x6d98 <delay>
}
    6f7e:	0f 90       	pop	r0
    6f80:	cf 91       	pop	r28
    6f82:	df 91       	pop	r29
    6f84:	08 95       	ret

00006f86 <LCD_send_command>:
void LCD_send_command(uint8 data)
{
    6f86:	df 93       	push	r29
    6f88:	cf 93       	push	r28
    6f8a:	0f 92       	push	r0
    6f8c:	cd b7       	in	r28, 0x3d	; 61
    6f8e:	de b7       	in	r29, 0x3e	; 62
    6f90:	89 83       	std	Y+1, r24	; 0x01
	DIO_Write(LCD_RS_GPIO, LCD_RS_PIN, LOW);
    6f92:	80 e0       	ldi	r24, 0x00	; 0
    6f94:	62 e0       	ldi	r22, 0x02	; 2
    6f96:	40 e0       	ldi	r20, 0x00	; 0
    6f98:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>

	/* Higher nibble first */
	LCD_send_nibble(data);
    6f9c:	89 81       	ldd	r24, Y+1	; 0x01
    6f9e:	0e 94 41 37 	call	0x6e82	; 0x6e82 <LCD_send_nibble>
	LCD_EN_pulse();
    6fa2:	0e 94 e5 36 	call	0x6dca	; 0x6dca <LCD_EN_pulse>
	delay();
    6fa6:	0e 94 cc 36 	call	0x6d98	; 0x6d98 <delay>

	LCD_send_nibble(data << 4);
    6faa:	89 81       	ldd	r24, Y+1	; 0x01
    6fac:	82 95       	swap	r24
    6fae:	80 7f       	andi	r24, 0xF0	; 240
    6fb0:	0e 94 41 37 	call	0x6e82	; 0x6e82 <LCD_send_nibble>
	LCD_EN_pulse();
    6fb4:	0e 94 e5 36 	call	0x6dca	; 0x6dca <LCD_EN_pulse>
	delay();
    6fb8:	0e 94 cc 36 	call	0x6d98	; 0x6d98 <delay>
}
    6fbc:	0f 90       	pop	r0
    6fbe:	cf 91       	pop	r28
    6fc0:	df 91       	pop	r29
    6fc2:	08 95       	ret

00006fc4 <LCD_init>:
void LCD_init(void)
{
    6fc4:	df 93       	push	r29
    6fc6:	cf 93       	push	r28
    6fc8:	cd b7       	in	r28, 0x3d	; 61
    6fca:	de b7       	in	r29, 0x3e	; 62
	LCD_config_pins();
    6fcc:	0e 94 fa 36 	call	0x6df4	; 0x6df4 <LCD_config_pins>

	DIO_Write(LCD_RS_GPIO, LCD_RS_PIN, LOW);
    6fd0:	80 e0       	ldi	r24, 0x00	; 0
    6fd2:	62 e0       	ldi	r22, 0x02	; 2
    6fd4:	40 e0       	ldi	r20, 0x00	; 0
    6fd6:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>
	DIO_Write(LCD_RW_GPIO, LCD_RW_PIN, LOW);
    6fda:	80 e0       	ldi	r24, 0x00	; 0
    6fdc:	64 e0       	ldi	r22, 0x04	; 4
    6fde:	40 e0       	ldi	r20, 0x00	; 0
    6fe0:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>
	DIO_Write(LCD_EN_GPIO, LCD_EN_PIN, LOW);
    6fe4:	80 e0       	ldi	r24, 0x00	; 0
    6fe6:	68 e0       	ldi	r22, 0x08	; 8
    6fe8:	40 e0       	ldi	r20, 0x00	; 0
    6fea:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>

	LCD_send_command(0x32);
    6fee:	82 e3       	ldi	r24, 0x32	; 50
    6ff0:	0e 94 c3 37 	call	0x6f86	; 0x6f86 <LCD_send_command>
	LCD_send_command(Four_bit);
    6ff4:	88 e2       	ldi	r24, 0x28	; 40
    6ff6:	0e 94 c3 37 	call	0x6f86	; 0x6f86 <LCD_send_command>
	LCD_send_command(Cursor_on);
    6ffa:	8e e0       	ldi	r24, 0x0E	; 14
    6ffc:	0e 94 c3 37 	call	0x6f86	; 0x6f86 <LCD_send_command>
	LCD_send_command(Lcd_clear);
    7000:	81 e0       	ldi	r24, 0x01	; 1
    7002:	0e 94 c3 37 	call	0x6f86	; 0x6f86 <LCD_send_command>
	LCD_send_command(Increment_cursor);
    7006:	86 e0       	ldi	r24, 0x06	; 6
    7008:	0e 94 c3 37 	call	0x6f86	; 0x6f86 <LCD_send_command>
	LCD_send_command(Cursor_off);
    700c:	8c e0       	ldi	r24, 0x0C	; 12
    700e:	0e 94 c3 37 	call	0x6f86	; 0x6f86 <LCD_send_command>
}
    7012:	cf 91       	pop	r28
    7014:	df 91       	pop	r29
    7016:	08 95       	ret

00007018 <LCD_clear>:
void LCD_clear(void)
{
    7018:	df 93       	push	r29
    701a:	cf 93       	push	r28
    701c:	cd b7       	in	r28, 0x3d	; 61
    701e:	de b7       	in	r29, 0x3e	; 62
	LCD_send_command(Lcd_clear);
    7020:	81 e0       	ldi	r24, 0x01	; 1
    7022:	0e 94 c3 37 	call	0x6f86	; 0x6f86 <LCD_send_command>
}
    7026:	cf 91       	pop	r28
    7028:	df 91       	pop	r29
    702a:	08 95       	ret

0000702c <LCD_send_string>:

void LCD_send_string(char *data)
{
    702c:	df 93       	push	r29
    702e:	cf 93       	push	r28
    7030:	00 d0       	rcall	.+0      	; 0x7032 <LCD_send_string+0x6>
    7032:	cd b7       	in	r28, 0x3d	; 61
    7034:	de b7       	in	r29, 0x3e	; 62
    7036:	9a 83       	std	Y+2, r25	; 0x02
    7038:	89 83       	std	Y+1, r24	; 0x01
    703a:	0b c0       	rjmp	.+22     	; 0x7052 <LCD_send_string+0x26>
	while (*data)
	{
		LCD_send_char(*data++);
    703c:	e9 81       	ldd	r30, Y+1	; 0x01
    703e:	fa 81       	ldd	r31, Y+2	; 0x02
    7040:	20 81       	ld	r18, Z
    7042:	89 81       	ldd	r24, Y+1	; 0x01
    7044:	9a 81       	ldd	r25, Y+2	; 0x02
    7046:	01 96       	adiw	r24, 0x01	; 1
    7048:	9a 83       	std	Y+2, r25	; 0x02
    704a:	89 83       	std	Y+1, r24	; 0x01
    704c:	82 2f       	mov	r24, r18
    704e:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
	LCD_send_command(Lcd_clear);
}

void LCD_send_string(char *data)
{
	while (*data)
    7052:	e9 81       	ldd	r30, Y+1	; 0x01
    7054:	fa 81       	ldd	r31, Y+2	; 0x02
    7056:	80 81       	ld	r24, Z
    7058:	88 23       	and	r24, r24
    705a:	81 f7       	brne	.-32     	; 0x703c <LCD_send_string+0x10>
	{
		LCD_send_char(*data++);
	}
}
    705c:	0f 90       	pop	r0
    705e:	0f 90       	pop	r0
    7060:	cf 91       	pop	r28
    7062:	df 91       	pop	r29
    7064:	08 95       	ret

00007066 <LCD_goto_xy>:

void LCD_goto_xy(uint8 x, uint8 y)
{
    7066:	df 93       	push	r29
    7068:	cf 93       	push	r28
    706a:	00 d0       	rcall	.+0      	; 0x706c <LCD_goto_xy+0x6>
    706c:	00 d0       	rcall	.+0      	; 0x706e <LCD_goto_xy+0x8>
    706e:	0f 92       	push	r0
    7070:	cd b7       	in	r28, 0x3d	; 61
    7072:	de b7       	in	r29, 0x3e	; 62
    7074:	8a 83       	std	Y+2, r24	; 0x02
    7076:	6b 83       	std	Y+3, r22	; 0x03
	uint8 DDRAMAddr;
	// remap lines into proper order
	switch (y)
    7078:	8b 81       	ldd	r24, Y+3	; 0x03
    707a:	28 2f       	mov	r18, r24
    707c:	30 e0       	ldi	r19, 0x00	; 0
    707e:	3d 83       	std	Y+5, r19	; 0x05
    7080:	2c 83       	std	Y+4, r18	; 0x04
    7082:	8c 81       	ldd	r24, Y+4	; 0x04
    7084:	9d 81       	ldd	r25, Y+5	; 0x05
    7086:	81 30       	cpi	r24, 0x01	; 1
    7088:	91 05       	cpc	r25, r1
    708a:	c1 f0       	breq	.+48     	; 0x70bc <LCD_goto_xy+0x56>
    708c:	2c 81       	ldd	r18, Y+4	; 0x04
    708e:	3d 81       	ldd	r19, Y+5	; 0x05
    7090:	22 30       	cpi	r18, 0x02	; 2
    7092:	31 05       	cpc	r19, r1
    7094:	2c f4       	brge	.+10     	; 0x70a0 <LCD_goto_xy+0x3a>
    7096:	8c 81       	ldd	r24, Y+4	; 0x04
    7098:	9d 81       	ldd	r25, Y+5	; 0x05
    709a:	00 97       	sbiw	r24, 0x00	; 0
    709c:	61 f0       	breq	.+24     	; 0x70b6 <LCD_goto_xy+0x50>
    709e:	1a c0       	rjmp	.+52     	; 0x70d4 <LCD_goto_xy+0x6e>
    70a0:	2c 81       	ldd	r18, Y+4	; 0x04
    70a2:	3d 81       	ldd	r19, Y+5	; 0x05
    70a4:	22 30       	cpi	r18, 0x02	; 2
    70a6:	31 05       	cpc	r19, r1
    70a8:	69 f0       	breq	.+26     	; 0x70c4 <LCD_goto_xy+0x5e>
    70aa:	8c 81       	ldd	r24, Y+4	; 0x04
    70ac:	9d 81       	ldd	r25, Y+5	; 0x05
    70ae:	83 30       	cpi	r24, 0x03	; 3
    70b0:	91 05       	cpc	r25, r1
    70b2:	61 f0       	breq	.+24     	; 0x70cc <LCD_goto_xy+0x66>
    70b4:	0f c0       	rjmp	.+30     	; 0x70d4 <LCD_goto_xy+0x6e>
	{
	case 0:
		DDRAMAddr = LCD_LINE0_DDRAMADDR + x;
    70b6:	8a 81       	ldd	r24, Y+2	; 0x02
    70b8:	89 83       	std	Y+1, r24	; 0x01
    70ba:	0e c0       	rjmp	.+28     	; 0x70d8 <LCD_goto_xy+0x72>
		break;
	case 1:
		DDRAMAddr = LCD_LINE1_DDRAMADDR + x;
    70bc:	8a 81       	ldd	r24, Y+2	; 0x02
    70be:	80 5c       	subi	r24, 0xC0	; 192
    70c0:	89 83       	std	Y+1, r24	; 0x01
    70c2:	0a c0       	rjmp	.+20     	; 0x70d8 <LCD_goto_xy+0x72>
		break;
	case 2:
		DDRAMAddr = LCD_LINE2_DDRAMADDR + x;
    70c4:	8a 81       	ldd	r24, Y+2	; 0x02
    70c6:	8c 5e       	subi	r24, 0xEC	; 236
    70c8:	89 83       	std	Y+1, r24	; 0x01
    70ca:	06 c0       	rjmp	.+12     	; 0x70d8 <LCD_goto_xy+0x72>
		break;
	case 3:
		DDRAMAddr = LCD_LINE3_DDRAMADDR + x;
    70cc:	8a 81       	ldd	r24, Y+2	; 0x02
    70ce:	8c 5a       	subi	r24, 0xAC	; 172
    70d0:	89 83       	std	Y+1, r24	; 0x01
    70d2:	02 c0       	rjmp	.+4      	; 0x70d8 <LCD_goto_xy+0x72>
		break;
	default:
		DDRAMAddr = LCD_LINE0_DDRAMADDR + x;
    70d4:	8a 81       	ldd	r24, Y+2	; 0x02
    70d6:	89 83       	std	Y+1, r24	; 0x01
	}
	// set data address
	LCD_send_command(1 << LCD_DDRAM | DDRAMAddr);
    70d8:	89 81       	ldd	r24, Y+1	; 0x01
    70da:	80 68       	ori	r24, 0x80	; 128
    70dc:	0e 94 c3 37 	call	0x6f86	; 0x6f86 <LCD_send_command>
	delay();
    70e0:	0e 94 cc 36 	call	0x6d98	; 0x6d98 <delay>
}
    70e4:	0f 90       	pop	r0
    70e6:	0f 90       	pop	r0
    70e8:	0f 90       	pop	r0
    70ea:	0f 90       	pop	r0
    70ec:	0f 90       	pop	r0
    70ee:	cf 91       	pop	r28
    70f0:	df 91       	pop	r29
    70f2:	08 95       	ret

000070f4 <Keypad_Init>:
/**
 * Description: Initialize Keypad module
 * @return: Keypad error status
 */
KPD_ERROR_STATUS Keypad_Init(void)
{
    70f4:	df 93       	push	r29
    70f6:	cf 93       	push	r28
    70f8:	cd b7       	in	r28, 0x3d	; 61
    70fa:	de b7       	in	r29, 0x3e	; 62
    70fc:	29 97       	sbiw	r28, 0x09	; 9
    70fe:	0f b6       	in	r0, 0x3f	; 63
    7100:	f8 94       	cli
    7102:	de bf       	out	0x3e, r29	; 62
    7104:	0f be       	out	0x3f, r0	; 63
    7106:	cd bf       	out	0x3d, r28	; 61
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = KPD_BASE_ERROR + ERR_SUCCESS;
    7108:	82 e9       	ldi	r24, 0x92	; 146
    710a:	8b 83       	std	Y+3, r24	; 0x03
	uint8 u8_Pin, u8_Counter;

	/*
	 * Initialize column pins as output
	 */
	u8_Pin = COL_START;
    710c:	80 e2       	ldi	r24, 0x20	; 32
    710e:	8a 83       	std	Y+2, r24	; 0x02
	for (u8_Counter = 0; u8_Counter < COL_MAX; u8_Counter++)
    7110:	19 82       	std	Y+1, r1	; 0x01
    7112:	17 c0       	rjmp	.+46     	; 0x7142 <Keypad_Init+0x4e>
	{
		DIO_Cfg_s COL_DIO =
		{ KPD_COL_PORT, u8_Pin, OUTPUT };
    7114:	82 e0       	ldi	r24, 0x02	; 2
    7116:	8c 83       	std	Y+4, r24	; 0x04
    7118:	8a 81       	ldd	r24, Y+2	; 0x02
    711a:	8d 83       	std	Y+5, r24	; 0x05
    711c:	8f ef       	ldi	r24, 0xFF	; 255
    711e:	8e 83       	std	Y+6, r24	; 0x06
		s8_ErrorStatus = DIO_init(&COL_DIO);
    7120:	ce 01       	movw	r24, r28
    7122:	04 96       	adiw	r24, 0x04	; 4
    7124:	0e 94 90 33 	call	0x6720	; 0x6720 <DIO_init>
    7128:	8b 83       	std	Y+3, r24	; 0x03
		/*
		 * deactivate column pins
		 */
		s8_ErrorStatus = DIO_Write(KPD_COL_PORT, u8_Pin, HIGH);
    712a:	82 e0       	ldi	r24, 0x02	; 2
    712c:	6a 81       	ldd	r22, Y+2	; 0x02
    712e:	4f ef       	ldi	r20, 0xFF	; 255
    7130:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>
    7134:	8b 83       	std	Y+3, r24	; 0x03
		u8_Pin <<= 1;
    7136:	8a 81       	ldd	r24, Y+2	; 0x02
    7138:	88 0f       	add	r24, r24
    713a:	8a 83       	std	Y+2, r24	; 0x02

	/*
	 * Initialize column pins as output
	 */
	u8_Pin = COL_START;
	for (u8_Counter = 0; u8_Counter < COL_MAX; u8_Counter++)
    713c:	89 81       	ldd	r24, Y+1	; 0x01
    713e:	8f 5f       	subi	r24, 0xFF	; 255
    7140:	89 83       	std	Y+1, r24	; 0x01
    7142:	89 81       	ldd	r24, Y+1	; 0x01
    7144:	83 30       	cpi	r24, 0x03	; 3
    7146:	30 f3       	brcs	.-52     	; 0x7114 <Keypad_Init+0x20>
		 * deactivate column pins
		 */
		s8_ErrorStatus = DIO_Write(KPD_COL_PORT, u8_Pin, HIGH);
		u8_Pin <<= 1;
	}
	if (s8_ErrorStatus == DIO_BASE_ERROR + ERR_SUCCESS)
    7148:	8b 81       	ldd	r24, Y+3	; 0x03
    714a:	86 3f       	cpi	r24, 0xF6	; 246
    714c:	09 f5       	brne	.+66     	; 0x7190 <Keypad_Init+0x9c>
	{
		/*
		 * initialize row pins as input
		 */
		u8_Pin = ROW_START;
    714e:	84 e0       	ldi	r24, 0x04	; 4
    7150:	8a 83       	std	Y+2, r24	; 0x02
		for (u8_Counter = 0; u8_Counter < ROW_MAX; u8_Counter++)
    7152:	19 82       	std	Y+1, r1	; 0x01
    7154:	16 c0       	rjmp	.+44     	; 0x7182 <Keypad_Init+0x8e>
		{
			DIO_Cfg_s ROW_DIO =
			{ KPD_ROW_PORT, u8_Pin, INPUT };
    7156:	82 e0       	ldi	r24, 0x02	; 2
    7158:	8f 83       	std	Y+7, r24	; 0x07
    715a:	8a 81       	ldd	r24, Y+2	; 0x02
    715c:	88 87       	std	Y+8, r24	; 0x08
    715e:	19 86       	std	Y+9, r1	; 0x09
			s8_ErrorStatus = DIO_init(&ROW_DIO);
    7160:	ce 01       	movw	r24, r28
    7162:	07 96       	adiw	r24, 0x07	; 7
    7164:	0e 94 90 33 	call	0x6720	; 0x6720 <DIO_init>
    7168:	8b 83       	std	Y+3, r24	; 0x03
			/*
			 * pull-up row pins
			 */
			s8_ErrorStatus = DIO_Write(KPD_ROW_PORT, u8_Pin, HIGH);
    716a:	82 e0       	ldi	r24, 0x02	; 2
    716c:	6a 81       	ldd	r22, Y+2	; 0x02
    716e:	4f ef       	ldi	r20, 0xFF	; 255
    7170:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>
    7174:	8b 83       	std	Y+3, r24	; 0x03
			u8_Pin <<= 1;
    7176:	8a 81       	ldd	r24, Y+2	; 0x02
    7178:	88 0f       	add	r24, r24
    717a:	8a 83       	std	Y+2, r24	; 0x02
	{
		/*
		 * initialize row pins as input
		 */
		u8_Pin = ROW_START;
		for (u8_Counter = 0; u8_Counter < ROW_MAX; u8_Counter++)
    717c:	89 81       	ldd	r24, Y+1	; 0x01
    717e:	8f 5f       	subi	r24, 0xFF	; 255
    7180:	89 83       	std	Y+1, r24	; 0x01
    7182:	89 81       	ldd	r24, Y+1	; 0x01
    7184:	83 30       	cpi	r24, 0x03	; 3
    7186:	38 f3       	brcs	.-50     	; 0x7156 <Keypad_Init+0x62>
			 * pull-up row pins
			 */
			s8_ErrorStatus = DIO_Write(KPD_ROW_PORT, u8_Pin, HIGH);
			u8_Pin <<= 1;
		}
		gu8_KeyPadStatus = KEYPAD_INITILAIZED;
    7188:	81 e0       	ldi	r24, 0x01	; 1
    718a:	80 93 ee 07 	sts	0x07EE, r24
    718e:	02 c0       	rjmp	.+4      	; 0x7194 <Keypad_Init+0xa0>
	}
	else
	{
		gu8_KeyPadStatus = KEYPAD_UNINITIALIZED;
    7190:	10 92 ee 07 	sts	0x07EE, r1
	}
	/*
	 * Function shall return the Error state
	 */
	return (s8_ErrorStatus);
    7194:	8b 81       	ldd	r24, Y+3	; 0x03
}
    7196:	29 96       	adiw	r28, 0x09	; 9
    7198:	0f b6       	in	r0, 0x3f	; 63
    719a:	f8 94       	cli
    719c:	de bf       	out	0x3e, r29	; 62
    719e:	0f be       	out	0x3f, r0	; 63
    71a0:	cd bf       	out	0x3d, r28	; 61
    71a2:	cf 91       	pop	r28
    71a4:	df 91       	pop	r29
    71a6:	08 95       	ret

000071a8 <Keypad_Update>:
/**
 * Description: update pressed key to be called in the schaduler
 * @return: Keypad error status
 */
KPD_ERROR_STATUS Keypad_Update(void)
{
    71a8:	df 93       	push	r29
    71aa:	cf 93       	push	r28
    71ac:	00 d0       	rcall	.+0      	; 0x71ae <Keypad_Update+0x6>
    71ae:	00 d0       	rcall	.+0      	; 0x71b0 <Keypad_Update+0x8>
    71b0:	00 d0       	rcall	.+0      	; 0x71b2 <Keypad_Update+0xa>
    71b2:	cd b7       	in	r28, 0x3d	; 61
    71b4:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = KPD_BASE_ERROR + ERR_SUCCESS;
    71b6:	82 e9       	ldi	r24, 0x92	; 146
    71b8:	8d 83       	std	Y+5, r24	; 0x05
	uint8 u8Col_Num, u8_ColPin, u8_Row_Num, u8_RowPin, u8_KeyState;

	if (gu8_KeyPadStatus == KEYPAD_UNINITIALIZED)
    71ba:	80 91 ee 07 	lds	r24, 0x07EE
    71be:	88 23       	and	r24, r24
    71c0:	19 f4       	brne	.+6      	; 0x71c8 <Keypad_Update+0x20>
	{
		s8_ErrorStatus = KPD_BASE_ERROR + ERR_NOT_INITIALIZED;
    71c2:	80 e9       	ldi	r24, 0x90	; 144
    71c4:	8d 83       	std	Y+5, r24	; 0x05
    71c6:	50 c0       	rjmp	.+160    	; 0x7268 <Keypad_Update+0xc0>
	}
	else
	{
		u8_ColPin = COL_START;
    71c8:	80 e2       	ldi	r24, 0x20	; 32
    71ca:	8b 83       	std	Y+3, r24	; 0x03
		for (u8Col_Num = 0; u8Col_Num < COL_MAX; u8Col_Num++)
    71cc:	1c 82       	std	Y+4, r1	; 0x04
    71ce:	48 c0       	rjmp	.+144    	; 0x7260 <Keypad_Update+0xb8>
		{
			/*
			 * Activate the current column
			 */
			s8_ErrorStatus = DIO_Write(KPD_COL_PORT, u8_ColPin, LOW);
    71d0:	82 e0       	ldi	r24, 0x02	; 2
    71d2:	6b 81       	ldd	r22, Y+3	; 0x03
    71d4:	40 e0       	ldi	r20, 0x00	; 0
    71d6:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>
    71da:	8d 83       	std	Y+5, r24	; 0x05
			u8_RowPin = ROW_START;
    71dc:	84 e0       	ldi	r24, 0x04	; 4
    71de:	89 83       	std	Y+1, r24	; 0x01
			for (u8_Row_Num = 0; u8_Row_Num < ROW_MAX; u8_Row_Num++)
    71e0:	1a 82       	std	Y+2, r1	; 0x02
    71e2:	2f c0       	rjmp	.+94     	; 0x7242 <Keypad_Update+0x9a>
			{
				/*
				 * read current key value
				 */
				s8_ErrorStatus = DIO_Read(KPD_ROW_PORT, u8_RowPin,
    71e4:	9e 01       	movw	r18, r28
    71e6:	2a 5f       	subi	r18, 0xFA	; 250
    71e8:	3f 4f       	sbci	r19, 0xFF	; 255
    71ea:	82 e0       	ldi	r24, 0x02	; 2
    71ec:	69 81       	ldd	r22, Y+1	; 0x01
    71ee:	a9 01       	movw	r20, r18
    71f0:	0e 94 b6 34 	call	0x696c	; 0x696c <DIO_Read>
    71f4:	8d 83       	std	Y+5, r24	; 0x05
						&u8_KeyState);

				if (u8_KeyState == PRESSED)
    71f6:	8e 81       	ldd	r24, Y+6	; 0x06
    71f8:	88 23       	and	r24, r24
    71fa:	a1 f4       	brne	.+40     	; 0x7224 <Keypad_Update+0x7c>
				{
					gu8_PressedKey = gau8_Keys[u8_Row_Num][u8Col_Num];
    71fc:	8a 81       	ldd	r24, Y+2	; 0x02
    71fe:	28 2f       	mov	r18, r24
    7200:	30 e0       	ldi	r19, 0x00	; 0
    7202:	8c 81       	ldd	r24, Y+4	; 0x04
    7204:	48 2f       	mov	r20, r24
    7206:	50 e0       	ldi	r21, 0x00	; 0
    7208:	c9 01       	movw	r24, r18
    720a:	88 0f       	add	r24, r24
    720c:	99 1f       	adc	r25, r25
    720e:	82 0f       	add	r24, r18
    7210:	93 1f       	adc	r25, r19
    7212:	84 0f       	add	r24, r20
    7214:	95 1f       	adc	r25, r21
    7216:	fc 01       	movw	r30, r24
    7218:	e2 50       	subi	r30, 0x02	; 2
    721a:	ff 4f       	sbci	r31, 0xFF	; 255
    721c:	80 81       	ld	r24, Z
    721e:	80 93 ed 07 	sts	0x07ED, r24
    7222:	09 c0       	rjmp	.+18     	; 0x7236 <Keypad_Update+0x8e>
				}
				else
				{
					if ((u8_Row_Num == 0) && (u8Col_Num == 0))
    7224:	8a 81       	ldd	r24, Y+2	; 0x02
    7226:	88 23       	and	r24, r24
    7228:	31 f4       	brne	.+12     	; 0x7236 <Keypad_Update+0x8e>
    722a:	8c 81       	ldd	r24, Y+4	; 0x04
    722c:	88 23       	and	r24, r24
    722e:	19 f4       	brne	.+6      	; 0x7236 <Keypad_Update+0x8e>
					{
						gu8_PressedKey = NO_KEYPRESSED;
    7230:	8f ef       	ldi	r24, 0xFF	; 255
    7232:	80 93 ed 07 	sts	0x07ED, r24
					else
					{
						/* DO NOTHING */
					}
				}
				u8_RowPin <<= 1;
    7236:	89 81       	ldd	r24, Y+1	; 0x01
    7238:	88 0f       	add	r24, r24
    723a:	89 83       	std	Y+1, r24	; 0x01
			/*
			 * Activate the current column
			 */
			s8_ErrorStatus = DIO_Write(KPD_COL_PORT, u8_ColPin, LOW);
			u8_RowPin = ROW_START;
			for (u8_Row_Num = 0; u8_Row_Num < ROW_MAX; u8_Row_Num++)
    723c:	8a 81       	ldd	r24, Y+2	; 0x02
    723e:	8f 5f       	subi	r24, 0xFF	; 255
    7240:	8a 83       	std	Y+2, r24	; 0x02
    7242:	8a 81       	ldd	r24, Y+2	; 0x02
    7244:	83 30       	cpi	r24, 0x03	; 3
    7246:	70 f2       	brcs	.-100    	; 0x71e4 <Keypad_Update+0x3c>
				u8_RowPin <<= 1;
			}
			/*
			 * Deactivate the current column
			 */
			s8_ErrorStatus = DIO_Write(KPD_COL_PORT, u8_ColPin, HIGH);
    7248:	82 e0       	ldi	r24, 0x02	; 2
    724a:	6b 81       	ldd	r22, Y+3	; 0x03
    724c:	4f ef       	ldi	r20, 0xFF	; 255
    724e:	0e 94 35 34 	call	0x686a	; 0x686a <DIO_Write>
    7252:	8d 83       	std	Y+5, r24	; 0x05
			u8_ColPin <<= 1;
    7254:	8b 81       	ldd	r24, Y+3	; 0x03
    7256:	88 0f       	add	r24, r24
    7258:	8b 83       	std	Y+3, r24	; 0x03
		s8_ErrorStatus = KPD_BASE_ERROR + ERR_NOT_INITIALIZED;
	}
	else
	{
		u8_ColPin = COL_START;
		for (u8Col_Num = 0; u8Col_Num < COL_MAX; u8Col_Num++)
    725a:	8c 81       	ldd	r24, Y+4	; 0x04
    725c:	8f 5f       	subi	r24, 0xFF	; 255
    725e:	8c 83       	std	Y+4, r24	; 0x04
    7260:	8c 81       	ldd	r24, Y+4	; 0x04
    7262:	83 30       	cpi	r24, 0x03	; 3
    7264:	08 f4       	brcc	.+2      	; 0x7268 <Keypad_Update+0xc0>
    7266:	b4 cf       	rjmp	.-152    	; 0x71d0 <Keypad_Update+0x28>
	}

	/*
	 * Function shall return the Error state
	 */
	return (s8_ErrorStatus);
    7268:	8d 81       	ldd	r24, Y+5	; 0x05
}
    726a:	26 96       	adiw	r28, 0x06	; 6
    726c:	0f b6       	in	r0, 0x3f	; 63
    726e:	f8 94       	cli
    7270:	de bf       	out	0x3e, r29	; 62
    7272:	0f be       	out	0x3f, r0	; 63
    7274:	cd bf       	out	0x3d, r28	; 61
    7276:	cf 91       	pop	r28
    7278:	df 91       	pop	r29
    727a:	08 95       	ret

0000727c <Keypad_GetPressedKey>:
 * Description: returns the number of pressed key
 * @param u8_PressedKey(output): the number of pressed key
 * @return: Keypad error status
 */
KPD_ERROR_STATUS Keypad_GetPressedKey(uint8 *u8_PressedKey)
{
    727c:	df 93       	push	r29
    727e:	cf 93       	push	r28
    7280:	00 d0       	rcall	.+0      	; 0x7282 <Keypad_GetPressedKey+0x6>
    7282:	0f 92       	push	r0
    7284:	cd b7       	in	r28, 0x3d	; 61
    7286:	de b7       	in	r29, 0x3e	; 62
    7288:	9b 83       	std	Y+3, r25	; 0x03
    728a:	8a 83       	std	Y+2, r24	; 0x02
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = KPD_BASE_ERROR + ERR_SUCCESS;
    728c:	82 e9       	ldi	r24, 0x92	; 146
    728e:	89 83       	std	Y+1, r24	; 0x01
	static uint8 u8_PreviousKey;

	if (gu8_KeyPadStatus == KEYPAD_UNINITIALIZED)
    7290:	80 91 ee 07 	lds	r24, 0x07EE
    7294:	88 23       	and	r24, r24
    7296:	19 f4       	brne	.+6      	; 0x729e <Keypad_GetPressedKey+0x22>
	{
		s8_ErrorStatus = KPD_BASE_ERROR + ERR_NOT_INITIALIZED;
    7298:	80 e9       	ldi	r24, 0x90	; 144
    729a:	89 83       	std	Y+1, r24	; 0x01
    729c:	1b c0       	rjmp	.+54     	; 0x72d4 <Keypad_GetPressedKey+0x58>
	}
	else if (NULL == u8_PressedKey)
    729e:	8a 81       	ldd	r24, Y+2	; 0x02
    72a0:	9b 81       	ldd	r25, Y+3	; 0x03
    72a2:	00 97       	sbiw	r24, 0x00	; 0
    72a4:	19 f4       	brne	.+6      	; 0x72ac <Keypad_GetPressedKey+0x30>
	{
		s8_ErrorStatus = KPD_BASE_ERROR + ERR_NULL_PTR;
    72a6:	8e e8       	ldi	r24, 0x8E	; 142
    72a8:	89 83       	std	Y+1, r24	; 0x01
    72aa:	14 c0       	rjmp	.+40     	; 0x72d4 <Keypad_GetPressedKey+0x58>
	}
	else
	{
		if (u8_PreviousKey == gu8_PressedKey)
    72ac:	90 91 ec 07 	lds	r25, 0x07EC
    72b0:	80 91 ed 07 	lds	r24, 0x07ED
    72b4:	98 17       	cp	r25, r24
    72b6:	31 f4       	brne	.+12     	; 0x72c4 <Keypad_GetPressedKey+0x48>
		{
			*u8_PressedKey = u8_PreviousKey;
    72b8:	80 91 ec 07 	lds	r24, 0x07EC
    72bc:	ea 81       	ldd	r30, Y+2	; 0x02
    72be:	fb 81       	ldd	r31, Y+3	; 0x03
    72c0:	80 83       	st	Z, r24
    72c2:	04 c0       	rjmp	.+8      	; 0x72cc <Keypad_GetPressedKey+0x50>
		}
		else
		{
			*u8_PressedKey = ALL_RELEASED;
    72c4:	ea 81       	ldd	r30, Y+2	; 0x02
    72c6:	fb 81       	ldd	r31, Y+3	; 0x03
    72c8:	8f ef       	ldi	r24, 0xFF	; 255
    72ca:	80 83       	st	Z, r24
		}
		u8_PreviousKey = gu8_PressedKey;
    72cc:	80 91 ed 07 	lds	r24, 0x07ED
    72d0:	80 93 ec 07 	sts	0x07EC, r24
	}

	/*
	 * Function shall return the Error state
	 */
	return (s8_ErrorStatus);
    72d4:	89 81       	ldd	r24, Y+1	; 0x01
}
    72d6:	0f 90       	pop	r0
    72d8:	0f 90       	pop	r0
    72da:	0f 90       	pop	r0
    72dc:	cf 91       	pop	r28
    72de:	df 91       	pop	r29
    72e0:	08 95       	ret

000072e2 <vDIO_Init>:
 * DIO tasks
 */

/* Task to be created. */
void vDIO_Init(void * pvParameters)
{
    72e2:	df 93       	push	r29
    72e4:	cf 93       	push	r28
    72e6:	cd b7       	in	r28, 0x3d	; 61
    72e8:	de b7       	in	r29, 0x3e	; 62
    72ea:	2a 97       	sbiw	r28, 0x0a	; 10
    72ec:	0f b6       	in	r0, 0x3f	; 63
    72ee:	f8 94       	cli
    72f0:	de bf       	out	0x3e, r29	; 62
    72f2:	0f be       	out	0x3f, r0	; 63
    72f4:	cd bf       	out	0x3d, r28	; 61
    72f6:	9d 83       	std	Y+5, r25	; 0x05
    72f8:	8c 83       	std	Y+4, r24	; 0x04

	for (;;)
	{
		/* Task code goes here. */
		DIO_Cfg_s DIO_test =
		{ GPIOB, UPPER_NIBBLE, OUTPUT };
    72fa:	ce 01       	movw	r24, r28
    72fc:	01 96       	adiw	r24, 0x01	; 1
    72fe:	9f 83       	std	Y+7, r25	; 0x07
    7300:	8e 83       	std	Y+6, r24	; 0x06
    7302:	e7 e0       	ldi	r30, 0x07	; 7
    7304:	f1 e0       	ldi	r31, 0x01	; 1
    7306:	f9 87       	std	Y+9, r31	; 0x09
    7308:	e8 87       	std	Y+8, r30	; 0x08
    730a:	f3 e0       	ldi	r31, 0x03	; 3
    730c:	fa 87       	std	Y+10, r31	; 0x0a
    730e:	e8 85       	ldd	r30, Y+8	; 0x08
    7310:	f9 85       	ldd	r31, Y+9	; 0x09
    7312:	00 80       	ld	r0, Z
    7314:	88 85       	ldd	r24, Y+8	; 0x08
    7316:	99 85       	ldd	r25, Y+9	; 0x09
    7318:	01 96       	adiw	r24, 0x01	; 1
    731a:	99 87       	std	Y+9, r25	; 0x09
    731c:	88 87       	std	Y+8, r24	; 0x08
    731e:	ee 81       	ldd	r30, Y+6	; 0x06
    7320:	ff 81       	ldd	r31, Y+7	; 0x07
    7322:	00 82       	st	Z, r0
    7324:	8e 81       	ldd	r24, Y+6	; 0x06
    7326:	9f 81       	ldd	r25, Y+7	; 0x07
    7328:	01 96       	adiw	r24, 0x01	; 1
    732a:	9f 83       	std	Y+7, r25	; 0x07
    732c:	8e 83       	std	Y+6, r24	; 0x06
    732e:	9a 85       	ldd	r25, Y+10	; 0x0a
    7330:	91 50       	subi	r25, 0x01	; 1
    7332:	9a 87       	std	Y+10, r25	; 0x0a
    7334:	ea 85       	ldd	r30, Y+10	; 0x0a
    7336:	ee 23       	and	r30, r30
    7338:	51 f7       	brne	.-44     	; 0x730e <vDIO_Init+0x2c>
		DIO_init(&DIO_test);
    733a:	ce 01       	movw	r24, r28
    733c:	01 96       	adiw	r24, 0x01	; 1
    733e:	0e 94 90 33 	call	0x6720	; 0x6720 <DIO_init>
		vTaskDelay(100);
    7342:	84 e6       	ldi	r24, 0x64	; 100
    7344:	90 e0       	ldi	r25, 0x00	; 0
    7346:	0e 94 c6 1a 	call	0x358c	; 0x358c <vTaskDelay>
    734a:	d7 cf       	rjmp	.-82     	; 0x72fa <vDIO_Init+0x18>

0000734c <vDio_InitCreation>:
	}
}

/* Function that creates a task. */
void vDio_InitCreation(void)
{
    734c:	ef 92       	push	r14
    734e:	ff 92       	push	r15
    7350:	0f 93       	push	r16
    7352:	df 93       	push	r29
    7354:	cf 93       	push	r28
    7356:	00 d0       	rcall	.+0      	; 0x7358 <vDio_InitCreation+0xc>
    7358:	0f 92       	push	r0
    735a:	cd b7       	in	r28, 0x3d	; 61
    735c:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xReturned;
	TaskHandle_t xDio_Init_Handle = NULL;
    735e:	1b 82       	std	Y+3, r1	; 0x03
    7360:	1a 82       	std	Y+2, r1	; 0x02

	/* Create the task, storing the handle. */
	xReturned = xTaskCreate(vDIO_Init, /* Function that implements the task. */
    7362:	81 e7       	ldi	r24, 0x71	; 113
    7364:	99 e3       	ldi	r25, 0x39	; 57
    7366:	25 e6       	ldi	r18, 0x65	; 101
    7368:	30 e0       	ldi	r19, 0x00	; 0
    736a:	fe 01       	movw	r30, r28
    736c:	32 96       	adiw	r30, 0x02	; 2
    736e:	b9 01       	movw	r22, r18
    7370:	44 e6       	ldi	r20, 0x64	; 100
    7372:	50 e0       	ldi	r21, 0x00	; 0
    7374:	21 e0       	ldi	r18, 0x01	; 1
    7376:	30 e0       	ldi	r19, 0x00	; 0
    7378:	04 e0       	ldi	r16, 0x04	; 4
    737a:	7f 01       	movw	r14, r30
    737c:	0e 94 ad 18 	call	0x315a	; 0x315a <xTaskCreate>
    7380:	89 83       	std	Y+1, r24	; 0x01
	if (xReturned == pdPASS)
	{
		/* The task was created.  Use the task's handle to delete the task. */
		/* vTaskSuspend(xDio_Init_Handle); */
	}
}
    7382:	0f 90       	pop	r0
    7384:	0f 90       	pop	r0
    7386:	0f 90       	pop	r0
    7388:	cf 91       	pop	r28
    738a:	df 91       	pop	r29
    738c:	0f 91       	pop	r16
    738e:	ff 90       	pop	r15
    7390:	ef 90       	pop	r14
    7392:	08 95       	ret

00007394 <vLCD_Init>:

/* Task to be created. */
void vLCD_Init(void * pvParameters)
{
    7394:	df 93       	push	r29
    7396:	cf 93       	push	r28
    7398:	00 d0       	rcall	.+0      	; 0x739a <vLCD_Init+0x6>
    739a:	cd b7       	in	r28, 0x3d	; 61
    739c:	de b7       	in	r29, 0x3e	; 62
    739e:	9a 83       	std	Y+2, r25	; 0x02
    73a0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( ( ( uint32_t ) pvParameters ) == 1 );

	for (;;)
	{
		/* Task code goes here. */
		LCD_init();
    73a2:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <LCD_init>
		vTaskSuspend(NULL);
    73a6:	80 e0       	ldi	r24, 0x00	; 0
    73a8:	90 e0       	ldi	r25, 0x00	; 0
    73aa:	0e 94 e8 1a 	call	0x35d0	; 0x35d0 <vTaskSuspend>
    73ae:	f9 cf       	rjmp	.-14     	; 0x73a2 <vLCD_Init+0xe>

000073b0 <vLCD_InitCreation>:
	}
}

/* Function that creates a task. */
void vLCD_InitCreation(void)
{
    73b0:	ef 92       	push	r14
    73b2:	ff 92       	push	r15
    73b4:	0f 93       	push	r16
    73b6:	df 93       	push	r29
    73b8:	cf 93       	push	r28
    73ba:	00 d0       	rcall	.+0      	; 0x73bc <vLCD_InitCreation+0xc>
    73bc:	0f 92       	push	r0
    73be:	cd b7       	in	r28, 0x3d	; 61
    73c0:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xReturned;
	TaskHandle_t xLCD_Init_Handle = NULL;
    73c2:	1b 82       	std	Y+3, r1	; 0x03
    73c4:	1a 82       	std	Y+2, r1	; 0x02

	/* Create lcdQueueBuffer */
	lcdQueueBuffer = xQueueCreate(1, sizeof(uint8));
    73c6:	81 e0       	ldi	r24, 0x01	; 1
    73c8:	61 e0       	ldi	r22, 0x01	; 1
    73ca:	40 e0       	ldi	r20, 0x00	; 0
    73cc:	0e 94 93 0a 	call	0x1526	; 0x1526 <xQueueGenericCreate>
    73d0:	90 93 f0 07 	sts	0x07F0, r25
    73d4:	80 93 ef 07 	sts	0x07EF, r24

	/* Create the task, storing the handle. */
	xReturned = xTaskCreate(vLCD_Init, /* Function that implements the task. */
    73d8:	8a ec       	ldi	r24, 0xCA	; 202
    73da:	99 e3       	ldi	r25, 0x39	; 57
    73dc:	29 e6       	ldi	r18, 0x69	; 105
    73de:	30 e0       	ldi	r19, 0x00	; 0
    73e0:	fe 01       	movw	r30, r28
    73e2:	32 96       	adiw	r30, 0x02	; 2
    73e4:	b9 01       	movw	r22, r18
    73e6:	44 e6       	ldi	r20, 0x64	; 100
    73e8:	50 e0       	ldi	r21, 0x00	; 0
    73ea:	21 e0       	ldi	r18, 0x01	; 1
    73ec:	30 e0       	ldi	r19, 0x00	; 0
    73ee:	03 e0       	ldi	r16, 0x03	; 3
    73f0:	7f 01       	movw	r14, r30
    73f2:	0e 94 ad 18 	call	0x315a	; 0x315a <xTaskCreate>
    73f6:	89 83       	std	Y+1, r24	; 0x01
	if (xReturned == pdPASS)
	{
		/* The task was created.  Use the task's handle to delete the task. */
		//vTaskSuspend(xLCD_Init_Handle);
	}
}
    73f8:	0f 90       	pop	r0
    73fa:	0f 90       	pop	r0
    73fc:	0f 90       	pop	r0
    73fe:	cf 91       	pop	r28
    7400:	df 91       	pop	r29
    7402:	0f 91       	pop	r16
    7404:	ff 90       	pop	r15
    7406:	ef 90       	pop	r14
    7408:	08 95       	ret

0000740a <vLCD_Print>:

/* Task to be created. */
void vLCD_Print(void * pvParameters)
{
    740a:	df 93       	push	r29
    740c:	cf 93       	push	r28
    740e:	00 d0       	rcall	.+0      	; 0x7410 <vLCD_Print+0x6>
    7410:	0f 92       	push	r0
    7412:	cd b7       	in	r28, 0x3d	; 61
    7414:	de b7       	in	r29, 0x3e	; 62
    7416:	9b 83       	std	Y+3, r25	; 0x03
    7418:	8a 83       	std	Y+2, r24	; 0x02
	/* The parameter value is expected to be 1 as 1 is passed in the
	 pvParameters value in the call to xTaskCreate() below. */
	configASSERT( ( ( uint32_t ) pvParameters ) == 1 );

	uint8 u8_rxBuffer = 0;
    741a:	19 82       	std	Y+1, r1	; 0x01
	u32_Password = 0;
    741c:	10 92 f1 07 	sts	0x07F1, r1
    7420:	10 92 f2 07 	sts	0x07F2, r1
    7424:	10 92 f3 07 	sts	0x07F3, r1
    7428:	10 92 f4 07 	sts	0x07F4, r1

	for (;;)
	{
		/* Task code goes here. */

		if(lcdQueueBuffer != 0)
    742c:	80 91 ef 07 	lds	r24, 0x07EF
    7430:	90 91 f0 07 	lds	r25, 0x07F0
    7434:	00 97       	sbiw	r24, 0x00	; 0
    7436:	09 f4       	brne	.+2      	; 0x743a <vLCD_Print+0x30>
    7438:	d4 c0       	rjmp	.+424    	; 0x75e2 <vLCD_Print+0x1d8>
		{
			if(xQueueReceive(lcdQueueBuffer, &u8_rxBuffer, (TickType_t) 5))
    743a:	80 91 ef 07 	lds	r24, 0x07EF
    743e:	90 91 f0 07 	lds	r25, 0x07F0
    7442:	9e 01       	movw	r18, r28
    7444:	2f 5f       	subi	r18, 0xFF	; 255
    7446:	3f 4f       	sbci	r19, 0xFF	; 255
    7448:	b9 01       	movw	r22, r18
    744a:	45 e0       	ldi	r20, 0x05	; 5
    744c:	50 e0       	ldi	r21, 0x00	; 0
    744e:	0e 94 6a 0c 	call	0x18d4	; 0x18d4 <xQueueReceive>
    7452:	88 23       	and	r24, r24
    7454:	09 f4       	brne	.+2      	; 0x7458 <vLCD_Print+0x4e>
    7456:	c5 c0       	rjmp	.+394    	; 0x75e2 <vLCD_Print+0x1d8>
			{
				if(u8_rxBuffer != NO_KEYPRESSED)
    7458:	89 81       	ldd	r24, Y+1	; 0x01
    745a:	8f 3f       	cpi	r24, 0xFF	; 255
    745c:	09 f4       	brne	.+2      	; 0x7460 <vLCD_Print+0x56>
    745e:	c1 c0       	rjmp	.+386    	; 0x75e2 <vLCD_Print+0x1d8>
				{
					if(u8_rxBuffer == 9)
    7460:	89 81       	ldd	r24, Y+1	; 0x01
    7462:	89 30       	cpi	r24, 0x09	; 9
    7464:	09 f0       	breq	.+2      	; 0x7468 <vLCD_Print+0x5e>
    7466:	74 c0       	rjmp	.+232    	; 0x7550 <vLCD_Print+0x146>
					{
						/* Enter button */
						if(u32_Password == PASSWORD)
    7468:	80 91 f1 07 	lds	r24, 0x07F1
    746c:	90 91 f2 07 	lds	r25, 0x07F2
    7470:	a0 91 f3 07 	lds	r26, 0x07F3
    7474:	b0 91 f4 07 	lds	r27, 0x07F4
    7478:	80 34       	cpi	r24, 0x40	; 64
    747a:	22 ee       	ldi	r18, 0xE2	; 226
    747c:	92 07       	cpc	r25, r18
    747e:	21 e0       	ldi	r18, 0x01	; 1
    7480:	a2 07       	cpc	r26, r18
    7482:	20 e0       	ldi	r18, 0x00	; 0
    7484:	b2 07       	cpc	r27, r18
    7486:	79 f5       	brne	.+94     	; 0x74e6 <vLCD_Print+0xdc>
						{
							/* Password is correct */
							LCD_clear();
    7488:	0e 94 0c 38 	call	0x7018	; 0x7018 <LCD_clear>
							//LCD_send_string("Password correct");

							LCD_send_char('P');
    748c:	80 e5       	ldi	r24, 0x50	; 80
    748e:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('a');
    7492:	81 e6       	ldi	r24, 0x61	; 97
    7494:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('s');
    7498:	83 e7       	ldi	r24, 0x73	; 115
    749a:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('s');
    749e:	83 e7       	ldi	r24, 0x73	; 115
    74a0:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char(' ');
    74a4:	80 e2       	ldi	r24, 0x20	; 32
    74a6:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('c');
    74aa:	83 e6       	ldi	r24, 0x63	; 99
    74ac:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('o');
    74b0:	8f e6       	ldi	r24, 0x6F	; 111
    74b2:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('r');
    74b6:	82 e7       	ldi	r24, 0x72	; 114
    74b8:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('r');
    74bc:	82 e7       	ldi	r24, 0x72	; 114
    74be:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('e');
    74c2:	85 e6       	ldi	r24, 0x65	; 101
    74c4:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('c');
    74c8:	83 e6       	ldi	r24, 0x63	; 99
    74ca:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('t');
    74ce:	84 e7       	ldi	r24, 0x74	; 116
    74d0:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							u32_Password = 0;
    74d4:	10 92 f1 07 	sts	0x07F1, r1
    74d8:	10 92 f2 07 	sts	0x07F2, r1
    74dc:	10 92 f3 07 	sts	0x07F3, r1
    74e0:	10 92 f4 07 	sts	0x07F4, r1
    74e4:	7e c0       	rjmp	.+252    	; 0x75e2 <vLCD_Print+0x1d8>
						}
						else
						{
							/* Password is incorrect */
							LCD_clear();
    74e6:	0e 94 0c 38 	call	0x7018	; 0x7018 <LCD_clear>
							//LCD_send_string("Password incorrect");
							LCD_send_char('P');
    74ea:	80 e5       	ldi	r24, 0x50	; 80
    74ec:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('a');
    74f0:	81 e6       	ldi	r24, 0x61	; 97
    74f2:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('s');
    74f6:	83 e7       	ldi	r24, 0x73	; 115
    74f8:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('s');
    74fc:	83 e7       	ldi	r24, 0x73	; 115
    74fe:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char(' ');
    7502:	80 e2       	ldi	r24, 0x20	; 32
    7504:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('i');
    7508:	89 e6       	ldi	r24, 0x69	; 105
    750a:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('n');
    750e:	8e e6       	ldi	r24, 0x6E	; 110
    7510:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('c');
    7514:	83 e6       	ldi	r24, 0x63	; 99
    7516:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('o');
    751a:	8f e6       	ldi	r24, 0x6F	; 111
    751c:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('r');
    7520:	82 e7       	ldi	r24, 0x72	; 114
    7522:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('r');
    7526:	82 e7       	ldi	r24, 0x72	; 114
    7528:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('e');
    752c:	85 e6       	ldi	r24, 0x65	; 101
    752e:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('c');
    7532:	83 e6       	ldi	r24, 0x63	; 99
    7534:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							LCD_send_char('t');
    7538:	84 e7       	ldi	r24, 0x74	; 116
    753a:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
							u32_Password = 0;
    753e:	10 92 f1 07 	sts	0x07F1, r1
    7542:	10 92 f2 07 	sts	0x07F2, r1
    7546:	10 92 f3 07 	sts	0x07F3, r1
    754a:	10 92 f4 07 	sts	0x07F4, r1
    754e:	49 c0       	rjmp	.+146    	; 0x75e2 <vLCD_Print+0x1d8>
						}
					}
					else if(u8_rxBuffer == 7)
    7550:	89 81       	ldd	r24, Y+1	; 0x01
    7552:	87 30       	cpi	r24, 0x07	; 7
    7554:	59 f4       	brne	.+22     	; 0x756c <vLCD_Print+0x162>
					{
						LCD_clear();
    7556:	0e 94 0c 38 	call	0x7018	; 0x7018 <LCD_clear>
						u32_Password = 0;
    755a:	10 92 f1 07 	sts	0x07F1, r1
    755e:	10 92 f2 07 	sts	0x07F2, r1
    7562:	10 92 f3 07 	sts	0x07F3, r1
    7566:	10 92 f4 07 	sts	0x07F4, r1
    756a:	3b c0       	rjmp	.+118    	; 0x75e2 <vLCD_Print+0x1d8>
					}
					else
					{
						/* Shift password variable to the left */
						u32_Password *= 10;
    756c:	80 91 f1 07 	lds	r24, 0x07F1
    7570:	90 91 f2 07 	lds	r25, 0x07F2
    7574:	a0 91 f3 07 	lds	r26, 0x07F3
    7578:	b0 91 f4 07 	lds	r27, 0x07F4
    757c:	2a e0       	ldi	r18, 0x0A	; 10
    757e:	30 e0       	ldi	r19, 0x00	; 0
    7580:	40 e0       	ldi	r20, 0x00	; 0
    7582:	50 e0       	ldi	r21, 0x00	; 0
    7584:	bc 01       	movw	r22, r24
    7586:	cd 01       	movw	r24, r26
    7588:	0e 94 0c 3c 	call	0x7818	; 0x7818 <__mulsi3>
    758c:	dc 01       	movw	r26, r24
    758e:	cb 01       	movw	r24, r22
    7590:	80 93 f1 07 	sts	0x07F1, r24
    7594:	90 93 f2 07 	sts	0x07F2, r25
    7598:	a0 93 f3 07 	sts	0x07F3, r26
    759c:	b0 93 f4 07 	sts	0x07F4, r27
						/* Append entered digit */
						u32_Password += (u8_rxBuffer);
    75a0:	89 81       	ldd	r24, Y+1	; 0x01
    75a2:	28 2f       	mov	r18, r24
    75a4:	30 e0       	ldi	r19, 0x00	; 0
    75a6:	40 e0       	ldi	r20, 0x00	; 0
    75a8:	50 e0       	ldi	r21, 0x00	; 0
    75aa:	80 91 f1 07 	lds	r24, 0x07F1
    75ae:	90 91 f2 07 	lds	r25, 0x07F2
    75b2:	a0 91 f3 07 	lds	r26, 0x07F3
    75b6:	b0 91 f4 07 	lds	r27, 0x07F4
    75ba:	82 0f       	add	r24, r18
    75bc:	93 1f       	adc	r25, r19
    75be:	a4 1f       	adc	r26, r20
    75c0:	b5 1f       	adc	r27, r21
    75c2:	80 93 f1 07 	sts	0x07F1, r24
    75c6:	90 93 f2 07 	sts	0x07F2, r25
    75ca:	a0 93 f3 07 	sts	0x07F3, r26
    75ce:	b0 93 f4 07 	sts	0x07F4, r27
						/* Print entered digit */
						LCD_send_char(u8_rxBuffer+48);
    75d2:	89 81       	ldd	r24, Y+1	; 0x01
    75d4:	80 5d       	subi	r24, 0xD0	; 208
    75d6:	0e 94 a4 37 	call	0x6f48	; 0x6f48 <LCD_send_char>
						vTaskDelay(1);
    75da:	81 e0       	ldi	r24, 0x01	; 1
    75dc:	90 e0       	ldi	r25, 0x00	; 0
    75de:	0e 94 c6 1a 	call	0x358c	; 0x358c <vTaskDelay>
				}
			}

		}

		vTaskDelay(10);
    75e2:	8a e0       	ldi	r24, 0x0A	; 10
    75e4:	90 e0       	ldi	r25, 0x00	; 0
    75e6:	0e 94 c6 1a 	call	0x358c	; 0x358c <vTaskDelay>
    75ea:	20 cf       	rjmp	.-448    	; 0x742c <vLCD_Print+0x22>

000075ec <vLCD_PrintCreation>:
	}
}

/* Function that creates a task. */
void vLCD_PrintCreation(void)
{
    75ec:	ef 92       	push	r14
    75ee:	ff 92       	push	r15
    75f0:	0f 93       	push	r16
    75f2:	df 93       	push	r29
    75f4:	cf 93       	push	r28
    75f6:	00 d0       	rcall	.+0      	; 0x75f8 <vLCD_PrintCreation+0xc>
    75f8:	0f 92       	push	r0
    75fa:	cd b7       	in	r28, 0x3d	; 61
    75fc:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xReturned;
	TaskHandle_t xLCD_Print_Handle = NULL;
    75fe:	1b 82       	std	Y+3, r1	; 0x03
    7600:	1a 82       	std	Y+2, r1	; 0x02

	/* Create the task, storing the handle. */
	xReturned = xTaskCreate(vLCD_Print, /* Function that implements the task. */
    7602:	85 e0       	ldi	r24, 0x05	; 5
    7604:	9a e3       	ldi	r25, 0x3A	; 58
    7606:	2d e6       	ldi	r18, 0x6D	; 109
    7608:	30 e0       	ldi	r19, 0x00	; 0
    760a:	fe 01       	movw	r30, r28
    760c:	32 96       	adiw	r30, 0x02	; 2
    760e:	b9 01       	movw	r22, r18
    7610:	44 e6       	ldi	r20, 0x64	; 100
    7612:	50 e0       	ldi	r21, 0x00	; 0
    7614:	21 e0       	ldi	r18, 0x01	; 1
    7616:	30 e0       	ldi	r19, 0x00	; 0
    7618:	01 e0       	ldi	r16, 0x01	; 1
    761a:	7f 01       	movw	r14, r30
    761c:	0e 94 ad 18 	call	0x315a	; 0x315a <xTaskCreate>
    7620:	89 83       	std	Y+1, r24	; 0x01
	if (xReturned == pdPASS)
	{
		/* The task was created.  Use the task's handle to delete the task. */
		//vTaskSuspend(NULL);
	}
}
    7622:	0f 90       	pop	r0
    7624:	0f 90       	pop	r0
    7626:	0f 90       	pop	r0
    7628:	cf 91       	pop	r28
    762a:	df 91       	pop	r29
    762c:	0f 91       	pop	r16
    762e:	ff 90       	pop	r15
    7630:	ef 90       	pop	r14
    7632:	08 95       	ret

00007634 <vToggleLED>:
 * LED tasks
 */

/* Task to be created. */
void vToggleLED(void * pvParameters)
{
    7634:	df 93       	push	r29
    7636:	cf 93       	push	r28
    7638:	00 d0       	rcall	.+0      	; 0x763a <vToggleLED+0x6>
    763a:	cd b7       	in	r28, 0x3d	; 61
    763c:	de b7       	in	r29, 0x3e	; 62
    763e:	9a 83       	std	Y+2, r25	; 0x02
    7640:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( ( ( uint32_t ) pvParameters ) == 1 );

	for (;;)
	{
		/* Task code goes here. */
		DIO_Toggle(GPIOB, PIN6);
    7642:	81 e0       	ldi	r24, 0x01	; 1
    7644:	60 e4       	ldi	r22, 0x40	; 64
    7646:	0e 94 1c 35 	call	0x6a38	; 0x6a38 <DIO_Toggle>
		vTaskDelay(1000);
    764a:	88 ee       	ldi	r24, 0xE8	; 232
    764c:	93 e0       	ldi	r25, 0x03	; 3
    764e:	0e 94 c6 1a 	call	0x358c	; 0x358c <vTaskDelay>
    7652:	f7 cf       	rjmp	.-18     	; 0x7642 <vToggleLED+0xe>

00007654 <vToggleLEDCreation>:
	}
}

/* Function that creates a task. */
void vToggleLEDCreation(void)
{
    7654:	ef 92       	push	r14
    7656:	ff 92       	push	r15
    7658:	0f 93       	push	r16
    765a:	df 93       	push	r29
    765c:	cf 93       	push	r28
    765e:	00 d0       	rcall	.+0      	; 0x7660 <vToggleLEDCreation+0xc>
    7660:	0f 92       	push	r0
    7662:	cd b7       	in	r28, 0x3d	; 61
    7664:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xReturned;
	TaskHandle_t xToggleLED_Handle = NULL;
    7666:	1b 82       	std	Y+3, r1	; 0x03
    7668:	1a 82       	std	Y+2, r1	; 0x02

	/* Create the task, storing the handle. */
	xReturned = xTaskCreate(vToggleLED, /* Function that implements the task. */
    766a:	8a e1       	ldi	r24, 0x1A	; 26
    766c:	9b e3       	ldi	r25, 0x3B	; 59
    766e:	27 e7       	ldi	r18, 0x77	; 119
    7670:	30 e0       	ldi	r19, 0x00	; 0
    7672:	fe 01       	movw	r30, r28
    7674:	32 96       	adiw	r30, 0x02	; 2
    7676:	b9 01       	movw	r22, r18
    7678:	44 e6       	ldi	r20, 0x64	; 100
    767a:	50 e0       	ldi	r21, 0x00	; 0
    767c:	21 e0       	ldi	r18, 0x01	; 1
    767e:	30 e0       	ldi	r19, 0x00	; 0
    7680:	01 e0       	ldi	r16, 0x01	; 1
    7682:	7f 01       	movw	r14, r30
    7684:	0e 94 ad 18 	call	0x315a	; 0x315a <xTaskCreate>
    7688:	89 83       	std	Y+1, r24	; 0x01
	if (xReturned == pdPASS)
	{
		/* The task was created.  Use the task's handle to delete the task. */
		//vTaskSuspend(NULL);
	}
}
    768a:	0f 90       	pop	r0
    768c:	0f 90       	pop	r0
    768e:	0f 90       	pop	r0
    7690:	cf 91       	pop	r28
    7692:	df 91       	pop	r29
    7694:	0f 91       	pop	r16
    7696:	ff 90       	pop	r15
    7698:	ef 90       	pop	r14
    769a:	08 95       	ret

0000769c <vKeyPad_Init>:
 */


/* Task to be created. */
void vKeyPad_Init(void * pvParameters)
{
    769c:	df 93       	push	r29
    769e:	cf 93       	push	r28
    76a0:	00 d0       	rcall	.+0      	; 0x76a2 <vKeyPad_Init+0x6>
    76a2:	cd b7       	in	r28, 0x3d	; 61
    76a4:	de b7       	in	r29, 0x3e	; 62
    76a6:	9a 83       	std	Y+2, r25	; 0x02
    76a8:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( ( ( uint32_t ) pvParameters ) == 1 );

	for (;;)
	{
		/* Task code goes here. */
		Keypad_Init();
    76aa:	0e 94 7a 38 	call	0x70f4	; 0x70f4 <Keypad_Init>
		vTaskSuspend(NULL);
    76ae:	80 e0       	ldi	r24, 0x00	; 0
    76b0:	90 e0       	ldi	r25, 0x00	; 0
    76b2:	0e 94 e8 1a 	call	0x35d0	; 0x35d0 <vTaskSuspend>
    76b6:	f9 cf       	rjmp	.-14     	; 0x76aa <vKeyPad_Init+0xe>

000076b8 <vKeypad_InitCreation>:
	}
}

/* Function that creates a task. */
void vKeypad_InitCreation(void)
{
    76b8:	ef 92       	push	r14
    76ba:	ff 92       	push	r15
    76bc:	0f 93       	push	r16
    76be:	df 93       	push	r29
    76c0:	cf 93       	push	r28
    76c2:	00 d0       	rcall	.+0      	; 0x76c4 <vKeypad_InitCreation+0xc>
    76c4:	0f 92       	push	r0
    76c6:	cd b7       	in	r28, 0x3d	; 61
    76c8:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xReturned;
	TaskHandle_t xKeypad_Init_Handle = NULL;
    76ca:	1b 82       	std	Y+3, r1	; 0x03
    76cc:	1a 82       	std	Y+2, r1	; 0x02

	/* Create the task, storing the handle. */
	xReturned = xTaskCreate(vKeyPad_Init, /* Function that implements the task. */
    76ce:	8e e4       	ldi	r24, 0x4E	; 78
    76d0:	9b e3       	ldi	r25, 0x3B	; 59
    76d2:	22 e8       	ldi	r18, 0x82	; 130
    76d4:	30 e0       	ldi	r19, 0x00	; 0
    76d6:	fe 01       	movw	r30, r28
    76d8:	32 96       	adiw	r30, 0x02	; 2
    76da:	b9 01       	movw	r22, r18
    76dc:	44 e6       	ldi	r20, 0x64	; 100
    76de:	50 e0       	ldi	r21, 0x00	; 0
    76e0:	21 e0       	ldi	r18, 0x01	; 1
    76e2:	30 e0       	ldi	r19, 0x00	; 0
    76e4:	03 e0       	ldi	r16, 0x03	; 3
    76e6:	7f 01       	movw	r14, r30
    76e8:	0e 94 ad 18 	call	0x315a	; 0x315a <xTaskCreate>
    76ec:	89 83       	std	Y+1, r24	; 0x01
	if (xReturned == pdPASS)
	{
		/* The task was created.  Use the task's handle to delete the task. */
//		vTaskSuspend(xKeypad_Init_Handle);
	}
}
    76ee:	0f 90       	pop	r0
    76f0:	0f 90       	pop	r0
    76f2:	0f 90       	pop	r0
    76f4:	cf 91       	pop	r28
    76f6:	df 91       	pop	r29
    76f8:	0f 91       	pop	r16
    76fa:	ff 90       	pop	r15
    76fc:	ef 90       	pop	r14
    76fe:	08 95       	ret

00007700 <vKeyPad_Update>:

/* Task to be created. */
void vKeyPad_Update(void * pvParameters)
{
    7700:	df 93       	push	r29
    7702:	cf 93       	push	r28
    7704:	00 d0       	rcall	.+0      	; 0x7706 <vKeyPad_Update+0x6>
    7706:	cd b7       	in	r28, 0x3d	; 61
    7708:	de b7       	in	r29, 0x3e	; 62
    770a:	9a 83       	std	Y+2, r25	; 0x02
    770c:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( ( ( uint32_t ) pvParameters ) == 1 );

	for (;;)
	{
		/* Task code goes here. */
		Keypad_Update();
    770e:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <Keypad_Update>
		vTaskDelay(50);
    7712:	82 e3       	ldi	r24, 0x32	; 50
    7714:	90 e0       	ldi	r25, 0x00	; 0
    7716:	0e 94 c6 1a 	call	0x358c	; 0x358c <vTaskDelay>
    771a:	f9 cf       	rjmp	.-14     	; 0x770e <vKeyPad_Update+0xe>

0000771c <vKeyPad_UpdateCreation>:
	}
}

/* Function that creates a task. */
void vKeyPad_UpdateCreation(void)
{
    771c:	ef 92       	push	r14
    771e:	ff 92       	push	r15
    7720:	0f 93       	push	r16
    7722:	df 93       	push	r29
    7724:	cf 93       	push	r28
    7726:	00 d0       	rcall	.+0      	; 0x7728 <vKeyPad_UpdateCreation+0xc>
    7728:	0f 92       	push	r0
    772a:	cd b7       	in	r28, 0x3d	; 61
    772c:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xReturned;
	TaskHandle_t xKeyPad_Update_Handle = NULL;
    772e:	1b 82       	std	Y+3, r1	; 0x03
    7730:	1a 82       	std	Y+2, r1	; 0x02

	/* Create the task, storing the handle. */
	xReturned = xTaskCreate(vKeyPad_Update, /* Function that implements the task. */
    7732:	80 e8       	ldi	r24, 0x80	; 128
    7734:	9b e3       	ldi	r25, 0x3B	; 59
    7736:	28 e9       	ldi	r18, 0x98	; 152
    7738:	30 e0       	ldi	r19, 0x00	; 0
    773a:	fe 01       	movw	r30, r28
    773c:	32 96       	adiw	r30, 0x02	; 2
    773e:	b9 01       	movw	r22, r18
    7740:	44 e6       	ldi	r20, 0x64	; 100
    7742:	50 e0       	ldi	r21, 0x00	; 0
    7744:	21 e0       	ldi	r18, 0x01	; 1
    7746:	30 e0       	ldi	r19, 0x00	; 0
    7748:	02 e0       	ldi	r16, 0x02	; 2
    774a:	7f 01       	movw	r14, r30
    774c:	0e 94 ad 18 	call	0x315a	; 0x315a <xTaskCreate>
    7750:	89 83       	std	Y+1, r24	; 0x01
	if (xReturned == pdPASS)
	{
		/* The task was created.  Use the task's handle to delete the task. */
//		vTaskSuspend(xKeyPad_Update_Handle);
	}
}
    7752:	0f 90       	pop	r0
    7754:	0f 90       	pop	r0
    7756:	0f 90       	pop	r0
    7758:	cf 91       	pop	r28
    775a:	df 91       	pop	r29
    775c:	0f 91       	pop	r16
    775e:	ff 90       	pop	r15
    7760:	ef 90       	pop	r14
    7762:	08 95       	ret

00007764 <vKeyPad_GetPressedKey>:

/* Task to be created. */
void vKeyPad_GetPressedKey(void * pvParameters)
{
    7764:	df 93       	push	r29
    7766:	cf 93       	push	r28
    7768:	00 d0       	rcall	.+0      	; 0x776a <vKeyPad_GetPressedKey+0x6>
    776a:	0f 92       	push	r0
    776c:	cd b7       	in	r28, 0x3d	; 61
    776e:	de b7       	in	r29, 0x3e	; 62
    7770:	9b 83       	std	Y+3, r25	; 0x03
    7772:	8a 83       	std	Y+2, r24	; 0x02

	uint8 u8_Key;
	for (;;)
	{
		/* Task code goes here. */
		Keypad_GetPressedKey(&u8_Key);
    7774:	ce 01       	movw	r24, r28
    7776:	01 96       	adiw	r24, 0x01	; 1
    7778:	0e 94 3e 39 	call	0x727c	; 0x727c <Keypad_GetPressedKey>
		//xQueueSend(pvParameters,&u8_Key,250);
		if(u8_Key != NO_KEYPRESSED)
    777c:	89 81       	ldd	r24, Y+1	; 0x01
    777e:	8f 3f       	cpi	r24, 0xFF	; 255
    7780:	69 f0       	breq	.+26     	; 0x779c <vKeyPad_GetPressedKey+0x38>
		{
			xQueueSend(lcdQueueBuffer, &u8_Key, (TickType_t) 0);
    7782:	80 91 ef 07 	lds	r24, 0x07EF
    7786:	90 91 f0 07 	lds	r25, 0x07F0
    778a:	9e 01       	movw	r18, r28
    778c:	2f 5f       	subi	r18, 0xFF	; 255
    778e:	3f 4f       	sbci	r19, 0xFF	; 255
    7790:	b9 01       	movw	r22, r18
    7792:	40 e0       	ldi	r20, 0x00	; 0
    7794:	50 e0       	ldi	r21, 0x00	; 0
    7796:	20 e0       	ldi	r18, 0x00	; 0
    7798:	0e 94 1f 0b 	call	0x163e	; 0x163e <xQueueGenericSend>
		else
		{
			/* Do nothing */
		}

		vTaskDelay(100);
    779c:	84 e6       	ldi	r24, 0x64	; 100
    779e:	90 e0       	ldi	r25, 0x00	; 0
    77a0:	0e 94 c6 1a 	call	0x358c	; 0x358c <vTaskDelay>
    77a4:	e7 cf       	rjmp	.-50     	; 0x7774 <vKeyPad_GetPressedKey+0x10>

000077a6 <vKeyPad_GetPressedKeyCreation>:
	}
}

/* Function that creates a task. */
void vKeyPad_GetPressedKeyCreation(void)
{
    77a6:	ef 92       	push	r14
    77a8:	ff 92       	push	r15
    77aa:	0f 93       	push	r16
    77ac:	df 93       	push	r29
    77ae:	cf 93       	push	r28
    77b0:	00 d0       	rcall	.+0      	; 0x77b2 <vKeyPad_GetPressedKeyCreation+0xc>
    77b2:	0f 92       	push	r0
    77b4:	cd b7       	in	r28, 0x3d	; 61
    77b6:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xReturned;
	TaskHandle_t xKeyPad_GetPressedKey_Handle = NULL;
    77b8:	1b 82       	std	Y+3, r1	; 0x03
    77ba:	1a 82       	std	Y+2, r1	; 0x02

	/* Create the task, storing the handle. */
	xReturned = xTaskCreate(vKeyPad_GetPressedKey, /* Function that implements the task. */
    77bc:	82 eb       	ldi	r24, 0xB2	; 178
    77be:	9b e3       	ldi	r25, 0x3B	; 59
    77c0:	26 ea       	ldi	r18, 0xA6	; 166
    77c2:	30 e0       	ldi	r19, 0x00	; 0
    77c4:	fe 01       	movw	r30, r28
    77c6:	32 96       	adiw	r30, 0x02	; 2
    77c8:	b9 01       	movw	r22, r18
    77ca:	44 e6       	ldi	r20, 0x64	; 100
    77cc:	50 e0       	ldi	r21, 0x00	; 0
    77ce:	21 e0       	ldi	r18, 0x01	; 1
    77d0:	30 e0       	ldi	r19, 0x00	; 0
    77d2:	02 e0       	ldi	r16, 0x02	; 2
    77d4:	7f 01       	movw	r14, r30
    77d6:	0e 94 ad 18 	call	0x315a	; 0x315a <xTaskCreate>
    77da:	89 83       	std	Y+1, r24	; 0x01
	if (xReturned == pdPASS)
	{
		/* The task was created.  Use the task's handle to delete the task. */
//		vTaskSuspend(xKeyPad_Update_Handle);
	}
}
    77dc:	0f 90       	pop	r0
    77de:	0f 90       	pop	r0
    77e0:	0f 90       	pop	r0
    77e2:	cf 91       	pop	r28
    77e4:	df 91       	pop	r29
    77e6:	0f 91       	pop	r16
    77e8:	ff 90       	pop	r15
    77ea:	ef 90       	pop	r14
    77ec:	08 95       	ret

000077ee <main>:


#include "Tasks.h"

int main(void)
{
    77ee:	df 93       	push	r29
    77f0:	cf 93       	push	r28
    77f2:	cd b7       	in	r28, 0x3d	; 61
    77f4:	de b7       	in	r29, 0x3e	; 62
	vDio_InitCreation();
    77f6:	0e 94 a6 39 	call	0x734c	; 0x734c <vDio_InitCreation>
	vToggleLEDCreation();
    77fa:	0e 94 2a 3b 	call	0x7654	; 0x7654 <vToggleLEDCreation>
	vKeypad_InitCreation();
    77fe:	0e 94 5c 3b 	call	0x76b8	; 0x76b8 <vKeypad_InitCreation>
	vKeyPad_UpdateCreation();
    7802:	0e 94 8e 3b 	call	0x771c	; 0x771c <vKeyPad_UpdateCreation>
	vLCD_InitCreation();
    7806:	0e 94 d8 39 	call	0x73b0	; 0x73b0 <vLCD_InitCreation>
	vLCD_PrintCreation();
    780a:	0e 94 f6 3a 	call	0x75ec	; 0x75ec <vLCD_PrintCreation>
	vKeyPad_GetPressedKeyCreation();
    780e:	0e 94 d3 3b 	call	0x77a6	; 0x77a6 <vKeyPad_GetPressedKeyCreation>

	/* Start Scheduler */
	vTaskStartScheduler();
    7812:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <vTaskStartScheduler>
    7816:	ff cf       	rjmp	.-2      	; 0x7816 <main+0x28>

00007818 <__mulsi3>:
    7818:	62 9f       	mul	r22, r18
    781a:	d0 01       	movw	r26, r0
    781c:	73 9f       	mul	r23, r19
    781e:	f0 01       	movw	r30, r0
    7820:	82 9f       	mul	r24, r18
    7822:	e0 0d       	add	r30, r0
    7824:	f1 1d       	adc	r31, r1
    7826:	64 9f       	mul	r22, r20
    7828:	e0 0d       	add	r30, r0
    782a:	f1 1d       	adc	r31, r1
    782c:	92 9f       	mul	r25, r18
    782e:	f0 0d       	add	r31, r0
    7830:	83 9f       	mul	r24, r19
    7832:	f0 0d       	add	r31, r0
    7834:	74 9f       	mul	r23, r20
    7836:	f0 0d       	add	r31, r0
    7838:	65 9f       	mul	r22, r21
    783a:	f0 0d       	add	r31, r0
    783c:	99 27       	eor	r25, r25
    783e:	72 9f       	mul	r23, r18
    7840:	b0 0d       	add	r27, r0
    7842:	e1 1d       	adc	r30, r1
    7844:	f9 1f       	adc	r31, r25
    7846:	63 9f       	mul	r22, r19
    7848:	b0 0d       	add	r27, r0
    784a:	e1 1d       	adc	r30, r1
    784c:	f9 1f       	adc	r31, r25
    784e:	bd 01       	movw	r22, r26
    7850:	cf 01       	movw	r24, r30
    7852:	11 24       	eor	r1, r1
    7854:	08 95       	ret

00007856 <__udivmodhi4>:
    7856:	aa 1b       	sub	r26, r26
    7858:	bb 1b       	sub	r27, r27
    785a:	51 e1       	ldi	r21, 0x11	; 17
    785c:	07 c0       	rjmp	.+14     	; 0x786c <__udivmodhi4_ep>

0000785e <__udivmodhi4_loop>:
    785e:	aa 1f       	adc	r26, r26
    7860:	bb 1f       	adc	r27, r27
    7862:	a6 17       	cp	r26, r22
    7864:	b7 07       	cpc	r27, r23
    7866:	10 f0       	brcs	.+4      	; 0x786c <__udivmodhi4_ep>
    7868:	a6 1b       	sub	r26, r22
    786a:	b7 0b       	sbc	r27, r23

0000786c <__udivmodhi4_ep>:
    786c:	88 1f       	adc	r24, r24
    786e:	99 1f       	adc	r25, r25
    7870:	5a 95       	dec	r21
    7872:	a9 f7       	brne	.-22     	; 0x785e <__udivmodhi4_loop>
    7874:	80 95       	com	r24
    7876:	90 95       	com	r25
    7878:	bc 01       	movw	r22, r24
    787a:	cd 01       	movw	r24, r26
    787c:	08 95       	ret

0000787e <__udivmodsi4>:
    787e:	a1 e2       	ldi	r26, 0x21	; 33
    7880:	1a 2e       	mov	r1, r26
    7882:	aa 1b       	sub	r26, r26
    7884:	bb 1b       	sub	r27, r27
    7886:	fd 01       	movw	r30, r26
    7888:	0d c0       	rjmp	.+26     	; 0x78a4 <__udivmodsi4_ep>

0000788a <__udivmodsi4_loop>:
    788a:	aa 1f       	adc	r26, r26
    788c:	bb 1f       	adc	r27, r27
    788e:	ee 1f       	adc	r30, r30
    7890:	ff 1f       	adc	r31, r31
    7892:	a2 17       	cp	r26, r18
    7894:	b3 07       	cpc	r27, r19
    7896:	e4 07       	cpc	r30, r20
    7898:	f5 07       	cpc	r31, r21
    789a:	20 f0       	brcs	.+8      	; 0x78a4 <__udivmodsi4_ep>
    789c:	a2 1b       	sub	r26, r18
    789e:	b3 0b       	sbc	r27, r19
    78a0:	e4 0b       	sbc	r30, r20
    78a2:	f5 0b       	sbc	r31, r21

000078a4 <__udivmodsi4_ep>:
    78a4:	66 1f       	adc	r22, r22
    78a6:	77 1f       	adc	r23, r23
    78a8:	88 1f       	adc	r24, r24
    78aa:	99 1f       	adc	r25, r25
    78ac:	1a 94       	dec	r1
    78ae:	69 f7       	brne	.-38     	; 0x788a <__udivmodsi4_loop>
    78b0:	60 95       	com	r22
    78b2:	70 95       	com	r23
    78b4:	80 95       	com	r24
    78b6:	90 95       	com	r25
    78b8:	9b 01       	movw	r18, r22
    78ba:	ac 01       	movw	r20, r24
    78bc:	bd 01       	movw	r22, r26
    78be:	cf 01       	movw	r24, r30
    78c0:	08 95       	ret

000078c2 <memcpy>:
    78c2:	fb 01       	movw	r30, r22
    78c4:	dc 01       	movw	r26, r24
    78c6:	02 c0       	rjmp	.+4      	; 0x78cc <memcpy+0xa>
    78c8:	01 90       	ld	r0, Z+
    78ca:	0d 92       	st	X+, r0
    78cc:	41 50       	subi	r20, 0x01	; 1
    78ce:	50 40       	sbci	r21, 0x00	; 0
    78d0:	d8 f7       	brcc	.-10     	; 0x78c8 <memcpy+0x6>
    78d2:	08 95       	ret

000078d4 <memset>:
    78d4:	dc 01       	movw	r26, r24
    78d6:	01 c0       	rjmp	.+2      	; 0x78da <memset+0x6>
    78d8:	6d 93       	st	X+, r22
    78da:	41 50       	subi	r20, 0x01	; 1
    78dc:	50 40       	sbci	r21, 0x00	; 0
    78de:	e0 f7       	brcc	.-8      	; 0x78d8 <memset+0x4>
    78e0:	08 95       	ret

000078e2 <_exit>:
    78e2:	f8 94       	cli

000078e4 <__stop_program>:
    78e4:	ff cf       	rjmp	.-2      	; 0x78e4 <__stop_program>
