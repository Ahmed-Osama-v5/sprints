
FreeRTOS_Story3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005096  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000016  00800060  00005096  0000512a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000649  00800076  00800076  00005140  2**0
                  ALLOC
  3 .debug_aranges 000004d0  00000000  00000000  00005140  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000a2c  00000000  00000000  00005610  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003d00  00000000  00000000  0000603c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000bf7  00000000  00000000  00009d3c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000050b8  00000000  00000000  0000a933  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000840  00000000  00000000  0000f9ec  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001908  00000000  00000000  0001022c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_macinfo 0004ad0c  00000000  00000000  00011b34  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000478  00000000  00000000  0005c840  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 11 08 	jmp	0x1022	; 0x1022 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e9       	ldi	r30, 0x96	; 150
      68:	f0 e5       	ldi	r31, 0x50	; 80
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 37       	cpi	r26, 0x76	; 118
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	a6 e7       	ldi	r26, 0x76	; 118
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 3b       	cpi	r26, 0xBF	; 191
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 e2 27 	call	0x4fc4	; 0x4fc4 <main>
      8a:	0c 94 49 28 	jmp	0x5092	; 0x5092 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <xEventGroupCreate+0x6>
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
      9c:	8b e0       	ldi	r24, 0x0B	; 11
      9e:	90 e0       	ldi	r25, 0x00	; 0
      a0:	0e 94 8e 03 	call	0x71c	; 0x71c <pvPortMalloc>
      a4:	9a 83       	std	Y+2, r25	; 0x02
      a6:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
      a8:	89 81       	ldd	r24, Y+1	; 0x01
      aa:	9a 81       	ldd	r25, Y+2	; 0x02
      ac:	00 97       	sbiw	r24, 0x00	; 0
      ae:	49 f0       	breq	.+18     	; 0xc2 <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
      b0:	e9 81       	ldd	r30, Y+1	; 0x01
      b2:	fa 81       	ldd	r31, Y+2	; 0x02
      b4:	11 82       	std	Z+1, r1	; 0x01
      b6:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
      b8:	89 81       	ldd	r24, Y+1	; 0x01
      ba:	9a 81       	ldd	r25, Y+2	; 0x02
      bc:	02 96       	adiw	r24, 0x02	; 2
      be:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
      c2:	89 81       	ldd	r24, Y+1	; 0x01
      c4:	9a 81       	ldd	r25, Y+2	; 0x02
	}
      c6:	0f 90       	pop	r0
      c8:	0f 90       	pop	r0
      ca:	cf 91       	pop	r28
      cc:	df 91       	pop	r29
      ce:	08 95       	ret

000000d0 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
      d0:	df 93       	push	r29
      d2:	cf 93       	push	r28
      d4:	cd b7       	in	r28, 0x3d	; 61
      d6:	de b7       	in	r29, 0x3e	; 62
      d8:	60 97       	sbiw	r28, 0x10	; 16
      da:	0f b6       	in	r0, 0x3f	; 63
      dc:	f8 94       	cli
      de:	de bf       	out	0x3e, r29	; 62
      e0:	0f be       	out	0x3f, r0	; 63
      e2:	cd bf       	out	0x3d, r28	; 61
      e4:	9a 87       	std	Y+10, r25	; 0x0a
      e6:	89 87       	std	Y+9, r24	; 0x09
      e8:	7c 87       	std	Y+12, r23	; 0x0c
      ea:	6b 87       	std	Y+11, r22	; 0x0b
      ec:	5e 87       	std	Y+14, r21	; 0x0e
      ee:	4d 87       	std	Y+13, r20	; 0x0d
      f0:	38 8b       	std	Y+16, r19	; 0x10
      f2:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
      f4:	89 85       	ldd	r24, Y+9	; 0x09
      f6:	9a 85       	ldd	r25, Y+10	; 0x0a
      f8:	9c 83       	std	Y+4, r25	; 0x04
      fa:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
      fc:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
      fe:	0e 94 b8 1a 	call	0x3570	; 0x3570 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     102:	eb 81       	ldd	r30, Y+3	; 0x03
     104:	fc 81       	ldd	r31, Y+4	; 0x04
     106:	80 81       	ld	r24, Z
     108:	91 81       	ldd	r25, Z+1	; 0x01
     10a:	98 87       	std	Y+8, r25	; 0x08
     10c:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     10e:	89 85       	ldd	r24, Y+9	; 0x09
     110:	9a 85       	ldd	r25, Y+10	; 0x0a
     112:	2b 85       	ldd	r18, Y+11	; 0x0b
     114:	3c 85       	ldd	r19, Y+12	; 0x0c
     116:	b9 01       	movw	r22, r18
     118:	0e 94 3f 02 	call	0x47e	; 0x47e <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     11c:	2f 81       	ldd	r18, Y+7	; 0x07
     11e:	38 85       	ldd	r19, Y+8	; 0x08
     120:	8b 85       	ldd	r24, Y+11	; 0x0b
     122:	9c 85       	ldd	r25, Y+12	; 0x0c
     124:	28 2b       	or	r18, r24
     126:	39 2b       	or	r19, r25
     128:	8d 85       	ldd	r24, Y+13	; 0x0d
     12a:	9e 85       	ldd	r25, Y+14	; 0x0e
     12c:	28 23       	and	r18, r24
     12e:	39 23       	and	r19, r25
     130:	8d 85       	ldd	r24, Y+13	; 0x0d
     132:	9e 85       	ldd	r25, Y+14	; 0x0e
     134:	28 17       	cp	r18, r24
     136:	39 07       	cpc	r19, r25
     138:	c9 f4       	brne	.+50     	; 0x16c <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     13a:	2f 81       	ldd	r18, Y+7	; 0x07
     13c:	38 85       	ldd	r19, Y+8	; 0x08
     13e:	8b 85       	ldd	r24, Y+11	; 0x0b
     140:	9c 85       	ldd	r25, Y+12	; 0x0c
     142:	82 2b       	or	r24, r18
     144:	93 2b       	or	r25, r19
     146:	9e 83       	std	Y+6, r25	; 0x06
     148:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     14a:	eb 81       	ldd	r30, Y+3	; 0x03
     14c:	fc 81       	ldd	r31, Y+4	; 0x04
     14e:	20 81       	ld	r18, Z
     150:	31 81       	ldd	r19, Z+1	; 0x01
     152:	8d 85       	ldd	r24, Y+13	; 0x0d
     154:	9e 85       	ldd	r25, Y+14	; 0x0e
     156:	80 95       	com	r24
     158:	90 95       	com	r25
     15a:	82 23       	and	r24, r18
     15c:	93 23       	and	r25, r19
     15e:	eb 81       	ldd	r30, Y+3	; 0x03
     160:	fc 81       	ldd	r31, Y+4	; 0x04
     162:	91 83       	std	Z+1, r25	; 0x01
     164:	80 83       	st	Z, r24

			xTicksToWait = 0;
     166:	18 8a       	std	Y+16, r1	; 0x10
     168:	1f 86       	std	Y+15, r1	; 0x0f
     16a:	1e c0       	rjmp	.+60     	; 0x1a8 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     16c:	8f 85       	ldd	r24, Y+15	; 0x0f
     16e:	98 89       	ldd	r25, Y+16	; 0x10
     170:	00 97       	sbiw	r24, 0x00	; 0
     172:	91 f0       	breq	.+36     	; 0x198 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     174:	8b 81       	ldd	r24, Y+3	; 0x03
     176:	9c 81       	ldd	r25, Y+4	; 0x04
     178:	bc 01       	movw	r22, r24
     17a:	6e 5f       	subi	r22, 0xFE	; 254
     17c:	7f 4f       	sbci	r23, 0xFF	; 255
     17e:	8d 85       	ldd	r24, Y+13	; 0x0d
     180:	9e 85       	ldd	r25, Y+14	; 0x0e
     182:	9c 01       	movw	r18, r24
     184:	35 60       	ori	r19, 0x05	; 5
     186:	4f 85       	ldd	r20, Y+15	; 0x0f
     188:	58 89       	ldd	r21, Y+16	; 0x10
     18a:	cb 01       	movw	r24, r22
     18c:	b9 01       	movw	r22, r18
     18e:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     192:	1e 82       	std	Y+6, r1	; 0x06
     194:	1d 82       	std	Y+5, r1	; 0x05
     196:	08 c0       	rjmp	.+16     	; 0x1a8 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     198:	eb 81       	ldd	r30, Y+3	; 0x03
     19a:	fc 81       	ldd	r31, Y+4	; 0x04
     19c:	80 81       	ld	r24, Z
     19e:	91 81       	ldd	r25, Z+1	; 0x01
     1a0:	9e 83       	std	Y+6, r25	; 0x06
     1a2:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     1a4:	81 e0       	ldi	r24, 0x01	; 1
     1a6:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     1a8:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>
     1ac:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     1ae:	8f 85       	ldd	r24, Y+15	; 0x0f
     1b0:	98 89       	ldd	r25, Y+16	; 0x10
     1b2:	00 97       	sbiw	r24, 0x00	; 0
     1b4:	09 f4       	brne	.+2      	; 0x1b8 <xEventGroupSync+0xe8>
     1b6:	3a c0       	rjmp	.+116    	; 0x22c <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
     1b8:	8a 81       	ldd	r24, Y+2	; 0x02
     1ba:	88 23       	and	r24, r24
     1bc:	11 f4       	brne	.+4      	; 0x1c2 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     1be:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     1c2:	0e 94 2b 1f 	call	0x3e56	; 0x3e56 <uxTaskResetEventItemValue>
     1c6:	9e 83       	std	Y+6, r25	; 0x06
     1c8:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     1ca:	8d 81       	ldd	r24, Y+5	; 0x05
     1cc:	9e 81       	ldd	r25, Y+6	; 0x06
     1ce:	80 70       	andi	r24, 0x00	; 0
     1d0:	92 70       	andi	r25, 0x02	; 2
     1d2:	00 97       	sbiw	r24, 0x00	; 0
     1d4:	31 f5       	brne	.+76     	; 0x222 <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     1d6:	0f b6       	in	r0, 0x3f	; 63
     1d8:	f8 94       	cli
     1da:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     1dc:	eb 81       	ldd	r30, Y+3	; 0x03
     1de:	fc 81       	ldd	r31, Y+4	; 0x04
     1e0:	80 81       	ld	r24, Z
     1e2:	91 81       	ldd	r25, Z+1	; 0x01
     1e4:	9e 83       	std	Y+6, r25	; 0x06
     1e6:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     1e8:	2d 81       	ldd	r18, Y+5	; 0x05
     1ea:	3e 81       	ldd	r19, Y+6	; 0x06
     1ec:	8d 85       	ldd	r24, Y+13	; 0x0d
     1ee:	9e 85       	ldd	r25, Y+14	; 0x0e
     1f0:	28 23       	and	r18, r24
     1f2:	39 23       	and	r19, r25
     1f4:	8d 85       	ldd	r24, Y+13	; 0x0d
     1f6:	9e 85       	ldd	r25, Y+14	; 0x0e
     1f8:	28 17       	cp	r18, r24
     1fa:	39 07       	cpc	r19, r25
     1fc:	71 f4       	brne	.+28     	; 0x21a <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     1fe:	eb 81       	ldd	r30, Y+3	; 0x03
     200:	fc 81       	ldd	r31, Y+4	; 0x04
     202:	20 81       	ld	r18, Z
     204:	31 81       	ldd	r19, Z+1	; 0x01
     206:	8d 85       	ldd	r24, Y+13	; 0x0d
     208:	9e 85       	ldd	r25, Y+14	; 0x0e
     20a:	80 95       	com	r24
     20c:	90 95       	com	r25
     20e:	82 23       	and	r24, r18
     210:	93 23       	and	r25, r19
     212:	eb 81       	ldd	r30, Y+3	; 0x03
     214:	fc 81       	ldd	r31, Y+4	; 0x04
     216:	91 83       	std	Z+1, r25	; 0x01
     218:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     21a:	0f 90       	pop	r0
     21c:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     21e:	81 e0       	ldi	r24, 0x01	; 1
     220:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     222:	8d 81       	ldd	r24, Y+5	; 0x05
     224:	9e 81       	ldd	r25, Y+6	; 0x06
     226:	90 70       	andi	r25, 0x00	; 0
     228:	9e 83       	std	Y+6, r25	; 0x06
     22a:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     22c:	8d 81       	ldd	r24, Y+5	; 0x05
     22e:	9e 81       	ldd	r25, Y+6	; 0x06
}
     230:	60 96       	adiw	r28, 0x10	; 16
     232:	0f b6       	in	r0, 0x3f	; 63
     234:	f8 94       	cli
     236:	de bf       	out	0x3e, r29	; 62
     238:	0f be       	out	0x3f, r0	; 63
     23a:	cd bf       	out	0x3d, r28	; 61
     23c:	cf 91       	pop	r28
     23e:	df 91       	pop	r29
     240:	08 95       	ret

00000242 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     242:	0f 93       	push	r16
     244:	1f 93       	push	r17
     246:	df 93       	push	r29
     248:	cf 93       	push	r28
     24a:	cd b7       	in	r28, 0x3d	; 61
     24c:	de b7       	in	r29, 0x3e	; 62
     24e:	63 97       	sbiw	r28, 0x13	; 19
     250:	0f b6       	in	r0, 0x3f	; 63
     252:	f8 94       	cli
     254:	de bf       	out	0x3e, r29	; 62
     256:	0f be       	out	0x3f, r0	; 63
     258:	cd bf       	out	0x3d, r28	; 61
     25a:	9d 87       	std	Y+13, r25	; 0x0d
     25c:	8c 87       	std	Y+12, r24	; 0x0c
     25e:	7f 87       	std	Y+15, r23	; 0x0f
     260:	6e 87       	std	Y+14, r22	; 0x0e
     262:	48 8b       	std	Y+16, r20	; 0x10
     264:	29 8b       	std	Y+17, r18	; 0x11
     266:	1b 8b       	std	Y+19, r17	; 0x13
     268:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     26a:	8c 85       	ldd	r24, Y+12	; 0x0c
     26c:	9d 85       	ldd	r25, Y+13	; 0x0d
     26e:	9b 87       	std	Y+11, r25	; 0x0b
     270:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     272:	1f 82       	std	Y+7, r1	; 0x07
     274:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     276:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     278:	0e 94 b8 1a 	call	0x3570	; 0x3570 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     27c:	ea 85       	ldd	r30, Y+10	; 0x0a
     27e:	fb 85       	ldd	r31, Y+11	; 0x0b
     280:	80 81       	ld	r24, Z
     282:	91 81       	ldd	r25, Z+1	; 0x01
     284:	9a 83       	std	Y+2, r25	; 0x02
     286:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     288:	89 81       	ldd	r24, Y+1	; 0x01
     28a:	9a 81       	ldd	r25, Y+2	; 0x02
     28c:	2e 85       	ldd	r18, Y+14	; 0x0e
     28e:	3f 85       	ldd	r19, Y+15	; 0x0f
     290:	b9 01       	movw	r22, r18
     292:	49 89       	ldd	r20, Y+17	; 0x11
     294:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <prvTestWaitCondition>
     298:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     29a:	8d 81       	ldd	r24, Y+5	; 0x05
     29c:	88 23       	and	r24, r24
     29e:	c1 f0       	breq	.+48     	; 0x2d0 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     2a0:	89 81       	ldd	r24, Y+1	; 0x01
     2a2:	9a 81       	ldd	r25, Y+2	; 0x02
     2a4:	99 87       	std	Y+9, r25	; 0x09
     2a6:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     2a8:	1b 8a       	std	Y+19, r1	; 0x13
     2aa:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     2ac:	88 89       	ldd	r24, Y+16	; 0x10
     2ae:	88 23       	and	r24, r24
     2b0:	e9 f1       	breq	.+122    	; 0x32c <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     2b2:	ea 85       	ldd	r30, Y+10	; 0x0a
     2b4:	fb 85       	ldd	r31, Y+11	; 0x0b
     2b6:	20 81       	ld	r18, Z
     2b8:	31 81       	ldd	r19, Z+1	; 0x01
     2ba:	8e 85       	ldd	r24, Y+14	; 0x0e
     2bc:	9f 85       	ldd	r25, Y+15	; 0x0f
     2be:	80 95       	com	r24
     2c0:	90 95       	com	r25
     2c2:	82 23       	and	r24, r18
     2c4:	93 23       	and	r25, r19
     2c6:	ea 85       	ldd	r30, Y+10	; 0x0a
     2c8:	fb 85       	ldd	r31, Y+11	; 0x0b
     2ca:	91 83       	std	Z+1, r25	; 0x01
     2cc:	80 83       	st	Z, r24
     2ce:	2e c0       	rjmp	.+92     	; 0x32c <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     2d0:	8a 89       	ldd	r24, Y+18	; 0x12
     2d2:	9b 89       	ldd	r25, Y+19	; 0x13
     2d4:	00 97       	sbiw	r24, 0x00	; 0
     2d6:	39 f4       	brne	.+14     	; 0x2e6 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     2d8:	89 81       	ldd	r24, Y+1	; 0x01
     2da:	9a 81       	ldd	r25, Y+2	; 0x02
     2dc:	99 87       	std	Y+9, r25	; 0x09
     2de:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     2e0:	81 e0       	ldi	r24, 0x01	; 1
     2e2:	8b 83       	std	Y+3, r24	; 0x03
     2e4:	23 c0       	rjmp	.+70     	; 0x32c <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     2e6:	88 89       	ldd	r24, Y+16	; 0x10
     2e8:	88 23       	and	r24, r24
     2ea:	29 f0       	breq	.+10     	; 0x2f6 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     2ec:	8e 81       	ldd	r24, Y+6	; 0x06
     2ee:	9f 81       	ldd	r25, Y+7	; 0x07
     2f0:	91 60       	ori	r25, 0x01	; 1
     2f2:	9f 83       	std	Y+7, r25	; 0x07
     2f4:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     2f6:	89 89       	ldd	r24, Y+17	; 0x11
     2f8:	88 23       	and	r24, r24
     2fa:	29 f0       	breq	.+10     	; 0x306 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     2fc:	8e 81       	ldd	r24, Y+6	; 0x06
     2fe:	9f 81       	ldd	r25, Y+7	; 0x07
     300:	94 60       	ori	r25, 0x04	; 4
     302:	9f 83       	std	Y+7, r25	; 0x07
     304:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     306:	8a 85       	ldd	r24, Y+10	; 0x0a
     308:	9b 85       	ldd	r25, Y+11	; 0x0b
     30a:	bc 01       	movw	r22, r24
     30c:	6e 5f       	subi	r22, 0xFE	; 254
     30e:	7f 4f       	sbci	r23, 0xFF	; 255
     310:	2e 85       	ldd	r18, Y+14	; 0x0e
     312:	3f 85       	ldd	r19, Y+15	; 0x0f
     314:	8e 81       	ldd	r24, Y+6	; 0x06
     316:	9f 81       	ldd	r25, Y+7	; 0x07
     318:	28 2b       	or	r18, r24
     31a:	39 2b       	or	r19, r25
     31c:	4a 89       	ldd	r20, Y+18	; 0x12
     31e:	5b 89       	ldd	r21, Y+19	; 0x13
     320:	cb 01       	movw	r24, r22
     322:	b9 01       	movw	r22, r18
     324:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     328:	19 86       	std	Y+9, r1	; 0x09
     32a:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     32c:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>
     330:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     332:	8a 89       	ldd	r24, Y+18	; 0x12
     334:	9b 89       	ldd	r25, Y+19	; 0x13
     336:	00 97       	sbiw	r24, 0x00	; 0
     338:	09 f4       	brne	.+2      	; 0x33c <xEventGroupWaitBits+0xfa>
     33a:	3c c0       	rjmp	.+120    	; 0x3b4 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     33c:	8c 81       	ldd	r24, Y+4	; 0x04
     33e:	88 23       	and	r24, r24
     340:	11 f4       	brne	.+4      	; 0x346 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     342:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     346:	0e 94 2b 1f 	call	0x3e56	; 0x3e56 <uxTaskResetEventItemValue>
     34a:	99 87       	std	Y+9, r25	; 0x09
     34c:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     34e:	88 85       	ldd	r24, Y+8	; 0x08
     350:	99 85       	ldd	r25, Y+9	; 0x09
     352:	80 70       	andi	r24, 0x00	; 0
     354:	92 70       	andi	r25, 0x02	; 2
     356:	00 97       	sbiw	r24, 0x00	; 0
     358:	41 f5       	brne	.+80     	; 0x3aa <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     35a:	0f b6       	in	r0, 0x3f	; 63
     35c:	f8 94       	cli
     35e:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     360:	ea 85       	ldd	r30, Y+10	; 0x0a
     362:	fb 85       	ldd	r31, Y+11	; 0x0b
     364:	80 81       	ld	r24, Z
     366:	91 81       	ldd	r25, Z+1	; 0x01
     368:	99 87       	std	Y+9, r25	; 0x09
     36a:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     36c:	88 85       	ldd	r24, Y+8	; 0x08
     36e:	99 85       	ldd	r25, Y+9	; 0x09
     370:	2e 85       	ldd	r18, Y+14	; 0x0e
     372:	3f 85       	ldd	r19, Y+15	; 0x0f
     374:	b9 01       	movw	r22, r18
     376:	49 89       	ldd	r20, Y+17	; 0x11
     378:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <prvTestWaitCondition>
     37c:	88 23       	and	r24, r24
     37e:	89 f0       	breq	.+34     	; 0x3a2 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     380:	88 89       	ldd	r24, Y+16	; 0x10
     382:	88 23       	and	r24, r24
     384:	71 f0       	breq	.+28     	; 0x3a2 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     386:	ea 85       	ldd	r30, Y+10	; 0x0a
     388:	fb 85       	ldd	r31, Y+11	; 0x0b
     38a:	20 81       	ld	r18, Z
     38c:	31 81       	ldd	r19, Z+1	; 0x01
     38e:	8e 85       	ldd	r24, Y+14	; 0x0e
     390:	9f 85       	ldd	r25, Y+15	; 0x0f
     392:	80 95       	com	r24
     394:	90 95       	com	r25
     396:	82 23       	and	r24, r18
     398:	93 23       	and	r25, r19
     39a:	ea 85       	ldd	r30, Y+10	; 0x0a
     39c:	fb 85       	ldd	r31, Y+11	; 0x0b
     39e:	91 83       	std	Z+1, r25	; 0x01
     3a0:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     3a2:	81 e0       	ldi	r24, 0x01	; 1
     3a4:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     3a6:	0f 90       	pop	r0
     3a8:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     3aa:	88 85       	ldd	r24, Y+8	; 0x08
     3ac:	99 85       	ldd	r25, Y+9	; 0x09
     3ae:	90 70       	andi	r25, 0x00	; 0
     3b0:	99 87       	std	Y+9, r25	; 0x09
     3b2:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     3b4:	88 85       	ldd	r24, Y+8	; 0x08
     3b6:	99 85       	ldd	r25, Y+9	; 0x09
}
     3b8:	63 96       	adiw	r28, 0x13	; 19
     3ba:	0f b6       	in	r0, 0x3f	; 63
     3bc:	f8 94       	cli
     3be:	de bf       	out	0x3e, r29	; 62
     3c0:	0f be       	out	0x3f, r0	; 63
     3c2:	cd bf       	out	0x3d, r28	; 61
     3c4:	cf 91       	pop	r28
     3c6:	df 91       	pop	r29
     3c8:	1f 91       	pop	r17
     3ca:	0f 91       	pop	r16
     3cc:	08 95       	ret

000003ce <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     3ce:	df 93       	push	r29
     3d0:	cf 93       	push	r28
     3d2:	cd b7       	in	r28, 0x3d	; 61
     3d4:	de b7       	in	r29, 0x3e	; 62
     3d6:	28 97       	sbiw	r28, 0x08	; 8
     3d8:	0f b6       	in	r0, 0x3f	; 63
     3da:	f8 94       	cli
     3dc:	de bf       	out	0x3e, r29	; 62
     3de:	0f be       	out	0x3f, r0	; 63
     3e0:	cd bf       	out	0x3d, r28	; 61
     3e2:	9e 83       	std	Y+6, r25	; 0x06
     3e4:	8d 83       	std	Y+5, r24	; 0x05
     3e6:	78 87       	std	Y+8, r23	; 0x08
     3e8:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     3ea:	8d 81       	ldd	r24, Y+5	; 0x05
     3ec:	9e 81       	ldd	r25, Y+6	; 0x06
     3ee:	9c 83       	std	Y+4, r25	; 0x04
     3f0:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     3f2:	0f b6       	in	r0, 0x3f	; 63
     3f4:	f8 94       	cli
     3f6:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     3f8:	eb 81       	ldd	r30, Y+3	; 0x03
     3fa:	fc 81       	ldd	r31, Y+4	; 0x04
     3fc:	80 81       	ld	r24, Z
     3fe:	91 81       	ldd	r25, Z+1	; 0x01
     400:	9a 83       	std	Y+2, r25	; 0x02
     402:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     404:	eb 81       	ldd	r30, Y+3	; 0x03
     406:	fc 81       	ldd	r31, Y+4	; 0x04
     408:	20 81       	ld	r18, Z
     40a:	31 81       	ldd	r19, Z+1	; 0x01
     40c:	8f 81       	ldd	r24, Y+7	; 0x07
     40e:	98 85       	ldd	r25, Y+8	; 0x08
     410:	80 95       	com	r24
     412:	90 95       	com	r25
     414:	82 23       	and	r24, r18
     416:	93 23       	and	r25, r19
     418:	eb 81       	ldd	r30, Y+3	; 0x03
     41a:	fc 81       	ldd	r31, Y+4	; 0x04
     41c:	91 83       	std	Z+1, r25	; 0x01
     41e:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     420:	0f 90       	pop	r0
     422:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     424:	89 81       	ldd	r24, Y+1	; 0x01
     426:	9a 81       	ldd	r25, Y+2	; 0x02
}
     428:	28 96       	adiw	r28, 0x08	; 8
     42a:	0f b6       	in	r0, 0x3f	; 63
     42c:	f8 94       	cli
     42e:	de bf       	out	0x3e, r29	; 62
     430:	0f be       	out	0x3f, r0	; 63
     432:	cd bf       	out	0x3d, r28	; 61
     434:	cf 91       	pop	r28
     436:	df 91       	pop	r29
     438:	08 95       	ret

0000043a <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     43a:	df 93       	push	r29
     43c:	cf 93       	push	r28
     43e:	cd b7       	in	r28, 0x3d	; 61
     440:	de b7       	in	r29, 0x3e	; 62
     442:	27 97       	sbiw	r28, 0x07	; 7
     444:	0f b6       	in	r0, 0x3f	; 63
     446:	f8 94       	cli
     448:	de bf       	out	0x3e, r29	; 62
     44a:	0f be       	out	0x3f, r0	; 63
     44c:	cd bf       	out	0x3d, r28	; 61
     44e:	9f 83       	std	Y+7, r25	; 0x07
     450:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     452:	8e 81       	ldd	r24, Y+6	; 0x06
     454:	9f 81       	ldd	r25, Y+7	; 0x07
     456:	9c 83       	std	Y+4, r25	; 0x04
     458:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     45a:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     45c:	eb 81       	ldd	r30, Y+3	; 0x03
     45e:	fc 81       	ldd	r31, Y+4	; 0x04
     460:	80 81       	ld	r24, Z
     462:	91 81       	ldd	r25, Z+1	; 0x01
     464:	9a 83       	std	Y+2, r25	; 0x02
     466:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     468:	89 81       	ldd	r24, Y+1	; 0x01
     46a:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     46c:	27 96       	adiw	r28, 0x07	; 7
     46e:	0f b6       	in	r0, 0x3f	; 63
     470:	f8 94       	cli
     472:	de bf       	out	0x3e, r29	; 62
     474:	0f be       	out	0x3f, r0	; 63
     476:	cd bf       	out	0x3d, r28	; 61
     478:	cf 91       	pop	r28
     47a:	df 91       	pop	r29
     47c:	08 95       	ret

0000047e <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     47e:	df 93       	push	r29
     480:	cf 93       	push	r28
     482:	cd b7       	in	r28, 0x3d	; 61
     484:	de b7       	in	r29, 0x3e	; 62
     486:	65 97       	sbiw	r28, 0x15	; 21
     488:	0f b6       	in	r0, 0x3f	; 63
     48a:	f8 94       	cli
     48c:	de bf       	out	0x3e, r29	; 62
     48e:	0f be       	out	0x3f, r0	; 63
     490:	cd bf       	out	0x3d, r28	; 61
     492:	9b 8b       	std	Y+19, r25	; 0x13
     494:	8a 8b       	std	Y+18, r24	; 0x12
     496:	7d 8b       	std	Y+21, r23	; 0x15
     498:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     49a:	19 86       	std	Y+9, r1	; 0x09
     49c:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     49e:	8a 89       	ldd	r24, Y+18	; 0x12
     4a0:	9b 89       	ldd	r25, Y+19	; 0x13
     4a2:	9b 83       	std	Y+3, r25	; 0x03
     4a4:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     4a6:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     4a8:	8a 81       	ldd	r24, Y+2	; 0x02
     4aa:	9b 81       	ldd	r25, Y+3	; 0x03
     4ac:	02 96       	adiw	r24, 0x02	; 2
     4ae:	9b 87       	std	Y+11, r25	; 0x0b
     4b0:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     4b2:	8a 85       	ldd	r24, Y+10	; 0x0a
     4b4:	9b 85       	ldd	r25, Y+11	; 0x0b
     4b6:	03 96       	adiw	r24, 0x03	; 3
     4b8:	9d 87       	std	Y+13, r25	; 0x0d
     4ba:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     4bc:	0e 94 b8 1a 	call	0x3570	; 0x3570 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     4c0:	ea 85       	ldd	r30, Y+10	; 0x0a
     4c2:	fb 85       	ldd	r31, Y+11	; 0x0b
     4c4:	85 81       	ldd	r24, Z+5	; 0x05
     4c6:	96 81       	ldd	r25, Z+6	; 0x06
     4c8:	99 8b       	std	Y+17, r25	; 0x11
     4ca:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     4cc:	ea 81       	ldd	r30, Y+2	; 0x02
     4ce:	fb 81       	ldd	r31, Y+3	; 0x03
     4d0:	20 81       	ld	r18, Z
     4d2:	31 81       	ldd	r19, Z+1	; 0x01
     4d4:	8c 89       	ldd	r24, Y+20	; 0x14
     4d6:	9d 89       	ldd	r25, Y+21	; 0x15
     4d8:	82 2b       	or	r24, r18
     4da:	93 2b       	or	r25, r19
     4dc:	ea 81       	ldd	r30, Y+2	; 0x02
     4de:	fb 81       	ldd	r31, Y+3	; 0x03
     4e0:	91 83       	std	Z+1, r25	; 0x01
     4e2:	80 83       	st	Z, r24
     4e4:	59 c0       	rjmp	.+178    	; 0x598 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     4e6:	e8 89       	ldd	r30, Y+16	; 0x10
     4e8:	f9 89       	ldd	r31, Y+17	; 0x11
     4ea:	82 81       	ldd	r24, Z+2	; 0x02
     4ec:	93 81       	ldd	r25, Z+3	; 0x03
     4ee:	9f 87       	std	Y+15, r25	; 0x0f
     4f0:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     4f2:	e8 89       	ldd	r30, Y+16	; 0x10
     4f4:	f9 89       	ldd	r31, Y+17	; 0x11
     4f6:	80 81       	ld	r24, Z
     4f8:	91 81       	ldd	r25, Z+1	; 0x01
     4fa:	9f 83       	std	Y+7, r25	; 0x07
     4fc:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     4fe:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     500:	8e 81       	ldd	r24, Y+6	; 0x06
     502:	9f 81       	ldd	r25, Y+7	; 0x07
     504:	80 70       	andi	r24, 0x00	; 0
     506:	9d 83       	std	Y+5, r25	; 0x05
     508:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     50a:	8e 81       	ldd	r24, Y+6	; 0x06
     50c:	9f 81       	ldd	r25, Y+7	; 0x07
     50e:	90 70       	andi	r25, 0x00	; 0
     510:	9f 83       	std	Y+7, r25	; 0x07
     512:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     514:	8c 81       	ldd	r24, Y+4	; 0x04
     516:	9d 81       	ldd	r25, Y+5	; 0x05
     518:	80 70       	andi	r24, 0x00	; 0
     51a:	94 70       	andi	r25, 0x04	; 4
     51c:	00 97       	sbiw	r24, 0x00	; 0
     51e:	69 f4       	brne	.+26     	; 0x53a <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     520:	ea 81       	ldd	r30, Y+2	; 0x02
     522:	fb 81       	ldd	r31, Y+3	; 0x03
     524:	20 81       	ld	r18, Z
     526:	31 81       	ldd	r19, Z+1	; 0x01
     528:	8e 81       	ldd	r24, Y+6	; 0x06
     52a:	9f 81       	ldd	r25, Y+7	; 0x07
     52c:	82 23       	and	r24, r18
     52e:	93 23       	and	r25, r19
     530:	00 97       	sbiw	r24, 0x00	; 0
     532:	91 f0       	breq	.+36     	; 0x558 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     534:	81 e0       	ldi	r24, 0x01	; 1
     536:	89 83       	std	Y+1, r24	; 0x01
     538:	0f c0       	rjmp	.+30     	; 0x558 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     53a:	ea 81       	ldd	r30, Y+2	; 0x02
     53c:	fb 81       	ldd	r31, Y+3	; 0x03
     53e:	20 81       	ld	r18, Z
     540:	31 81       	ldd	r19, Z+1	; 0x01
     542:	8e 81       	ldd	r24, Y+6	; 0x06
     544:	9f 81       	ldd	r25, Y+7	; 0x07
     546:	28 23       	and	r18, r24
     548:	39 23       	and	r19, r25
     54a:	8e 81       	ldd	r24, Y+6	; 0x06
     54c:	9f 81       	ldd	r25, Y+7	; 0x07
     54e:	28 17       	cp	r18, r24
     550:	39 07       	cpc	r19, r25
     552:	11 f4       	brne	.+4      	; 0x558 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     554:	81 e0       	ldi	r24, 0x01	; 1
     556:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     558:	89 81       	ldd	r24, Y+1	; 0x01
     55a:	88 23       	and	r24, r24
     55c:	c9 f0       	breq	.+50     	; 0x590 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     55e:	8c 81       	ldd	r24, Y+4	; 0x04
     560:	9d 81       	ldd	r25, Y+5	; 0x05
     562:	80 70       	andi	r24, 0x00	; 0
     564:	91 70       	andi	r25, 0x01	; 1
     566:	00 97       	sbiw	r24, 0x00	; 0
     568:	41 f0       	breq	.+16     	; 0x57a <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     56a:	88 85       	ldd	r24, Y+8	; 0x08
     56c:	99 85       	ldd	r25, Y+9	; 0x09
     56e:	2e 81       	ldd	r18, Y+6	; 0x06
     570:	3f 81       	ldd	r19, Y+7	; 0x07
     572:	82 2b       	or	r24, r18
     574:	93 2b       	or	r25, r19
     576:	99 87       	std	Y+9, r25	; 0x09
     578:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     57a:	ea 81       	ldd	r30, Y+2	; 0x02
     57c:	fb 81       	ldd	r31, Y+3	; 0x03
     57e:	80 81       	ld	r24, Z
     580:	91 81       	ldd	r25, Z+1	; 0x01
     582:	9c 01       	movw	r18, r24
     584:	32 60       	ori	r19, 0x02	; 2
     586:	88 89       	ldd	r24, Y+16	; 0x10
     588:	99 89       	ldd	r25, Y+17	; 0x11
     58a:	b9 01       	movw	r22, r18
     58c:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     590:	8e 85       	ldd	r24, Y+14	; 0x0e
     592:	9f 85       	ldd	r25, Y+15	; 0x0f
     594:	99 8b       	std	Y+17, r25	; 0x11
     596:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     598:	28 89       	ldd	r18, Y+16	; 0x10
     59a:	39 89       	ldd	r19, Y+17	; 0x11
     59c:	8c 85       	ldd	r24, Y+12	; 0x0c
     59e:	9d 85       	ldd	r25, Y+13	; 0x0d
     5a0:	28 17       	cp	r18, r24
     5a2:	39 07       	cpc	r19, r25
     5a4:	09 f0       	breq	.+2      	; 0x5a8 <xEventGroupSetBits+0x12a>
     5a6:	9f cf       	rjmp	.-194    	; 0x4e6 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     5a8:	ea 81       	ldd	r30, Y+2	; 0x02
     5aa:	fb 81       	ldd	r31, Y+3	; 0x03
     5ac:	20 81       	ld	r18, Z
     5ae:	31 81       	ldd	r19, Z+1	; 0x01
     5b0:	88 85       	ldd	r24, Y+8	; 0x08
     5b2:	99 85       	ldd	r25, Y+9	; 0x09
     5b4:	80 95       	com	r24
     5b6:	90 95       	com	r25
     5b8:	82 23       	and	r24, r18
     5ba:	93 23       	and	r25, r19
     5bc:	ea 81       	ldd	r30, Y+2	; 0x02
     5be:	fb 81       	ldd	r31, Y+3	; 0x03
     5c0:	91 83       	std	Z+1, r25	; 0x01
     5c2:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     5c4:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     5c8:	ea 81       	ldd	r30, Y+2	; 0x02
     5ca:	fb 81       	ldd	r31, Y+3	; 0x03
     5cc:	80 81       	ld	r24, Z
     5ce:	91 81       	ldd	r25, Z+1	; 0x01
}
     5d0:	65 96       	adiw	r28, 0x15	; 21
     5d2:	0f b6       	in	r0, 0x3f	; 63
     5d4:	f8 94       	cli
     5d6:	de bf       	out	0x3e, r29	; 62
     5d8:	0f be       	out	0x3f, r0	; 63
     5da:	cd bf       	out	0x3d, r28	; 61
     5dc:	cf 91       	pop	r28
     5de:	df 91       	pop	r29
     5e0:	08 95       	ret

000005e2 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     5e2:	df 93       	push	r29
     5e4:	cf 93       	push	r28
     5e6:	00 d0       	rcall	.+0      	; 0x5e8 <vEventGroupDelete+0x6>
     5e8:	00 d0       	rcall	.+0      	; 0x5ea <vEventGroupDelete+0x8>
     5ea:	00 d0       	rcall	.+0      	; 0x5ec <vEventGroupDelete+0xa>
     5ec:	cd b7       	in	r28, 0x3d	; 61
     5ee:	de b7       	in	r29, 0x3e	; 62
     5f0:	9e 83       	std	Y+6, r25	; 0x06
     5f2:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
     5f4:	8d 81       	ldd	r24, Y+5	; 0x05
     5f6:	9e 81       	ldd	r25, Y+6	; 0x06
     5f8:	9c 83       	std	Y+4, r25	; 0x04
     5fa:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     5fc:	8b 81       	ldd	r24, Y+3	; 0x03
     5fe:	9c 81       	ldd	r25, Y+4	; 0x04
     600:	02 96       	adiw	r24, 0x02	; 2
     602:	9a 83       	std	Y+2, r25	; 0x02
     604:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     606:	0e 94 b8 1a 	call	0x3570	; 0x3570 <vTaskSuspendAll>
     60a:	08 c0       	rjmp	.+16     	; 0x61c <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     60c:	e9 81       	ldd	r30, Y+1	; 0x01
     60e:	fa 81       	ldd	r31, Y+2	; 0x02
     610:	85 81       	ldd	r24, Z+5	; 0x05
     612:	96 81       	ldd	r25, Z+6	; 0x06
     614:	60 e0       	ldi	r22, 0x00	; 0
     616:	72 e0       	ldi	r23, 0x02	; 2
     618:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     61c:	e9 81       	ldd	r30, Y+1	; 0x01
     61e:	fa 81       	ldd	r31, Y+2	; 0x02
     620:	80 81       	ld	r24, Z
     622:	88 23       	and	r24, r24
     624:	99 f7       	brne	.-26     	; 0x60c <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     626:	8b 81       	ldd	r24, Y+3	; 0x03
     628:	9c 81       	ldd	r25, Y+4	; 0x04
     62a:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     62e:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>
}
     632:	26 96       	adiw	r28, 0x06	; 6
     634:	0f b6       	in	r0, 0x3f	; 63
     636:	f8 94       	cli
     638:	de bf       	out	0x3e, r29	; 62
     63a:	0f be       	out	0x3f, r0	; 63
     63c:	cd bf       	out	0x3d, r28	; 61
     63e:	cf 91       	pop	r28
     640:	df 91       	pop	r29
     642:	08 95       	ret

00000644 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     644:	df 93       	push	r29
     646:	cf 93       	push	r28
     648:	00 d0       	rcall	.+0      	; 0x64a <vEventGroupSetBitsCallback+0x6>
     64a:	00 d0       	rcall	.+0      	; 0x64c <vEventGroupSetBitsCallback+0x8>
     64c:	00 d0       	rcall	.+0      	; 0x64e <vEventGroupSetBitsCallback+0xa>
     64e:	cd b7       	in	r28, 0x3d	; 61
     650:	de b7       	in	r29, 0x3e	; 62
     652:	9a 83       	std	Y+2, r25	; 0x02
     654:	89 83       	std	Y+1, r24	; 0x01
     656:	4b 83       	std	Y+3, r20	; 0x03
     658:	5c 83       	std	Y+4, r21	; 0x04
     65a:	6d 83       	std	Y+5, r22	; 0x05
     65c:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     65e:	89 81       	ldd	r24, Y+1	; 0x01
     660:	9a 81       	ldd	r25, Y+2	; 0x02
     662:	2b 81       	ldd	r18, Y+3	; 0x03
     664:	3c 81       	ldd	r19, Y+4	; 0x04
     666:	b9 01       	movw	r22, r18
     668:	0e 94 3f 02 	call	0x47e	; 0x47e <xEventGroupSetBits>
}
     66c:	26 96       	adiw	r28, 0x06	; 6
     66e:	0f b6       	in	r0, 0x3f	; 63
     670:	f8 94       	cli
     672:	de bf       	out	0x3e, r29	; 62
     674:	0f be       	out	0x3f, r0	; 63
     676:	cd bf       	out	0x3d, r28	; 61
     678:	cf 91       	pop	r28
     67a:	df 91       	pop	r29
     67c:	08 95       	ret

0000067e <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     67e:	df 93       	push	r29
     680:	cf 93       	push	r28
     682:	00 d0       	rcall	.+0      	; 0x684 <vEventGroupClearBitsCallback+0x6>
     684:	00 d0       	rcall	.+0      	; 0x686 <vEventGroupClearBitsCallback+0x8>
     686:	00 d0       	rcall	.+0      	; 0x688 <vEventGroupClearBitsCallback+0xa>
     688:	cd b7       	in	r28, 0x3d	; 61
     68a:	de b7       	in	r29, 0x3e	; 62
     68c:	9a 83       	std	Y+2, r25	; 0x02
     68e:	89 83       	std	Y+1, r24	; 0x01
     690:	4b 83       	std	Y+3, r20	; 0x03
     692:	5c 83       	std	Y+4, r21	; 0x04
     694:	6d 83       	std	Y+5, r22	; 0x05
     696:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     698:	89 81       	ldd	r24, Y+1	; 0x01
     69a:	9a 81       	ldd	r25, Y+2	; 0x02
     69c:	2b 81       	ldd	r18, Y+3	; 0x03
     69e:	3c 81       	ldd	r19, Y+4	; 0x04
     6a0:	b9 01       	movw	r22, r18
     6a2:	0e 94 e7 01 	call	0x3ce	; 0x3ce <xEventGroupClearBits>
}
     6a6:	26 96       	adiw	r28, 0x06	; 6
     6a8:	0f b6       	in	r0, 0x3f	; 63
     6aa:	f8 94       	cli
     6ac:	de bf       	out	0x3e, r29	; 62
     6ae:	0f be       	out	0x3f, r0	; 63
     6b0:	cd bf       	out	0x3d, r28	; 61
     6b2:	cf 91       	pop	r28
     6b4:	df 91       	pop	r29
     6b6:	08 95       	ret

000006b8 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     6b8:	df 93       	push	r29
     6ba:	cf 93       	push	r28
     6bc:	00 d0       	rcall	.+0      	; 0x6be <prvTestWaitCondition+0x6>
     6be:	00 d0       	rcall	.+0      	; 0x6c0 <prvTestWaitCondition+0x8>
     6c0:	00 d0       	rcall	.+0      	; 0x6c2 <prvTestWaitCondition+0xa>
     6c2:	cd b7       	in	r28, 0x3d	; 61
     6c4:	de b7       	in	r29, 0x3e	; 62
     6c6:	9b 83       	std	Y+3, r25	; 0x03
     6c8:	8a 83       	std	Y+2, r24	; 0x02
     6ca:	7d 83       	std	Y+5, r23	; 0x05
     6cc:	6c 83       	std	Y+4, r22	; 0x04
     6ce:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     6d0:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     6d2:	8e 81       	ldd	r24, Y+6	; 0x06
     6d4:	88 23       	and	r24, r24
     6d6:	59 f4       	brne	.+22     	; 0x6ee <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     6d8:	8a 81       	ldd	r24, Y+2	; 0x02
     6da:	9b 81       	ldd	r25, Y+3	; 0x03
     6dc:	2c 81       	ldd	r18, Y+4	; 0x04
     6de:	3d 81       	ldd	r19, Y+5	; 0x05
     6e0:	82 23       	and	r24, r18
     6e2:	93 23       	and	r25, r19
     6e4:	00 97       	sbiw	r24, 0x00	; 0
     6e6:	81 f0       	breq	.+32     	; 0x708 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     6e8:	81 e0       	ldi	r24, 0x01	; 1
     6ea:	89 83       	std	Y+1, r24	; 0x01
     6ec:	0d c0       	rjmp	.+26     	; 0x708 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     6ee:	2a 81       	ldd	r18, Y+2	; 0x02
     6f0:	3b 81       	ldd	r19, Y+3	; 0x03
     6f2:	8c 81       	ldd	r24, Y+4	; 0x04
     6f4:	9d 81       	ldd	r25, Y+5	; 0x05
     6f6:	28 23       	and	r18, r24
     6f8:	39 23       	and	r19, r25
     6fa:	8c 81       	ldd	r24, Y+4	; 0x04
     6fc:	9d 81       	ldd	r25, Y+5	; 0x05
     6fe:	28 17       	cp	r18, r24
     700:	39 07       	cpc	r19, r25
     702:	11 f4       	brne	.+4      	; 0x708 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     704:	81 e0       	ldi	r24, 0x01	; 1
     706:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     708:	89 81       	ldd	r24, Y+1	; 0x01
}
     70a:	26 96       	adiw	r28, 0x06	; 6
     70c:	0f b6       	in	r0, 0x3f	; 63
     70e:	f8 94       	cli
     710:	de bf       	out	0x3e, r29	; 62
     712:	0f be       	out	0x3f, r0	; 63
     714:	cd bf       	out	0x3d, r28	; 61
     716:	cf 91       	pop	r28
     718:	df 91       	pop	r29
     71a:	08 95       	ret

0000071c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     71c:	df 93       	push	r29
     71e:	cf 93       	push	r28
     720:	00 d0       	rcall	.+0      	; 0x722 <pvPortMalloc+0x6>
     722:	00 d0       	rcall	.+0      	; 0x724 <pvPortMalloc+0x8>
     724:	cd b7       	in	r28, 0x3d	; 61
     726:	de b7       	in	r29, 0x3e	; 62
     728:	9c 83       	std	Y+4, r25	; 0x04
     72a:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     72c:	1a 82       	std	Y+2, r1	; 0x02
     72e:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     730:	0e 94 b8 1a 	call	0x3570	; 0x3570 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     734:	80 91 78 00 	lds	r24, 0x0078
     738:	90 91 79 00 	lds	r25, 0x0079
     73c:	00 97       	sbiw	r24, 0x00	; 0
     73e:	31 f4       	brne	.+12     	; 0x74c <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     740:	8b e7       	ldi	r24, 0x7B	; 123
     742:	90 e0       	ldi	r25, 0x00	; 0
     744:	90 93 79 00 	sts	0x0079, r25
     748:	80 93 78 00 	sts	0x0078, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     74c:	80 91 76 00 	lds	r24, 0x0076
     750:	90 91 77 00 	lds	r25, 0x0077
     754:	2b 81       	ldd	r18, Y+3	; 0x03
     756:	3c 81       	ldd	r19, Y+4	; 0x04
     758:	82 0f       	add	r24, r18
     75a:	93 1f       	adc	r25, r19
     75c:	25 e0       	ldi	r18, 0x05	; 5
     75e:	8b 3d       	cpi	r24, 0xDB	; 219
     760:	92 07       	cpc	r25, r18
     762:	38 f5       	brcc	.+78     	; 0x7b2 <pvPortMalloc+0x96>
     764:	20 91 76 00 	lds	r18, 0x0076
     768:	30 91 77 00 	lds	r19, 0x0077
     76c:	8b 81       	ldd	r24, Y+3	; 0x03
     76e:	9c 81       	ldd	r25, Y+4	; 0x04
     770:	28 0f       	add	r18, r24
     772:	39 1f       	adc	r19, r25
     774:	80 91 76 00 	lds	r24, 0x0076
     778:	90 91 77 00 	lds	r25, 0x0077
     77c:	82 17       	cp	r24, r18
     77e:	93 07       	cpc	r25, r19
     780:	c0 f4       	brcc	.+48     	; 0x7b2 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     782:	20 91 78 00 	lds	r18, 0x0078
     786:	30 91 79 00 	lds	r19, 0x0079
     78a:	80 91 76 00 	lds	r24, 0x0076
     78e:	90 91 77 00 	lds	r25, 0x0077
     792:	82 0f       	add	r24, r18
     794:	93 1f       	adc	r25, r19
     796:	9a 83       	std	Y+2, r25	; 0x02
     798:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     79a:	20 91 76 00 	lds	r18, 0x0076
     79e:	30 91 77 00 	lds	r19, 0x0077
     7a2:	8b 81       	ldd	r24, Y+3	; 0x03
     7a4:	9c 81       	ldd	r25, Y+4	; 0x04
     7a6:	82 0f       	add	r24, r18
     7a8:	93 1f       	adc	r25, r19
     7aa:	90 93 77 00 	sts	0x0077, r25
     7ae:	80 93 76 00 	sts	0x0076, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     7b2:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     7b6:	89 81       	ldd	r24, Y+1	; 0x01
     7b8:	9a 81       	ldd	r25, Y+2	; 0x02
}
     7ba:	0f 90       	pop	r0
     7bc:	0f 90       	pop	r0
     7be:	0f 90       	pop	r0
     7c0:	0f 90       	pop	r0
     7c2:	cf 91       	pop	r28
     7c4:	df 91       	pop	r29
     7c6:	08 95       	ret

000007c8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     7c8:	df 93       	push	r29
     7ca:	cf 93       	push	r28
     7cc:	00 d0       	rcall	.+0      	; 0x7ce <vPortFree+0x6>
     7ce:	cd b7       	in	r28, 0x3d	; 61
     7d0:	de b7       	in	r29, 0x3e	; 62
     7d2:	9a 83       	std	Y+2, r25	; 0x02
     7d4:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     7d6:	0f 90       	pop	r0
     7d8:	0f 90       	pop	r0
     7da:	cf 91       	pop	r28
     7dc:	df 91       	pop	r29
     7de:	08 95       	ret

000007e0 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     7e0:	df 93       	push	r29
     7e2:	cf 93       	push	r28
     7e4:	cd b7       	in	r28, 0x3d	; 61
     7e6:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     7e8:	10 92 77 00 	sts	0x0077, r1
     7ec:	10 92 76 00 	sts	0x0076, r1
}
     7f0:	cf 91       	pop	r28
     7f2:	df 91       	pop	r29
     7f4:	08 95       	ret

000007f6 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     7f6:	df 93       	push	r29
     7f8:	cf 93       	push	r28
     7fa:	cd b7       	in	r28, 0x3d	; 61
     7fc:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     7fe:	20 91 76 00 	lds	r18, 0x0076
     802:	30 91 77 00 	lds	r19, 0x0077
     806:	8b ed       	ldi	r24, 0xDB	; 219
     808:	95 e0       	ldi	r25, 0x05	; 5
     80a:	82 1b       	sub	r24, r18
     80c:	93 0b       	sbc	r25, r19
}
     80e:	cf 91       	pop	r28
     810:	df 91       	pop	r29
     812:	08 95       	ret

00000814 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     814:	df 93       	push	r29
     816:	cf 93       	push	r28
     818:	00 d0       	rcall	.+0      	; 0x81a <vListInitialise+0x6>
     81a:	cd b7       	in	r28, 0x3d	; 61
     81c:	de b7       	in	r29, 0x3e	; 62
     81e:	9a 83       	std	Y+2, r25	; 0x02
     820:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     822:	89 81       	ldd	r24, Y+1	; 0x01
     824:	9a 81       	ldd	r25, Y+2	; 0x02
     826:	03 96       	adiw	r24, 0x03	; 3
     828:	e9 81       	ldd	r30, Y+1	; 0x01
     82a:	fa 81       	ldd	r31, Y+2	; 0x02
     82c:	92 83       	std	Z+2, r25	; 0x02
     82e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     830:	e9 81       	ldd	r30, Y+1	; 0x01
     832:	fa 81       	ldd	r31, Y+2	; 0x02
     834:	8f ef       	ldi	r24, 0xFF	; 255
     836:	9f ef       	ldi	r25, 0xFF	; 255
     838:	94 83       	std	Z+4, r25	; 0x04
     83a:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     83c:	89 81       	ldd	r24, Y+1	; 0x01
     83e:	9a 81       	ldd	r25, Y+2	; 0x02
     840:	03 96       	adiw	r24, 0x03	; 3
     842:	e9 81       	ldd	r30, Y+1	; 0x01
     844:	fa 81       	ldd	r31, Y+2	; 0x02
     846:	96 83       	std	Z+6, r25	; 0x06
     848:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     84a:	89 81       	ldd	r24, Y+1	; 0x01
     84c:	9a 81       	ldd	r25, Y+2	; 0x02
     84e:	03 96       	adiw	r24, 0x03	; 3
     850:	e9 81       	ldd	r30, Y+1	; 0x01
     852:	fa 81       	ldd	r31, Y+2	; 0x02
     854:	90 87       	std	Z+8, r25	; 0x08
     856:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     858:	e9 81       	ldd	r30, Y+1	; 0x01
     85a:	fa 81       	ldd	r31, Y+2	; 0x02
     85c:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     85e:	0f 90       	pop	r0
     860:	0f 90       	pop	r0
     862:	cf 91       	pop	r28
     864:	df 91       	pop	r29
     866:	08 95       	ret

00000868 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     868:	df 93       	push	r29
     86a:	cf 93       	push	r28
     86c:	00 d0       	rcall	.+0      	; 0x86e <vListInitialiseItem+0x6>
     86e:	cd b7       	in	r28, 0x3d	; 61
     870:	de b7       	in	r29, 0x3e	; 62
     872:	9a 83       	std	Y+2, r25	; 0x02
     874:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     876:	e9 81       	ldd	r30, Y+1	; 0x01
     878:	fa 81       	ldd	r31, Y+2	; 0x02
     87a:	11 86       	std	Z+9, r1	; 0x09
     87c:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     87e:	0f 90       	pop	r0
     880:	0f 90       	pop	r0
     882:	cf 91       	pop	r28
     884:	df 91       	pop	r29
     886:	08 95       	ret

00000888 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     888:	df 93       	push	r29
     88a:	cf 93       	push	r28
     88c:	00 d0       	rcall	.+0      	; 0x88e <vListInsertEnd+0x6>
     88e:	00 d0       	rcall	.+0      	; 0x890 <vListInsertEnd+0x8>
     890:	00 d0       	rcall	.+0      	; 0x892 <vListInsertEnd+0xa>
     892:	cd b7       	in	r28, 0x3d	; 61
     894:	de b7       	in	r29, 0x3e	; 62
     896:	9c 83       	std	Y+4, r25	; 0x04
     898:	8b 83       	std	Y+3, r24	; 0x03
     89a:	7e 83       	std	Y+6, r23	; 0x06
     89c:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     89e:	eb 81       	ldd	r30, Y+3	; 0x03
     8a0:	fc 81       	ldd	r31, Y+4	; 0x04
     8a2:	81 81       	ldd	r24, Z+1	; 0x01
     8a4:	92 81       	ldd	r25, Z+2	; 0x02
     8a6:	9a 83       	std	Y+2, r25	; 0x02
     8a8:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     8aa:	ed 81       	ldd	r30, Y+5	; 0x05
     8ac:	fe 81       	ldd	r31, Y+6	; 0x06
     8ae:	89 81       	ldd	r24, Y+1	; 0x01
     8b0:	9a 81       	ldd	r25, Y+2	; 0x02
     8b2:	93 83       	std	Z+3, r25	; 0x03
     8b4:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     8b6:	e9 81       	ldd	r30, Y+1	; 0x01
     8b8:	fa 81       	ldd	r31, Y+2	; 0x02
     8ba:	84 81       	ldd	r24, Z+4	; 0x04
     8bc:	95 81       	ldd	r25, Z+5	; 0x05
     8be:	ed 81       	ldd	r30, Y+5	; 0x05
     8c0:	fe 81       	ldd	r31, Y+6	; 0x06
     8c2:	95 83       	std	Z+5, r25	; 0x05
     8c4:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     8c6:	e9 81       	ldd	r30, Y+1	; 0x01
     8c8:	fa 81       	ldd	r31, Y+2	; 0x02
     8ca:	04 80       	ldd	r0, Z+4	; 0x04
     8cc:	f5 81       	ldd	r31, Z+5	; 0x05
     8ce:	e0 2d       	mov	r30, r0
     8d0:	8d 81       	ldd	r24, Y+5	; 0x05
     8d2:	9e 81       	ldd	r25, Y+6	; 0x06
     8d4:	93 83       	std	Z+3, r25	; 0x03
     8d6:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     8d8:	e9 81       	ldd	r30, Y+1	; 0x01
     8da:	fa 81       	ldd	r31, Y+2	; 0x02
     8dc:	8d 81       	ldd	r24, Y+5	; 0x05
     8de:	9e 81       	ldd	r25, Y+6	; 0x06
     8e0:	95 83       	std	Z+5, r25	; 0x05
     8e2:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     8e4:	ed 81       	ldd	r30, Y+5	; 0x05
     8e6:	fe 81       	ldd	r31, Y+6	; 0x06
     8e8:	8b 81       	ldd	r24, Y+3	; 0x03
     8ea:	9c 81       	ldd	r25, Y+4	; 0x04
     8ec:	91 87       	std	Z+9, r25	; 0x09
     8ee:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     8f0:	eb 81       	ldd	r30, Y+3	; 0x03
     8f2:	fc 81       	ldd	r31, Y+4	; 0x04
     8f4:	80 81       	ld	r24, Z
     8f6:	8f 5f       	subi	r24, 0xFF	; 255
     8f8:	eb 81       	ldd	r30, Y+3	; 0x03
     8fa:	fc 81       	ldd	r31, Y+4	; 0x04
     8fc:	80 83       	st	Z, r24
}
     8fe:	26 96       	adiw	r28, 0x06	; 6
     900:	0f b6       	in	r0, 0x3f	; 63
     902:	f8 94       	cli
     904:	de bf       	out	0x3e, r29	; 62
     906:	0f be       	out	0x3f, r0	; 63
     908:	cd bf       	out	0x3d, r28	; 61
     90a:	cf 91       	pop	r28
     90c:	df 91       	pop	r29
     90e:	08 95       	ret

00000910 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     910:	df 93       	push	r29
     912:	cf 93       	push	r28
     914:	cd b7       	in	r28, 0x3d	; 61
     916:	de b7       	in	r29, 0x3e	; 62
     918:	28 97       	sbiw	r28, 0x08	; 8
     91a:	0f b6       	in	r0, 0x3f	; 63
     91c:	f8 94       	cli
     91e:	de bf       	out	0x3e, r29	; 62
     920:	0f be       	out	0x3f, r0	; 63
     922:	cd bf       	out	0x3d, r28	; 61
     924:	9e 83       	std	Y+6, r25	; 0x06
     926:	8d 83       	std	Y+5, r24	; 0x05
     928:	78 87       	std	Y+8, r23	; 0x08
     92a:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     92c:	ef 81       	ldd	r30, Y+7	; 0x07
     92e:	f8 85       	ldd	r31, Y+8	; 0x08
     930:	80 81       	ld	r24, Z
     932:	91 81       	ldd	r25, Z+1	; 0x01
     934:	9a 83       	std	Y+2, r25	; 0x02
     936:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     938:	89 81       	ldd	r24, Y+1	; 0x01
     93a:	9a 81       	ldd	r25, Y+2	; 0x02
     93c:	2f ef       	ldi	r18, 0xFF	; 255
     93e:	8f 3f       	cpi	r24, 0xFF	; 255
     940:	92 07       	cpc	r25, r18
     942:	39 f4       	brne	.+14     	; 0x952 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     944:	ed 81       	ldd	r30, Y+5	; 0x05
     946:	fe 81       	ldd	r31, Y+6	; 0x06
     948:	87 81       	ldd	r24, Z+7	; 0x07
     94a:	90 85       	ldd	r25, Z+8	; 0x08
     94c:	9c 83       	std	Y+4, r25	; 0x04
     94e:	8b 83       	std	Y+3, r24	; 0x03
     950:	18 c0       	rjmp	.+48     	; 0x982 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     952:	8d 81       	ldd	r24, Y+5	; 0x05
     954:	9e 81       	ldd	r25, Y+6	; 0x06
     956:	03 96       	adiw	r24, 0x03	; 3
     958:	9c 83       	std	Y+4, r25	; 0x04
     95a:	8b 83       	std	Y+3, r24	; 0x03
     95c:	06 c0       	rjmp	.+12     	; 0x96a <vListInsert+0x5a>
     95e:	eb 81       	ldd	r30, Y+3	; 0x03
     960:	fc 81       	ldd	r31, Y+4	; 0x04
     962:	82 81       	ldd	r24, Z+2	; 0x02
     964:	93 81       	ldd	r25, Z+3	; 0x03
     966:	9c 83       	std	Y+4, r25	; 0x04
     968:	8b 83       	std	Y+3, r24	; 0x03
     96a:	eb 81       	ldd	r30, Y+3	; 0x03
     96c:	fc 81       	ldd	r31, Y+4	; 0x04
     96e:	02 80       	ldd	r0, Z+2	; 0x02
     970:	f3 81       	ldd	r31, Z+3	; 0x03
     972:	e0 2d       	mov	r30, r0
     974:	20 81       	ld	r18, Z
     976:	31 81       	ldd	r19, Z+1	; 0x01
     978:	89 81       	ldd	r24, Y+1	; 0x01
     97a:	9a 81       	ldd	r25, Y+2	; 0x02
     97c:	82 17       	cp	r24, r18
     97e:	93 07       	cpc	r25, r19
     980:	70 f7       	brcc	.-36     	; 0x95e <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     982:	eb 81       	ldd	r30, Y+3	; 0x03
     984:	fc 81       	ldd	r31, Y+4	; 0x04
     986:	82 81       	ldd	r24, Z+2	; 0x02
     988:	93 81       	ldd	r25, Z+3	; 0x03
     98a:	ef 81       	ldd	r30, Y+7	; 0x07
     98c:	f8 85       	ldd	r31, Y+8	; 0x08
     98e:	93 83       	std	Z+3, r25	; 0x03
     990:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     992:	ef 81       	ldd	r30, Y+7	; 0x07
     994:	f8 85       	ldd	r31, Y+8	; 0x08
     996:	02 80       	ldd	r0, Z+2	; 0x02
     998:	f3 81       	ldd	r31, Z+3	; 0x03
     99a:	e0 2d       	mov	r30, r0
     99c:	8f 81       	ldd	r24, Y+7	; 0x07
     99e:	98 85       	ldd	r25, Y+8	; 0x08
     9a0:	95 83       	std	Z+5, r25	; 0x05
     9a2:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     9a4:	ef 81       	ldd	r30, Y+7	; 0x07
     9a6:	f8 85       	ldd	r31, Y+8	; 0x08
     9a8:	8b 81       	ldd	r24, Y+3	; 0x03
     9aa:	9c 81       	ldd	r25, Y+4	; 0x04
     9ac:	95 83       	std	Z+5, r25	; 0x05
     9ae:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
     9b0:	eb 81       	ldd	r30, Y+3	; 0x03
     9b2:	fc 81       	ldd	r31, Y+4	; 0x04
     9b4:	8f 81       	ldd	r24, Y+7	; 0x07
     9b6:	98 85       	ldd	r25, Y+8	; 0x08
     9b8:	93 83       	std	Z+3, r25	; 0x03
     9ba:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     9bc:	ef 81       	ldd	r30, Y+7	; 0x07
     9be:	f8 85       	ldd	r31, Y+8	; 0x08
     9c0:	8d 81       	ldd	r24, Y+5	; 0x05
     9c2:	9e 81       	ldd	r25, Y+6	; 0x06
     9c4:	91 87       	std	Z+9, r25	; 0x09
     9c6:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     9c8:	ed 81       	ldd	r30, Y+5	; 0x05
     9ca:	fe 81       	ldd	r31, Y+6	; 0x06
     9cc:	80 81       	ld	r24, Z
     9ce:	8f 5f       	subi	r24, 0xFF	; 255
     9d0:	ed 81       	ldd	r30, Y+5	; 0x05
     9d2:	fe 81       	ldd	r31, Y+6	; 0x06
     9d4:	80 83       	st	Z, r24
}
     9d6:	28 96       	adiw	r28, 0x08	; 8
     9d8:	0f b6       	in	r0, 0x3f	; 63
     9da:	f8 94       	cli
     9dc:	de bf       	out	0x3e, r29	; 62
     9de:	0f be       	out	0x3f, r0	; 63
     9e0:	cd bf       	out	0x3d, r28	; 61
     9e2:	cf 91       	pop	r28
     9e4:	df 91       	pop	r29
     9e6:	08 95       	ret

000009e8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     9e8:	df 93       	push	r29
     9ea:	cf 93       	push	r28
     9ec:	00 d0       	rcall	.+0      	; 0x9ee <uxListRemove+0x6>
     9ee:	00 d0       	rcall	.+0      	; 0x9f0 <uxListRemove+0x8>
     9f0:	cd b7       	in	r28, 0x3d	; 61
     9f2:	de b7       	in	r29, 0x3e	; 62
     9f4:	9c 83       	std	Y+4, r25	; 0x04
     9f6:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     9f8:	eb 81       	ldd	r30, Y+3	; 0x03
     9fa:	fc 81       	ldd	r31, Y+4	; 0x04
     9fc:	80 85       	ldd	r24, Z+8	; 0x08
     9fe:	91 85       	ldd	r25, Z+9	; 0x09
     a00:	9a 83       	std	Y+2, r25	; 0x02
     a02:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a04:	eb 81       	ldd	r30, Y+3	; 0x03
     a06:	fc 81       	ldd	r31, Y+4	; 0x04
     a08:	a2 81       	ldd	r26, Z+2	; 0x02
     a0a:	b3 81       	ldd	r27, Z+3	; 0x03
     a0c:	eb 81       	ldd	r30, Y+3	; 0x03
     a0e:	fc 81       	ldd	r31, Y+4	; 0x04
     a10:	84 81       	ldd	r24, Z+4	; 0x04
     a12:	95 81       	ldd	r25, Z+5	; 0x05
     a14:	15 96       	adiw	r26, 0x05	; 5
     a16:	9c 93       	st	X, r25
     a18:	8e 93       	st	-X, r24
     a1a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a1c:	eb 81       	ldd	r30, Y+3	; 0x03
     a1e:	fc 81       	ldd	r31, Y+4	; 0x04
     a20:	a4 81       	ldd	r26, Z+4	; 0x04
     a22:	b5 81       	ldd	r27, Z+5	; 0x05
     a24:	eb 81       	ldd	r30, Y+3	; 0x03
     a26:	fc 81       	ldd	r31, Y+4	; 0x04
     a28:	82 81       	ldd	r24, Z+2	; 0x02
     a2a:	93 81       	ldd	r25, Z+3	; 0x03
     a2c:	13 96       	adiw	r26, 0x03	; 3
     a2e:	9c 93       	st	X, r25
     a30:	8e 93       	st	-X, r24
     a32:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     a34:	e9 81       	ldd	r30, Y+1	; 0x01
     a36:	fa 81       	ldd	r31, Y+2	; 0x02
     a38:	21 81       	ldd	r18, Z+1	; 0x01
     a3a:	32 81       	ldd	r19, Z+2	; 0x02
     a3c:	8b 81       	ldd	r24, Y+3	; 0x03
     a3e:	9c 81       	ldd	r25, Y+4	; 0x04
     a40:	28 17       	cp	r18, r24
     a42:	39 07       	cpc	r19, r25
     a44:	41 f4       	brne	.+16     	; 0xa56 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     a46:	eb 81       	ldd	r30, Y+3	; 0x03
     a48:	fc 81       	ldd	r31, Y+4	; 0x04
     a4a:	84 81       	ldd	r24, Z+4	; 0x04
     a4c:	95 81       	ldd	r25, Z+5	; 0x05
     a4e:	e9 81       	ldd	r30, Y+1	; 0x01
     a50:	fa 81       	ldd	r31, Y+2	; 0x02
     a52:	92 83       	std	Z+2, r25	; 0x02
     a54:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     a56:	eb 81       	ldd	r30, Y+3	; 0x03
     a58:	fc 81       	ldd	r31, Y+4	; 0x04
     a5a:	11 86       	std	Z+9, r1	; 0x09
     a5c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     a5e:	e9 81       	ldd	r30, Y+1	; 0x01
     a60:	fa 81       	ldd	r31, Y+2	; 0x02
     a62:	80 81       	ld	r24, Z
     a64:	81 50       	subi	r24, 0x01	; 1
     a66:	e9 81       	ldd	r30, Y+1	; 0x01
     a68:	fa 81       	ldd	r31, Y+2	; 0x02
     a6a:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
     a6c:	e9 81       	ldd	r30, Y+1	; 0x01
     a6e:	fa 81       	ldd	r31, Y+2	; 0x02
     a70:	80 81       	ld	r24, Z
}
     a72:	0f 90       	pop	r0
     a74:	0f 90       	pop	r0
     a76:	0f 90       	pop	r0
     a78:	0f 90       	pop	r0
     a7a:	cf 91       	pop	r28
     a7c:	df 91       	pop	r29
     a7e:	08 95       	ret

00000a80 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     a80:	df 93       	push	r29
     a82:	cf 93       	push	r28
     a84:	cd b7       	in	r28, 0x3d	; 61
     a86:	de b7       	in	r29, 0x3e	; 62
     a88:	28 97       	sbiw	r28, 0x08	; 8
     a8a:	0f b6       	in	r0, 0x3f	; 63
     a8c:	f8 94       	cli
     a8e:	de bf       	out	0x3e, r29	; 62
     a90:	0f be       	out	0x3f, r0	; 63
     a92:	cd bf       	out	0x3d, r28	; 61
     a94:	9c 83       	std	Y+4, r25	; 0x04
     a96:	8b 83       	std	Y+3, r24	; 0x03
     a98:	7e 83       	std	Y+6, r23	; 0x06
     a9a:	6d 83       	std	Y+5, r22	; 0x05
     a9c:	58 87       	std	Y+8, r21	; 0x08
     a9e:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     aa0:	eb 81       	ldd	r30, Y+3	; 0x03
     aa2:	fc 81       	ldd	r31, Y+4	; 0x04
     aa4:	81 e1       	ldi	r24, 0x11	; 17
     aa6:	80 83       	st	Z, r24
	pxTopOfStack--;
     aa8:	8b 81       	ldd	r24, Y+3	; 0x03
     aaa:	9c 81       	ldd	r25, Y+4	; 0x04
     aac:	01 97       	sbiw	r24, 0x01	; 1
     aae:	9c 83       	std	Y+4, r25	; 0x04
     ab0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     ab2:	eb 81       	ldd	r30, Y+3	; 0x03
     ab4:	fc 81       	ldd	r31, Y+4	; 0x04
     ab6:	82 e2       	ldi	r24, 0x22	; 34
     ab8:	80 83       	st	Z, r24
	pxTopOfStack--;
     aba:	8b 81       	ldd	r24, Y+3	; 0x03
     abc:	9c 81       	ldd	r25, Y+4	; 0x04
     abe:	01 97       	sbiw	r24, 0x01	; 1
     ac0:	9c 83       	std	Y+4, r25	; 0x04
     ac2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     ac4:	eb 81       	ldd	r30, Y+3	; 0x03
     ac6:	fc 81       	ldd	r31, Y+4	; 0x04
     ac8:	83 e3       	ldi	r24, 0x33	; 51
     aca:	80 83       	st	Z, r24
	pxTopOfStack--;
     acc:	8b 81       	ldd	r24, Y+3	; 0x03
     ace:	9c 81       	ldd	r25, Y+4	; 0x04
     ad0:	01 97       	sbiw	r24, 0x01	; 1
     ad2:	9c 83       	std	Y+4, r25	; 0x04
     ad4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     ad6:	8d 81       	ldd	r24, Y+5	; 0x05
     ad8:	9e 81       	ldd	r25, Y+6	; 0x06
     ada:	9a 83       	std	Y+2, r25	; 0x02
     adc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     ade:	89 81       	ldd	r24, Y+1	; 0x01
     ae0:	eb 81       	ldd	r30, Y+3	; 0x03
     ae2:	fc 81       	ldd	r31, Y+4	; 0x04
     ae4:	80 83       	st	Z, r24
	pxTopOfStack--;
     ae6:	8b 81       	ldd	r24, Y+3	; 0x03
     ae8:	9c 81       	ldd	r25, Y+4	; 0x04
     aea:	01 97       	sbiw	r24, 0x01	; 1
     aec:	9c 83       	std	Y+4, r25	; 0x04
     aee:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     af0:	89 81       	ldd	r24, Y+1	; 0x01
     af2:	9a 81       	ldd	r25, Y+2	; 0x02
     af4:	89 2f       	mov	r24, r25
     af6:	99 27       	eor	r25, r25
     af8:	9a 83       	std	Y+2, r25	; 0x02
     afa:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     afc:	89 81       	ldd	r24, Y+1	; 0x01
     afe:	eb 81       	ldd	r30, Y+3	; 0x03
     b00:	fc 81       	ldd	r31, Y+4	; 0x04
     b02:	80 83       	st	Z, r24
	pxTopOfStack--;
     b04:	8b 81       	ldd	r24, Y+3	; 0x03
     b06:	9c 81       	ldd	r25, Y+4	; 0x04
     b08:	01 97       	sbiw	r24, 0x01	; 1
     b0a:	9c 83       	std	Y+4, r25	; 0x04
     b0c:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     b0e:	eb 81       	ldd	r30, Y+3	; 0x03
     b10:	fc 81       	ldd	r31, Y+4	; 0x04
     b12:	10 82       	st	Z, r1
	pxTopOfStack--;
     b14:	8b 81       	ldd	r24, Y+3	; 0x03
     b16:	9c 81       	ldd	r25, Y+4	; 0x04
     b18:	01 97       	sbiw	r24, 0x01	; 1
     b1a:	9c 83       	std	Y+4, r25	; 0x04
     b1c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     b1e:	eb 81       	ldd	r30, Y+3	; 0x03
     b20:	fc 81       	ldd	r31, Y+4	; 0x04
     b22:	80 e8       	ldi	r24, 0x80	; 128
     b24:	80 83       	st	Z, r24
	pxTopOfStack--;
     b26:	8b 81       	ldd	r24, Y+3	; 0x03
     b28:	9c 81       	ldd	r25, Y+4	; 0x04
     b2a:	01 97       	sbiw	r24, 0x01	; 1
     b2c:	9c 83       	std	Y+4, r25	; 0x04
     b2e:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     b30:	eb 81       	ldd	r30, Y+3	; 0x03
     b32:	fc 81       	ldd	r31, Y+4	; 0x04
     b34:	10 82       	st	Z, r1
	pxTopOfStack--;
     b36:	8b 81       	ldd	r24, Y+3	; 0x03
     b38:	9c 81       	ldd	r25, Y+4	; 0x04
     b3a:	01 97       	sbiw	r24, 0x01	; 1
     b3c:	9c 83       	std	Y+4, r25	; 0x04
     b3e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     b40:	eb 81       	ldd	r30, Y+3	; 0x03
     b42:	fc 81       	ldd	r31, Y+4	; 0x04
     b44:	82 e0       	ldi	r24, 0x02	; 2
     b46:	80 83       	st	Z, r24
	pxTopOfStack--;
     b48:	8b 81       	ldd	r24, Y+3	; 0x03
     b4a:	9c 81       	ldd	r25, Y+4	; 0x04
     b4c:	01 97       	sbiw	r24, 0x01	; 1
     b4e:	9c 83       	std	Y+4, r25	; 0x04
     b50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     b52:	eb 81       	ldd	r30, Y+3	; 0x03
     b54:	fc 81       	ldd	r31, Y+4	; 0x04
     b56:	83 e0       	ldi	r24, 0x03	; 3
     b58:	80 83       	st	Z, r24
	pxTopOfStack--;
     b5a:	8b 81       	ldd	r24, Y+3	; 0x03
     b5c:	9c 81       	ldd	r25, Y+4	; 0x04
     b5e:	01 97       	sbiw	r24, 0x01	; 1
     b60:	9c 83       	std	Y+4, r25	; 0x04
     b62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     b64:	eb 81       	ldd	r30, Y+3	; 0x03
     b66:	fc 81       	ldd	r31, Y+4	; 0x04
     b68:	84 e0       	ldi	r24, 0x04	; 4
     b6a:	80 83       	st	Z, r24
	pxTopOfStack--;
     b6c:	8b 81       	ldd	r24, Y+3	; 0x03
     b6e:	9c 81       	ldd	r25, Y+4	; 0x04
     b70:	01 97       	sbiw	r24, 0x01	; 1
     b72:	9c 83       	std	Y+4, r25	; 0x04
     b74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     b76:	eb 81       	ldd	r30, Y+3	; 0x03
     b78:	fc 81       	ldd	r31, Y+4	; 0x04
     b7a:	85 e0       	ldi	r24, 0x05	; 5
     b7c:	80 83       	st	Z, r24
	pxTopOfStack--;
     b7e:	8b 81       	ldd	r24, Y+3	; 0x03
     b80:	9c 81       	ldd	r25, Y+4	; 0x04
     b82:	01 97       	sbiw	r24, 0x01	; 1
     b84:	9c 83       	std	Y+4, r25	; 0x04
     b86:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     b88:	eb 81       	ldd	r30, Y+3	; 0x03
     b8a:	fc 81       	ldd	r31, Y+4	; 0x04
     b8c:	86 e0       	ldi	r24, 0x06	; 6
     b8e:	80 83       	st	Z, r24
	pxTopOfStack--;
     b90:	8b 81       	ldd	r24, Y+3	; 0x03
     b92:	9c 81       	ldd	r25, Y+4	; 0x04
     b94:	01 97       	sbiw	r24, 0x01	; 1
     b96:	9c 83       	std	Y+4, r25	; 0x04
     b98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     b9a:	eb 81       	ldd	r30, Y+3	; 0x03
     b9c:	fc 81       	ldd	r31, Y+4	; 0x04
     b9e:	87 e0       	ldi	r24, 0x07	; 7
     ba0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ba2:	8b 81       	ldd	r24, Y+3	; 0x03
     ba4:	9c 81       	ldd	r25, Y+4	; 0x04
     ba6:	01 97       	sbiw	r24, 0x01	; 1
     ba8:	9c 83       	std	Y+4, r25	; 0x04
     baa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     bac:	eb 81       	ldd	r30, Y+3	; 0x03
     bae:	fc 81       	ldd	r31, Y+4	; 0x04
     bb0:	88 e0       	ldi	r24, 0x08	; 8
     bb2:	80 83       	st	Z, r24
	pxTopOfStack--;
     bb4:	8b 81       	ldd	r24, Y+3	; 0x03
     bb6:	9c 81       	ldd	r25, Y+4	; 0x04
     bb8:	01 97       	sbiw	r24, 0x01	; 1
     bba:	9c 83       	std	Y+4, r25	; 0x04
     bbc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     bbe:	eb 81       	ldd	r30, Y+3	; 0x03
     bc0:	fc 81       	ldd	r31, Y+4	; 0x04
     bc2:	89 e0       	ldi	r24, 0x09	; 9
     bc4:	80 83       	st	Z, r24
	pxTopOfStack--;
     bc6:	8b 81       	ldd	r24, Y+3	; 0x03
     bc8:	9c 81       	ldd	r25, Y+4	; 0x04
     bca:	01 97       	sbiw	r24, 0x01	; 1
     bcc:	9c 83       	std	Y+4, r25	; 0x04
     bce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     bd0:	eb 81       	ldd	r30, Y+3	; 0x03
     bd2:	fc 81       	ldd	r31, Y+4	; 0x04
     bd4:	80 e1       	ldi	r24, 0x10	; 16
     bd6:	80 83       	st	Z, r24
	pxTopOfStack--;
     bd8:	8b 81       	ldd	r24, Y+3	; 0x03
     bda:	9c 81       	ldd	r25, Y+4	; 0x04
     bdc:	01 97       	sbiw	r24, 0x01	; 1
     bde:	9c 83       	std	Y+4, r25	; 0x04
     be0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     be2:	eb 81       	ldd	r30, Y+3	; 0x03
     be4:	fc 81       	ldd	r31, Y+4	; 0x04
     be6:	81 e1       	ldi	r24, 0x11	; 17
     be8:	80 83       	st	Z, r24
	pxTopOfStack--;
     bea:	8b 81       	ldd	r24, Y+3	; 0x03
     bec:	9c 81       	ldd	r25, Y+4	; 0x04
     bee:	01 97       	sbiw	r24, 0x01	; 1
     bf0:	9c 83       	std	Y+4, r25	; 0x04
     bf2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     bf4:	eb 81       	ldd	r30, Y+3	; 0x03
     bf6:	fc 81       	ldd	r31, Y+4	; 0x04
     bf8:	82 e1       	ldi	r24, 0x12	; 18
     bfa:	80 83       	st	Z, r24
	pxTopOfStack--;
     bfc:	8b 81       	ldd	r24, Y+3	; 0x03
     bfe:	9c 81       	ldd	r25, Y+4	; 0x04
     c00:	01 97       	sbiw	r24, 0x01	; 1
     c02:	9c 83       	std	Y+4, r25	; 0x04
     c04:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     c06:	eb 81       	ldd	r30, Y+3	; 0x03
     c08:	fc 81       	ldd	r31, Y+4	; 0x04
     c0a:	83 e1       	ldi	r24, 0x13	; 19
     c0c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c0e:	8b 81       	ldd	r24, Y+3	; 0x03
     c10:	9c 81       	ldd	r25, Y+4	; 0x04
     c12:	01 97       	sbiw	r24, 0x01	; 1
     c14:	9c 83       	std	Y+4, r25	; 0x04
     c16:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     c18:	eb 81       	ldd	r30, Y+3	; 0x03
     c1a:	fc 81       	ldd	r31, Y+4	; 0x04
     c1c:	84 e1       	ldi	r24, 0x14	; 20
     c1e:	80 83       	st	Z, r24
	pxTopOfStack--;
     c20:	8b 81       	ldd	r24, Y+3	; 0x03
     c22:	9c 81       	ldd	r25, Y+4	; 0x04
     c24:	01 97       	sbiw	r24, 0x01	; 1
     c26:	9c 83       	std	Y+4, r25	; 0x04
     c28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     c2a:	eb 81       	ldd	r30, Y+3	; 0x03
     c2c:	fc 81       	ldd	r31, Y+4	; 0x04
     c2e:	85 e1       	ldi	r24, 0x15	; 21
     c30:	80 83       	st	Z, r24
	pxTopOfStack--;
     c32:	8b 81       	ldd	r24, Y+3	; 0x03
     c34:	9c 81       	ldd	r25, Y+4	; 0x04
     c36:	01 97       	sbiw	r24, 0x01	; 1
     c38:	9c 83       	std	Y+4, r25	; 0x04
     c3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     c3c:	eb 81       	ldd	r30, Y+3	; 0x03
     c3e:	fc 81       	ldd	r31, Y+4	; 0x04
     c40:	86 e1       	ldi	r24, 0x16	; 22
     c42:	80 83       	st	Z, r24
	pxTopOfStack--;
     c44:	8b 81       	ldd	r24, Y+3	; 0x03
     c46:	9c 81       	ldd	r25, Y+4	; 0x04
     c48:	01 97       	sbiw	r24, 0x01	; 1
     c4a:	9c 83       	std	Y+4, r25	; 0x04
     c4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     c4e:	eb 81       	ldd	r30, Y+3	; 0x03
     c50:	fc 81       	ldd	r31, Y+4	; 0x04
     c52:	87 e1       	ldi	r24, 0x17	; 23
     c54:	80 83       	st	Z, r24
	pxTopOfStack--;
     c56:	8b 81       	ldd	r24, Y+3	; 0x03
     c58:	9c 81       	ldd	r25, Y+4	; 0x04
     c5a:	01 97       	sbiw	r24, 0x01	; 1
     c5c:	9c 83       	std	Y+4, r25	; 0x04
     c5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     c60:	eb 81       	ldd	r30, Y+3	; 0x03
     c62:	fc 81       	ldd	r31, Y+4	; 0x04
     c64:	88 e1       	ldi	r24, 0x18	; 24
     c66:	80 83       	st	Z, r24
	pxTopOfStack--;
     c68:	8b 81       	ldd	r24, Y+3	; 0x03
     c6a:	9c 81       	ldd	r25, Y+4	; 0x04
     c6c:	01 97       	sbiw	r24, 0x01	; 1
     c6e:	9c 83       	std	Y+4, r25	; 0x04
     c70:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     c72:	eb 81       	ldd	r30, Y+3	; 0x03
     c74:	fc 81       	ldd	r31, Y+4	; 0x04
     c76:	89 e1       	ldi	r24, 0x19	; 25
     c78:	80 83       	st	Z, r24
	pxTopOfStack--;
     c7a:	8b 81       	ldd	r24, Y+3	; 0x03
     c7c:	9c 81       	ldd	r25, Y+4	; 0x04
     c7e:	01 97       	sbiw	r24, 0x01	; 1
     c80:	9c 83       	std	Y+4, r25	; 0x04
     c82:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     c84:	eb 81       	ldd	r30, Y+3	; 0x03
     c86:	fc 81       	ldd	r31, Y+4	; 0x04
     c88:	80 e2       	ldi	r24, 0x20	; 32
     c8a:	80 83       	st	Z, r24
	pxTopOfStack--;
     c8c:	8b 81       	ldd	r24, Y+3	; 0x03
     c8e:	9c 81       	ldd	r25, Y+4	; 0x04
     c90:	01 97       	sbiw	r24, 0x01	; 1
     c92:	9c 83       	std	Y+4, r25	; 0x04
     c94:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     c96:	eb 81       	ldd	r30, Y+3	; 0x03
     c98:	fc 81       	ldd	r31, Y+4	; 0x04
     c9a:	81 e2       	ldi	r24, 0x21	; 33
     c9c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c9e:	8b 81       	ldd	r24, Y+3	; 0x03
     ca0:	9c 81       	ldd	r25, Y+4	; 0x04
     ca2:	01 97       	sbiw	r24, 0x01	; 1
     ca4:	9c 83       	std	Y+4, r25	; 0x04
     ca6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     ca8:	eb 81       	ldd	r30, Y+3	; 0x03
     caa:	fc 81       	ldd	r31, Y+4	; 0x04
     cac:	82 e2       	ldi	r24, 0x22	; 34
     cae:	80 83       	st	Z, r24
	pxTopOfStack--;
     cb0:	8b 81       	ldd	r24, Y+3	; 0x03
     cb2:	9c 81       	ldd	r25, Y+4	; 0x04
     cb4:	01 97       	sbiw	r24, 0x01	; 1
     cb6:	9c 83       	std	Y+4, r25	; 0x04
     cb8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     cba:	eb 81       	ldd	r30, Y+3	; 0x03
     cbc:	fc 81       	ldd	r31, Y+4	; 0x04
     cbe:	83 e2       	ldi	r24, 0x23	; 35
     cc0:	80 83       	st	Z, r24
	pxTopOfStack--;
     cc2:	8b 81       	ldd	r24, Y+3	; 0x03
     cc4:	9c 81       	ldd	r25, Y+4	; 0x04
     cc6:	01 97       	sbiw	r24, 0x01	; 1
     cc8:	9c 83       	std	Y+4, r25	; 0x04
     cca:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     ccc:	8f 81       	ldd	r24, Y+7	; 0x07
     cce:	98 85       	ldd	r25, Y+8	; 0x08
     cd0:	9a 83       	std	Y+2, r25	; 0x02
     cd2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     cd4:	89 81       	ldd	r24, Y+1	; 0x01
     cd6:	eb 81       	ldd	r30, Y+3	; 0x03
     cd8:	fc 81       	ldd	r31, Y+4	; 0x04
     cda:	80 83       	st	Z, r24
	pxTopOfStack--;
     cdc:	8b 81       	ldd	r24, Y+3	; 0x03
     cde:	9c 81       	ldd	r25, Y+4	; 0x04
     ce0:	01 97       	sbiw	r24, 0x01	; 1
     ce2:	9c 83       	std	Y+4, r25	; 0x04
     ce4:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     ce6:	89 81       	ldd	r24, Y+1	; 0x01
     ce8:	9a 81       	ldd	r25, Y+2	; 0x02
     cea:	89 2f       	mov	r24, r25
     cec:	99 27       	eor	r25, r25
     cee:	9a 83       	std	Y+2, r25	; 0x02
     cf0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     cf2:	89 81       	ldd	r24, Y+1	; 0x01
     cf4:	eb 81       	ldd	r30, Y+3	; 0x03
     cf6:	fc 81       	ldd	r31, Y+4	; 0x04
     cf8:	80 83       	st	Z, r24
	pxTopOfStack--;
     cfa:	8b 81       	ldd	r24, Y+3	; 0x03
     cfc:	9c 81       	ldd	r25, Y+4	; 0x04
     cfe:	01 97       	sbiw	r24, 0x01	; 1
     d00:	9c 83       	std	Y+4, r25	; 0x04
     d02:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     d04:	eb 81       	ldd	r30, Y+3	; 0x03
     d06:	fc 81       	ldd	r31, Y+4	; 0x04
     d08:	86 e2       	ldi	r24, 0x26	; 38
     d0a:	80 83       	st	Z, r24
	pxTopOfStack--;
     d0c:	8b 81       	ldd	r24, Y+3	; 0x03
     d0e:	9c 81       	ldd	r25, Y+4	; 0x04
     d10:	01 97       	sbiw	r24, 0x01	; 1
     d12:	9c 83       	std	Y+4, r25	; 0x04
     d14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     d16:	eb 81       	ldd	r30, Y+3	; 0x03
     d18:	fc 81       	ldd	r31, Y+4	; 0x04
     d1a:	87 e2       	ldi	r24, 0x27	; 39
     d1c:	80 83       	st	Z, r24
	pxTopOfStack--;
     d1e:	8b 81       	ldd	r24, Y+3	; 0x03
     d20:	9c 81       	ldd	r25, Y+4	; 0x04
     d22:	01 97       	sbiw	r24, 0x01	; 1
     d24:	9c 83       	std	Y+4, r25	; 0x04
     d26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     d28:	eb 81       	ldd	r30, Y+3	; 0x03
     d2a:	fc 81       	ldd	r31, Y+4	; 0x04
     d2c:	88 e2       	ldi	r24, 0x28	; 40
     d2e:	80 83       	st	Z, r24
	pxTopOfStack--;
     d30:	8b 81       	ldd	r24, Y+3	; 0x03
     d32:	9c 81       	ldd	r25, Y+4	; 0x04
     d34:	01 97       	sbiw	r24, 0x01	; 1
     d36:	9c 83       	std	Y+4, r25	; 0x04
     d38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     d3a:	eb 81       	ldd	r30, Y+3	; 0x03
     d3c:	fc 81       	ldd	r31, Y+4	; 0x04
     d3e:	89 e2       	ldi	r24, 0x29	; 41
     d40:	80 83       	st	Z, r24
	pxTopOfStack--;
     d42:	8b 81       	ldd	r24, Y+3	; 0x03
     d44:	9c 81       	ldd	r25, Y+4	; 0x04
     d46:	01 97       	sbiw	r24, 0x01	; 1
     d48:	9c 83       	std	Y+4, r25	; 0x04
     d4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     d4c:	eb 81       	ldd	r30, Y+3	; 0x03
     d4e:	fc 81       	ldd	r31, Y+4	; 0x04
     d50:	80 e3       	ldi	r24, 0x30	; 48
     d52:	80 83       	st	Z, r24
	pxTopOfStack--;
     d54:	8b 81       	ldd	r24, Y+3	; 0x03
     d56:	9c 81       	ldd	r25, Y+4	; 0x04
     d58:	01 97       	sbiw	r24, 0x01	; 1
     d5a:	9c 83       	std	Y+4, r25	; 0x04
     d5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     d5e:	eb 81       	ldd	r30, Y+3	; 0x03
     d60:	fc 81       	ldd	r31, Y+4	; 0x04
     d62:	81 e3       	ldi	r24, 0x31	; 49
     d64:	80 83       	st	Z, r24
	pxTopOfStack--;
     d66:	8b 81       	ldd	r24, Y+3	; 0x03
     d68:	9c 81       	ldd	r25, Y+4	; 0x04
     d6a:	01 97       	sbiw	r24, 0x01	; 1
     d6c:	9c 83       	std	Y+4, r25	; 0x04
     d6e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     d70:	8b 81       	ldd	r24, Y+3	; 0x03
     d72:	9c 81       	ldd	r25, Y+4	; 0x04
}
     d74:	28 96       	adiw	r28, 0x08	; 8
     d76:	0f b6       	in	r0, 0x3f	; 63
     d78:	f8 94       	cli
     d7a:	de bf       	out	0x3e, r29	; 62
     d7c:	0f be       	out	0x3f, r0	; 63
     d7e:	cd bf       	out	0x3d, r28	; 61
     d80:	cf 91       	pop	r28
     d82:	df 91       	pop	r29
     d84:	08 95       	ret

00000d86 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     d86:	df 93       	push	r29
     d88:	cf 93       	push	r28
     d8a:	cd b7       	in	r28, 0x3d	; 61
     d8c:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     d8e:	0e 94 b5 07 	call	0xf6a	; 0xf6a <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     d92:	a0 91 56 06 	lds	r26, 0x0656
     d96:	b0 91 57 06 	lds	r27, 0x0657
     d9a:	cd 91       	ld	r28, X+
     d9c:	cd bf       	out	0x3d, r28	; 61
     d9e:	dd 91       	ld	r29, X+
     da0:	de bf       	out	0x3e, r29	; 62
     da2:	ff 91       	pop	r31
     da4:	ef 91       	pop	r30
     da6:	df 91       	pop	r29
     da8:	cf 91       	pop	r28
     daa:	bf 91       	pop	r27
     dac:	af 91       	pop	r26
     dae:	9f 91       	pop	r25
     db0:	8f 91       	pop	r24
     db2:	7f 91       	pop	r23
     db4:	6f 91       	pop	r22
     db6:	5f 91       	pop	r21
     db8:	4f 91       	pop	r20
     dba:	3f 91       	pop	r19
     dbc:	2f 91       	pop	r18
     dbe:	1f 91       	pop	r17
     dc0:	0f 91       	pop	r16
     dc2:	ff 90       	pop	r15
     dc4:	ef 90       	pop	r14
     dc6:	df 90       	pop	r13
     dc8:	cf 90       	pop	r12
     dca:	bf 90       	pop	r11
     dcc:	af 90       	pop	r10
     dce:	9f 90       	pop	r9
     dd0:	8f 90       	pop	r8
     dd2:	7f 90       	pop	r7
     dd4:	6f 90       	pop	r6
     dd6:	5f 90       	pop	r5
     dd8:	4f 90       	pop	r4
     dda:	3f 90       	pop	r3
     ddc:	2f 90       	pop	r2
     dde:	1f 90       	pop	r1
     de0:	0f 90       	pop	r0
     de2:	0f be       	out	0x3f, r0	; 63
     de4:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     de6:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     de8:	81 e0       	ldi	r24, 0x01	; 1
}
     dea:	cf 91       	pop	r28
     dec:	df 91       	pop	r29
     dee:	08 95       	ret

00000df0 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     df0:	df 93       	push	r29
     df2:	cf 93       	push	r28
     df4:	cd b7       	in	r28, 0x3d	; 61
     df6:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     df8:	cf 91       	pop	r28
     dfa:	df 91       	pop	r29
     dfc:	08 95       	ret

00000dfe <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     dfe:	0f 92       	push	r0
     e00:	0f b6       	in	r0, 0x3f	; 63
     e02:	f8 94       	cli
     e04:	0f 92       	push	r0
     e06:	1f 92       	push	r1
     e08:	11 24       	eor	r1, r1
     e0a:	2f 92       	push	r2
     e0c:	3f 92       	push	r3
     e0e:	4f 92       	push	r4
     e10:	5f 92       	push	r5
     e12:	6f 92       	push	r6
     e14:	7f 92       	push	r7
     e16:	8f 92       	push	r8
     e18:	9f 92       	push	r9
     e1a:	af 92       	push	r10
     e1c:	bf 92       	push	r11
     e1e:	cf 92       	push	r12
     e20:	df 92       	push	r13
     e22:	ef 92       	push	r14
     e24:	ff 92       	push	r15
     e26:	0f 93       	push	r16
     e28:	1f 93       	push	r17
     e2a:	2f 93       	push	r18
     e2c:	3f 93       	push	r19
     e2e:	4f 93       	push	r20
     e30:	5f 93       	push	r21
     e32:	6f 93       	push	r22
     e34:	7f 93       	push	r23
     e36:	8f 93       	push	r24
     e38:	9f 93       	push	r25
     e3a:	af 93       	push	r26
     e3c:	bf 93       	push	r27
     e3e:	cf 93       	push	r28
     e40:	df 93       	push	r29
     e42:	ef 93       	push	r30
     e44:	ff 93       	push	r31
     e46:	a0 91 56 06 	lds	r26, 0x0656
     e4a:	b0 91 57 06 	lds	r27, 0x0657
     e4e:	0d b6       	in	r0, 0x3d	; 61
     e50:	0d 92       	st	X+, r0
     e52:	0e b6       	in	r0, 0x3e	; 62
     e54:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e56:	0e 94 69 1c 	call	0x38d2	; 0x38d2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e5a:	a0 91 56 06 	lds	r26, 0x0656
     e5e:	b0 91 57 06 	lds	r27, 0x0657
     e62:	cd 91       	ld	r28, X+
     e64:	cd bf       	out	0x3d, r28	; 61
     e66:	dd 91       	ld	r29, X+
     e68:	de bf       	out	0x3e, r29	; 62
     e6a:	ff 91       	pop	r31
     e6c:	ef 91       	pop	r30
     e6e:	df 91       	pop	r29
     e70:	cf 91       	pop	r28
     e72:	bf 91       	pop	r27
     e74:	af 91       	pop	r26
     e76:	9f 91       	pop	r25
     e78:	8f 91       	pop	r24
     e7a:	7f 91       	pop	r23
     e7c:	6f 91       	pop	r22
     e7e:	5f 91       	pop	r21
     e80:	4f 91       	pop	r20
     e82:	3f 91       	pop	r19
     e84:	2f 91       	pop	r18
     e86:	1f 91       	pop	r17
     e88:	0f 91       	pop	r16
     e8a:	ff 90       	pop	r15
     e8c:	ef 90       	pop	r14
     e8e:	df 90       	pop	r13
     e90:	cf 90       	pop	r12
     e92:	bf 90       	pop	r11
     e94:	af 90       	pop	r10
     e96:	9f 90       	pop	r9
     e98:	8f 90       	pop	r8
     e9a:	7f 90       	pop	r7
     e9c:	6f 90       	pop	r6
     e9e:	5f 90       	pop	r5
     ea0:	4f 90       	pop	r4
     ea2:	3f 90       	pop	r3
     ea4:	2f 90       	pop	r2
     ea6:	1f 90       	pop	r1
     ea8:	0f 90       	pop	r0
     eaa:	0f be       	out	0x3f, r0	; 63
     eac:	0f 90       	pop	r0

	asm volatile ( "ret" );
     eae:	08 95       	ret

00000eb0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     eb0:	0f 92       	push	r0
     eb2:	0f b6       	in	r0, 0x3f	; 63
     eb4:	f8 94       	cli
     eb6:	0f 92       	push	r0
     eb8:	1f 92       	push	r1
     eba:	11 24       	eor	r1, r1
     ebc:	2f 92       	push	r2
     ebe:	3f 92       	push	r3
     ec0:	4f 92       	push	r4
     ec2:	5f 92       	push	r5
     ec4:	6f 92       	push	r6
     ec6:	7f 92       	push	r7
     ec8:	8f 92       	push	r8
     eca:	9f 92       	push	r9
     ecc:	af 92       	push	r10
     ece:	bf 92       	push	r11
     ed0:	cf 92       	push	r12
     ed2:	df 92       	push	r13
     ed4:	ef 92       	push	r14
     ed6:	ff 92       	push	r15
     ed8:	0f 93       	push	r16
     eda:	1f 93       	push	r17
     edc:	2f 93       	push	r18
     ede:	3f 93       	push	r19
     ee0:	4f 93       	push	r20
     ee2:	5f 93       	push	r21
     ee4:	6f 93       	push	r22
     ee6:	7f 93       	push	r23
     ee8:	8f 93       	push	r24
     eea:	9f 93       	push	r25
     eec:	af 93       	push	r26
     eee:	bf 93       	push	r27
     ef0:	cf 93       	push	r28
     ef2:	df 93       	push	r29
     ef4:	ef 93       	push	r30
     ef6:	ff 93       	push	r31
     ef8:	a0 91 56 06 	lds	r26, 0x0656
     efc:	b0 91 57 06 	lds	r27, 0x0657
     f00:	0d b6       	in	r0, 0x3d	; 61
     f02:	0d 92       	st	X+, r0
     f04:	0e b6       	in	r0, 0x3e	; 62
     f06:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     f08:	0e 94 b0 1b 	call	0x3760	; 0x3760 <xTaskIncrementTick>
     f0c:	88 23       	and	r24, r24
     f0e:	11 f0       	breq	.+4      	; 0xf14 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     f10:	0e 94 69 1c 	call	0x38d2	; 0x38d2 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     f14:	a0 91 56 06 	lds	r26, 0x0656
     f18:	b0 91 57 06 	lds	r27, 0x0657
     f1c:	cd 91       	ld	r28, X+
     f1e:	cd bf       	out	0x3d, r28	; 61
     f20:	dd 91       	ld	r29, X+
     f22:	de bf       	out	0x3e, r29	; 62
     f24:	ff 91       	pop	r31
     f26:	ef 91       	pop	r30
     f28:	df 91       	pop	r29
     f2a:	cf 91       	pop	r28
     f2c:	bf 91       	pop	r27
     f2e:	af 91       	pop	r26
     f30:	9f 91       	pop	r25
     f32:	8f 91       	pop	r24
     f34:	7f 91       	pop	r23
     f36:	6f 91       	pop	r22
     f38:	5f 91       	pop	r21
     f3a:	4f 91       	pop	r20
     f3c:	3f 91       	pop	r19
     f3e:	2f 91       	pop	r18
     f40:	1f 91       	pop	r17
     f42:	0f 91       	pop	r16
     f44:	ff 90       	pop	r15
     f46:	ef 90       	pop	r14
     f48:	df 90       	pop	r13
     f4a:	cf 90       	pop	r12
     f4c:	bf 90       	pop	r11
     f4e:	af 90       	pop	r10
     f50:	9f 90       	pop	r9
     f52:	8f 90       	pop	r8
     f54:	7f 90       	pop	r7
     f56:	6f 90       	pop	r6
     f58:	5f 90       	pop	r5
     f5a:	4f 90       	pop	r4
     f5c:	3f 90       	pop	r3
     f5e:	2f 90       	pop	r2
     f60:	1f 90       	pop	r1
     f62:	0f 90       	pop	r0
     f64:	0f be       	out	0x3f, r0	; 63
     f66:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f68:	08 95       	ret

00000f6a <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     f6a:	df 93       	push	r29
     f6c:	cf 93       	push	r28
     f6e:	00 d0       	rcall	.+0      	; 0xf70 <prvSetupTimerInterrupt+0x6>
     f70:	00 d0       	rcall	.+0      	; 0xf72 <prvSetupTimerInterrupt+0x8>
     f72:	00 d0       	rcall	.+0      	; 0xf74 <prvSetupTimerInterrupt+0xa>
     f74:	cd b7       	in	r28, 0x3d	; 61
     f76:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     f78:	80 e8       	ldi	r24, 0x80	; 128
     f7a:	9e e3       	ldi	r25, 0x3E	; 62
     f7c:	a0 e0       	ldi	r26, 0x00	; 0
     f7e:	b0 e0       	ldi	r27, 0x00	; 0
     f80:	8b 83       	std	Y+3, r24	; 0x03
     f82:	9c 83       	std	Y+4, r25	; 0x04
     f84:	ad 83       	std	Y+5, r26	; 0x05
     f86:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     f88:	8b 81       	ldd	r24, Y+3	; 0x03
     f8a:	9c 81       	ldd	r25, Y+4	; 0x04
     f8c:	ad 81       	ldd	r26, Y+5	; 0x05
     f8e:	be 81       	ldd	r27, Y+6	; 0x06
     f90:	68 94       	set
     f92:	15 f8       	bld	r1, 5
     f94:	b6 95       	lsr	r27
     f96:	a7 95       	ror	r26
     f98:	97 95       	ror	r25
     f9a:	87 95       	ror	r24
     f9c:	16 94       	lsr	r1
     f9e:	d1 f7       	brne	.-12     	; 0xf94 <prvSetupTimerInterrupt+0x2a>
     fa0:	8b 83       	std	Y+3, r24	; 0x03
     fa2:	9c 83       	std	Y+4, r25	; 0x04
     fa4:	ad 83       	std	Y+5, r26	; 0x05
     fa6:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     fa8:	8b 81       	ldd	r24, Y+3	; 0x03
     faa:	9c 81       	ldd	r25, Y+4	; 0x04
     fac:	ad 81       	ldd	r26, Y+5	; 0x05
     fae:	be 81       	ldd	r27, Y+6	; 0x06
     fb0:	01 97       	sbiw	r24, 0x01	; 1
     fb2:	a1 09       	sbc	r26, r1
     fb4:	b1 09       	sbc	r27, r1
     fb6:	8b 83       	std	Y+3, r24	; 0x03
     fb8:	9c 83       	std	Y+4, r25	; 0x04
     fba:	ad 83       	std	Y+5, r26	; 0x05
     fbc:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     fbe:	8b 81       	ldd	r24, Y+3	; 0x03
     fc0:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     fc2:	8b 81       	ldd	r24, Y+3	; 0x03
     fc4:	9c 81       	ldd	r25, Y+4	; 0x04
     fc6:	ad 81       	ldd	r26, Y+5	; 0x05
     fc8:	be 81       	ldd	r27, Y+6	; 0x06
     fca:	89 2f       	mov	r24, r25
     fcc:	9a 2f       	mov	r25, r26
     fce:	ab 2f       	mov	r26, r27
     fd0:	bb 27       	eor	r27, r27
     fd2:	8b 83       	std	Y+3, r24	; 0x03
     fd4:	9c 83       	std	Y+4, r25	; 0x04
     fd6:	ad 83       	std	Y+5, r26	; 0x05
     fd8:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     fda:	8b 81       	ldd	r24, Y+3	; 0x03
     fdc:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     fde:	eb e4       	ldi	r30, 0x4B	; 75
     fe0:	f0 e0       	ldi	r31, 0x00	; 0
     fe2:	8a 81       	ldd	r24, Y+2	; 0x02
     fe4:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     fe6:	ea e4       	ldi	r30, 0x4A	; 74
     fe8:	f0 e0       	ldi	r31, 0x00	; 0
     fea:	89 81       	ldd	r24, Y+1	; 0x01
     fec:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     fee:	8b e0       	ldi	r24, 0x0B	; 11
     ff0:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     ff2:	ee e4       	ldi	r30, 0x4E	; 78
     ff4:	f0 e0       	ldi	r31, 0x00	; 0
     ff6:	89 81       	ldd	r24, Y+1	; 0x01
     ff8:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     ffa:	e9 e5       	ldi	r30, 0x59	; 89
     ffc:	f0 e0       	ldi	r31, 0x00	; 0
     ffe:	80 81       	ld	r24, Z
    1000:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1002:	89 81       	ldd	r24, Y+1	; 0x01
    1004:	80 61       	ori	r24, 0x10	; 16
    1006:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1008:	e9 e5       	ldi	r30, 0x59	; 89
    100a:	f0 e0       	ldi	r31, 0x00	; 0
    100c:	89 81       	ldd	r24, Y+1	; 0x01
    100e:	80 83       	st	Z, r24
}
    1010:	26 96       	adiw	r28, 0x06	; 6
    1012:	0f b6       	in	r0, 0x3f	; 63
    1014:	f8 94       	cli
    1016:	de bf       	out	0x3e, r29	; 62
    1018:	0f be       	out	0x3f, r0	; 63
    101a:	cd bf       	out	0x3d, r28	; 61
    101c:	cf 91       	pop	r28
    101e:	df 91       	pop	r29
    1020:	08 95       	ret

00001022 <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal ) );
	void TIMER1_COMPA_vect( void )
	{
    1022:	1f 92       	push	r1
    1024:	0f 92       	push	r0
    1026:	0f b6       	in	r0, 0x3f	; 63
    1028:	0f 92       	push	r0
    102a:	11 24       	eor	r1, r1
    102c:	2f 93       	push	r18
    102e:	3f 93       	push	r19
    1030:	4f 93       	push	r20
    1032:	5f 93       	push	r21
    1034:	6f 93       	push	r22
    1036:	7f 93       	push	r23
    1038:	8f 93       	push	r24
    103a:	9f 93       	push	r25
    103c:	af 93       	push	r26
    103e:	bf 93       	push	r27
    1040:	ef 93       	push	r30
    1042:	ff 93       	push	r31
    1044:	df 93       	push	r29
    1046:	cf 93       	push	r28
    1048:	cd b7       	in	r28, 0x3d	; 61
    104a:	de b7       	in	r29, 0x3e	; 62
		xTaskIncrementTick();
    104c:	0e 94 b0 1b 	call	0x3760	; 0x3760 <xTaskIncrementTick>
	}
    1050:	cf 91       	pop	r28
    1052:	df 91       	pop	r29
    1054:	ff 91       	pop	r31
    1056:	ef 91       	pop	r30
    1058:	bf 91       	pop	r27
    105a:	af 91       	pop	r26
    105c:	9f 91       	pop	r25
    105e:	8f 91       	pop	r24
    1060:	7f 91       	pop	r23
    1062:	6f 91       	pop	r22
    1064:	5f 91       	pop	r21
    1066:	4f 91       	pop	r20
    1068:	3f 91       	pop	r19
    106a:	2f 91       	pop	r18
    106c:	0f 90       	pop	r0
    106e:	0f be       	out	0x3f, r0	; 63
    1070:	0f 90       	pop	r0
    1072:	1f 90       	pop	r1
    1074:	18 95       	reti

00001076 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1076:	df 93       	push	r29
    1078:	cf 93       	push	r28
    107a:	00 d0       	rcall	.+0      	; 0x107c <xQueueGenericReset+0x6>
    107c:	00 d0       	rcall	.+0      	; 0x107e <xQueueGenericReset+0x8>
    107e:	0f 92       	push	r0
    1080:	cd b7       	in	r28, 0x3d	; 61
    1082:	de b7       	in	r29, 0x3e	; 62
    1084:	9c 83       	std	Y+4, r25	; 0x04
    1086:	8b 83       	std	Y+3, r24	; 0x03
    1088:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    108a:	8b 81       	ldd	r24, Y+3	; 0x03
    108c:	9c 81       	ldd	r25, Y+4	; 0x04
    108e:	9a 83       	std	Y+2, r25	; 0x02
    1090:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1092:	0f b6       	in	r0, 0x3f	; 63
    1094:	f8 94       	cli
    1096:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1098:	e9 81       	ldd	r30, Y+1	; 0x01
    109a:	fa 81       	ldd	r31, Y+2	; 0x02
    109c:	40 81       	ld	r20, Z
    109e:	51 81       	ldd	r21, Z+1	; 0x01
    10a0:	e9 81       	ldd	r30, Y+1	; 0x01
    10a2:	fa 81       	ldd	r31, Y+2	; 0x02
    10a4:	83 8d       	ldd	r24, Z+27	; 0x1b
    10a6:	28 2f       	mov	r18, r24
    10a8:	30 e0       	ldi	r19, 0x00	; 0
    10aa:	e9 81       	ldd	r30, Y+1	; 0x01
    10ac:	fa 81       	ldd	r31, Y+2	; 0x02
    10ae:	84 8d       	ldd	r24, Z+28	; 0x1c
    10b0:	88 2f       	mov	r24, r24
    10b2:	90 e0       	ldi	r25, 0x00	; 0
    10b4:	bc 01       	movw	r22, r24
    10b6:	26 9f       	mul	r18, r22
    10b8:	c0 01       	movw	r24, r0
    10ba:	27 9f       	mul	r18, r23
    10bc:	90 0d       	add	r25, r0
    10be:	36 9f       	mul	r19, r22
    10c0:	90 0d       	add	r25, r0
    10c2:	11 24       	eor	r1, r1
    10c4:	84 0f       	add	r24, r20
    10c6:	95 1f       	adc	r25, r21
    10c8:	e9 81       	ldd	r30, Y+1	; 0x01
    10ca:	fa 81       	ldd	r31, Y+2	; 0x02
    10cc:	95 83       	std	Z+5, r25	; 0x05
    10ce:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    10d0:	e9 81       	ldd	r30, Y+1	; 0x01
    10d2:	fa 81       	ldd	r31, Y+2	; 0x02
    10d4:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    10d6:	e9 81       	ldd	r30, Y+1	; 0x01
    10d8:	fa 81       	ldd	r31, Y+2	; 0x02
    10da:	80 81       	ld	r24, Z
    10dc:	91 81       	ldd	r25, Z+1	; 0x01
    10de:	e9 81       	ldd	r30, Y+1	; 0x01
    10e0:	fa 81       	ldd	r31, Y+2	; 0x02
    10e2:	93 83       	std	Z+3, r25	; 0x03
    10e4:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    10e6:	e9 81       	ldd	r30, Y+1	; 0x01
    10e8:	fa 81       	ldd	r31, Y+2	; 0x02
    10ea:	40 81       	ld	r20, Z
    10ec:	51 81       	ldd	r21, Z+1	; 0x01
    10ee:	e9 81       	ldd	r30, Y+1	; 0x01
    10f0:	fa 81       	ldd	r31, Y+2	; 0x02
    10f2:	83 8d       	ldd	r24, Z+27	; 0x1b
    10f4:	88 2f       	mov	r24, r24
    10f6:	90 e0       	ldi	r25, 0x00	; 0
    10f8:	9c 01       	movw	r18, r24
    10fa:	21 50       	subi	r18, 0x01	; 1
    10fc:	30 40       	sbci	r19, 0x00	; 0
    10fe:	e9 81       	ldd	r30, Y+1	; 0x01
    1100:	fa 81       	ldd	r31, Y+2	; 0x02
    1102:	84 8d       	ldd	r24, Z+28	; 0x1c
    1104:	88 2f       	mov	r24, r24
    1106:	90 e0       	ldi	r25, 0x00	; 0
    1108:	bc 01       	movw	r22, r24
    110a:	26 9f       	mul	r18, r22
    110c:	c0 01       	movw	r24, r0
    110e:	27 9f       	mul	r18, r23
    1110:	90 0d       	add	r25, r0
    1112:	36 9f       	mul	r19, r22
    1114:	90 0d       	add	r25, r0
    1116:	11 24       	eor	r1, r1
    1118:	84 0f       	add	r24, r20
    111a:	95 1f       	adc	r25, r21
    111c:	e9 81       	ldd	r30, Y+1	; 0x01
    111e:	fa 81       	ldd	r31, Y+2	; 0x02
    1120:	97 83       	std	Z+7, r25	; 0x07
    1122:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1124:	e9 81       	ldd	r30, Y+1	; 0x01
    1126:	fa 81       	ldd	r31, Y+2	; 0x02
    1128:	8f ef       	ldi	r24, 0xFF	; 255
    112a:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    112c:	e9 81       	ldd	r30, Y+1	; 0x01
    112e:	fa 81       	ldd	r31, Y+2	; 0x02
    1130:	8f ef       	ldi	r24, 0xFF	; 255
    1132:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1134:	8d 81       	ldd	r24, Y+5	; 0x05
    1136:	88 23       	and	r24, r24
    1138:	59 f4       	brne	.+22     	; 0x1150 <xQueueGenericReset+0xda>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    113a:	e9 81       	ldd	r30, Y+1	; 0x01
    113c:	fa 81       	ldd	r31, Y+2	; 0x02
    113e:	80 85       	ldd	r24, Z+8	; 0x08
    1140:	88 23       	and	r24, r24
    1142:	81 f0       	breq	.+32     	; 0x1164 <xQueueGenericReset+0xee>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1144:	89 81       	ldd	r24, Y+1	; 0x01
    1146:	9a 81       	ldd	r25, Y+2	; 0x02
    1148:	08 96       	adiw	r24, 0x08	; 8
    114a:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <xTaskRemoveFromEventList>
    114e:	0a c0       	rjmp	.+20     	; 0x1164 <xQueueGenericReset+0xee>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1150:	89 81       	ldd	r24, Y+1	; 0x01
    1152:	9a 81       	ldd	r25, Y+2	; 0x02
    1154:	08 96       	adiw	r24, 0x08	; 8
    1156:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    115a:	89 81       	ldd	r24, Y+1	; 0x01
    115c:	9a 81       	ldd	r25, Y+2	; 0x02
    115e:	41 96       	adiw	r24, 0x11	; 17
    1160:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1164:	0f 90       	pop	r0
    1166:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1168:	81 e0       	ldi	r24, 0x01	; 1
}
    116a:	0f 90       	pop	r0
    116c:	0f 90       	pop	r0
    116e:	0f 90       	pop	r0
    1170:	0f 90       	pop	r0
    1172:	0f 90       	pop	r0
    1174:	cf 91       	pop	r28
    1176:	df 91       	pop	r29
    1178:	08 95       	ret

0000117a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    117a:	0f 93       	push	r16
    117c:	1f 93       	push	r17
    117e:	df 93       	push	r29
    1180:	cf 93       	push	r28
    1182:	cd b7       	in	r28, 0x3d	; 61
    1184:	de b7       	in	r29, 0x3e	; 62
    1186:	29 97       	sbiw	r28, 0x09	; 9
    1188:	0f b6       	in	r0, 0x3f	; 63
    118a:	f8 94       	cli
    118c:	de bf       	out	0x3e, r29	; 62
    118e:	0f be       	out	0x3f, r0	; 63
    1190:	cd bf       	out	0x3d, r28	; 61
    1192:	8f 83       	std	Y+7, r24	; 0x07
    1194:	68 87       	std	Y+8, r22	; 0x08
    1196:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1198:	88 85       	ldd	r24, Y+8	; 0x08
    119a:	88 23       	and	r24, r24
    119c:	19 f4       	brne	.+6      	; 0x11a4 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    119e:	1c 82       	std	Y+4, r1	; 0x04
    11a0:	1b 82       	std	Y+3, r1	; 0x03
    11a2:	10 c0       	rjmp	.+32     	; 0x11c4 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    11a4:	8f 81       	ldd	r24, Y+7	; 0x07
    11a6:	28 2f       	mov	r18, r24
    11a8:	30 e0       	ldi	r19, 0x00	; 0
    11aa:	88 85       	ldd	r24, Y+8	; 0x08
    11ac:	88 2f       	mov	r24, r24
    11ae:	90 e0       	ldi	r25, 0x00	; 0
    11b0:	ac 01       	movw	r20, r24
    11b2:	24 9f       	mul	r18, r20
    11b4:	c0 01       	movw	r24, r0
    11b6:	25 9f       	mul	r18, r21
    11b8:	90 0d       	add	r25, r0
    11ba:	34 9f       	mul	r19, r20
    11bc:	90 0d       	add	r25, r0
    11be:	11 24       	eor	r1, r1
    11c0:	9c 83       	std	Y+4, r25	; 0x04
    11c2:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    11c4:	8b 81       	ldd	r24, Y+3	; 0x03
    11c6:	9c 81       	ldd	r25, Y+4	; 0x04
    11c8:	4f 96       	adiw	r24, 0x1f	; 31
    11ca:	0e 94 8e 03 	call	0x71c	; 0x71c <pvPortMalloc>
    11ce:	9e 83       	std	Y+6, r25	; 0x06
    11d0:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    11d2:	8d 81       	ldd	r24, Y+5	; 0x05
    11d4:	9e 81       	ldd	r25, Y+6	; 0x06
    11d6:	00 97       	sbiw	r24, 0x00	; 0
    11d8:	a1 f0       	breq	.+40     	; 0x1202 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    11da:	8d 81       	ldd	r24, Y+5	; 0x05
    11dc:	9e 81       	ldd	r25, Y+6	; 0x06
    11de:	9a 83       	std	Y+2, r25	; 0x02
    11e0:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    11e2:	89 81       	ldd	r24, Y+1	; 0x01
    11e4:	9a 81       	ldd	r25, Y+2	; 0x02
    11e6:	4f 96       	adiw	r24, 0x1f	; 31
    11e8:	9a 83       	std	Y+2, r25	; 0x02
    11ea:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    11ec:	29 81       	ldd	r18, Y+1	; 0x01
    11ee:	3a 81       	ldd	r19, Y+2	; 0x02
    11f0:	ed 81       	ldd	r30, Y+5	; 0x05
    11f2:	fe 81       	ldd	r31, Y+6	; 0x06
    11f4:	8f 81       	ldd	r24, Y+7	; 0x07
    11f6:	68 85       	ldd	r22, Y+8	; 0x08
    11f8:	a9 01       	movw	r20, r18
    11fa:	29 85       	ldd	r18, Y+9	; 0x09
    11fc:	8f 01       	movw	r16, r30
    11fe:	0e 94 0e 09 	call	0x121c	; 0x121c <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    1202:	8d 81       	ldd	r24, Y+5	; 0x05
    1204:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    1206:	29 96       	adiw	r28, 0x09	; 9
    1208:	0f b6       	in	r0, 0x3f	; 63
    120a:	f8 94       	cli
    120c:	de bf       	out	0x3e, r29	; 62
    120e:	0f be       	out	0x3f, r0	; 63
    1210:	cd bf       	out	0x3d, r28	; 61
    1212:	cf 91       	pop	r28
    1214:	df 91       	pop	r29
    1216:	1f 91       	pop	r17
    1218:	0f 91       	pop	r16
    121a:	08 95       	ret

0000121c <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    121c:	0f 93       	push	r16
    121e:	1f 93       	push	r17
    1220:	df 93       	push	r29
    1222:	cf 93       	push	r28
    1224:	cd b7       	in	r28, 0x3d	; 61
    1226:	de b7       	in	r29, 0x3e	; 62
    1228:	27 97       	sbiw	r28, 0x07	; 7
    122a:	0f b6       	in	r0, 0x3f	; 63
    122c:	f8 94       	cli
    122e:	de bf       	out	0x3e, r29	; 62
    1230:	0f be       	out	0x3f, r0	; 63
    1232:	cd bf       	out	0x3d, r28	; 61
    1234:	89 83       	std	Y+1, r24	; 0x01
    1236:	6a 83       	std	Y+2, r22	; 0x02
    1238:	5c 83       	std	Y+4, r21	; 0x04
    123a:	4b 83       	std	Y+3, r20	; 0x03
    123c:	2d 83       	std	Y+5, r18	; 0x05
    123e:	1f 83       	std	Y+7, r17	; 0x07
    1240:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1242:	8a 81       	ldd	r24, Y+2	; 0x02
    1244:	88 23       	and	r24, r24
    1246:	39 f4       	brne	.+14     	; 0x1256 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1248:	8e 81       	ldd	r24, Y+6	; 0x06
    124a:	9f 81       	ldd	r25, Y+7	; 0x07
    124c:	ee 81       	ldd	r30, Y+6	; 0x06
    124e:	ff 81       	ldd	r31, Y+7	; 0x07
    1250:	91 83       	std	Z+1, r25	; 0x01
    1252:	80 83       	st	Z, r24
    1254:	06 c0       	rjmp	.+12     	; 0x1262 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1256:	8b 81       	ldd	r24, Y+3	; 0x03
    1258:	9c 81       	ldd	r25, Y+4	; 0x04
    125a:	ee 81       	ldd	r30, Y+6	; 0x06
    125c:	ff 81       	ldd	r31, Y+7	; 0x07
    125e:	91 83       	std	Z+1, r25	; 0x01
    1260:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1262:	ee 81       	ldd	r30, Y+6	; 0x06
    1264:	ff 81       	ldd	r31, Y+7	; 0x07
    1266:	89 81       	ldd	r24, Y+1	; 0x01
    1268:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    126a:	ee 81       	ldd	r30, Y+6	; 0x06
    126c:	ff 81       	ldd	r31, Y+7	; 0x07
    126e:	8a 81       	ldd	r24, Y+2	; 0x02
    1270:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1272:	8e 81       	ldd	r24, Y+6	; 0x06
    1274:	9f 81       	ldd	r25, Y+7	; 0x07
    1276:	61 e0       	ldi	r22, 0x01	; 1
    1278:	0e 94 3b 08 	call	0x1076	; 0x1076 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    127c:	27 96       	adiw	r28, 0x07	; 7
    127e:	0f b6       	in	r0, 0x3f	; 63
    1280:	f8 94       	cli
    1282:	de bf       	out	0x3e, r29	; 62
    1284:	0f be       	out	0x3f, r0	; 63
    1286:	cd bf       	out	0x3d, r28	; 61
    1288:	cf 91       	pop	r28
    128a:	df 91       	pop	r29
    128c:	1f 91       	pop	r17
    128e:	0f 91       	pop	r16
    1290:	08 95       	ret

00001292 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1292:	df 93       	push	r29
    1294:	cf 93       	push	r28
    1296:	cd b7       	in	r28, 0x3d	; 61
    1298:	de b7       	in	r29, 0x3e	; 62
    129a:	2f 97       	sbiw	r28, 0x0f	; 15
    129c:	0f b6       	in	r0, 0x3f	; 63
    129e:	f8 94       	cli
    12a0:	de bf       	out	0x3e, r29	; 62
    12a2:	0f be       	out	0x3f, r0	; 63
    12a4:	cd bf       	out	0x3d, r28	; 61
    12a6:	99 87       	std	Y+9, r25	; 0x09
    12a8:	88 87       	std	Y+8, r24	; 0x08
    12aa:	7b 87       	std	Y+11, r23	; 0x0b
    12ac:	6a 87       	std	Y+10, r22	; 0x0a
    12ae:	5d 87       	std	Y+13, r21	; 0x0d
    12b0:	4c 87       	std	Y+12, r20	; 0x0c
    12b2:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    12b4:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    12b6:	88 85       	ldd	r24, Y+8	; 0x08
    12b8:	99 85       	ldd	r25, Y+9	; 0x09
    12ba:	9a 83       	std	Y+2, r25	; 0x02
    12bc:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    12be:	0f b6       	in	r0, 0x3f	; 63
    12c0:	f8 94       	cli
    12c2:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    12c4:	e9 81       	ldd	r30, Y+1	; 0x01
    12c6:	fa 81       	ldd	r31, Y+2	; 0x02
    12c8:	92 8d       	ldd	r25, Z+26	; 0x1a
    12ca:	e9 81       	ldd	r30, Y+1	; 0x01
    12cc:	fa 81       	ldd	r31, Y+2	; 0x02
    12ce:	83 8d       	ldd	r24, Z+27	; 0x1b
    12d0:	98 17       	cp	r25, r24
    12d2:	18 f0       	brcs	.+6      	; 0x12da <xQueueGenericSend+0x48>
    12d4:	8e 85       	ldd	r24, Y+14	; 0x0e
    12d6:	82 30       	cpi	r24, 0x02	; 2
    12d8:	c1 f4       	brne	.+48     	; 0x130a <xQueueGenericSend+0x78>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    12da:	89 81       	ldd	r24, Y+1	; 0x01
    12dc:	9a 81       	ldd	r25, Y+2	; 0x02
    12de:	2a 85       	ldd	r18, Y+10	; 0x0a
    12e0:	3b 85       	ldd	r19, Y+11	; 0x0b
    12e2:	b9 01       	movw	r22, r18
    12e4:	4e 85       	ldd	r20, Y+14	; 0x0e
    12e6:	0e 94 85 0d 	call	0x1b0a	; 0x1b0a <prvCopyDataToQueue>
    12ea:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12ec:	e9 81       	ldd	r30, Y+1	; 0x01
    12ee:	fa 81       	ldd	r31, Y+2	; 0x02
    12f0:	81 89       	ldd	r24, Z+17	; 0x11
    12f2:	88 23       	and	r24, r24
    12f4:	29 f0       	breq	.+10     	; 0x1300 <xQueueGenericSend+0x6e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12f6:	89 81       	ldd	r24, Y+1	; 0x01
    12f8:	9a 81       	ldd	r25, Y+2	; 0x02
    12fa:	41 96       	adiw	r24, 0x11	; 17
    12fc:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <xTaskRemoveFromEventList>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1300:	0f 90       	pop	r0
    1302:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1304:	81 e0       	ldi	r24, 0x01	; 1
    1306:	8f 87       	std	Y+15, r24	; 0x0f
    1308:	5c c0       	rjmp	.+184    	; 0x13c2 <xQueueGenericSend+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    130a:	8c 85       	ldd	r24, Y+12	; 0x0c
    130c:	9d 85       	ldd	r25, Y+13	; 0x0d
    130e:	00 97       	sbiw	r24, 0x00	; 0
    1310:	21 f4       	brne	.+8      	; 0x131a <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1312:	0f 90       	pop	r0
    1314:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1316:	1f 86       	std	Y+15, r1	; 0x0f
    1318:	54 c0       	rjmp	.+168    	; 0x13c2 <xQueueGenericSend+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    131a:	8c 81       	ldd	r24, Y+4	; 0x04
    131c:	88 23       	and	r24, r24
    131e:	31 f4       	brne	.+12     	; 0x132c <xQueueGenericSend+0x9a>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1320:	ce 01       	movw	r24, r28
    1322:	05 96       	adiw	r24, 0x05	; 5
    1324:	0e 94 0e 1e 	call	0x3c1c	; 0x3c1c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1328:	81 e0       	ldi	r24, 0x01	; 1
    132a:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    132c:	0f 90       	pop	r0
    132e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1330:	0e 94 b8 1a 	call	0x3570	; 0x3570 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1334:	0f b6       	in	r0, 0x3f	; 63
    1336:	f8 94       	cli
    1338:	0f 92       	push	r0
    133a:	e9 81       	ldd	r30, Y+1	; 0x01
    133c:	fa 81       	ldd	r31, Y+2	; 0x02
    133e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1340:	8f 3f       	cpi	r24, 0xFF	; 255
    1342:	19 f4       	brne	.+6      	; 0x134a <xQueueGenericSend+0xb8>
    1344:	e9 81       	ldd	r30, Y+1	; 0x01
    1346:	fa 81       	ldd	r31, Y+2	; 0x02
    1348:	15 8e       	std	Z+29, r1	; 0x1d
    134a:	e9 81       	ldd	r30, Y+1	; 0x01
    134c:	fa 81       	ldd	r31, Y+2	; 0x02
    134e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1350:	8f 3f       	cpi	r24, 0xFF	; 255
    1352:	19 f4       	brne	.+6      	; 0x135a <xQueueGenericSend+0xc8>
    1354:	e9 81       	ldd	r30, Y+1	; 0x01
    1356:	fa 81       	ldd	r31, Y+2	; 0x02
    1358:	16 8e       	std	Z+30, r1	; 0x1e
    135a:	0f 90       	pop	r0
    135c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    135e:	ce 01       	movw	r24, r28
    1360:	05 96       	adiw	r24, 0x05	; 5
    1362:	9e 01       	movw	r18, r28
    1364:	24 5f       	subi	r18, 0xF4	; 244
    1366:	3f 4f       	sbci	r19, 0xFF	; 255
    1368:	b9 01       	movw	r22, r18
    136a:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <xTaskCheckForTimeOut>
    136e:	88 23       	and	r24, r24
    1370:	09 f5       	brne	.+66     	; 0x13b4 <xQueueGenericSend+0x122>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1372:	89 81       	ldd	r24, Y+1	; 0x01
    1374:	9a 81       	ldd	r25, Y+2	; 0x02
    1376:	0e 94 01 0f 	call	0x1e02	; 0x1e02 <prvIsQueueFull>
    137a:	88 23       	and	r24, r24
    137c:	a1 f0       	breq	.+40     	; 0x13a6 <xQueueGenericSend+0x114>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    137e:	89 81       	ldd	r24, Y+1	; 0x01
    1380:	9a 81       	ldd	r25, Y+2	; 0x02
    1382:	08 96       	adiw	r24, 0x08	; 8
    1384:	2c 85       	ldd	r18, Y+12	; 0x0c
    1386:	3d 85       	ldd	r19, Y+13	; 0x0d
    1388:	b9 01       	movw	r22, r18
    138a:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    138e:	89 81       	ldd	r24, Y+1	; 0x01
    1390:	9a 81       	ldd	r25, Y+2	; 0x02
    1392:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1396:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>
    139a:	88 23       	and	r24, r24
    139c:	09 f0       	breq	.+2      	; 0x13a0 <xQueueGenericSend+0x10e>
    139e:	8f cf       	rjmp	.-226    	; 0x12be <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    13a0:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    13a4:	8c cf       	rjmp	.-232    	; 0x12be <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    13a6:	89 81       	ldd	r24, Y+1	; 0x01
    13a8:	9a 81       	ldd	r25, Y+2	; 0x02
    13aa:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    13ae:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>
    13b2:	85 cf       	rjmp	.-246    	; 0x12be <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    13b4:	89 81       	ldd	r24, Y+1	; 0x01
    13b6:	9a 81       	ldd	r25, Y+2	; 0x02
    13b8:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    13bc:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    13c0:	1f 86       	std	Y+15, r1	; 0x0f
    13c2:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    13c4:	2f 96       	adiw	r28, 0x0f	; 15
    13c6:	0f b6       	in	r0, 0x3f	; 63
    13c8:	f8 94       	cli
    13ca:	de bf       	out	0x3e, r29	; 62
    13cc:	0f be       	out	0x3f, r0	; 63
    13ce:	cd bf       	out	0x3d, r28	; 61
    13d0:	cf 91       	pop	r28
    13d2:	df 91       	pop	r29
    13d4:	08 95       	ret

000013d6 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    13d6:	df 93       	push	r29
    13d8:	cf 93       	push	r28
    13da:	cd b7       	in	r28, 0x3d	; 61
    13dc:	de b7       	in	r29, 0x3e	; 62
    13de:	2c 97       	sbiw	r28, 0x0c	; 12
    13e0:	0f b6       	in	r0, 0x3f	; 63
    13e2:	f8 94       	cli
    13e4:	de bf       	out	0x3e, r29	; 62
    13e6:	0f be       	out	0x3f, r0	; 63
    13e8:	cd bf       	out	0x3d, r28	; 61
    13ea:	9f 83       	std	Y+7, r25	; 0x07
    13ec:	8e 83       	std	Y+6, r24	; 0x06
    13ee:	79 87       	std	Y+9, r23	; 0x09
    13f0:	68 87       	std	Y+8, r22	; 0x08
    13f2:	5b 87       	std	Y+11, r21	; 0x0b
    13f4:	4a 87       	std	Y+10, r20	; 0x0a
    13f6:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    13f8:	8e 81       	ldd	r24, Y+6	; 0x06
    13fa:	9f 81       	ldd	r25, Y+7	; 0x07
    13fc:	9b 83       	std	Y+3, r25	; 0x03
    13fe:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1400:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1402:	ea 81       	ldd	r30, Y+2	; 0x02
    1404:	fb 81       	ldd	r31, Y+3	; 0x03
    1406:	92 8d       	ldd	r25, Z+26	; 0x1a
    1408:	ea 81       	ldd	r30, Y+2	; 0x02
    140a:	fb 81       	ldd	r31, Y+3	; 0x03
    140c:	83 8d       	ldd	r24, Z+27	; 0x1b
    140e:	98 17       	cp	r25, r24
    1410:	18 f0       	brcs	.+6      	; 0x1418 <xQueueGenericSendFromISR+0x42>
    1412:	8c 85       	ldd	r24, Y+12	; 0x0c
    1414:	82 30       	cpi	r24, 0x02	; 2
    1416:	61 f5       	brne	.+88     	; 0x1470 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1418:	ea 81       	ldd	r30, Y+2	; 0x02
    141a:	fb 81       	ldd	r31, Y+3	; 0x03
    141c:	86 8d       	ldd	r24, Z+30	; 0x1e
    141e:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1420:	8a 81       	ldd	r24, Y+2	; 0x02
    1422:	9b 81       	ldd	r25, Y+3	; 0x03
    1424:	28 85       	ldd	r18, Y+8	; 0x08
    1426:	39 85       	ldd	r19, Y+9	; 0x09
    1428:	b9 01       	movw	r22, r18
    142a:	4c 85       	ldd	r20, Y+12	; 0x0c
    142c:	0e 94 85 0d 	call	0x1b0a	; 0x1b0a <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1430:	89 81       	ldd	r24, Y+1	; 0x01
    1432:	8f 3f       	cpi	r24, 0xFF	; 255
    1434:	a9 f4       	brne	.+42     	; 0x1460 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1436:	ea 81       	ldd	r30, Y+2	; 0x02
    1438:	fb 81       	ldd	r31, Y+3	; 0x03
    143a:	81 89       	ldd	r24, Z+17	; 0x11
    143c:	88 23       	and	r24, r24
    143e:	a9 f0       	breq	.+42     	; 0x146a <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1440:	8a 81       	ldd	r24, Y+2	; 0x02
    1442:	9b 81       	ldd	r25, Y+3	; 0x03
    1444:	41 96       	adiw	r24, 0x11	; 17
    1446:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <xTaskRemoveFromEventList>
    144a:	88 23       	and	r24, r24
    144c:	71 f0       	breq	.+28     	; 0x146a <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    144e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1450:	9b 85       	ldd	r25, Y+11	; 0x0b
    1452:	00 97       	sbiw	r24, 0x00	; 0
    1454:	51 f0       	breq	.+20     	; 0x146a <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1456:	ea 85       	ldd	r30, Y+10	; 0x0a
    1458:	fb 85       	ldd	r31, Y+11	; 0x0b
    145a:	81 e0       	ldi	r24, 0x01	; 1
    145c:	80 83       	st	Z, r24
    145e:	05 c0       	rjmp	.+10     	; 0x146a <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1460:	89 81       	ldd	r24, Y+1	; 0x01
    1462:	8f 5f       	subi	r24, 0xFF	; 255
    1464:	ea 81       	ldd	r30, Y+2	; 0x02
    1466:	fb 81       	ldd	r31, Y+3	; 0x03
    1468:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    146a:	81 e0       	ldi	r24, 0x01	; 1
    146c:	8d 83       	std	Y+5, r24	; 0x05
    146e:	01 c0       	rjmp	.+2      	; 0x1472 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1470:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1472:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1474:	2c 96       	adiw	r28, 0x0c	; 12
    1476:	0f b6       	in	r0, 0x3f	; 63
    1478:	f8 94       	cli
    147a:	de bf       	out	0x3e, r29	; 62
    147c:	0f be       	out	0x3f, r0	; 63
    147e:	cd bf       	out	0x3d, r28	; 61
    1480:	cf 91       	pop	r28
    1482:	df 91       	pop	r29
    1484:	08 95       	ret

00001486 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1486:	df 93       	push	r29
    1488:	cf 93       	push	r28
    148a:	cd b7       	in	r28, 0x3d	; 61
    148c:	de b7       	in	r29, 0x3e	; 62
    148e:	2a 97       	sbiw	r28, 0x0a	; 10
    1490:	0f b6       	in	r0, 0x3f	; 63
    1492:	f8 94       	cli
    1494:	de bf       	out	0x3e, r29	; 62
    1496:	0f be       	out	0x3f, r0	; 63
    1498:	cd bf       	out	0x3d, r28	; 61
    149a:	98 87       	std	Y+8, r25	; 0x08
    149c:	8f 83       	std	Y+7, r24	; 0x07
    149e:	7a 87       	std	Y+10, r23	; 0x0a
    14a0:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    14a2:	8f 81       	ldd	r24, Y+7	; 0x07
    14a4:	98 85       	ldd	r25, Y+8	; 0x08
    14a6:	9c 83       	std	Y+4, r25	; 0x04
    14a8:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    14aa:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    14ac:	eb 81       	ldd	r30, Y+3	; 0x03
    14ae:	fc 81       	ldd	r31, Y+4	; 0x04
    14b0:	82 8d       	ldd	r24, Z+26	; 0x1a
    14b2:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    14b4:	eb 81       	ldd	r30, Y+3	; 0x03
    14b6:	fc 81       	ldd	r31, Y+4	; 0x04
    14b8:	93 8d       	ldd	r25, Z+27	; 0x1b
    14ba:	8a 81       	ldd	r24, Y+2	; 0x02
    14bc:	89 17       	cp	r24, r25
    14be:	48 f5       	brcc	.+82     	; 0x1512 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    14c0:	eb 81       	ldd	r30, Y+3	; 0x03
    14c2:	fc 81       	ldd	r31, Y+4	; 0x04
    14c4:	86 8d       	ldd	r24, Z+30	; 0x1e
    14c6:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    14c8:	8a 81       	ldd	r24, Y+2	; 0x02
    14ca:	8f 5f       	subi	r24, 0xFF	; 255
    14cc:	eb 81       	ldd	r30, Y+3	; 0x03
    14ce:	fc 81       	ldd	r31, Y+4	; 0x04
    14d0:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    14d2:	89 81       	ldd	r24, Y+1	; 0x01
    14d4:	8f 3f       	cpi	r24, 0xFF	; 255
    14d6:	a9 f4       	brne	.+42     	; 0x1502 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14d8:	eb 81       	ldd	r30, Y+3	; 0x03
    14da:	fc 81       	ldd	r31, Y+4	; 0x04
    14dc:	81 89       	ldd	r24, Z+17	; 0x11
    14de:	88 23       	and	r24, r24
    14e0:	a9 f0       	breq	.+42     	; 0x150c <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14e2:	8b 81       	ldd	r24, Y+3	; 0x03
    14e4:	9c 81       	ldd	r25, Y+4	; 0x04
    14e6:	41 96       	adiw	r24, 0x11	; 17
    14e8:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <xTaskRemoveFromEventList>
    14ec:	88 23       	and	r24, r24
    14ee:	71 f0       	breq	.+28     	; 0x150c <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    14f0:	89 85       	ldd	r24, Y+9	; 0x09
    14f2:	9a 85       	ldd	r25, Y+10	; 0x0a
    14f4:	00 97       	sbiw	r24, 0x00	; 0
    14f6:	51 f0       	breq	.+20     	; 0x150c <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    14f8:	e9 85       	ldd	r30, Y+9	; 0x09
    14fa:	fa 85       	ldd	r31, Y+10	; 0x0a
    14fc:	81 e0       	ldi	r24, 0x01	; 1
    14fe:	80 83       	st	Z, r24
    1500:	05 c0       	rjmp	.+10     	; 0x150c <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1502:	89 81       	ldd	r24, Y+1	; 0x01
    1504:	8f 5f       	subi	r24, 0xFF	; 255
    1506:	eb 81       	ldd	r30, Y+3	; 0x03
    1508:	fc 81       	ldd	r31, Y+4	; 0x04
    150a:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    150c:	81 e0       	ldi	r24, 0x01	; 1
    150e:	8e 83       	std	Y+6, r24	; 0x06
    1510:	01 c0       	rjmp	.+2      	; 0x1514 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1512:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1514:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1516:	2a 96       	adiw	r28, 0x0a	; 10
    1518:	0f b6       	in	r0, 0x3f	; 63
    151a:	f8 94       	cli
    151c:	de bf       	out	0x3e, r29	; 62
    151e:	0f be       	out	0x3f, r0	; 63
    1520:	cd bf       	out	0x3d, r28	; 61
    1522:	cf 91       	pop	r28
    1524:	df 91       	pop	r29
    1526:	08 95       	ret

00001528 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1528:	df 93       	push	r29
    152a:	cf 93       	push	r28
    152c:	cd b7       	in	r28, 0x3d	; 61
    152e:	de b7       	in	r29, 0x3e	; 62
    1530:	2e 97       	sbiw	r28, 0x0e	; 14
    1532:	0f b6       	in	r0, 0x3f	; 63
    1534:	f8 94       	cli
    1536:	de bf       	out	0x3e, r29	; 62
    1538:	0f be       	out	0x3f, r0	; 63
    153a:	cd bf       	out	0x3d, r28	; 61
    153c:	99 87       	std	Y+9, r25	; 0x09
    153e:	88 87       	std	Y+8, r24	; 0x08
    1540:	7b 87       	std	Y+11, r23	; 0x0b
    1542:	6a 87       	std	Y+10, r22	; 0x0a
    1544:	5d 87       	std	Y+13, r21	; 0x0d
    1546:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    1548:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    154a:	88 85       	ldd	r24, Y+8	; 0x08
    154c:	99 85       	ldd	r25, Y+9	; 0x09
    154e:	9b 83       	std	Y+3, r25	; 0x03
    1550:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1552:	0f b6       	in	r0, 0x3f	; 63
    1554:	f8 94       	cli
    1556:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1558:	ea 81       	ldd	r30, Y+2	; 0x02
    155a:	fb 81       	ldd	r31, Y+3	; 0x03
    155c:	82 8d       	ldd	r24, Z+26	; 0x1a
    155e:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1560:	89 81       	ldd	r24, Y+1	; 0x01
    1562:	88 23       	and	r24, r24
    1564:	d9 f0       	breq	.+54     	; 0x159c <xQueueReceive+0x74>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1566:	8a 81       	ldd	r24, Y+2	; 0x02
    1568:	9b 81       	ldd	r25, Y+3	; 0x03
    156a:	2a 85       	ldd	r18, Y+10	; 0x0a
    156c:	3b 85       	ldd	r19, Y+11	; 0x0b
    156e:	b9 01       	movw	r22, r18
    1570:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1574:	89 81       	ldd	r24, Y+1	; 0x01
    1576:	81 50       	subi	r24, 0x01	; 1
    1578:	ea 81       	ldd	r30, Y+2	; 0x02
    157a:	fb 81       	ldd	r31, Y+3	; 0x03
    157c:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    157e:	ea 81       	ldd	r30, Y+2	; 0x02
    1580:	fb 81       	ldd	r31, Y+3	; 0x03
    1582:	80 85       	ldd	r24, Z+8	; 0x08
    1584:	88 23       	and	r24, r24
    1586:	29 f0       	breq	.+10     	; 0x1592 <xQueueReceive+0x6a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1588:	8a 81       	ldd	r24, Y+2	; 0x02
    158a:	9b 81       	ldd	r25, Y+3	; 0x03
    158c:	08 96       	adiw	r24, 0x08	; 8
    158e:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <xTaskRemoveFromEventList>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1592:	0f 90       	pop	r0
    1594:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1596:	81 e0       	ldi	r24, 0x01	; 1
    1598:	8e 87       	std	Y+14, r24	; 0x0e
    159a:	63 c0       	rjmp	.+198    	; 0x1662 <xQueueReceive+0x13a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    159c:	8c 85       	ldd	r24, Y+12	; 0x0c
    159e:	9d 85       	ldd	r25, Y+13	; 0x0d
    15a0:	00 97       	sbiw	r24, 0x00	; 0
    15a2:	21 f4       	brne	.+8      	; 0x15ac <xQueueReceive+0x84>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    15a4:	0f 90       	pop	r0
    15a6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    15a8:	1e 86       	std	Y+14, r1	; 0x0e
    15aa:	5b c0       	rjmp	.+182    	; 0x1662 <xQueueReceive+0x13a>
				}
				else if( xEntryTimeSet == pdFALSE )
    15ac:	8c 81       	ldd	r24, Y+4	; 0x04
    15ae:	88 23       	and	r24, r24
    15b0:	31 f4       	brne	.+12     	; 0x15be <xQueueReceive+0x96>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    15b2:	ce 01       	movw	r24, r28
    15b4:	05 96       	adiw	r24, 0x05	; 5
    15b6:	0e 94 0e 1e 	call	0x3c1c	; 0x3c1c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    15ba:	81 e0       	ldi	r24, 0x01	; 1
    15bc:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    15be:	0f 90       	pop	r0
    15c0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    15c2:	0e 94 b8 1a 	call	0x3570	; 0x3570 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    15c6:	0f b6       	in	r0, 0x3f	; 63
    15c8:	f8 94       	cli
    15ca:	0f 92       	push	r0
    15cc:	ea 81       	ldd	r30, Y+2	; 0x02
    15ce:	fb 81       	ldd	r31, Y+3	; 0x03
    15d0:	85 8d       	ldd	r24, Z+29	; 0x1d
    15d2:	8f 3f       	cpi	r24, 0xFF	; 255
    15d4:	19 f4       	brne	.+6      	; 0x15dc <xQueueReceive+0xb4>
    15d6:	ea 81       	ldd	r30, Y+2	; 0x02
    15d8:	fb 81       	ldd	r31, Y+3	; 0x03
    15da:	15 8e       	std	Z+29, r1	; 0x1d
    15dc:	ea 81       	ldd	r30, Y+2	; 0x02
    15de:	fb 81       	ldd	r31, Y+3	; 0x03
    15e0:	86 8d       	ldd	r24, Z+30	; 0x1e
    15e2:	8f 3f       	cpi	r24, 0xFF	; 255
    15e4:	19 f4       	brne	.+6      	; 0x15ec <xQueueReceive+0xc4>
    15e6:	ea 81       	ldd	r30, Y+2	; 0x02
    15e8:	fb 81       	ldd	r31, Y+3	; 0x03
    15ea:	16 8e       	std	Z+30, r1	; 0x1e
    15ec:	0f 90       	pop	r0
    15ee:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    15f0:	ce 01       	movw	r24, r28
    15f2:	05 96       	adiw	r24, 0x05	; 5
    15f4:	9e 01       	movw	r18, r28
    15f6:	24 5f       	subi	r18, 0xF4	; 244
    15f8:	3f 4f       	sbci	r19, 0xFF	; 255
    15fa:	b9 01       	movw	r22, r18
    15fc:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <xTaskCheckForTimeOut>
    1600:	88 23       	and	r24, r24
    1602:	09 f5       	brne	.+66     	; 0x1646 <xQueueReceive+0x11e>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1604:	8a 81       	ldd	r24, Y+2	; 0x02
    1606:	9b 81       	ldd	r25, Y+3	; 0x03
    1608:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <prvIsQueueEmpty>
    160c:	88 23       	and	r24, r24
    160e:	a1 f0       	breq	.+40     	; 0x1638 <xQueueReceive+0x110>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1610:	8a 81       	ldd	r24, Y+2	; 0x02
    1612:	9b 81       	ldd	r25, Y+3	; 0x03
    1614:	41 96       	adiw	r24, 0x11	; 17
    1616:	2c 85       	ldd	r18, Y+12	; 0x0c
    1618:	3d 85       	ldd	r19, Y+13	; 0x0d
    161a:	b9 01       	movw	r22, r18
    161c:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1620:	8a 81       	ldd	r24, Y+2	; 0x02
    1622:	9b 81       	ldd	r25, Y+3	; 0x03
    1624:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1628:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>
    162c:	88 23       	and	r24, r24
    162e:	09 f0       	breq	.+2      	; 0x1632 <xQueueReceive+0x10a>
    1630:	90 cf       	rjmp	.-224    	; 0x1552 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    1632:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    1636:	8d cf       	rjmp	.-230    	; 0x1552 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1638:	8a 81       	ldd	r24, Y+2	; 0x02
    163a:	9b 81       	ldd	r25, Y+3	; 0x03
    163c:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1640:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>
    1644:	86 cf       	rjmp	.-244    	; 0x1552 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1646:	8a 81       	ldd	r24, Y+2	; 0x02
    1648:	9b 81       	ldd	r25, Y+3	; 0x03
    164a:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    164e:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1652:	8a 81       	ldd	r24, Y+2	; 0x02
    1654:	9b 81       	ldd	r25, Y+3	; 0x03
    1656:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <prvIsQueueEmpty>
    165a:	88 23       	and	r24, r24
    165c:	09 f4       	brne	.+2      	; 0x1660 <xQueueReceive+0x138>
    165e:	79 cf       	rjmp	.-270    	; 0x1552 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1660:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1662:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    1664:	2e 96       	adiw	r28, 0x0e	; 14
    1666:	0f b6       	in	r0, 0x3f	; 63
    1668:	f8 94       	cli
    166a:	de bf       	out	0x3e, r29	; 62
    166c:	0f be       	out	0x3f, r0	; 63
    166e:	cd bf       	out	0x3d, r28	; 61
    1670:	cf 91       	pop	r28
    1672:	df 91       	pop	r29
    1674:	08 95       	ret

00001676 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1676:	df 93       	push	r29
    1678:	cf 93       	push	r28
    167a:	cd b7       	in	r28, 0x3d	; 61
    167c:	de b7       	in	r29, 0x3e	; 62
    167e:	2c 97       	sbiw	r28, 0x0c	; 12
    1680:	0f b6       	in	r0, 0x3f	; 63
    1682:	f8 94       	cli
    1684:	de bf       	out	0x3e, r29	; 62
    1686:	0f be       	out	0x3f, r0	; 63
    1688:	cd bf       	out	0x3d, r28	; 61
    168a:	99 87       	std	Y+9, r25	; 0x09
    168c:	88 87       	std	Y+8, r24	; 0x08
    168e:	7b 87       	std	Y+11, r23	; 0x0b
    1690:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    1692:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1694:	88 85       	ldd	r24, Y+8	; 0x08
    1696:	99 85       	ldd	r25, Y+9	; 0x09
    1698:	9b 83       	std	Y+3, r25	; 0x03
    169a:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    169c:	0f b6       	in	r0, 0x3f	; 63
    169e:	f8 94       	cli
    16a0:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    16a2:	ea 81       	ldd	r30, Y+2	; 0x02
    16a4:	fb 81       	ldd	r31, Y+3	; 0x03
    16a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    16a8:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    16aa:	89 81       	ldd	r24, Y+1	; 0x01
    16ac:	88 23       	and	r24, r24
    16ae:	a1 f0       	breq	.+40     	; 0x16d8 <xQueueSemaphoreTake+0x62>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    16b0:	89 81       	ldd	r24, Y+1	; 0x01
    16b2:	81 50       	subi	r24, 0x01	; 1
    16b4:	ea 81       	ldd	r30, Y+2	; 0x02
    16b6:	fb 81       	ldd	r31, Y+3	; 0x03
    16b8:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16ba:	ea 81       	ldd	r30, Y+2	; 0x02
    16bc:	fb 81       	ldd	r31, Y+3	; 0x03
    16be:	80 85       	ldd	r24, Z+8	; 0x08
    16c0:	88 23       	and	r24, r24
    16c2:	29 f0       	breq	.+10     	; 0x16ce <xQueueSemaphoreTake+0x58>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16c4:	8a 81       	ldd	r24, Y+2	; 0x02
    16c6:	9b 81       	ldd	r25, Y+3	; 0x03
    16c8:	08 96       	adiw	r24, 0x08	; 8
    16ca:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <xTaskRemoveFromEventList>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    16ce:	0f 90       	pop	r0
    16d0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    16d2:	81 e0       	ldi	r24, 0x01	; 1
    16d4:	8c 87       	std	Y+12, r24	; 0x0c
    16d6:	63 c0       	rjmp	.+198    	; 0x179e <xQueueSemaphoreTake+0x128>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    16d8:	8a 85       	ldd	r24, Y+10	; 0x0a
    16da:	9b 85       	ldd	r25, Y+11	; 0x0b
    16dc:	00 97       	sbiw	r24, 0x00	; 0
    16de:	21 f4       	brne	.+8      	; 0x16e8 <xQueueSemaphoreTake+0x72>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    16e0:	0f 90       	pop	r0
    16e2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    16e4:	1c 86       	std	Y+12, r1	; 0x0c
    16e6:	5b c0       	rjmp	.+182    	; 0x179e <xQueueSemaphoreTake+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    16e8:	8c 81       	ldd	r24, Y+4	; 0x04
    16ea:	88 23       	and	r24, r24
    16ec:	31 f4       	brne	.+12     	; 0x16fa <xQueueSemaphoreTake+0x84>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    16ee:	ce 01       	movw	r24, r28
    16f0:	05 96       	adiw	r24, 0x05	; 5
    16f2:	0e 94 0e 1e 	call	0x3c1c	; 0x3c1c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    16f6:	81 e0       	ldi	r24, 0x01	; 1
    16f8:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    16fa:	0f 90       	pop	r0
    16fc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    16fe:	0e 94 b8 1a 	call	0x3570	; 0x3570 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1702:	0f b6       	in	r0, 0x3f	; 63
    1704:	f8 94       	cli
    1706:	0f 92       	push	r0
    1708:	ea 81       	ldd	r30, Y+2	; 0x02
    170a:	fb 81       	ldd	r31, Y+3	; 0x03
    170c:	85 8d       	ldd	r24, Z+29	; 0x1d
    170e:	8f 3f       	cpi	r24, 0xFF	; 255
    1710:	19 f4       	brne	.+6      	; 0x1718 <xQueueSemaphoreTake+0xa2>
    1712:	ea 81       	ldd	r30, Y+2	; 0x02
    1714:	fb 81       	ldd	r31, Y+3	; 0x03
    1716:	15 8e       	std	Z+29, r1	; 0x1d
    1718:	ea 81       	ldd	r30, Y+2	; 0x02
    171a:	fb 81       	ldd	r31, Y+3	; 0x03
    171c:	86 8d       	ldd	r24, Z+30	; 0x1e
    171e:	8f 3f       	cpi	r24, 0xFF	; 255
    1720:	19 f4       	brne	.+6      	; 0x1728 <xQueueSemaphoreTake+0xb2>
    1722:	ea 81       	ldd	r30, Y+2	; 0x02
    1724:	fb 81       	ldd	r31, Y+3	; 0x03
    1726:	16 8e       	std	Z+30, r1	; 0x1e
    1728:	0f 90       	pop	r0
    172a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    172c:	ce 01       	movw	r24, r28
    172e:	05 96       	adiw	r24, 0x05	; 5
    1730:	9e 01       	movw	r18, r28
    1732:	26 5f       	subi	r18, 0xF6	; 246
    1734:	3f 4f       	sbci	r19, 0xFF	; 255
    1736:	b9 01       	movw	r22, r18
    1738:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <xTaskCheckForTimeOut>
    173c:	88 23       	and	r24, r24
    173e:	09 f5       	brne	.+66     	; 0x1782 <xQueueSemaphoreTake+0x10c>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1740:	8a 81       	ldd	r24, Y+2	; 0x02
    1742:	9b 81       	ldd	r25, Y+3	; 0x03
    1744:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <prvIsQueueEmpty>
    1748:	88 23       	and	r24, r24
    174a:	a1 f0       	breq	.+40     	; 0x1774 <xQueueSemaphoreTake+0xfe>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    174c:	8a 81       	ldd	r24, Y+2	; 0x02
    174e:	9b 81       	ldd	r25, Y+3	; 0x03
    1750:	41 96       	adiw	r24, 0x11	; 17
    1752:	2a 85       	ldd	r18, Y+10	; 0x0a
    1754:	3b 85       	ldd	r19, Y+11	; 0x0b
    1756:	b9 01       	movw	r22, r18
    1758:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    175c:	8a 81       	ldd	r24, Y+2	; 0x02
    175e:	9b 81       	ldd	r25, Y+3	; 0x03
    1760:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1764:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>
    1768:	88 23       	and	r24, r24
    176a:	09 f0       	breq	.+2      	; 0x176e <xQueueSemaphoreTake+0xf8>
    176c:	97 cf       	rjmp	.-210    	; 0x169c <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    176e:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    1772:	94 cf       	rjmp	.-216    	; 0x169c <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1774:	8a 81       	ldd	r24, Y+2	; 0x02
    1776:	9b 81       	ldd	r25, Y+3	; 0x03
    1778:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    177c:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>
    1780:	8d cf       	rjmp	.-230    	; 0x169c <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1782:	8a 81       	ldd	r24, Y+2	; 0x02
    1784:	9b 81       	ldd	r25, Y+3	; 0x03
    1786:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    178a:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    178e:	8a 81       	ldd	r24, Y+2	; 0x02
    1790:	9b 81       	ldd	r25, Y+3	; 0x03
    1792:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <prvIsQueueEmpty>
    1796:	88 23       	and	r24, r24
    1798:	09 f4       	brne	.+2      	; 0x179c <xQueueSemaphoreTake+0x126>
    179a:	80 cf       	rjmp	.-256    	; 0x169c <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    179c:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    179e:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    17a0:	2c 96       	adiw	r28, 0x0c	; 12
    17a2:	0f b6       	in	r0, 0x3f	; 63
    17a4:	f8 94       	cli
    17a6:	de bf       	out	0x3e, r29	; 62
    17a8:	0f be       	out	0x3f, r0	; 63
    17aa:	cd bf       	out	0x3d, r28	; 61
    17ac:	cf 91       	pop	r28
    17ae:	df 91       	pop	r29
    17b0:	08 95       	ret

000017b2 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    17b2:	df 93       	push	r29
    17b4:	cf 93       	push	r28
    17b6:	cd b7       	in	r28, 0x3d	; 61
    17b8:	de b7       	in	r29, 0x3e	; 62
    17ba:	60 97       	sbiw	r28, 0x10	; 16
    17bc:	0f b6       	in	r0, 0x3f	; 63
    17be:	f8 94       	cli
    17c0:	de bf       	out	0x3e, r29	; 62
    17c2:	0f be       	out	0x3f, r0	; 63
    17c4:	cd bf       	out	0x3d, r28	; 61
    17c6:	9b 87       	std	Y+11, r25	; 0x0b
    17c8:	8a 87       	std	Y+10, r24	; 0x0a
    17ca:	7d 87       	std	Y+13, r23	; 0x0d
    17cc:	6c 87       	std	Y+12, r22	; 0x0c
    17ce:	5f 87       	std	Y+15, r21	; 0x0f
    17d0:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    17d2:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    17d4:	8a 85       	ldd	r24, Y+10	; 0x0a
    17d6:	9b 85       	ldd	r25, Y+11	; 0x0b
    17d8:	9b 83       	std	Y+3, r25	; 0x03
    17da:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    17dc:	0f b6       	in	r0, 0x3f	; 63
    17de:	f8 94       	cli
    17e0:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    17e2:	ea 81       	ldd	r30, Y+2	; 0x02
    17e4:	fb 81       	ldd	r31, Y+3	; 0x03
    17e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    17e8:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    17ea:	89 81       	ldd	r24, Y+1	; 0x01
    17ec:	88 23       	and	r24, r24
    17ee:	11 f1       	breq	.+68     	; 0x1834 <xQueuePeek+0x82>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    17f0:	ea 81       	ldd	r30, Y+2	; 0x02
    17f2:	fb 81       	ldd	r31, Y+3	; 0x03
    17f4:	86 81       	ldd	r24, Z+6	; 0x06
    17f6:	97 81       	ldd	r25, Z+7	; 0x07
    17f8:	9d 83       	std	Y+5, r25	; 0x05
    17fa:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    17fc:	8a 81       	ldd	r24, Y+2	; 0x02
    17fe:	9b 81       	ldd	r25, Y+3	; 0x03
    1800:	2c 85       	ldd	r18, Y+12	; 0x0c
    1802:	3d 85       	ldd	r19, Y+13	; 0x0d
    1804:	b9 01       	movw	r22, r18
    1806:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    180a:	ea 81       	ldd	r30, Y+2	; 0x02
    180c:	fb 81       	ldd	r31, Y+3	; 0x03
    180e:	8c 81       	ldd	r24, Y+4	; 0x04
    1810:	9d 81       	ldd	r25, Y+5	; 0x05
    1812:	97 83       	std	Z+7, r25	; 0x07
    1814:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1816:	ea 81       	ldd	r30, Y+2	; 0x02
    1818:	fb 81       	ldd	r31, Y+3	; 0x03
    181a:	81 89       	ldd	r24, Z+17	; 0x11
    181c:	88 23       	and	r24, r24
    181e:	29 f0       	breq	.+10     	; 0x182a <xQueuePeek+0x78>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1820:	8a 81       	ldd	r24, Y+2	; 0x02
    1822:	9b 81       	ldd	r25, Y+3	; 0x03
    1824:	41 96       	adiw	r24, 0x11	; 17
    1826:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <xTaskRemoveFromEventList>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    182a:	0f 90       	pop	r0
    182c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    182e:	81 e0       	ldi	r24, 0x01	; 1
    1830:	88 8b       	std	Y+16, r24	; 0x10
    1832:	63 c0       	rjmp	.+198    	; 0x18fa <xQueuePeek+0x148>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1834:	8e 85       	ldd	r24, Y+14	; 0x0e
    1836:	9f 85       	ldd	r25, Y+15	; 0x0f
    1838:	00 97       	sbiw	r24, 0x00	; 0
    183a:	21 f4       	brne	.+8      	; 0x1844 <xQueuePeek+0x92>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    183c:	0f 90       	pop	r0
    183e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1840:	18 8a       	std	Y+16, r1	; 0x10
    1842:	5b c0       	rjmp	.+182    	; 0x18fa <xQueuePeek+0x148>
				}
				else if( xEntryTimeSet == pdFALSE )
    1844:	8e 81       	ldd	r24, Y+6	; 0x06
    1846:	88 23       	and	r24, r24
    1848:	31 f4       	brne	.+12     	; 0x1856 <xQueuePeek+0xa4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    184a:	ce 01       	movw	r24, r28
    184c:	07 96       	adiw	r24, 0x07	; 7
    184e:	0e 94 0e 1e 	call	0x3c1c	; 0x3c1c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1852:	81 e0       	ldi	r24, 0x01	; 1
    1854:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1856:	0f 90       	pop	r0
    1858:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    185a:	0e 94 b8 1a 	call	0x3570	; 0x3570 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    185e:	0f b6       	in	r0, 0x3f	; 63
    1860:	f8 94       	cli
    1862:	0f 92       	push	r0
    1864:	ea 81       	ldd	r30, Y+2	; 0x02
    1866:	fb 81       	ldd	r31, Y+3	; 0x03
    1868:	85 8d       	ldd	r24, Z+29	; 0x1d
    186a:	8f 3f       	cpi	r24, 0xFF	; 255
    186c:	19 f4       	brne	.+6      	; 0x1874 <xQueuePeek+0xc2>
    186e:	ea 81       	ldd	r30, Y+2	; 0x02
    1870:	fb 81       	ldd	r31, Y+3	; 0x03
    1872:	15 8e       	std	Z+29, r1	; 0x1d
    1874:	ea 81       	ldd	r30, Y+2	; 0x02
    1876:	fb 81       	ldd	r31, Y+3	; 0x03
    1878:	86 8d       	ldd	r24, Z+30	; 0x1e
    187a:	8f 3f       	cpi	r24, 0xFF	; 255
    187c:	19 f4       	brne	.+6      	; 0x1884 <xQueuePeek+0xd2>
    187e:	ea 81       	ldd	r30, Y+2	; 0x02
    1880:	fb 81       	ldd	r31, Y+3	; 0x03
    1882:	16 8e       	std	Z+30, r1	; 0x1e
    1884:	0f 90       	pop	r0
    1886:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1888:	ce 01       	movw	r24, r28
    188a:	07 96       	adiw	r24, 0x07	; 7
    188c:	9e 01       	movw	r18, r28
    188e:	22 5f       	subi	r18, 0xF2	; 242
    1890:	3f 4f       	sbci	r19, 0xFF	; 255
    1892:	b9 01       	movw	r22, r18
    1894:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <xTaskCheckForTimeOut>
    1898:	88 23       	and	r24, r24
    189a:	09 f5       	brne	.+66     	; 0x18de <xQueuePeek+0x12c>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    189c:	8a 81       	ldd	r24, Y+2	; 0x02
    189e:	9b 81       	ldd	r25, Y+3	; 0x03
    18a0:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <prvIsQueueEmpty>
    18a4:	88 23       	and	r24, r24
    18a6:	a1 f0       	breq	.+40     	; 0x18d0 <xQueuePeek+0x11e>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18a8:	8a 81       	ldd	r24, Y+2	; 0x02
    18aa:	9b 81       	ldd	r25, Y+3	; 0x03
    18ac:	41 96       	adiw	r24, 0x11	; 17
    18ae:	2e 85       	ldd	r18, Y+14	; 0x0e
    18b0:	3f 85       	ldd	r19, Y+15	; 0x0f
    18b2:	b9 01       	movw	r22, r18
    18b4:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    18b8:	8a 81       	ldd	r24, Y+2	; 0x02
    18ba:	9b 81       	ldd	r25, Y+3	; 0x03
    18bc:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    18c0:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>
    18c4:	88 23       	and	r24, r24
    18c6:	09 f0       	breq	.+2      	; 0x18ca <xQueuePeek+0x118>
    18c8:	89 cf       	rjmp	.-238    	; 0x17dc <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    18ca:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    18ce:	86 cf       	rjmp	.-244    	; 0x17dc <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    18d0:	8a 81       	ldd	r24, Y+2	; 0x02
    18d2:	9b 81       	ldd	r25, Y+3	; 0x03
    18d4:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18d8:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>
    18dc:	7f cf       	rjmp	.-258    	; 0x17dc <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    18de:	8a 81       	ldd	r24, Y+2	; 0x02
    18e0:	9b 81       	ldd	r25, Y+3	; 0x03
    18e2:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    18e6:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18ea:	8a 81       	ldd	r24, Y+2	; 0x02
    18ec:	9b 81       	ldd	r25, Y+3	; 0x03
    18ee:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <prvIsQueueEmpty>
    18f2:	88 23       	and	r24, r24
    18f4:	09 f4       	brne	.+2      	; 0x18f8 <xQueuePeek+0x146>
    18f6:	72 cf       	rjmp	.-284    	; 0x17dc <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    18f8:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    18fa:	88 89       	ldd	r24, Y+16	; 0x10
}
    18fc:	60 96       	adiw	r28, 0x10	; 16
    18fe:	0f b6       	in	r0, 0x3f	; 63
    1900:	f8 94       	cli
    1902:	de bf       	out	0x3e, r29	; 62
    1904:	0f be       	out	0x3f, r0	; 63
    1906:	cd bf       	out	0x3d, r28	; 61
    1908:	cf 91       	pop	r28
    190a:	df 91       	pop	r29
    190c:	08 95       	ret

0000190e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    190e:	df 93       	push	r29
    1910:	cf 93       	push	r28
    1912:	cd b7       	in	r28, 0x3d	; 61
    1914:	de b7       	in	r29, 0x3e	; 62
    1916:	2c 97       	sbiw	r28, 0x0c	; 12
    1918:	0f b6       	in	r0, 0x3f	; 63
    191a:	f8 94       	cli
    191c:	de bf       	out	0x3e, r29	; 62
    191e:	0f be       	out	0x3f, r0	; 63
    1920:	cd bf       	out	0x3d, r28	; 61
    1922:	98 87       	std	Y+8, r25	; 0x08
    1924:	8f 83       	std	Y+7, r24	; 0x07
    1926:	7a 87       	std	Y+10, r23	; 0x0a
    1928:	69 87       	std	Y+9, r22	; 0x09
    192a:	5c 87       	std	Y+12, r21	; 0x0c
    192c:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    192e:	8f 81       	ldd	r24, Y+7	; 0x07
    1930:	98 85       	ldd	r25, Y+8	; 0x08
    1932:	9c 83       	std	Y+4, r25	; 0x04
    1934:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1936:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1938:	eb 81       	ldd	r30, Y+3	; 0x03
    193a:	fc 81       	ldd	r31, Y+4	; 0x04
    193c:	82 8d       	ldd	r24, Z+26	; 0x1a
    193e:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1940:	8a 81       	ldd	r24, Y+2	; 0x02
    1942:	88 23       	and	r24, r24
    1944:	81 f1       	breq	.+96     	; 0x19a6 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1946:	eb 81       	ldd	r30, Y+3	; 0x03
    1948:	fc 81       	ldd	r31, Y+4	; 0x04
    194a:	85 8d       	ldd	r24, Z+29	; 0x1d
    194c:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    194e:	8b 81       	ldd	r24, Y+3	; 0x03
    1950:	9c 81       	ldd	r25, Y+4	; 0x04
    1952:	29 85       	ldd	r18, Y+9	; 0x09
    1954:	3a 85       	ldd	r19, Y+10	; 0x0a
    1956:	b9 01       	movw	r22, r18
    1958:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    195c:	8a 81       	ldd	r24, Y+2	; 0x02
    195e:	81 50       	subi	r24, 0x01	; 1
    1960:	eb 81       	ldd	r30, Y+3	; 0x03
    1962:	fc 81       	ldd	r31, Y+4	; 0x04
    1964:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1966:	89 81       	ldd	r24, Y+1	; 0x01
    1968:	8f 3f       	cpi	r24, 0xFF	; 255
    196a:	a9 f4       	brne	.+42     	; 0x1996 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    196c:	eb 81       	ldd	r30, Y+3	; 0x03
    196e:	fc 81       	ldd	r31, Y+4	; 0x04
    1970:	80 85       	ldd	r24, Z+8	; 0x08
    1972:	88 23       	and	r24, r24
    1974:	a9 f0       	breq	.+42     	; 0x19a0 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1976:	8b 81       	ldd	r24, Y+3	; 0x03
    1978:	9c 81       	ldd	r25, Y+4	; 0x04
    197a:	08 96       	adiw	r24, 0x08	; 8
    197c:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <xTaskRemoveFromEventList>
    1980:	88 23       	and	r24, r24
    1982:	71 f0       	breq	.+28     	; 0x19a0 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1984:	8b 85       	ldd	r24, Y+11	; 0x0b
    1986:	9c 85       	ldd	r25, Y+12	; 0x0c
    1988:	00 97       	sbiw	r24, 0x00	; 0
    198a:	51 f0       	breq	.+20     	; 0x19a0 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    198c:	eb 85       	ldd	r30, Y+11	; 0x0b
    198e:	fc 85       	ldd	r31, Y+12	; 0x0c
    1990:	81 e0       	ldi	r24, 0x01	; 1
    1992:	80 83       	st	Z, r24
    1994:	05 c0       	rjmp	.+10     	; 0x19a0 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1996:	89 81       	ldd	r24, Y+1	; 0x01
    1998:	8f 5f       	subi	r24, 0xFF	; 255
    199a:	eb 81       	ldd	r30, Y+3	; 0x03
    199c:	fc 81       	ldd	r31, Y+4	; 0x04
    199e:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    19a0:	81 e0       	ldi	r24, 0x01	; 1
    19a2:	8e 83       	std	Y+6, r24	; 0x06
    19a4:	01 c0       	rjmp	.+2      	; 0x19a8 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    19a6:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    19a8:	8e 81       	ldd	r24, Y+6	; 0x06
}
    19aa:	2c 96       	adiw	r28, 0x0c	; 12
    19ac:	0f b6       	in	r0, 0x3f	; 63
    19ae:	f8 94       	cli
    19b0:	de bf       	out	0x3e, r29	; 62
    19b2:	0f be       	out	0x3f, r0	; 63
    19b4:	cd bf       	out	0x3d, r28	; 61
    19b6:	cf 91       	pop	r28
    19b8:	df 91       	pop	r29
    19ba:	08 95       	ret

000019bc <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    19bc:	df 93       	push	r29
    19be:	cf 93       	push	r28
    19c0:	cd b7       	in	r28, 0x3d	; 61
    19c2:	de b7       	in	r29, 0x3e	; 62
    19c4:	2a 97       	sbiw	r28, 0x0a	; 10
    19c6:	0f b6       	in	r0, 0x3f	; 63
    19c8:	f8 94       	cli
    19ca:	de bf       	out	0x3e, r29	; 62
    19cc:	0f be       	out	0x3f, r0	; 63
    19ce:	cd bf       	out	0x3d, r28	; 61
    19d0:	98 87       	std	Y+8, r25	; 0x08
    19d2:	8f 83       	std	Y+7, r24	; 0x07
    19d4:	7a 87       	std	Y+10, r23	; 0x0a
    19d6:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    19d8:	8f 81       	ldd	r24, Y+7	; 0x07
    19da:	98 85       	ldd	r25, Y+8	; 0x08
    19dc:	9a 83       	std	Y+2, r25	; 0x02
    19de:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    19e0:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    19e2:	e9 81       	ldd	r30, Y+1	; 0x01
    19e4:	fa 81       	ldd	r31, Y+2	; 0x02
    19e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    19e8:	88 23       	and	r24, r24
    19ea:	b1 f0       	breq	.+44     	; 0x1a18 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    19ec:	e9 81       	ldd	r30, Y+1	; 0x01
    19ee:	fa 81       	ldd	r31, Y+2	; 0x02
    19f0:	86 81       	ldd	r24, Z+6	; 0x06
    19f2:	97 81       	ldd	r25, Z+7	; 0x07
    19f4:	9c 83       	std	Y+4, r25	; 0x04
    19f6:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    19f8:	89 81       	ldd	r24, Y+1	; 0x01
    19fa:	9a 81       	ldd	r25, Y+2	; 0x02
    19fc:	29 85       	ldd	r18, Y+9	; 0x09
    19fe:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a00:	b9 01       	movw	r22, r18
    1a02:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1a06:	e9 81       	ldd	r30, Y+1	; 0x01
    1a08:	fa 81       	ldd	r31, Y+2	; 0x02
    1a0a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a0c:	9c 81       	ldd	r25, Y+4	; 0x04
    1a0e:	97 83       	std	Z+7, r25	; 0x07
    1a10:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    1a12:	81 e0       	ldi	r24, 0x01	; 1
    1a14:	8e 83       	std	Y+6, r24	; 0x06
    1a16:	01 c0       	rjmp	.+2      	; 0x1a1a <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    1a18:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1a1a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1a1c:	2a 96       	adiw	r28, 0x0a	; 10
    1a1e:	0f b6       	in	r0, 0x3f	; 63
    1a20:	f8 94       	cli
    1a22:	de bf       	out	0x3e, r29	; 62
    1a24:	0f be       	out	0x3f, r0	; 63
    1a26:	cd bf       	out	0x3d, r28	; 61
    1a28:	cf 91       	pop	r28
    1a2a:	df 91       	pop	r29
    1a2c:	08 95       	ret

00001a2e <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    1a2e:	df 93       	push	r29
    1a30:	cf 93       	push	r28
    1a32:	00 d0       	rcall	.+0      	; 0x1a34 <uxQueueMessagesWaiting+0x6>
    1a34:	0f 92       	push	r0
    1a36:	cd b7       	in	r28, 0x3d	; 61
    1a38:	de b7       	in	r29, 0x3e	; 62
    1a3a:	9b 83       	std	Y+3, r25	; 0x03
    1a3c:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1a3e:	0f b6       	in	r0, 0x3f	; 63
    1a40:	f8 94       	cli
    1a42:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1a44:	ea 81       	ldd	r30, Y+2	; 0x02
    1a46:	fb 81       	ldd	r31, Y+3	; 0x03
    1a48:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a4a:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1a4c:	0f 90       	pop	r0
    1a4e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1a50:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1a52:	0f 90       	pop	r0
    1a54:	0f 90       	pop	r0
    1a56:	0f 90       	pop	r0
    1a58:	cf 91       	pop	r28
    1a5a:	df 91       	pop	r29
    1a5c:	08 95       	ret

00001a5e <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1a5e:	df 93       	push	r29
    1a60:	cf 93       	push	r28
    1a62:	00 d0       	rcall	.+0      	; 0x1a64 <uxQueueSpacesAvailable+0x6>
    1a64:	00 d0       	rcall	.+0      	; 0x1a66 <uxQueueSpacesAvailable+0x8>
    1a66:	0f 92       	push	r0
    1a68:	cd b7       	in	r28, 0x3d	; 61
    1a6a:	de b7       	in	r29, 0x3e	; 62
    1a6c:	9d 83       	std	Y+5, r25	; 0x05
    1a6e:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    1a70:	8c 81       	ldd	r24, Y+4	; 0x04
    1a72:	9d 81       	ldd	r25, Y+5	; 0x05
    1a74:	9a 83       	std	Y+2, r25	; 0x02
    1a76:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1a78:	0f b6       	in	r0, 0x3f	; 63
    1a7a:	f8 94       	cli
    1a7c:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1a7e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a80:	fa 81       	ldd	r31, Y+2	; 0x02
    1a82:	93 8d       	ldd	r25, Z+27	; 0x1b
    1a84:	e9 81       	ldd	r30, Y+1	; 0x01
    1a86:	fa 81       	ldd	r31, Y+2	; 0x02
    1a88:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a8a:	29 2f       	mov	r18, r25
    1a8c:	28 1b       	sub	r18, r24
    1a8e:	82 2f       	mov	r24, r18
    1a90:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    1a92:	0f 90       	pop	r0
    1a94:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1a96:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1a98:	0f 90       	pop	r0
    1a9a:	0f 90       	pop	r0
    1a9c:	0f 90       	pop	r0
    1a9e:	0f 90       	pop	r0
    1aa0:	0f 90       	pop	r0
    1aa2:	cf 91       	pop	r28
    1aa4:	df 91       	pop	r29
    1aa6:	08 95       	ret

00001aa8 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    1aa8:	df 93       	push	r29
    1aaa:	cf 93       	push	r28
    1aac:	00 d0       	rcall	.+0      	; 0x1aae <uxQueueMessagesWaitingFromISR+0x6>
    1aae:	00 d0       	rcall	.+0      	; 0x1ab0 <uxQueueMessagesWaitingFromISR+0x8>
    1ab0:	0f 92       	push	r0
    1ab2:	cd b7       	in	r28, 0x3d	; 61
    1ab4:	de b7       	in	r29, 0x3e	; 62
    1ab6:	9d 83       	std	Y+5, r25	; 0x05
    1ab8:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    1aba:	8c 81       	ldd	r24, Y+4	; 0x04
    1abc:	9d 81       	ldd	r25, Y+5	; 0x05
    1abe:	9a 83       	std	Y+2, r25	; 0x02
    1ac0:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1ac2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ac4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ac6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ac8:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    1aca:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1acc:	0f 90       	pop	r0
    1ace:	0f 90       	pop	r0
    1ad0:	0f 90       	pop	r0
    1ad2:	0f 90       	pop	r0
    1ad4:	0f 90       	pop	r0
    1ad6:	cf 91       	pop	r28
    1ad8:	df 91       	pop	r29
    1ada:	08 95       	ret

00001adc <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1adc:	df 93       	push	r29
    1ade:	cf 93       	push	r28
    1ae0:	00 d0       	rcall	.+0      	; 0x1ae2 <vQueueDelete+0x6>
    1ae2:	00 d0       	rcall	.+0      	; 0x1ae4 <vQueueDelete+0x8>
    1ae4:	cd b7       	in	r28, 0x3d	; 61
    1ae6:	de b7       	in	r29, 0x3e	; 62
    1ae8:	9c 83       	std	Y+4, r25	; 0x04
    1aea:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    1aec:	8b 81       	ldd	r24, Y+3	; 0x03
    1aee:	9c 81       	ldd	r25, Y+4	; 0x04
    1af0:	9a 83       	std	Y+2, r25	; 0x02
    1af2:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1af4:	89 81       	ldd	r24, Y+1	; 0x01
    1af6:	9a 81       	ldd	r25, Y+2	; 0x02
    1af8:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1afc:	0f 90       	pop	r0
    1afe:	0f 90       	pop	r0
    1b00:	0f 90       	pop	r0
    1b02:	0f 90       	pop	r0
    1b04:	cf 91       	pop	r28
    1b06:	df 91       	pop	r29
    1b08:	08 95       	ret

00001b0a <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1b0a:	df 93       	push	r29
    1b0c:	cf 93       	push	r28
    1b0e:	cd b7       	in	r28, 0x3d	; 61
    1b10:	de b7       	in	r29, 0x3e	; 62
    1b12:	27 97       	sbiw	r28, 0x07	; 7
    1b14:	0f b6       	in	r0, 0x3f	; 63
    1b16:	f8 94       	cli
    1b18:	de bf       	out	0x3e, r29	; 62
    1b1a:	0f be       	out	0x3f, r0	; 63
    1b1c:	cd bf       	out	0x3d, r28	; 61
    1b1e:	9c 83       	std	Y+4, r25	; 0x04
    1b20:	8b 83       	std	Y+3, r24	; 0x03
    1b22:	7e 83       	std	Y+6, r23	; 0x06
    1b24:	6d 83       	std	Y+5, r22	; 0x05
    1b26:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    1b28:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1b2a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b2c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b2e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b30:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1b32:	eb 81       	ldd	r30, Y+3	; 0x03
    1b34:	fc 81       	ldd	r31, Y+4	; 0x04
    1b36:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b38:	88 23       	and	r24, r24
    1b3a:	09 f4       	brne	.+2      	; 0x1b3e <prvCopyDataToQueue+0x34>
    1b3c:	7d c0       	rjmp	.+250    	; 0x1c38 <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1b3e:	8f 81       	ldd	r24, Y+7	; 0x07
    1b40:	88 23       	and	r24, r24
    1b42:	99 f5       	brne	.+102    	; 0x1baa <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1b44:	eb 81       	ldd	r30, Y+3	; 0x03
    1b46:	fc 81       	ldd	r31, Y+4	; 0x04
    1b48:	62 81       	ldd	r22, Z+2	; 0x02
    1b4a:	73 81       	ldd	r23, Z+3	; 0x03
    1b4c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b4e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b50:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b52:	48 2f       	mov	r20, r24
    1b54:	50 e0       	ldi	r21, 0x00	; 0
    1b56:	2d 81       	ldd	r18, Y+5	; 0x05
    1b58:	3e 81       	ldd	r19, Y+6	; 0x06
    1b5a:	cb 01       	movw	r24, r22
    1b5c:	b9 01       	movw	r22, r18
    1b5e:	0e 94 39 28 	call	0x5072	; 0x5072 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1b62:	eb 81       	ldd	r30, Y+3	; 0x03
    1b64:	fc 81       	ldd	r31, Y+4	; 0x04
    1b66:	22 81       	ldd	r18, Z+2	; 0x02
    1b68:	33 81       	ldd	r19, Z+3	; 0x03
    1b6a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b6c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b6e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b70:	88 2f       	mov	r24, r24
    1b72:	90 e0       	ldi	r25, 0x00	; 0
    1b74:	82 0f       	add	r24, r18
    1b76:	93 1f       	adc	r25, r19
    1b78:	eb 81       	ldd	r30, Y+3	; 0x03
    1b7a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b7c:	93 83       	std	Z+3, r25	; 0x03
    1b7e:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1b80:	eb 81       	ldd	r30, Y+3	; 0x03
    1b82:	fc 81       	ldd	r31, Y+4	; 0x04
    1b84:	22 81       	ldd	r18, Z+2	; 0x02
    1b86:	33 81       	ldd	r19, Z+3	; 0x03
    1b88:	eb 81       	ldd	r30, Y+3	; 0x03
    1b8a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b8c:	84 81       	ldd	r24, Z+4	; 0x04
    1b8e:	95 81       	ldd	r25, Z+5	; 0x05
    1b90:	28 17       	cp	r18, r24
    1b92:	39 07       	cpc	r19, r25
    1b94:	08 f4       	brcc	.+2      	; 0x1b98 <prvCopyDataToQueue+0x8e>
    1b96:	50 c0       	rjmp	.+160    	; 0x1c38 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1b98:	eb 81       	ldd	r30, Y+3	; 0x03
    1b9a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b9c:	80 81       	ld	r24, Z
    1b9e:	91 81       	ldd	r25, Z+1	; 0x01
    1ba0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ba2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ba4:	93 83       	std	Z+3, r25	; 0x03
    1ba6:	82 83       	std	Z+2, r24	; 0x02
    1ba8:	47 c0       	rjmp	.+142    	; 0x1c38 <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1baa:	eb 81       	ldd	r30, Y+3	; 0x03
    1bac:	fc 81       	ldd	r31, Y+4	; 0x04
    1bae:	66 81       	ldd	r22, Z+6	; 0x06
    1bb0:	77 81       	ldd	r23, Z+7	; 0x07
    1bb2:	eb 81       	ldd	r30, Y+3	; 0x03
    1bb4:	fc 81       	ldd	r31, Y+4	; 0x04
    1bb6:	84 8d       	ldd	r24, Z+28	; 0x1c
    1bb8:	48 2f       	mov	r20, r24
    1bba:	50 e0       	ldi	r21, 0x00	; 0
    1bbc:	2d 81       	ldd	r18, Y+5	; 0x05
    1bbe:	3e 81       	ldd	r19, Y+6	; 0x06
    1bc0:	cb 01       	movw	r24, r22
    1bc2:	b9 01       	movw	r22, r18
    1bc4:	0e 94 39 28 	call	0x5072	; 0x5072 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1bc8:	eb 81       	ldd	r30, Y+3	; 0x03
    1bca:	fc 81       	ldd	r31, Y+4	; 0x04
    1bcc:	26 81       	ldd	r18, Z+6	; 0x06
    1bce:	37 81       	ldd	r19, Z+7	; 0x07
    1bd0:	eb 81       	ldd	r30, Y+3	; 0x03
    1bd2:	fc 81       	ldd	r31, Y+4	; 0x04
    1bd4:	84 8d       	ldd	r24, Z+28	; 0x1c
    1bd6:	88 2f       	mov	r24, r24
    1bd8:	90 e0       	ldi	r25, 0x00	; 0
    1bda:	90 95       	com	r25
    1bdc:	81 95       	neg	r24
    1bde:	9f 4f       	sbci	r25, 0xFF	; 255
    1be0:	82 0f       	add	r24, r18
    1be2:	93 1f       	adc	r25, r19
    1be4:	eb 81       	ldd	r30, Y+3	; 0x03
    1be6:	fc 81       	ldd	r31, Y+4	; 0x04
    1be8:	97 83       	std	Z+7, r25	; 0x07
    1bea:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1bec:	eb 81       	ldd	r30, Y+3	; 0x03
    1bee:	fc 81       	ldd	r31, Y+4	; 0x04
    1bf0:	26 81       	ldd	r18, Z+6	; 0x06
    1bf2:	37 81       	ldd	r19, Z+7	; 0x07
    1bf4:	eb 81       	ldd	r30, Y+3	; 0x03
    1bf6:	fc 81       	ldd	r31, Y+4	; 0x04
    1bf8:	80 81       	ld	r24, Z
    1bfa:	91 81       	ldd	r25, Z+1	; 0x01
    1bfc:	28 17       	cp	r18, r24
    1bfe:	39 07       	cpc	r19, r25
    1c00:	90 f4       	brcc	.+36     	; 0x1c26 <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1c02:	eb 81       	ldd	r30, Y+3	; 0x03
    1c04:	fc 81       	ldd	r31, Y+4	; 0x04
    1c06:	24 81       	ldd	r18, Z+4	; 0x04
    1c08:	35 81       	ldd	r19, Z+5	; 0x05
    1c0a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c0c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c0e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c10:	88 2f       	mov	r24, r24
    1c12:	90 e0       	ldi	r25, 0x00	; 0
    1c14:	90 95       	com	r25
    1c16:	81 95       	neg	r24
    1c18:	9f 4f       	sbci	r25, 0xFF	; 255
    1c1a:	82 0f       	add	r24, r18
    1c1c:	93 1f       	adc	r25, r19
    1c1e:	eb 81       	ldd	r30, Y+3	; 0x03
    1c20:	fc 81       	ldd	r31, Y+4	; 0x04
    1c22:	97 83       	std	Z+7, r25	; 0x07
    1c24:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1c26:	8f 81       	ldd	r24, Y+7	; 0x07
    1c28:	82 30       	cpi	r24, 0x02	; 2
    1c2a:	31 f4       	brne	.+12     	; 0x1c38 <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c2c:	89 81       	ldd	r24, Y+1	; 0x01
    1c2e:	88 23       	and	r24, r24
    1c30:	19 f0       	breq	.+6      	; 0x1c38 <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1c32:	89 81       	ldd	r24, Y+1	; 0x01
    1c34:	81 50       	subi	r24, 0x01	; 1
    1c36:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1c38:	89 81       	ldd	r24, Y+1	; 0x01
    1c3a:	8f 5f       	subi	r24, 0xFF	; 255
    1c3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1c40:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    1c42:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1c44:	27 96       	adiw	r28, 0x07	; 7
    1c46:	0f b6       	in	r0, 0x3f	; 63
    1c48:	f8 94       	cli
    1c4a:	de bf       	out	0x3e, r29	; 62
    1c4c:	0f be       	out	0x3f, r0	; 63
    1c4e:	cd bf       	out	0x3d, r28	; 61
    1c50:	cf 91       	pop	r28
    1c52:	df 91       	pop	r29
    1c54:	08 95       	ret

00001c56 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1c56:	df 93       	push	r29
    1c58:	cf 93       	push	r28
    1c5a:	00 d0       	rcall	.+0      	; 0x1c5c <prvCopyDataFromQueue+0x6>
    1c5c:	00 d0       	rcall	.+0      	; 0x1c5e <prvCopyDataFromQueue+0x8>
    1c5e:	cd b7       	in	r28, 0x3d	; 61
    1c60:	de b7       	in	r29, 0x3e	; 62
    1c62:	9a 83       	std	Y+2, r25	; 0x02
    1c64:	89 83       	std	Y+1, r24	; 0x01
    1c66:	7c 83       	std	Y+4, r23	; 0x04
    1c68:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1c6a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c6c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c6e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c70:	88 23       	and	r24, r24
    1c72:	89 f1       	breq	.+98     	; 0x1cd6 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1c74:	e9 81       	ldd	r30, Y+1	; 0x01
    1c76:	fa 81       	ldd	r31, Y+2	; 0x02
    1c78:	26 81       	ldd	r18, Z+6	; 0x06
    1c7a:	37 81       	ldd	r19, Z+7	; 0x07
    1c7c:	e9 81       	ldd	r30, Y+1	; 0x01
    1c7e:	fa 81       	ldd	r31, Y+2	; 0x02
    1c80:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c82:	88 2f       	mov	r24, r24
    1c84:	90 e0       	ldi	r25, 0x00	; 0
    1c86:	82 0f       	add	r24, r18
    1c88:	93 1f       	adc	r25, r19
    1c8a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c8c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c8e:	97 83       	std	Z+7, r25	; 0x07
    1c90:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1c92:	e9 81       	ldd	r30, Y+1	; 0x01
    1c94:	fa 81       	ldd	r31, Y+2	; 0x02
    1c96:	26 81       	ldd	r18, Z+6	; 0x06
    1c98:	37 81       	ldd	r19, Z+7	; 0x07
    1c9a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c9c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c9e:	84 81       	ldd	r24, Z+4	; 0x04
    1ca0:	95 81       	ldd	r25, Z+5	; 0x05
    1ca2:	28 17       	cp	r18, r24
    1ca4:	39 07       	cpc	r19, r25
    1ca6:	40 f0       	brcs	.+16     	; 0x1cb8 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1ca8:	e9 81       	ldd	r30, Y+1	; 0x01
    1caa:	fa 81       	ldd	r31, Y+2	; 0x02
    1cac:	80 81       	ld	r24, Z
    1cae:	91 81       	ldd	r25, Z+1	; 0x01
    1cb0:	e9 81       	ldd	r30, Y+1	; 0x01
    1cb2:	fa 81       	ldd	r31, Y+2	; 0x02
    1cb4:	97 83       	std	Z+7, r25	; 0x07
    1cb6:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1cb8:	e9 81       	ldd	r30, Y+1	; 0x01
    1cba:	fa 81       	ldd	r31, Y+2	; 0x02
    1cbc:	46 81       	ldd	r20, Z+6	; 0x06
    1cbe:	57 81       	ldd	r21, Z+7	; 0x07
    1cc0:	e9 81       	ldd	r30, Y+1	; 0x01
    1cc2:	fa 81       	ldd	r31, Y+2	; 0x02
    1cc4:	84 8d       	ldd	r24, Z+28	; 0x1c
    1cc6:	28 2f       	mov	r18, r24
    1cc8:	30 e0       	ldi	r19, 0x00	; 0
    1cca:	8b 81       	ldd	r24, Y+3	; 0x03
    1ccc:	9c 81       	ldd	r25, Y+4	; 0x04
    1cce:	ba 01       	movw	r22, r20
    1cd0:	a9 01       	movw	r20, r18
    1cd2:	0e 94 39 28 	call	0x5072	; 0x5072 <memcpy>
	}
}
    1cd6:	0f 90       	pop	r0
    1cd8:	0f 90       	pop	r0
    1cda:	0f 90       	pop	r0
    1cdc:	0f 90       	pop	r0
    1cde:	cf 91       	pop	r28
    1ce0:	df 91       	pop	r29
    1ce2:	08 95       	ret

00001ce4 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1ce4:	df 93       	push	r29
    1ce6:	cf 93       	push	r28
    1ce8:	00 d0       	rcall	.+0      	; 0x1cea <prvUnlockQueue+0x6>
    1cea:	00 d0       	rcall	.+0      	; 0x1cec <prvUnlockQueue+0x8>
    1cec:	cd b7       	in	r28, 0x3d	; 61
    1cee:	de b7       	in	r29, 0x3e	; 62
    1cf0:	9c 83       	std	Y+4, r25	; 0x04
    1cf2:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1cf4:	0f b6       	in	r0, 0x3f	; 63
    1cf6:	f8 94       	cli
    1cf8:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1cfa:	eb 81       	ldd	r30, Y+3	; 0x03
    1cfc:	fc 81       	ldd	r31, Y+4	; 0x04
    1cfe:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d00:	8a 83       	std	Y+2, r24	; 0x02
    1d02:	11 c0       	rjmp	.+34     	; 0x1d26 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d04:	eb 81       	ldd	r30, Y+3	; 0x03
    1d06:	fc 81       	ldd	r31, Y+4	; 0x04
    1d08:	81 89       	ldd	r24, Z+17	; 0x11
    1d0a:	88 23       	and	r24, r24
    1d0c:	79 f0       	breq	.+30     	; 0x1d2c <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1d0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d10:	9c 81       	ldd	r25, Y+4	; 0x04
    1d12:	41 96       	adiw	r24, 0x11	; 17
    1d14:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <xTaskRemoveFromEventList>
    1d18:	88 23       	and	r24, r24
    1d1a:	11 f0       	breq	.+4      	; 0x1d20 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    1d1c:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    1d20:	8a 81       	ldd	r24, Y+2	; 0x02
    1d22:	81 50       	subi	r24, 0x01	; 1
    1d24:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1d26:	8a 81       	ldd	r24, Y+2	; 0x02
    1d28:	18 16       	cp	r1, r24
    1d2a:	64 f3       	brlt	.-40     	; 0x1d04 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1d2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d30:	8f ef       	ldi	r24, 0xFF	; 255
    1d32:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1d34:	0f 90       	pop	r0
    1d36:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1d38:	0f b6       	in	r0, 0x3f	; 63
    1d3a:	f8 94       	cli
    1d3c:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1d3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d40:	fc 81       	ldd	r31, Y+4	; 0x04
    1d42:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d44:	89 83       	std	Y+1, r24	; 0x01
    1d46:	11 c0       	rjmp	.+34     	; 0x1d6a <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d48:	eb 81       	ldd	r30, Y+3	; 0x03
    1d4a:	fc 81       	ldd	r31, Y+4	; 0x04
    1d4c:	80 85       	ldd	r24, Z+8	; 0x08
    1d4e:	88 23       	and	r24, r24
    1d50:	79 f0       	breq	.+30     	; 0x1d70 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d52:	8b 81       	ldd	r24, Y+3	; 0x03
    1d54:	9c 81       	ldd	r25, Y+4	; 0x04
    1d56:	08 96       	adiw	r24, 0x08	; 8
    1d58:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <xTaskRemoveFromEventList>
    1d5c:	88 23       	and	r24, r24
    1d5e:	11 f0       	breq	.+4      	; 0x1d64 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    1d60:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    1d64:	89 81       	ldd	r24, Y+1	; 0x01
    1d66:	81 50       	subi	r24, 0x01	; 1
    1d68:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    1d6a:	89 81       	ldd	r24, Y+1	; 0x01
    1d6c:	18 16       	cp	r1, r24
    1d6e:	64 f3       	brlt	.-40     	; 0x1d48 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1d70:	eb 81       	ldd	r30, Y+3	; 0x03
    1d72:	fc 81       	ldd	r31, Y+4	; 0x04
    1d74:	8f ef       	ldi	r24, 0xFF	; 255
    1d76:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1d78:	0f 90       	pop	r0
    1d7a:	0f be       	out	0x3f, r0	; 63
}
    1d7c:	0f 90       	pop	r0
    1d7e:	0f 90       	pop	r0
    1d80:	0f 90       	pop	r0
    1d82:	0f 90       	pop	r0
    1d84:	cf 91       	pop	r28
    1d86:	df 91       	pop	r29
    1d88:	08 95       	ret

00001d8a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    1d8a:	df 93       	push	r29
    1d8c:	cf 93       	push	r28
    1d8e:	00 d0       	rcall	.+0      	; 0x1d90 <prvIsQueueEmpty+0x6>
    1d90:	0f 92       	push	r0
    1d92:	cd b7       	in	r28, 0x3d	; 61
    1d94:	de b7       	in	r29, 0x3e	; 62
    1d96:	9b 83       	std	Y+3, r25	; 0x03
    1d98:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1d9a:	0f b6       	in	r0, 0x3f	; 63
    1d9c:	f8 94       	cli
    1d9e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1da0:	ea 81       	ldd	r30, Y+2	; 0x02
    1da2:	fb 81       	ldd	r31, Y+3	; 0x03
    1da4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1da6:	88 23       	and	r24, r24
    1da8:	19 f4       	brne	.+6      	; 0x1db0 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    1daa:	81 e0       	ldi	r24, 0x01	; 1
    1dac:	89 83       	std	Y+1, r24	; 0x01
    1dae:	01 c0       	rjmp	.+2      	; 0x1db2 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    1db0:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1db2:	0f 90       	pop	r0
    1db4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1db6:	89 81       	ldd	r24, Y+1	; 0x01
}
    1db8:	0f 90       	pop	r0
    1dba:	0f 90       	pop	r0
    1dbc:	0f 90       	pop	r0
    1dbe:	cf 91       	pop	r28
    1dc0:	df 91       	pop	r29
    1dc2:	08 95       	ret

00001dc4 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    1dc4:	df 93       	push	r29
    1dc6:	cf 93       	push	r28
    1dc8:	00 d0       	rcall	.+0      	; 0x1dca <xQueueIsQueueEmptyFromISR+0x6>
    1dca:	00 d0       	rcall	.+0      	; 0x1dcc <xQueueIsQueueEmptyFromISR+0x8>
    1dcc:	0f 92       	push	r0
    1dce:	cd b7       	in	r28, 0x3d	; 61
    1dd0:	de b7       	in	r29, 0x3e	; 62
    1dd2:	9d 83       	std	Y+5, r25	; 0x05
    1dd4:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    1dd6:	8c 81       	ldd	r24, Y+4	; 0x04
    1dd8:	9d 81       	ldd	r25, Y+5	; 0x05
    1dda:	9a 83       	std	Y+2, r25	; 0x02
    1ddc:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1dde:	e9 81       	ldd	r30, Y+1	; 0x01
    1de0:	fa 81       	ldd	r31, Y+2	; 0x02
    1de2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1de4:	88 23       	and	r24, r24
    1de6:	19 f4       	brne	.+6      	; 0x1dee <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    1de8:	81 e0       	ldi	r24, 0x01	; 1
    1dea:	8b 83       	std	Y+3, r24	; 0x03
    1dec:	01 c0       	rjmp	.+2      	; 0x1df0 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    1dee:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    1df0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1df2:	0f 90       	pop	r0
    1df4:	0f 90       	pop	r0
    1df6:	0f 90       	pop	r0
    1df8:	0f 90       	pop	r0
    1dfa:	0f 90       	pop	r0
    1dfc:	cf 91       	pop	r28
    1dfe:	df 91       	pop	r29
    1e00:	08 95       	ret

00001e02 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    1e02:	df 93       	push	r29
    1e04:	cf 93       	push	r28
    1e06:	00 d0       	rcall	.+0      	; 0x1e08 <prvIsQueueFull+0x6>
    1e08:	0f 92       	push	r0
    1e0a:	cd b7       	in	r28, 0x3d	; 61
    1e0c:	de b7       	in	r29, 0x3e	; 62
    1e0e:	9b 83       	std	Y+3, r25	; 0x03
    1e10:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1e12:	0f b6       	in	r0, 0x3f	; 63
    1e14:	f8 94       	cli
    1e16:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1e18:	ea 81       	ldd	r30, Y+2	; 0x02
    1e1a:	fb 81       	ldd	r31, Y+3	; 0x03
    1e1c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e1e:	ea 81       	ldd	r30, Y+2	; 0x02
    1e20:	fb 81       	ldd	r31, Y+3	; 0x03
    1e22:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e24:	98 17       	cp	r25, r24
    1e26:	19 f4       	brne	.+6      	; 0x1e2e <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    1e28:	81 e0       	ldi	r24, 0x01	; 1
    1e2a:	89 83       	std	Y+1, r24	; 0x01
    1e2c:	01 c0       	rjmp	.+2      	; 0x1e30 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    1e2e:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1e30:	0f 90       	pop	r0
    1e32:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1e34:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e36:	0f 90       	pop	r0
    1e38:	0f 90       	pop	r0
    1e3a:	0f 90       	pop	r0
    1e3c:	cf 91       	pop	r28
    1e3e:	df 91       	pop	r29
    1e40:	08 95       	ret

00001e42 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1e42:	df 93       	push	r29
    1e44:	cf 93       	push	r28
    1e46:	00 d0       	rcall	.+0      	; 0x1e48 <xQueueIsQueueFullFromISR+0x6>
    1e48:	00 d0       	rcall	.+0      	; 0x1e4a <xQueueIsQueueFullFromISR+0x8>
    1e4a:	0f 92       	push	r0
    1e4c:	cd b7       	in	r28, 0x3d	; 61
    1e4e:	de b7       	in	r29, 0x3e	; 62
    1e50:	9d 83       	std	Y+5, r25	; 0x05
    1e52:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    1e54:	8c 81       	ldd	r24, Y+4	; 0x04
    1e56:	9d 81       	ldd	r25, Y+5	; 0x05
    1e58:	9a 83       	std	Y+2, r25	; 0x02
    1e5a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1e5c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e5e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e60:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e62:	e9 81       	ldd	r30, Y+1	; 0x01
    1e64:	fa 81       	ldd	r31, Y+2	; 0x02
    1e66:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e68:	98 17       	cp	r25, r24
    1e6a:	19 f4       	brne	.+6      	; 0x1e72 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    1e6c:	81 e0       	ldi	r24, 0x01	; 1
    1e6e:	8b 83       	std	Y+3, r24	; 0x03
    1e70:	01 c0       	rjmp	.+2      	; 0x1e74 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    1e72:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    1e74:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1e76:	0f 90       	pop	r0
    1e78:	0f 90       	pop	r0
    1e7a:	0f 90       	pop	r0
    1e7c:	0f 90       	pop	r0
    1e7e:	0f 90       	pop	r0
    1e80:	cf 91       	pop	r28
    1e82:	df 91       	pop	r29
    1e84:	08 95       	ret

00001e86 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    1e86:	0f 93       	push	r16
    1e88:	df 93       	push	r29
    1e8a:	cf 93       	push	r28
    1e8c:	cd b7       	in	r28, 0x3d	; 61
    1e8e:	de b7       	in	r29, 0x3e	; 62
    1e90:	28 97       	sbiw	r28, 0x08	; 8
    1e92:	0f b6       	in	r0, 0x3f	; 63
    1e94:	f8 94       	cli
    1e96:	de bf       	out	0x3e, r29	; 62
    1e98:	0f be       	out	0x3f, r0	; 63
    1e9a:	cd bf       	out	0x3d, r28	; 61
    1e9c:	9d 83       	std	Y+5, r25	; 0x05
    1e9e:	8c 83       	std	Y+4, r24	; 0x04
    1ea0:	7f 83       	std	Y+7, r23	; 0x07
    1ea2:	6e 83       	std	Y+6, r22	; 0x06
    1ea4:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    1ea6:	88 85       	ldd	r24, Y+8	; 0x08
    1ea8:	81 30       	cpi	r24, 0x01	; 1
    1eaa:	19 f4       	brne	.+6      	; 0x1eb2 <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    1eac:	81 e0       	ldi	r24, 0x01	; 1
    1eae:	89 83       	std	Y+1, r24	; 0x01
    1eb0:	01 c0       	rjmp	.+2      	; 0x1eb4 <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    1eb2:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    1eb4:	8e 81       	ldd	r24, Y+6	; 0x06
    1eb6:	9f 81       	ldd	r25, Y+7	; 0x07
    1eb8:	00 97       	sbiw	r24, 0x00	; 0
    1eba:	21 f4       	brne	.+8      	; 0x1ec4 <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    1ebc:	81 e0       	ldi	r24, 0x01	; 1
    1ebe:	90 e0       	ldi	r25, 0x00	; 0
    1ec0:	9f 83       	std	Y+7, r25	; 0x07
    1ec2:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    1ec4:	8c 81       	ldd	r24, Y+4	; 0x04
    1ec6:	9d 81       	ldd	r25, Y+5	; 0x05
    1ec8:	01 96       	adiw	r24, 0x01	; 1
    1eca:	9d 83       	std	Y+5, r25	; 0x05
    1ecc:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    1ece:	8c 81       	ldd	r24, Y+4	; 0x04
    1ed0:	9d 81       	ldd	r25, Y+5	; 0x05
    1ed2:	0f 96       	adiw	r24, 0x0f	; 15
    1ed4:	0e 94 8e 03 	call	0x71c	; 0x71c <pvPortMalloc>
    1ed8:	9b 83       	std	Y+3, r25	; 0x03
    1eda:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    1edc:	8a 81       	ldd	r24, Y+2	; 0x02
    1ede:	9b 81       	ldd	r25, Y+3	; 0x03
    1ee0:	00 97       	sbiw	r24, 0x00	; 0
    1ee2:	89 f0       	breq	.+34     	; 0x1f06 <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    1ee4:	6a 81       	ldd	r22, Y+2	; 0x02
    1ee6:	7b 81       	ldd	r23, Y+3	; 0x03
    1ee8:	8a 81       	ldd	r24, Y+2	; 0x02
    1eea:	9b 81       	ldd	r25, Y+3	; 0x03
    1eec:	9c 01       	movw	r18, r24
    1eee:	21 5f       	subi	r18, 0xF1	; 241
    1ef0:	3f 4f       	sbci	r19, 0xFF	; 255
    1ef2:	4c 81       	ldd	r20, Y+4	; 0x04
    1ef4:	5d 81       	ldd	r21, Y+5	; 0x05
    1ef6:	ee 81       	ldd	r30, Y+6	; 0x06
    1ef8:	ff 81       	ldd	r31, Y+7	; 0x07
    1efa:	cb 01       	movw	r24, r22
    1efc:	b9 01       	movw	r22, r18
    1efe:	9f 01       	movw	r18, r30
    1f00:	09 81       	ldd	r16, Y+1	; 0x01
    1f02:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    1f06:	8a 81       	ldd	r24, Y+2	; 0x02
    1f08:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    1f0a:	28 96       	adiw	r28, 0x08	; 8
    1f0c:	0f b6       	in	r0, 0x3f	; 63
    1f0e:	f8 94       	cli
    1f10:	de bf       	out	0x3e, r29	; 62
    1f12:	0f be       	out	0x3f, r0	; 63
    1f14:	cd bf       	out	0x3d, r28	; 61
    1f16:	cf 91       	pop	r28
    1f18:	df 91       	pop	r29
    1f1a:	0f 91       	pop	r16
    1f1c:	08 95       	ret

00001f1e <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    1f1e:	df 93       	push	r29
    1f20:	cf 93       	push	r28
    1f22:	00 d0       	rcall	.+0      	; 0x1f24 <vStreamBufferDelete+0x6>
    1f24:	00 d0       	rcall	.+0      	; 0x1f26 <vStreamBufferDelete+0x8>
    1f26:	cd b7       	in	r28, 0x3d	; 61
    1f28:	de b7       	in	r29, 0x3e	; 62
    1f2a:	9c 83       	std	Y+4, r25	; 0x04
    1f2c:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    1f2e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f30:	9c 81       	ldd	r25, Y+4	; 0x04
    1f32:	9a 83       	std	Y+2, r25	; 0x02
    1f34:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    1f36:	e9 81       	ldd	r30, Y+1	; 0x01
    1f38:	fa 81       	ldd	r31, Y+2	; 0x02
    1f3a:	86 85       	ldd	r24, Z+14	; 0x0e
    1f3c:	88 2f       	mov	r24, r24
    1f3e:	90 e0       	ldi	r25, 0x00	; 0
    1f40:	82 70       	andi	r24, 0x02	; 2
    1f42:	90 70       	andi	r25, 0x00	; 0
    1f44:	00 97       	sbiw	r24, 0x00	; 0
    1f46:	29 f4       	brne	.+10     	; 0x1f52 <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    1f48:	89 81       	ldd	r24, Y+1	; 0x01
    1f4a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f4c:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <vPortFree>
    1f50:	08 c0       	rjmp	.+16     	; 0x1f62 <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    1f52:	89 81       	ldd	r24, Y+1	; 0x01
    1f54:	9a 81       	ldd	r25, Y+2	; 0x02
    1f56:	60 e0       	ldi	r22, 0x00	; 0
    1f58:	70 e0       	ldi	r23, 0x00	; 0
    1f5a:	4f e0       	ldi	r20, 0x0F	; 15
    1f5c:	50 e0       	ldi	r21, 0x00	; 0
    1f5e:	0e 94 42 28 	call	0x5084	; 0x5084 <memset>
	}
}
    1f62:	0f 90       	pop	r0
    1f64:	0f 90       	pop	r0
    1f66:	0f 90       	pop	r0
    1f68:	0f 90       	pop	r0
    1f6a:	cf 91       	pop	r28
    1f6c:	df 91       	pop	r29
    1f6e:	08 95       	ret

00001f70 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    1f70:	0f 93       	push	r16
    1f72:	df 93       	push	r29
    1f74:	cf 93       	push	r28
    1f76:	00 d0       	rcall	.+0      	; 0x1f78 <xStreamBufferReset+0x8>
    1f78:	00 d0       	rcall	.+0      	; 0x1f7a <xStreamBufferReset+0xa>
    1f7a:	0f 92       	push	r0
    1f7c:	cd b7       	in	r28, 0x3d	; 61
    1f7e:	de b7       	in	r29, 0x3e	; 62
    1f80:	9d 83       	std	Y+5, r25	; 0x05
    1f82:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    1f84:	8c 81       	ldd	r24, Y+4	; 0x04
    1f86:	9d 81       	ldd	r25, Y+5	; 0x05
    1f88:	9b 83       	std	Y+3, r25	; 0x03
    1f8a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    1f8c:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    1f8e:	0f b6       	in	r0, 0x3f	; 63
    1f90:	f8 94       	cli
    1f92:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    1f94:	ea 81       	ldd	r30, Y+2	; 0x02
    1f96:	fb 81       	ldd	r31, Y+3	; 0x03
    1f98:	80 85       	ldd	r24, Z+8	; 0x08
    1f9a:	91 85       	ldd	r25, Z+9	; 0x09
    1f9c:	00 97       	sbiw	r24, 0x00	; 0
    1f9e:	f1 f4       	brne	.+60     	; 0x1fdc <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    1fa0:	ea 81       	ldd	r30, Y+2	; 0x02
    1fa2:	fb 81       	ldd	r31, Y+3	; 0x03
    1fa4:	82 85       	ldd	r24, Z+10	; 0x0a
    1fa6:	93 85       	ldd	r25, Z+11	; 0x0b
    1fa8:	00 97       	sbiw	r24, 0x00	; 0
    1faa:	c1 f4       	brne	.+48     	; 0x1fdc <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    1fac:	ea 81       	ldd	r30, Y+2	; 0x02
    1fae:	fb 81       	ldd	r31, Y+3	; 0x03
    1fb0:	24 85       	ldd	r18, Z+12	; 0x0c
    1fb2:	35 85       	ldd	r19, Z+13	; 0x0d
    1fb4:	ea 81       	ldd	r30, Y+2	; 0x02
    1fb6:	fb 81       	ldd	r31, Y+3	; 0x03
    1fb8:	44 81       	ldd	r20, Z+4	; 0x04
    1fba:	55 81       	ldd	r21, Z+5	; 0x05
    1fbc:	ea 81       	ldd	r30, Y+2	; 0x02
    1fbe:	fb 81       	ldd	r31, Y+3	; 0x03
    1fc0:	a6 81       	ldd	r26, Z+6	; 0x06
    1fc2:	b7 81       	ldd	r27, Z+7	; 0x07
    1fc4:	ea 81       	ldd	r30, Y+2	; 0x02
    1fc6:	fb 81       	ldd	r31, Y+3	; 0x03
    1fc8:	e6 85       	ldd	r30, Z+14	; 0x0e
    1fca:	8a 81       	ldd	r24, Y+2	; 0x02
    1fcc:	9b 81       	ldd	r25, Y+3	; 0x03
    1fce:	b9 01       	movw	r22, r18
    1fd0:	9d 01       	movw	r18, r26
    1fd2:	0e 2f       	mov	r16, r30
    1fd4:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    1fd8:	81 e0       	ldi	r24, 0x01	; 1
    1fda:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    1fdc:	0f 90       	pop	r0
    1fde:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1fe0:	89 81       	ldd	r24, Y+1	; 0x01
}
    1fe2:	0f 90       	pop	r0
    1fe4:	0f 90       	pop	r0
    1fe6:	0f 90       	pop	r0
    1fe8:	0f 90       	pop	r0
    1fea:	0f 90       	pop	r0
    1fec:	cf 91       	pop	r28
    1fee:	df 91       	pop	r29
    1ff0:	0f 91       	pop	r16
    1ff2:	08 95       	ret

00001ff4 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    1ff4:	df 93       	push	r29
    1ff6:	cf 93       	push	r28
    1ff8:	cd b7       	in	r28, 0x3d	; 61
    1ffa:	de b7       	in	r29, 0x3e	; 62
    1ffc:	27 97       	sbiw	r28, 0x07	; 7
    1ffe:	0f b6       	in	r0, 0x3f	; 63
    2000:	f8 94       	cli
    2002:	de bf       	out	0x3e, r29	; 62
    2004:	0f be       	out	0x3f, r0	; 63
    2006:	cd bf       	out	0x3d, r28	; 61
    2008:	9d 83       	std	Y+5, r25	; 0x05
    200a:	8c 83       	std	Y+4, r24	; 0x04
    200c:	7f 83       	std	Y+7, r23	; 0x07
    200e:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2010:	8c 81       	ldd	r24, Y+4	; 0x04
    2012:	9d 81       	ldd	r25, Y+5	; 0x05
    2014:	9b 83       	std	Y+3, r25	; 0x03
    2016:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    2018:	8e 81       	ldd	r24, Y+6	; 0x06
    201a:	9f 81       	ldd	r25, Y+7	; 0x07
    201c:	00 97       	sbiw	r24, 0x00	; 0
    201e:	21 f4       	brne	.+8      	; 0x2028 <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    2020:	81 e0       	ldi	r24, 0x01	; 1
    2022:	90 e0       	ldi	r25, 0x00	; 0
    2024:	9f 83       	std	Y+7, r25	; 0x07
    2026:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    2028:	ea 81       	ldd	r30, Y+2	; 0x02
    202a:	fb 81       	ldd	r31, Y+3	; 0x03
    202c:	24 81       	ldd	r18, Z+4	; 0x04
    202e:	35 81       	ldd	r19, Z+5	; 0x05
    2030:	8e 81       	ldd	r24, Y+6	; 0x06
    2032:	9f 81       	ldd	r25, Y+7	; 0x07
    2034:	28 17       	cp	r18, r24
    2036:	39 07       	cpc	r19, r25
    2038:	48 f0       	brcs	.+18     	; 0x204c <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    203a:	ea 81       	ldd	r30, Y+2	; 0x02
    203c:	fb 81       	ldd	r31, Y+3	; 0x03
    203e:	8e 81       	ldd	r24, Y+6	; 0x06
    2040:	9f 81       	ldd	r25, Y+7	; 0x07
    2042:	97 83       	std	Z+7, r25	; 0x07
    2044:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    2046:	81 e0       	ldi	r24, 0x01	; 1
    2048:	89 83       	std	Y+1, r24	; 0x01
    204a:	01 c0       	rjmp	.+2      	; 0x204e <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    204c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    204e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2050:	27 96       	adiw	r28, 0x07	; 7
    2052:	0f b6       	in	r0, 0x3f	; 63
    2054:	f8 94       	cli
    2056:	de bf       	out	0x3e, r29	; 62
    2058:	0f be       	out	0x3f, r0	; 63
    205a:	cd bf       	out	0x3d, r28	; 61
    205c:	cf 91       	pop	r28
    205e:	df 91       	pop	r29
    2060:	08 95       	ret

00002062 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2062:	df 93       	push	r29
    2064:	cf 93       	push	r28
    2066:	00 d0       	rcall	.+0      	; 0x2068 <xStreamBufferSpacesAvailable+0x6>
    2068:	00 d0       	rcall	.+0      	; 0x206a <xStreamBufferSpacesAvailable+0x8>
    206a:	00 d0       	rcall	.+0      	; 0x206c <xStreamBufferSpacesAvailable+0xa>
    206c:	cd b7       	in	r28, 0x3d	; 61
    206e:	de b7       	in	r29, 0x3e	; 62
    2070:	9e 83       	std	Y+6, r25	; 0x06
    2072:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2074:	8d 81       	ldd	r24, Y+5	; 0x05
    2076:	9e 81       	ldd	r25, Y+6	; 0x06
    2078:	9c 83       	std	Y+4, r25	; 0x04
    207a:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    207c:	eb 81       	ldd	r30, Y+3	; 0x03
    207e:	fc 81       	ldd	r31, Y+4	; 0x04
    2080:	24 81       	ldd	r18, Z+4	; 0x04
    2082:	35 81       	ldd	r19, Z+5	; 0x05
    2084:	eb 81       	ldd	r30, Y+3	; 0x03
    2086:	fc 81       	ldd	r31, Y+4	; 0x04
    2088:	80 81       	ld	r24, Z
    208a:	91 81       	ldd	r25, Z+1	; 0x01
    208c:	82 0f       	add	r24, r18
    208e:	93 1f       	adc	r25, r19
    2090:	9a 83       	std	Y+2, r25	; 0x02
    2092:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    2094:	eb 81       	ldd	r30, Y+3	; 0x03
    2096:	fc 81       	ldd	r31, Y+4	; 0x04
    2098:	22 81       	ldd	r18, Z+2	; 0x02
    209a:	33 81       	ldd	r19, Z+3	; 0x03
    209c:	89 81       	ldd	r24, Y+1	; 0x01
    209e:	9a 81       	ldd	r25, Y+2	; 0x02
    20a0:	82 1b       	sub	r24, r18
    20a2:	93 0b       	sbc	r25, r19
    20a4:	9a 83       	std	Y+2, r25	; 0x02
    20a6:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    20a8:	89 81       	ldd	r24, Y+1	; 0x01
    20aa:	9a 81       	ldd	r25, Y+2	; 0x02
    20ac:	01 97       	sbiw	r24, 0x01	; 1
    20ae:	9a 83       	std	Y+2, r25	; 0x02
    20b0:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    20b2:	eb 81       	ldd	r30, Y+3	; 0x03
    20b4:	fc 81       	ldd	r31, Y+4	; 0x04
    20b6:	24 81       	ldd	r18, Z+4	; 0x04
    20b8:	35 81       	ldd	r19, Z+5	; 0x05
    20ba:	89 81       	ldd	r24, Y+1	; 0x01
    20bc:	9a 81       	ldd	r25, Y+2	; 0x02
    20be:	82 17       	cp	r24, r18
    20c0:	93 07       	cpc	r25, r19
    20c2:	50 f0       	brcs	.+20     	; 0x20d8 <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    20c4:	eb 81       	ldd	r30, Y+3	; 0x03
    20c6:	fc 81       	ldd	r31, Y+4	; 0x04
    20c8:	24 81       	ldd	r18, Z+4	; 0x04
    20ca:	35 81       	ldd	r19, Z+5	; 0x05
    20cc:	89 81       	ldd	r24, Y+1	; 0x01
    20ce:	9a 81       	ldd	r25, Y+2	; 0x02
    20d0:	82 1b       	sub	r24, r18
    20d2:	93 0b       	sbc	r25, r19
    20d4:	9a 83       	std	Y+2, r25	; 0x02
    20d6:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    20d8:	89 81       	ldd	r24, Y+1	; 0x01
    20da:	9a 81       	ldd	r25, Y+2	; 0x02
}
    20dc:	26 96       	adiw	r28, 0x06	; 6
    20de:	0f b6       	in	r0, 0x3f	; 63
    20e0:	f8 94       	cli
    20e2:	de bf       	out	0x3e, r29	; 62
    20e4:	0f be       	out	0x3f, r0	; 63
    20e6:	cd bf       	out	0x3d, r28	; 61
    20e8:	cf 91       	pop	r28
    20ea:	df 91       	pop	r29
    20ec:	08 95       	ret

000020ee <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    20ee:	df 93       	push	r29
    20f0:	cf 93       	push	r28
    20f2:	00 d0       	rcall	.+0      	; 0x20f4 <xStreamBufferBytesAvailable+0x6>
    20f4:	00 d0       	rcall	.+0      	; 0x20f6 <xStreamBufferBytesAvailable+0x8>
    20f6:	00 d0       	rcall	.+0      	; 0x20f8 <xStreamBufferBytesAvailable+0xa>
    20f8:	cd b7       	in	r28, 0x3d	; 61
    20fa:	de b7       	in	r29, 0x3e	; 62
    20fc:	9e 83       	std	Y+6, r25	; 0x06
    20fe:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2100:	8d 81       	ldd	r24, Y+5	; 0x05
    2102:	9e 81       	ldd	r25, Y+6	; 0x06
    2104:	9c 83       	std	Y+4, r25	; 0x04
    2106:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    2108:	8b 81       	ldd	r24, Y+3	; 0x03
    210a:	9c 81       	ldd	r25, Y+4	; 0x04
    210c:	0e 94 61 16 	call	0x2cc2	; 0x2cc2 <prvBytesInBuffer>
    2110:	9a 83       	std	Y+2, r25	; 0x02
    2112:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    2114:	89 81       	ldd	r24, Y+1	; 0x01
    2116:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2118:	26 96       	adiw	r28, 0x06	; 6
    211a:	0f b6       	in	r0, 0x3f	; 63
    211c:	f8 94       	cli
    211e:	de bf       	out	0x3e, r29	; 62
    2120:	0f be       	out	0x3f, r0	; 63
    2122:	cd bf       	out	0x3d, r28	; 61
    2124:	cf 91       	pop	r28
    2126:	df 91       	pop	r29
    2128:	08 95       	ret

0000212a <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    212a:	ef 92       	push	r14
    212c:	ff 92       	push	r15
    212e:	0f 93       	push	r16
    2130:	1f 93       	push	r17
    2132:	df 93       	push	r29
    2134:	cf 93       	push	r28
    2136:	cd b7       	in	r28, 0x3d	; 61
    2138:	de b7       	in	r29, 0x3e	; 62
    213a:	63 97       	sbiw	r28, 0x13	; 19
    213c:	0f b6       	in	r0, 0x3f	; 63
    213e:	f8 94       	cli
    2140:	de bf       	out	0x3e, r29	; 62
    2142:	0f be       	out	0x3f, r0	; 63
    2144:	cd bf       	out	0x3d, r28	; 61
    2146:	9d 87       	std	Y+13, r25	; 0x0d
    2148:	8c 87       	std	Y+12, r24	; 0x0c
    214a:	7f 87       	std	Y+15, r23	; 0x0f
    214c:	6e 87       	std	Y+14, r22	; 0x0e
    214e:	59 8b       	std	Y+17, r21	; 0x11
    2150:	48 8b       	std	Y+16, r20	; 0x10
    2152:	3b 8b       	std	Y+19, r19	; 0x13
    2154:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2156:	8c 85       	ldd	r24, Y+12	; 0x0c
    2158:	9d 85       	ldd	r25, Y+13	; 0x0d
    215a:	98 87       	std	Y+8, r25	; 0x08
    215c:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    215e:	1c 82       	std	Y+4, r1	; 0x04
    2160:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    2162:	88 89       	ldd	r24, Y+16	; 0x10
    2164:	99 89       	ldd	r25, Y+17	; 0x11
    2166:	9a 83       	std	Y+2, r25	; 0x02
    2168:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    216a:	ef 81       	ldd	r30, Y+7	; 0x07
    216c:	f8 85       	ldd	r31, Y+8	; 0x08
    216e:	86 85       	ldd	r24, Z+14	; 0x0e
    2170:	88 2f       	mov	r24, r24
    2172:	90 e0       	ldi	r25, 0x00	; 0
    2174:	81 70       	andi	r24, 0x01	; 1
    2176:	90 70       	andi	r25, 0x00	; 0
    2178:	88 23       	and	r24, r24
    217a:	29 f0       	breq	.+10     	; 0x2186 <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    217c:	89 81       	ldd	r24, Y+1	; 0x01
    217e:	9a 81       	ldd	r25, Y+2	; 0x02
    2180:	02 96       	adiw	r24, 0x02	; 2
    2182:	9a 83       	std	Y+2, r25	; 0x02
    2184:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    2186:	8a 89       	ldd	r24, Y+18	; 0x12
    2188:	9b 89       	ldd	r25, Y+19	; 0x13
    218a:	00 97       	sbiw	r24, 0x00	; 0
    218c:	09 f4       	brne	.+2      	; 0x2190 <xStreamBufferSend+0x66>
    218e:	40 c0       	rjmp	.+128    	; 0x2210 <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    2190:	ce 01       	movw	r24, r28
    2192:	09 96       	adiw	r24, 0x09	; 9
    2194:	0e 94 f0 1d 	call	0x3be0	; 0x3be0 <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    2198:	0f b6       	in	r0, 0x3f	; 63
    219a:	f8 94       	cli
    219c:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    219e:	8f 81       	ldd	r24, Y+7	; 0x07
    21a0:	98 85       	ldd	r25, Y+8	; 0x08
    21a2:	0e 94 31 10 	call	0x2062	; 0x2062 <xStreamBufferSpacesAvailable>
    21a6:	9c 83       	std	Y+4, r25	; 0x04
    21a8:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    21aa:	2b 81       	ldd	r18, Y+3	; 0x03
    21ac:	3c 81       	ldd	r19, Y+4	; 0x04
    21ae:	89 81       	ldd	r24, Y+1	; 0x01
    21b0:	9a 81       	ldd	r25, Y+2	; 0x02
    21b2:	28 17       	cp	r18, r24
    21b4:	39 07       	cpc	r19, r25
    21b6:	50 f5       	brcc	.+84     	; 0x220c <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    21b8:	80 e0       	ldi	r24, 0x00	; 0
    21ba:	90 e0       	ldi	r25, 0x00	; 0
    21bc:	0e 94 b8 22 	call	0x4570	; 0x4570 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    21c0:	0e 94 19 1f 	call	0x3e32	; 0x3e32 <xTaskGetCurrentTaskHandle>
    21c4:	ef 81       	ldd	r30, Y+7	; 0x07
    21c6:	f8 85       	ldd	r31, Y+8	; 0x08
    21c8:	93 87       	std	Z+11, r25	; 0x0b
    21ca:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    21cc:	0f 90       	pop	r0
    21ce:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    21d0:	ea 89       	ldd	r30, Y+18	; 0x12
    21d2:	fb 89       	ldd	r31, Y+19	; 0x13
    21d4:	60 e0       	ldi	r22, 0x00	; 0
    21d6:	70 e0       	ldi	r23, 0x00	; 0
    21d8:	80 e0       	ldi	r24, 0x00	; 0
    21da:	90 e0       	ldi	r25, 0x00	; 0
    21dc:	20 e0       	ldi	r18, 0x00	; 0
    21de:	30 e0       	ldi	r19, 0x00	; 0
    21e0:	40 e0       	ldi	r20, 0x00	; 0
    21e2:	50 e0       	ldi	r21, 0x00	; 0
    21e4:	00 e0       	ldi	r16, 0x00	; 0
    21e6:	10 e0       	ldi	r17, 0x00	; 0
    21e8:	7f 01       	movw	r14, r30
    21ea:	0e 94 c9 1f 	call	0x3f92	; 0x3f92 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    21ee:	ef 81       	ldd	r30, Y+7	; 0x07
    21f0:	f8 85       	ldd	r31, Y+8	; 0x08
    21f2:	13 86       	std	Z+11, r1	; 0x0b
    21f4:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    21f6:	ce 01       	movw	r24, r28
    21f8:	09 96       	adiw	r24, 0x09	; 9
    21fa:	9e 01       	movw	r18, r28
    21fc:	2e 5e       	subi	r18, 0xEE	; 238
    21fe:	3f 4f       	sbci	r19, 0xFF	; 255
    2200:	b9 01       	movw	r22, r18
    2202:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <xTaskCheckForTimeOut>
    2206:	88 23       	and	r24, r24
    2208:	39 f2       	breq	.-114    	; 0x2198 <xStreamBufferSend+0x6e>
    220a:	02 c0       	rjmp	.+4      	; 0x2210 <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    220c:	0f 90       	pop	r0
    220e:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    2210:	8b 81       	ldd	r24, Y+3	; 0x03
    2212:	9c 81       	ldd	r25, Y+4	; 0x04
    2214:	00 97       	sbiw	r24, 0x00	; 0
    2216:	31 f4       	brne	.+12     	; 0x2224 <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2218:	8f 81       	ldd	r24, Y+7	; 0x07
    221a:	98 85       	ldd	r25, Y+8	; 0x08
    221c:	0e 94 31 10 	call	0x2062	; 0x2062 <xStreamBufferSpacesAvailable>
    2220:	9c 83       	std	Y+4, r25	; 0x04
    2222:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2224:	8f 81       	ldd	r24, Y+7	; 0x07
    2226:	98 85       	ldd	r25, Y+8	; 0x08
    2228:	2e 85       	ldd	r18, Y+14	; 0x0e
    222a:	3f 85       	ldd	r19, Y+15	; 0x0f
    222c:	48 89       	ldd	r20, Y+16	; 0x10
    222e:	59 89       	ldd	r21, Y+17	; 0x11
    2230:	eb 81       	ldd	r30, Y+3	; 0x03
    2232:	fc 81       	ldd	r31, Y+4	; 0x04
    2234:	a9 81       	ldd	r26, Y+1	; 0x01
    2236:	ba 81       	ldd	r27, Y+2	; 0x02
    2238:	b9 01       	movw	r22, r18
    223a:	9f 01       	movw	r18, r30
    223c:	8d 01       	movw	r16, r26
    223e:	0e 94 da 11 	call	0x23b4	; 0x23b4 <prvWriteMessageToBuffer>
    2242:	9e 83       	std	Y+6, r25	; 0x06
    2244:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    2246:	8d 81       	ldd	r24, Y+5	; 0x05
    2248:	9e 81       	ldd	r25, Y+6	; 0x06
    224a:	00 97       	sbiw	r24, 0x00	; 0
    224c:	39 f1       	breq	.+78     	; 0x229c <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    224e:	8f 81       	ldd	r24, Y+7	; 0x07
    2250:	98 85       	ldd	r25, Y+8	; 0x08
    2252:	0e 94 61 16 	call	0x2cc2	; 0x2cc2 <prvBytesInBuffer>
    2256:	9c 01       	movw	r18, r24
    2258:	ef 81       	ldd	r30, Y+7	; 0x07
    225a:	f8 85       	ldd	r31, Y+8	; 0x08
    225c:	86 81       	ldd	r24, Z+6	; 0x06
    225e:	97 81       	ldd	r25, Z+7	; 0x07
    2260:	28 17       	cp	r18, r24
    2262:	39 07       	cpc	r19, r25
    2264:	d8 f0       	brcs	.+54     	; 0x229c <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    2266:	0e 94 b8 1a 	call	0x3570	; 0x3570 <vTaskSuspendAll>
    226a:	ef 81       	ldd	r30, Y+7	; 0x07
    226c:	f8 85       	ldd	r31, Y+8	; 0x08
    226e:	80 85       	ldd	r24, Z+8	; 0x08
    2270:	91 85       	ldd	r25, Z+9	; 0x09
    2272:	00 97       	sbiw	r24, 0x00	; 0
    2274:	89 f0       	breq	.+34     	; 0x2298 <xStreamBufferSend+0x16e>
    2276:	ef 81       	ldd	r30, Y+7	; 0x07
    2278:	f8 85       	ldd	r31, Y+8	; 0x08
    227a:	80 85       	ldd	r24, Z+8	; 0x08
    227c:	91 85       	ldd	r25, Z+9	; 0x09
    227e:	40 e0       	ldi	r20, 0x00	; 0
    2280:	50 e0       	ldi	r21, 0x00	; 0
    2282:	60 e0       	ldi	r22, 0x00	; 0
    2284:	70 e0       	ldi	r23, 0x00	; 0
    2286:	20 e0       	ldi	r18, 0x00	; 0
    2288:	00 e0       	ldi	r16, 0x00	; 0
    228a:	10 e0       	ldi	r17, 0x00	; 0
    228c:	0e 94 65 20 	call	0x40ca	; 0x40ca <xTaskGenericNotify>
    2290:	ef 81       	ldd	r30, Y+7	; 0x07
    2292:	f8 85       	ldd	r31, Y+8	; 0x08
    2294:	11 86       	std	Z+9, r1	; 0x09
    2296:	10 86       	std	Z+8, r1	; 0x08
    2298:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    229c:	8d 81       	ldd	r24, Y+5	; 0x05
    229e:	9e 81       	ldd	r25, Y+6	; 0x06
}
    22a0:	63 96       	adiw	r28, 0x13	; 19
    22a2:	0f b6       	in	r0, 0x3f	; 63
    22a4:	f8 94       	cli
    22a6:	de bf       	out	0x3e, r29	; 62
    22a8:	0f be       	out	0x3f, r0	; 63
    22aa:	cd bf       	out	0x3d, r28	; 61
    22ac:	cf 91       	pop	r28
    22ae:	df 91       	pop	r29
    22b0:	1f 91       	pop	r17
    22b2:	0f 91       	pop	r16
    22b4:	ff 90       	pop	r15
    22b6:	ef 90       	pop	r14
    22b8:	08 95       	ret

000022ba <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    22ba:	ef 92       	push	r14
    22bc:	ff 92       	push	r15
    22be:	0f 93       	push	r16
    22c0:	1f 93       	push	r17
    22c2:	df 93       	push	r29
    22c4:	cf 93       	push	r28
    22c6:	cd b7       	in	r28, 0x3d	; 61
    22c8:	de b7       	in	r29, 0x3e	; 62
    22ca:	61 97       	sbiw	r28, 0x11	; 17
    22cc:	0f b6       	in	r0, 0x3f	; 63
    22ce:	f8 94       	cli
    22d0:	de bf       	out	0x3e, r29	; 62
    22d2:	0f be       	out	0x3f, r0	; 63
    22d4:	cd bf       	out	0x3d, r28	; 61
    22d6:	9b 87       	std	Y+11, r25	; 0x0b
    22d8:	8a 87       	std	Y+10, r24	; 0x0a
    22da:	7d 87       	std	Y+13, r23	; 0x0d
    22dc:	6c 87       	std	Y+12, r22	; 0x0c
    22de:	5f 87       	std	Y+15, r21	; 0x0f
    22e0:	4e 87       	std	Y+14, r20	; 0x0e
    22e2:	39 8b       	std	Y+17, r19	; 0x11
    22e4:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    22e6:	8a 85       	ldd	r24, Y+10	; 0x0a
    22e8:	9b 85       	ldd	r25, Y+11	; 0x0b
    22ea:	99 87       	std	Y+9, r25	; 0x09
    22ec:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    22ee:	8e 85       	ldd	r24, Y+14	; 0x0e
    22f0:	9f 85       	ldd	r25, Y+15	; 0x0f
    22f2:	9b 83       	std	Y+3, r25	; 0x03
    22f4:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    22f6:	e8 85       	ldd	r30, Y+8	; 0x08
    22f8:	f9 85       	ldd	r31, Y+9	; 0x09
    22fa:	86 85       	ldd	r24, Z+14	; 0x0e
    22fc:	88 2f       	mov	r24, r24
    22fe:	90 e0       	ldi	r25, 0x00	; 0
    2300:	81 70       	andi	r24, 0x01	; 1
    2302:	90 70       	andi	r25, 0x00	; 0
    2304:	88 23       	and	r24, r24
    2306:	29 f0       	breq	.+10     	; 0x2312 <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2308:	8a 81       	ldd	r24, Y+2	; 0x02
    230a:	9b 81       	ldd	r25, Y+3	; 0x03
    230c:	02 96       	adiw	r24, 0x02	; 2
    230e:	9b 83       	std	Y+3, r25	; 0x03
    2310:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2312:	88 85       	ldd	r24, Y+8	; 0x08
    2314:	99 85       	ldd	r25, Y+9	; 0x09
    2316:	0e 94 31 10 	call	0x2062	; 0x2062 <xStreamBufferSpacesAvailable>
    231a:	9d 83       	std	Y+5, r25	; 0x05
    231c:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    231e:	88 85       	ldd	r24, Y+8	; 0x08
    2320:	99 85       	ldd	r25, Y+9	; 0x09
    2322:	2c 85       	ldd	r18, Y+12	; 0x0c
    2324:	3d 85       	ldd	r19, Y+13	; 0x0d
    2326:	4e 85       	ldd	r20, Y+14	; 0x0e
    2328:	5f 85       	ldd	r21, Y+15	; 0x0f
    232a:	ec 81       	ldd	r30, Y+4	; 0x04
    232c:	fd 81       	ldd	r31, Y+5	; 0x05
    232e:	aa 81       	ldd	r26, Y+2	; 0x02
    2330:	bb 81       	ldd	r27, Y+3	; 0x03
    2332:	b9 01       	movw	r22, r18
    2334:	9f 01       	movw	r18, r30
    2336:	8d 01       	movw	r16, r26
    2338:	0e 94 da 11 	call	0x23b4	; 0x23b4 <prvWriteMessageToBuffer>
    233c:	9f 83       	std	Y+7, r25	; 0x07
    233e:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    2340:	8e 81       	ldd	r24, Y+6	; 0x06
    2342:	9f 81       	ldd	r25, Y+7	; 0x07
    2344:	00 97       	sbiw	r24, 0x00	; 0
    2346:	39 f1       	breq	.+78     	; 0x2396 <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2348:	88 85       	ldd	r24, Y+8	; 0x08
    234a:	99 85       	ldd	r25, Y+9	; 0x09
    234c:	0e 94 61 16 	call	0x2cc2	; 0x2cc2 <prvBytesInBuffer>
    2350:	9c 01       	movw	r18, r24
    2352:	e8 85       	ldd	r30, Y+8	; 0x08
    2354:	f9 85       	ldd	r31, Y+9	; 0x09
    2356:	86 81       	ldd	r24, Z+6	; 0x06
    2358:	97 81       	ldd	r25, Z+7	; 0x07
    235a:	28 17       	cp	r18, r24
    235c:	39 07       	cpc	r19, r25
    235e:	d8 f0       	brcs	.+54     	; 0x2396 <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    2360:	19 82       	std	Y+1, r1	; 0x01
    2362:	e8 85       	ldd	r30, Y+8	; 0x08
    2364:	f9 85       	ldd	r31, Y+9	; 0x09
    2366:	80 85       	ldd	r24, Z+8	; 0x08
    2368:	91 85       	ldd	r25, Z+9	; 0x09
    236a:	00 97       	sbiw	r24, 0x00	; 0
    236c:	a1 f0       	breq	.+40     	; 0x2396 <xStreamBufferSendFromISR+0xdc>
    236e:	e8 85       	ldd	r30, Y+8	; 0x08
    2370:	f9 85       	ldd	r31, Y+9	; 0x09
    2372:	80 85       	ldd	r24, Z+8	; 0x08
    2374:	91 85       	ldd	r25, Z+9	; 0x09
    2376:	e8 89       	ldd	r30, Y+16	; 0x10
    2378:	f9 89       	ldd	r31, Y+17	; 0x11
    237a:	40 e0       	ldi	r20, 0x00	; 0
    237c:	50 e0       	ldi	r21, 0x00	; 0
    237e:	60 e0       	ldi	r22, 0x00	; 0
    2380:	70 e0       	ldi	r23, 0x00	; 0
    2382:	20 e0       	ldi	r18, 0x00	; 0
    2384:	00 e0       	ldi	r16, 0x00	; 0
    2386:	10 e0       	ldi	r17, 0x00	; 0
    2388:	7f 01       	movw	r14, r30
    238a:	0e 94 3a 21 	call	0x4274	; 0x4274 <xTaskGenericNotifyFromISR>
    238e:	e8 85       	ldd	r30, Y+8	; 0x08
    2390:	f9 85       	ldd	r31, Y+9	; 0x09
    2392:	11 86       	std	Z+9, r1	; 0x09
    2394:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    2396:	8e 81       	ldd	r24, Y+6	; 0x06
    2398:	9f 81       	ldd	r25, Y+7	; 0x07
}
    239a:	61 96       	adiw	r28, 0x11	; 17
    239c:	0f b6       	in	r0, 0x3f	; 63
    239e:	f8 94       	cli
    23a0:	de bf       	out	0x3e, r29	; 62
    23a2:	0f be       	out	0x3f, r0	; 63
    23a4:	cd bf       	out	0x3d, r28	; 61
    23a6:	cf 91       	pop	r28
    23a8:	df 91       	pop	r29
    23aa:	1f 91       	pop	r17
    23ac:	0f 91       	pop	r16
    23ae:	ff 90       	pop	r15
    23b0:	ef 90       	pop	r14
    23b2:	08 95       	ret

000023b4 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    23b4:	0f 93       	push	r16
    23b6:	1f 93       	push	r17
    23b8:	df 93       	push	r29
    23ba:	cf 93       	push	r28
    23bc:	cd b7       	in	r28, 0x3d	; 61
    23be:	de b7       	in	r29, 0x3e	; 62
    23c0:	61 97       	sbiw	r28, 0x11	; 17
    23c2:	0f b6       	in	r0, 0x3f	; 63
    23c4:	f8 94       	cli
    23c6:	de bf       	out	0x3e, r29	; 62
    23c8:	0f be       	out	0x3f, r0	; 63
    23ca:	cd bf       	out	0x3d, r28	; 61
    23cc:	9d 83       	std	Y+5, r25	; 0x05
    23ce:	8c 83       	std	Y+4, r24	; 0x04
    23d0:	7f 83       	std	Y+7, r23	; 0x07
    23d2:	6e 83       	std	Y+6, r22	; 0x06
    23d4:	59 87       	std	Y+9, r21	; 0x09
    23d6:	48 87       	std	Y+8, r20	; 0x08
    23d8:	3b 87       	std	Y+11, r19	; 0x0b
    23da:	2a 87       	std	Y+10, r18	; 0x0a
    23dc:	1d 87       	std	Y+13, r17	; 0x0d
    23de:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    23e0:	8a 85       	ldd	r24, Y+10	; 0x0a
    23e2:	9b 85       	ldd	r25, Y+11	; 0x0b
    23e4:	00 97       	sbiw	r24, 0x00	; 0
    23e6:	11 f4       	brne	.+4      	; 0x23ec <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    23e8:	1b 82       	std	Y+3, r1	; 0x03
    23ea:	38 c0       	rjmp	.+112    	; 0x245c <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    23ec:	ec 81       	ldd	r30, Y+4	; 0x04
    23ee:	fd 81       	ldd	r31, Y+5	; 0x05
    23f0:	86 85       	ldd	r24, Z+14	; 0x0e
    23f2:	88 2f       	mov	r24, r24
    23f4:	90 e0       	ldi	r25, 0x00	; 0
    23f6:	81 70       	andi	r24, 0x01	; 1
    23f8:	90 70       	andi	r25, 0x00	; 0
    23fa:	00 97       	sbiw	r24, 0x00	; 0
    23fc:	d1 f4       	brne	.+52     	; 0x2432 <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    23fe:	81 e0       	ldi	r24, 0x01	; 1
    2400:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    2402:	28 85       	ldd	r18, Y+8	; 0x08
    2404:	39 85       	ldd	r19, Y+9	; 0x09
    2406:	39 8b       	std	Y+17, r19	; 0x11
    2408:	28 8b       	std	Y+16, r18	; 0x10
    240a:	8a 85       	ldd	r24, Y+10	; 0x0a
    240c:	9b 85       	ldd	r25, Y+11	; 0x0b
    240e:	9f 87       	std	Y+15, r25	; 0x0f
    2410:	8e 87       	std	Y+14, r24	; 0x0e
    2412:	2e 85       	ldd	r18, Y+14	; 0x0e
    2414:	3f 85       	ldd	r19, Y+15	; 0x0f
    2416:	88 89       	ldd	r24, Y+16	; 0x10
    2418:	99 89       	ldd	r25, Y+17	; 0x11
    241a:	82 17       	cp	r24, r18
    241c:	93 07       	cpc	r25, r19
    241e:	20 f4       	brcc	.+8      	; 0x2428 <prvWriteMessageToBuffer+0x74>
    2420:	28 89       	ldd	r18, Y+16	; 0x10
    2422:	39 89       	ldd	r19, Y+17	; 0x11
    2424:	3f 87       	std	Y+15, r19	; 0x0f
    2426:	2e 87       	std	Y+14, r18	; 0x0e
    2428:	8e 85       	ldd	r24, Y+14	; 0x0e
    242a:	9f 85       	ldd	r25, Y+15	; 0x0f
    242c:	99 87       	std	Y+9, r25	; 0x09
    242e:	88 87       	std	Y+8, r24	; 0x08
    2430:	15 c0       	rjmp	.+42     	; 0x245c <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    2432:	2a 85       	ldd	r18, Y+10	; 0x0a
    2434:	3b 85       	ldd	r19, Y+11	; 0x0b
    2436:	8c 85       	ldd	r24, Y+12	; 0x0c
    2438:	9d 85       	ldd	r25, Y+13	; 0x0d
    243a:	28 17       	cp	r18, r24
    243c:	39 07       	cpc	r19, r25
    243e:	68 f0       	brcs	.+26     	; 0x245a <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    2440:	81 e0       	ldi	r24, 0x01	; 1
    2442:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    2444:	9e 01       	movw	r18, r28
    2446:	28 5f       	subi	r18, 0xF8	; 248
    2448:	3f 4f       	sbci	r19, 0xFF	; 255
    244a:	8c 81       	ldd	r24, Y+4	; 0x04
    244c:	9d 81       	ldd	r25, Y+5	; 0x05
    244e:	b9 01       	movw	r22, r18
    2450:	42 e0       	ldi	r20, 0x02	; 2
    2452:	50 e0       	ldi	r21, 0x00	; 0
    2454:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <prvWriteBytesToBuffer>
    2458:	01 c0       	rjmp	.+2      	; 0x245c <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    245a:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    245c:	8b 81       	ldd	r24, Y+3	; 0x03
    245e:	88 23       	and	r24, r24
    2460:	61 f0       	breq	.+24     	; 0x247a <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    2462:	2e 81       	ldd	r18, Y+6	; 0x06
    2464:	3f 81       	ldd	r19, Y+7	; 0x07
    2466:	48 85       	ldd	r20, Y+8	; 0x08
    2468:	59 85       	ldd	r21, Y+9	; 0x09
    246a:	8c 81       	ldd	r24, Y+4	; 0x04
    246c:	9d 81       	ldd	r25, Y+5	; 0x05
    246e:	b9 01       	movw	r22, r18
    2470:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <prvWriteBytesToBuffer>
    2474:	9a 83       	std	Y+2, r25	; 0x02
    2476:	89 83       	std	Y+1, r24	; 0x01
    2478:	02 c0       	rjmp	.+4      	; 0x247e <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    247a:	1a 82       	std	Y+2, r1	; 0x02
    247c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    247e:	89 81       	ldd	r24, Y+1	; 0x01
    2480:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2482:	61 96       	adiw	r28, 0x11	; 17
    2484:	0f b6       	in	r0, 0x3f	; 63
    2486:	f8 94       	cli
    2488:	de bf       	out	0x3e, r29	; 62
    248a:	0f be       	out	0x3f, r0	; 63
    248c:	cd bf       	out	0x3d, r28	; 61
    248e:	cf 91       	pop	r28
    2490:	df 91       	pop	r29
    2492:	1f 91       	pop	r17
    2494:	0f 91       	pop	r16
    2496:	08 95       	ret

00002498 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    2498:	ef 92       	push	r14
    249a:	ff 92       	push	r15
    249c:	0f 93       	push	r16
    249e:	1f 93       	push	r17
    24a0:	df 93       	push	r29
    24a2:	cf 93       	push	r28
    24a4:	cd b7       	in	r28, 0x3d	; 61
    24a6:	de b7       	in	r29, 0x3e	; 62
    24a8:	60 97       	sbiw	r28, 0x10	; 16
    24aa:	0f b6       	in	r0, 0x3f	; 63
    24ac:	f8 94       	cli
    24ae:	de bf       	out	0x3e, r29	; 62
    24b0:	0f be       	out	0x3f, r0	; 63
    24b2:	cd bf       	out	0x3d, r28	; 61
    24b4:	9a 87       	std	Y+10, r25	; 0x0a
    24b6:	89 87       	std	Y+9, r24	; 0x09
    24b8:	7c 87       	std	Y+12, r23	; 0x0c
    24ba:	6b 87       	std	Y+11, r22	; 0x0b
    24bc:	5e 87       	std	Y+14, r21	; 0x0e
    24be:	4d 87       	std	Y+13, r20	; 0x0d
    24c0:	38 8b       	std	Y+16, r19	; 0x10
    24c2:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    24c4:	89 85       	ldd	r24, Y+9	; 0x09
    24c6:	9a 85       	ldd	r25, Y+10	; 0x0a
    24c8:	98 87       	std	Y+8, r25	; 0x08
    24ca:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    24cc:	1e 82       	std	Y+6, r1	; 0x06
    24ce:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    24d0:	ef 81       	ldd	r30, Y+7	; 0x07
    24d2:	f8 85       	ldd	r31, Y+8	; 0x08
    24d4:	86 85       	ldd	r24, Z+14	; 0x0e
    24d6:	88 2f       	mov	r24, r24
    24d8:	90 e0       	ldi	r25, 0x00	; 0
    24da:	81 70       	andi	r24, 0x01	; 1
    24dc:	90 70       	andi	r25, 0x00	; 0
    24de:	88 23       	and	r24, r24
    24e0:	29 f0       	breq	.+10     	; 0x24ec <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    24e2:	82 e0       	ldi	r24, 0x02	; 2
    24e4:	90 e0       	ldi	r25, 0x00	; 0
    24e6:	9a 83       	std	Y+2, r25	; 0x02
    24e8:	89 83       	std	Y+1, r24	; 0x01
    24ea:	02 c0       	rjmp	.+4      	; 0x24f0 <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    24ec:	1a 82       	std	Y+2, r1	; 0x02
    24ee:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    24f0:	8f 85       	ldd	r24, Y+15	; 0x0f
    24f2:	98 89       	ldd	r25, Y+16	; 0x10
    24f4:	00 97       	sbiw	r24, 0x00	; 0
    24f6:	09 f4       	brne	.+2      	; 0x24fa <xStreamBufferReceive+0x62>
    24f8:	3d c0       	rjmp	.+122    	; 0x2574 <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    24fa:	0f b6       	in	r0, 0x3f	; 63
    24fc:	f8 94       	cli
    24fe:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2500:	8f 81       	ldd	r24, Y+7	; 0x07
    2502:	98 85       	ldd	r25, Y+8	; 0x08
    2504:	0e 94 61 16 	call	0x2cc2	; 0x2cc2 <prvBytesInBuffer>
    2508:	9c 83       	std	Y+4, r25	; 0x04
    250a:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    250c:	2b 81       	ldd	r18, Y+3	; 0x03
    250e:	3c 81       	ldd	r19, Y+4	; 0x04
    2510:	89 81       	ldd	r24, Y+1	; 0x01
    2512:	9a 81       	ldd	r25, Y+2	; 0x02
    2514:	82 17       	cp	r24, r18
    2516:	93 07       	cpc	r25, r19
    2518:	50 f0       	brcs	.+20     	; 0x252e <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    251a:	80 e0       	ldi	r24, 0x00	; 0
    251c:	90 e0       	ldi	r25, 0x00	; 0
    251e:	0e 94 b8 22 	call	0x4570	; 0x4570 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    2522:	0e 94 19 1f 	call	0x3e32	; 0x3e32 <xTaskGetCurrentTaskHandle>
    2526:	ef 81       	ldd	r30, Y+7	; 0x07
    2528:	f8 85       	ldd	r31, Y+8	; 0x08
    252a:	91 87       	std	Z+9, r25	; 0x09
    252c:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    252e:	0f 90       	pop	r0
    2530:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    2532:	2b 81       	ldd	r18, Y+3	; 0x03
    2534:	3c 81       	ldd	r19, Y+4	; 0x04
    2536:	89 81       	ldd	r24, Y+1	; 0x01
    2538:	9a 81       	ldd	r25, Y+2	; 0x02
    253a:	82 17       	cp	r24, r18
    253c:	93 07       	cpc	r25, r19
    253e:	00 f1       	brcs	.+64     	; 0x2580 <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    2540:	ef 85       	ldd	r30, Y+15	; 0x0f
    2542:	f8 89       	ldd	r31, Y+16	; 0x10
    2544:	60 e0       	ldi	r22, 0x00	; 0
    2546:	70 e0       	ldi	r23, 0x00	; 0
    2548:	80 e0       	ldi	r24, 0x00	; 0
    254a:	90 e0       	ldi	r25, 0x00	; 0
    254c:	20 e0       	ldi	r18, 0x00	; 0
    254e:	30 e0       	ldi	r19, 0x00	; 0
    2550:	40 e0       	ldi	r20, 0x00	; 0
    2552:	50 e0       	ldi	r21, 0x00	; 0
    2554:	00 e0       	ldi	r16, 0x00	; 0
    2556:	10 e0       	ldi	r17, 0x00	; 0
    2558:	7f 01       	movw	r14, r30
    255a:	0e 94 c9 1f 	call	0x3f92	; 0x3f92 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    255e:	ef 81       	ldd	r30, Y+7	; 0x07
    2560:	f8 85       	ldd	r31, Y+8	; 0x08
    2562:	11 86       	std	Z+9, r1	; 0x09
    2564:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2566:	8f 81       	ldd	r24, Y+7	; 0x07
    2568:	98 85       	ldd	r25, Y+8	; 0x08
    256a:	0e 94 61 16 	call	0x2cc2	; 0x2cc2 <prvBytesInBuffer>
    256e:	9c 83       	std	Y+4, r25	; 0x04
    2570:	8b 83       	std	Y+3, r24	; 0x03
    2572:	06 c0       	rjmp	.+12     	; 0x2580 <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2574:	8f 81       	ldd	r24, Y+7	; 0x07
    2576:	98 85       	ldd	r25, Y+8	; 0x08
    2578:	0e 94 61 16 	call	0x2cc2	; 0x2cc2 <prvBytesInBuffer>
    257c:	9c 83       	std	Y+4, r25	; 0x04
    257e:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    2580:	2b 81       	ldd	r18, Y+3	; 0x03
    2582:	3c 81       	ldd	r19, Y+4	; 0x04
    2584:	89 81       	ldd	r24, Y+1	; 0x01
    2586:	9a 81       	ldd	r25, Y+2	; 0x02
    2588:	82 17       	cp	r24, r18
    258a:	93 07       	cpc	r25, r19
    258c:	80 f5       	brcc	.+96     	; 0x25ee <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    258e:	8f 81       	ldd	r24, Y+7	; 0x07
    2590:	98 85       	ldd	r25, Y+8	; 0x08
    2592:	2b 85       	ldd	r18, Y+11	; 0x0b
    2594:	3c 85       	ldd	r19, Y+12	; 0x0c
    2596:	4d 85       	ldd	r20, Y+13	; 0x0d
    2598:	5e 85       	ldd	r21, Y+14	; 0x0e
    259a:	eb 81       	ldd	r30, Y+3	; 0x03
    259c:	fc 81       	ldd	r31, Y+4	; 0x04
    259e:	a9 81       	ldd	r26, Y+1	; 0x01
    25a0:	ba 81       	ldd	r27, Y+2	; 0x02
    25a2:	b9 01       	movw	r22, r18
    25a4:	9f 01       	movw	r18, r30
    25a6:	8d 01       	movw	r16, r26
    25a8:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <prvReadMessageFromBuffer>
    25ac:	9e 83       	std	Y+6, r25	; 0x06
    25ae:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    25b0:	8d 81       	ldd	r24, Y+5	; 0x05
    25b2:	9e 81       	ldd	r25, Y+6	; 0x06
    25b4:	00 97       	sbiw	r24, 0x00	; 0
    25b6:	d9 f0       	breq	.+54     	; 0x25ee <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    25b8:	0e 94 b8 1a 	call	0x3570	; 0x3570 <vTaskSuspendAll>
    25bc:	ef 81       	ldd	r30, Y+7	; 0x07
    25be:	f8 85       	ldd	r31, Y+8	; 0x08
    25c0:	82 85       	ldd	r24, Z+10	; 0x0a
    25c2:	93 85       	ldd	r25, Z+11	; 0x0b
    25c4:	00 97       	sbiw	r24, 0x00	; 0
    25c6:	89 f0       	breq	.+34     	; 0x25ea <xStreamBufferReceive+0x152>
    25c8:	ef 81       	ldd	r30, Y+7	; 0x07
    25ca:	f8 85       	ldd	r31, Y+8	; 0x08
    25cc:	82 85       	ldd	r24, Z+10	; 0x0a
    25ce:	93 85       	ldd	r25, Z+11	; 0x0b
    25d0:	40 e0       	ldi	r20, 0x00	; 0
    25d2:	50 e0       	ldi	r21, 0x00	; 0
    25d4:	60 e0       	ldi	r22, 0x00	; 0
    25d6:	70 e0       	ldi	r23, 0x00	; 0
    25d8:	20 e0       	ldi	r18, 0x00	; 0
    25da:	00 e0       	ldi	r16, 0x00	; 0
    25dc:	10 e0       	ldi	r17, 0x00	; 0
    25de:	0e 94 65 20 	call	0x40ca	; 0x40ca <xTaskGenericNotify>
    25e2:	ef 81       	ldd	r30, Y+7	; 0x07
    25e4:	f8 85       	ldd	r31, Y+8	; 0x08
    25e6:	13 86       	std	Z+11, r1	; 0x0b
    25e8:	12 86       	std	Z+10, r1	; 0x0a
    25ea:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    25ee:	8d 81       	ldd	r24, Y+5	; 0x05
    25f0:	9e 81       	ldd	r25, Y+6	; 0x06
}
    25f2:	60 96       	adiw	r28, 0x10	; 16
    25f4:	0f b6       	in	r0, 0x3f	; 63
    25f6:	f8 94       	cli
    25f8:	de bf       	out	0x3e, r29	; 62
    25fa:	0f be       	out	0x3f, r0	; 63
    25fc:	cd bf       	out	0x3d, r28	; 61
    25fe:	cf 91       	pop	r28
    2600:	df 91       	pop	r29
    2602:	1f 91       	pop	r17
    2604:	0f 91       	pop	r16
    2606:	ff 90       	pop	r15
    2608:	ef 90       	pop	r14
    260a:	08 95       	ret

0000260c <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    260c:	df 93       	push	r29
    260e:	cf 93       	push	r28
    2610:	cd b7       	in	r28, 0x3d	; 61
    2612:	de b7       	in	r29, 0x3e	; 62
    2614:	2c 97       	sbiw	r28, 0x0c	; 12
    2616:	0f b6       	in	r0, 0x3f	; 63
    2618:	f8 94       	cli
    261a:	de bf       	out	0x3e, r29	; 62
    261c:	0f be       	out	0x3f, r0	; 63
    261e:	cd bf       	out	0x3d, r28	; 61
    2620:	9c 87       	std	Y+12, r25	; 0x0c
    2622:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2624:	8b 85       	ldd	r24, Y+11	; 0x0b
    2626:	9c 85       	ldd	r25, Y+12	; 0x0c
    2628:	98 87       	std	Y+8, r25	; 0x08
    262a:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    262c:	ef 81       	ldd	r30, Y+7	; 0x07
    262e:	f8 85       	ldd	r31, Y+8	; 0x08
    2630:	86 85       	ldd	r24, Z+14	; 0x0e
    2632:	88 2f       	mov	r24, r24
    2634:	90 e0       	ldi	r25, 0x00	; 0
    2636:	81 70       	andi	r24, 0x01	; 1
    2638:	90 70       	andi	r25, 0x00	; 0
    263a:	88 23       	and	r24, r24
    263c:	61 f1       	breq	.+88     	; 0x2696 <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    263e:	8f 81       	ldd	r24, Y+7	; 0x07
    2640:	98 85       	ldd	r25, Y+8	; 0x08
    2642:	0e 94 61 16 	call	0x2cc2	; 0x2cc2 <prvBytesInBuffer>
    2646:	9c 83       	std	Y+4, r25	; 0x04
    2648:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    264a:	8b 81       	ldd	r24, Y+3	; 0x03
    264c:	9c 81       	ldd	r25, Y+4	; 0x04
    264e:	83 30       	cpi	r24, 0x03	; 3
    2650:	91 05       	cpc	r25, r1
    2652:	f0 f0       	brcs	.+60     	; 0x2690 <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    2654:	ef 81       	ldd	r30, Y+7	; 0x07
    2656:	f8 85       	ldd	r31, Y+8	; 0x08
    2658:	80 81       	ld	r24, Z
    265a:	91 81       	ldd	r25, Z+1	; 0x01
    265c:	9a 83       	std	Y+2, r25	; 0x02
    265e:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    2660:	9e 01       	movw	r18, r28
    2662:	27 5f       	subi	r18, 0xF7	; 247
    2664:	3f 4f       	sbci	r19, 0xFF	; 255
    2666:	8f 81       	ldd	r24, Y+7	; 0x07
    2668:	98 85       	ldd	r25, Y+8	; 0x08
    266a:	eb 81       	ldd	r30, Y+3	; 0x03
    266c:	fc 81       	ldd	r31, Y+4	; 0x04
    266e:	b9 01       	movw	r22, r18
    2670:	42 e0       	ldi	r20, 0x02	; 2
    2672:	50 e0       	ldi	r21, 0x00	; 0
    2674:	9f 01       	movw	r18, r30
    2676:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    267a:	89 85       	ldd	r24, Y+9	; 0x09
    267c:	9a 85       	ldd	r25, Y+10	; 0x0a
    267e:	9e 83       	std	Y+6, r25	; 0x06
    2680:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    2682:	ef 81       	ldd	r30, Y+7	; 0x07
    2684:	f8 85       	ldd	r31, Y+8	; 0x08
    2686:	89 81       	ldd	r24, Y+1	; 0x01
    2688:	9a 81       	ldd	r25, Y+2	; 0x02
    268a:	91 83       	std	Z+1, r25	; 0x01
    268c:	80 83       	st	Z, r24
    268e:	05 c0       	rjmp	.+10     	; 0x269a <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    2690:	1e 82       	std	Y+6, r1	; 0x06
    2692:	1d 82       	std	Y+5, r1	; 0x05
    2694:	02 c0       	rjmp	.+4      	; 0x269a <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    2696:	1e 82       	std	Y+6, r1	; 0x06
    2698:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    269a:	8d 81       	ldd	r24, Y+5	; 0x05
    269c:	9e 81       	ldd	r25, Y+6	; 0x06
}
    269e:	2c 96       	adiw	r28, 0x0c	; 12
    26a0:	0f b6       	in	r0, 0x3f	; 63
    26a2:	f8 94       	cli
    26a4:	de bf       	out	0x3e, r29	; 62
    26a6:	0f be       	out	0x3f, r0	; 63
    26a8:	cd bf       	out	0x3d, r28	; 61
    26aa:	cf 91       	pop	r28
    26ac:	df 91       	pop	r29
    26ae:	08 95       	ret

000026b0 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    26b0:	ef 92       	push	r14
    26b2:	ff 92       	push	r15
    26b4:	0f 93       	push	r16
    26b6:	1f 93       	push	r17
    26b8:	df 93       	push	r29
    26ba:	cf 93       	push	r28
    26bc:	cd b7       	in	r28, 0x3d	; 61
    26be:	de b7       	in	r29, 0x3e	; 62
    26c0:	61 97       	sbiw	r28, 0x11	; 17
    26c2:	0f b6       	in	r0, 0x3f	; 63
    26c4:	f8 94       	cli
    26c6:	de bf       	out	0x3e, r29	; 62
    26c8:	0f be       	out	0x3f, r0	; 63
    26ca:	cd bf       	out	0x3d, r28	; 61
    26cc:	9b 87       	std	Y+11, r25	; 0x0b
    26ce:	8a 87       	std	Y+10, r24	; 0x0a
    26d0:	7d 87       	std	Y+13, r23	; 0x0d
    26d2:	6c 87       	std	Y+12, r22	; 0x0c
    26d4:	5f 87       	std	Y+15, r21	; 0x0f
    26d6:	4e 87       	std	Y+14, r20	; 0x0e
    26d8:	39 8b       	std	Y+17, r19	; 0x11
    26da:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    26dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    26de:	9b 85       	ldd	r25, Y+11	; 0x0b
    26e0:	99 87       	std	Y+9, r25	; 0x09
    26e2:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    26e4:	1f 82       	std	Y+7, r1	; 0x07
    26e6:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    26e8:	e8 85       	ldd	r30, Y+8	; 0x08
    26ea:	f9 85       	ldd	r31, Y+9	; 0x09
    26ec:	86 85       	ldd	r24, Z+14	; 0x0e
    26ee:	88 2f       	mov	r24, r24
    26f0:	90 e0       	ldi	r25, 0x00	; 0
    26f2:	81 70       	andi	r24, 0x01	; 1
    26f4:	90 70       	andi	r25, 0x00	; 0
    26f6:	88 23       	and	r24, r24
    26f8:	29 f0       	breq	.+10     	; 0x2704 <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    26fa:	82 e0       	ldi	r24, 0x02	; 2
    26fc:	90 e0       	ldi	r25, 0x00	; 0
    26fe:	9b 83       	std	Y+3, r25	; 0x03
    2700:	8a 83       	std	Y+2, r24	; 0x02
    2702:	02 c0       	rjmp	.+4      	; 0x2708 <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    2704:	1b 82       	std	Y+3, r1	; 0x03
    2706:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2708:	88 85       	ldd	r24, Y+8	; 0x08
    270a:	99 85       	ldd	r25, Y+9	; 0x09
    270c:	0e 94 61 16 	call	0x2cc2	; 0x2cc2 <prvBytesInBuffer>
    2710:	9d 83       	std	Y+5, r25	; 0x05
    2712:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    2714:	2c 81       	ldd	r18, Y+4	; 0x04
    2716:	3d 81       	ldd	r19, Y+5	; 0x05
    2718:	8a 81       	ldd	r24, Y+2	; 0x02
    271a:	9b 81       	ldd	r25, Y+3	; 0x03
    271c:	82 17       	cp	r24, r18
    271e:	93 07       	cpc	r25, r19
    2720:	80 f5       	brcc	.+96     	; 0x2782 <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    2722:	88 85       	ldd	r24, Y+8	; 0x08
    2724:	99 85       	ldd	r25, Y+9	; 0x09
    2726:	2c 85       	ldd	r18, Y+12	; 0x0c
    2728:	3d 85       	ldd	r19, Y+13	; 0x0d
    272a:	4e 85       	ldd	r20, Y+14	; 0x0e
    272c:	5f 85       	ldd	r21, Y+15	; 0x0f
    272e:	ec 81       	ldd	r30, Y+4	; 0x04
    2730:	fd 81       	ldd	r31, Y+5	; 0x05
    2732:	aa 81       	ldd	r26, Y+2	; 0x02
    2734:	bb 81       	ldd	r27, Y+3	; 0x03
    2736:	b9 01       	movw	r22, r18
    2738:	9f 01       	movw	r18, r30
    273a:	8d 01       	movw	r16, r26
    273c:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <prvReadMessageFromBuffer>
    2740:	9f 83       	std	Y+7, r25	; 0x07
    2742:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    2744:	8e 81       	ldd	r24, Y+6	; 0x06
    2746:	9f 81       	ldd	r25, Y+7	; 0x07
    2748:	00 97       	sbiw	r24, 0x00	; 0
    274a:	d9 f0       	breq	.+54     	; 0x2782 <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    274c:	19 82       	std	Y+1, r1	; 0x01
    274e:	e8 85       	ldd	r30, Y+8	; 0x08
    2750:	f9 85       	ldd	r31, Y+9	; 0x09
    2752:	82 85       	ldd	r24, Z+10	; 0x0a
    2754:	93 85       	ldd	r25, Z+11	; 0x0b
    2756:	00 97       	sbiw	r24, 0x00	; 0
    2758:	a1 f0       	breq	.+40     	; 0x2782 <xStreamBufferReceiveFromISR+0xd2>
    275a:	e8 85       	ldd	r30, Y+8	; 0x08
    275c:	f9 85       	ldd	r31, Y+9	; 0x09
    275e:	82 85       	ldd	r24, Z+10	; 0x0a
    2760:	93 85       	ldd	r25, Z+11	; 0x0b
    2762:	e8 89       	ldd	r30, Y+16	; 0x10
    2764:	f9 89       	ldd	r31, Y+17	; 0x11
    2766:	40 e0       	ldi	r20, 0x00	; 0
    2768:	50 e0       	ldi	r21, 0x00	; 0
    276a:	60 e0       	ldi	r22, 0x00	; 0
    276c:	70 e0       	ldi	r23, 0x00	; 0
    276e:	20 e0       	ldi	r18, 0x00	; 0
    2770:	00 e0       	ldi	r16, 0x00	; 0
    2772:	10 e0       	ldi	r17, 0x00	; 0
    2774:	7f 01       	movw	r14, r30
    2776:	0e 94 3a 21 	call	0x4274	; 0x4274 <xTaskGenericNotifyFromISR>
    277a:	e8 85       	ldd	r30, Y+8	; 0x08
    277c:	f9 85       	ldd	r31, Y+9	; 0x09
    277e:	13 86       	std	Z+11, r1	; 0x0b
    2780:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    2782:	8e 81       	ldd	r24, Y+6	; 0x06
    2784:	9f 81       	ldd	r25, Y+7	; 0x07
}
    2786:	61 96       	adiw	r28, 0x11	; 17
    2788:	0f b6       	in	r0, 0x3f	; 63
    278a:	f8 94       	cli
    278c:	de bf       	out	0x3e, r29	; 62
    278e:	0f be       	out	0x3f, r0	; 63
    2790:	cd bf       	out	0x3d, r28	; 61
    2792:	cf 91       	pop	r28
    2794:	df 91       	pop	r29
    2796:	1f 91       	pop	r17
    2798:	0f 91       	pop	r16
    279a:	ff 90       	pop	r15
    279c:	ef 90       	pop	r14
    279e:	08 95       	ret

000027a0 <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    27a0:	0f 93       	push	r16
    27a2:	1f 93       	push	r17
    27a4:	df 93       	push	r29
    27a6:	cf 93       	push	r28
    27a8:	cd b7       	in	r28, 0x3d	; 61
    27aa:	de b7       	in	r29, 0x3e	; 62
    27ac:	62 97       	sbiw	r28, 0x12	; 18
    27ae:	0f b6       	in	r0, 0x3f	; 63
    27b0:	f8 94       	cli
    27b2:	de bf       	out	0x3e, r29	; 62
    27b4:	0f be       	out	0x3f, r0	; 63
    27b6:	cd bf       	out	0x3d, r28	; 61
    27b8:	9a 87       	std	Y+10, r25	; 0x0a
    27ba:	89 87       	std	Y+9, r24	; 0x09
    27bc:	7c 87       	std	Y+12, r23	; 0x0c
    27be:	6b 87       	std	Y+11, r22	; 0x0b
    27c0:	5e 87       	std	Y+14, r21	; 0x0e
    27c2:	4d 87       	std	Y+13, r20	; 0x0d
    27c4:	38 8b       	std	Y+16, r19	; 0x10
    27c6:	2f 87       	std	Y+15, r18	; 0x0f
    27c8:	1a 8b       	std	Y+18, r17	; 0x12
    27ca:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    27cc:	89 89       	ldd	r24, Y+17	; 0x11
    27ce:	9a 89       	ldd	r25, Y+18	; 0x12
    27d0:	00 97       	sbiw	r24, 0x00	; 0
    27d2:	91 f1       	breq	.+100    	; 0x2838 <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    27d4:	e9 85       	ldd	r30, Y+9	; 0x09
    27d6:	fa 85       	ldd	r31, Y+10	; 0x0a
    27d8:	80 81       	ld	r24, Z
    27da:	91 81       	ldd	r25, Z+1	; 0x01
    27dc:	9e 83       	std	Y+6, r25	; 0x06
    27de:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    27e0:	ae 01       	movw	r20, r28
    27e2:	49 5f       	subi	r20, 0xF9	; 249
    27e4:	5f 4f       	sbci	r21, 0xFF	; 255
    27e6:	89 85       	ldd	r24, Y+9	; 0x09
    27e8:	9a 85       	ldd	r25, Y+10	; 0x0a
    27ea:	29 89       	ldd	r18, Y+17	; 0x11
    27ec:	3a 89       	ldd	r19, Y+18	; 0x12
    27ee:	ef 85       	ldd	r30, Y+15	; 0x0f
    27f0:	f8 89       	ldd	r31, Y+16	; 0x10
    27f2:	ba 01       	movw	r22, r20
    27f4:	a9 01       	movw	r20, r18
    27f6:	9f 01       	movw	r18, r30
    27f8:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    27fc:	8f 81       	ldd	r24, Y+7	; 0x07
    27fe:	98 85       	ldd	r25, Y+8	; 0x08
    2800:	9a 83       	std	Y+2, r25	; 0x02
    2802:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    2804:	2f 85       	ldd	r18, Y+15	; 0x0f
    2806:	38 89       	ldd	r19, Y+16	; 0x10
    2808:	89 89       	ldd	r24, Y+17	; 0x11
    280a:	9a 89       	ldd	r25, Y+18	; 0x12
    280c:	a9 01       	movw	r20, r18
    280e:	48 1b       	sub	r20, r24
    2810:	59 0b       	sbc	r21, r25
    2812:	ca 01       	movw	r24, r20
    2814:	98 8b       	std	Y+16, r25	; 0x10
    2816:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    2818:	29 81       	ldd	r18, Y+1	; 0x01
    281a:	3a 81       	ldd	r19, Y+2	; 0x02
    281c:	8d 85       	ldd	r24, Y+13	; 0x0d
    281e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2820:	82 17       	cp	r24, r18
    2822:	93 07       	cpc	r25, r19
    2824:	68 f4       	brcc	.+26     	; 0x2840 <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    2826:	e9 85       	ldd	r30, Y+9	; 0x09
    2828:	fa 85       	ldd	r31, Y+10	; 0x0a
    282a:	8d 81       	ldd	r24, Y+5	; 0x05
    282c:	9e 81       	ldd	r25, Y+6	; 0x06
    282e:	91 83       	std	Z+1, r25	; 0x01
    2830:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    2832:	1a 82       	std	Y+2, r1	; 0x02
    2834:	19 82       	std	Y+1, r1	; 0x01
    2836:	04 c0       	rjmp	.+8      	; 0x2840 <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    2838:	8d 85       	ldd	r24, Y+13	; 0x0d
    283a:	9e 85       	ldd	r25, Y+14	; 0x0e
    283c:	9a 83       	std	Y+2, r25	; 0x02
    283e:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    2840:	4b 85       	ldd	r20, Y+11	; 0x0b
    2842:	5c 85       	ldd	r21, Y+12	; 0x0c
    2844:	89 85       	ldd	r24, Y+9	; 0x09
    2846:	9a 85       	ldd	r25, Y+10	; 0x0a
    2848:	29 81       	ldd	r18, Y+1	; 0x01
    284a:	3a 81       	ldd	r19, Y+2	; 0x02
    284c:	ef 85       	ldd	r30, Y+15	; 0x0f
    284e:	f8 89       	ldd	r31, Y+16	; 0x10
    2850:	ba 01       	movw	r22, r20
    2852:	a9 01       	movw	r20, r18
    2854:	9f 01       	movw	r18, r30
    2856:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvReadBytesFromBuffer>
    285a:	9c 83       	std	Y+4, r25	; 0x04
    285c:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    285e:	8b 81       	ldd	r24, Y+3	; 0x03
    2860:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2862:	62 96       	adiw	r28, 0x12	; 18
    2864:	0f b6       	in	r0, 0x3f	; 63
    2866:	f8 94       	cli
    2868:	de bf       	out	0x3e, r29	; 62
    286a:	0f be       	out	0x3f, r0	; 63
    286c:	cd bf       	out	0x3d, r28	; 61
    286e:	cf 91       	pop	r28
    2870:	df 91       	pop	r29
    2872:	1f 91       	pop	r17
    2874:	0f 91       	pop	r16
    2876:	08 95       	ret

00002878 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    2878:	df 93       	push	r29
    287a:	cf 93       	push	r28
    287c:	cd b7       	in	r28, 0x3d	; 61
    287e:	de b7       	in	r29, 0x3e	; 62
    2880:	27 97       	sbiw	r28, 0x07	; 7
    2882:	0f b6       	in	r0, 0x3f	; 63
    2884:	f8 94       	cli
    2886:	de bf       	out	0x3e, r29	; 62
    2888:	0f be       	out	0x3f, r0	; 63
    288a:	cd bf       	out	0x3d, r28	; 61
    288c:	9f 83       	std	Y+7, r25	; 0x07
    288e:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2890:	8e 81       	ldd	r24, Y+6	; 0x06
    2892:	9f 81       	ldd	r25, Y+7	; 0x07
    2894:	9d 83       	std	Y+5, r25	; 0x05
    2896:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    2898:	ec 81       	ldd	r30, Y+4	; 0x04
    289a:	fd 81       	ldd	r31, Y+5	; 0x05
    289c:	80 81       	ld	r24, Z
    289e:	91 81       	ldd	r25, Z+1	; 0x01
    28a0:	9a 83       	std	Y+2, r25	; 0x02
    28a2:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    28a4:	ec 81       	ldd	r30, Y+4	; 0x04
    28a6:	fd 81       	ldd	r31, Y+5	; 0x05
    28a8:	22 81       	ldd	r18, Z+2	; 0x02
    28aa:	33 81       	ldd	r19, Z+3	; 0x03
    28ac:	89 81       	ldd	r24, Y+1	; 0x01
    28ae:	9a 81       	ldd	r25, Y+2	; 0x02
    28b0:	28 17       	cp	r18, r24
    28b2:	39 07       	cpc	r19, r25
    28b4:	19 f4       	brne	.+6      	; 0x28bc <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    28b6:	81 e0       	ldi	r24, 0x01	; 1
    28b8:	8b 83       	std	Y+3, r24	; 0x03
    28ba:	01 c0       	rjmp	.+2      	; 0x28be <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    28bc:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    28be:	8b 81       	ldd	r24, Y+3	; 0x03
}
    28c0:	27 96       	adiw	r28, 0x07	; 7
    28c2:	0f b6       	in	r0, 0x3f	; 63
    28c4:	f8 94       	cli
    28c6:	de bf       	out	0x3e, r29	; 62
    28c8:	0f be       	out	0x3f, r0	; 63
    28ca:	cd bf       	out	0x3d, r28	; 61
    28cc:	cf 91       	pop	r28
    28ce:	df 91       	pop	r29
    28d0:	08 95       	ret

000028d2 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    28d2:	df 93       	push	r29
    28d4:	cf 93       	push	r28
    28d6:	cd b7       	in	r28, 0x3d	; 61
    28d8:	de b7       	in	r29, 0x3e	; 62
    28da:	27 97       	sbiw	r28, 0x07	; 7
    28dc:	0f b6       	in	r0, 0x3f	; 63
    28de:	f8 94       	cli
    28e0:	de bf       	out	0x3e, r29	; 62
    28e2:	0f be       	out	0x3f, r0	; 63
    28e4:	cd bf       	out	0x3d, r28	; 61
    28e6:	9f 83       	std	Y+7, r25	; 0x07
    28e8:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    28ea:	8e 81       	ldd	r24, Y+6	; 0x06
    28ec:	9f 81       	ldd	r25, Y+7	; 0x07
    28ee:	9a 83       	std	Y+2, r25	; 0x02
    28f0:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    28f2:	e9 81       	ldd	r30, Y+1	; 0x01
    28f4:	fa 81       	ldd	r31, Y+2	; 0x02
    28f6:	86 85       	ldd	r24, Z+14	; 0x0e
    28f8:	88 2f       	mov	r24, r24
    28fa:	90 e0       	ldi	r25, 0x00	; 0
    28fc:	81 70       	andi	r24, 0x01	; 1
    28fe:	90 70       	andi	r25, 0x00	; 0
    2900:	88 23       	and	r24, r24
    2902:	29 f0       	breq	.+10     	; 0x290e <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2904:	82 e0       	ldi	r24, 0x02	; 2
    2906:	90 e0       	ldi	r25, 0x00	; 0
    2908:	9c 83       	std	Y+4, r25	; 0x04
    290a:	8b 83       	std	Y+3, r24	; 0x03
    290c:	02 c0       	rjmp	.+4      	; 0x2912 <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    290e:	1c 82       	std	Y+4, r1	; 0x04
    2910:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    2912:	8e 81       	ldd	r24, Y+6	; 0x06
    2914:	9f 81       	ldd	r25, Y+7	; 0x07
    2916:	0e 94 31 10 	call	0x2062	; 0x2062 <xStreamBufferSpacesAvailable>
    291a:	9c 01       	movw	r18, r24
    291c:	8b 81       	ldd	r24, Y+3	; 0x03
    291e:	9c 81       	ldd	r25, Y+4	; 0x04
    2920:	82 17       	cp	r24, r18
    2922:	93 07       	cpc	r25, r19
    2924:	18 f0       	brcs	.+6      	; 0x292c <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    2926:	81 e0       	ldi	r24, 0x01	; 1
    2928:	8d 83       	std	Y+5, r24	; 0x05
    292a:	01 c0       	rjmp	.+2      	; 0x292e <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    292c:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    292e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2930:	27 96       	adiw	r28, 0x07	; 7
    2932:	0f b6       	in	r0, 0x3f	; 63
    2934:	f8 94       	cli
    2936:	de bf       	out	0x3e, r29	; 62
    2938:	0f be       	out	0x3f, r0	; 63
    293a:	cd bf       	out	0x3d, r28	; 61
    293c:	cf 91       	pop	r28
    293e:	df 91       	pop	r29
    2940:	08 95       	ret

00002942 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    2942:	ef 92       	push	r14
    2944:	ff 92       	push	r15
    2946:	0f 93       	push	r16
    2948:	1f 93       	push	r17
    294a:	df 93       	push	r29
    294c:	cf 93       	push	r28
    294e:	cd b7       	in	r28, 0x3d	; 61
    2950:	de b7       	in	r29, 0x3e	; 62
    2952:	28 97       	sbiw	r28, 0x08	; 8
    2954:	0f b6       	in	r0, 0x3f	; 63
    2956:	f8 94       	cli
    2958:	de bf       	out	0x3e, r29	; 62
    295a:	0f be       	out	0x3f, r0	; 63
    295c:	cd bf       	out	0x3d, r28	; 61
    295e:	9e 83       	std	Y+6, r25	; 0x06
    2960:	8d 83       	std	Y+5, r24	; 0x05
    2962:	78 87       	std	Y+8, r23	; 0x08
    2964:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2966:	8d 81       	ldd	r24, Y+5	; 0x05
    2968:	9e 81       	ldd	r25, Y+6	; 0x06
    296a:	9c 83       	std	Y+4, r25	; 0x04
    296c:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    296e:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    2970:	eb 81       	ldd	r30, Y+3	; 0x03
    2972:	fc 81       	ldd	r31, Y+4	; 0x04
    2974:	80 85       	ldd	r24, Z+8	; 0x08
    2976:	91 85       	ldd	r25, Z+9	; 0x09
    2978:	00 97       	sbiw	r24, 0x00	; 0
    297a:	b9 f0       	breq	.+46     	; 0x29aa <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    297c:	eb 81       	ldd	r30, Y+3	; 0x03
    297e:	fc 81       	ldd	r31, Y+4	; 0x04
    2980:	80 85       	ldd	r24, Z+8	; 0x08
    2982:	91 85       	ldd	r25, Z+9	; 0x09
    2984:	ef 81       	ldd	r30, Y+7	; 0x07
    2986:	f8 85       	ldd	r31, Y+8	; 0x08
    2988:	40 e0       	ldi	r20, 0x00	; 0
    298a:	50 e0       	ldi	r21, 0x00	; 0
    298c:	60 e0       	ldi	r22, 0x00	; 0
    298e:	70 e0       	ldi	r23, 0x00	; 0
    2990:	20 e0       	ldi	r18, 0x00	; 0
    2992:	00 e0       	ldi	r16, 0x00	; 0
    2994:	10 e0       	ldi	r17, 0x00	; 0
    2996:	7f 01       	movw	r14, r30
    2998:	0e 94 3a 21 	call	0x4274	; 0x4274 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    299c:	eb 81       	ldd	r30, Y+3	; 0x03
    299e:	fc 81       	ldd	r31, Y+4	; 0x04
    29a0:	11 86       	std	Z+9, r1	; 0x09
    29a2:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    29a4:	81 e0       	ldi	r24, 0x01	; 1
    29a6:	8a 83       	std	Y+2, r24	; 0x02
    29a8:	01 c0       	rjmp	.+2      	; 0x29ac <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    29aa:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    29ac:	8a 81       	ldd	r24, Y+2	; 0x02
}
    29ae:	28 96       	adiw	r28, 0x08	; 8
    29b0:	0f b6       	in	r0, 0x3f	; 63
    29b2:	f8 94       	cli
    29b4:	de bf       	out	0x3e, r29	; 62
    29b6:	0f be       	out	0x3f, r0	; 63
    29b8:	cd bf       	out	0x3d, r28	; 61
    29ba:	cf 91       	pop	r28
    29bc:	df 91       	pop	r29
    29be:	1f 91       	pop	r17
    29c0:	0f 91       	pop	r16
    29c2:	ff 90       	pop	r15
    29c4:	ef 90       	pop	r14
    29c6:	08 95       	ret

000029c8 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    29c8:	ef 92       	push	r14
    29ca:	ff 92       	push	r15
    29cc:	0f 93       	push	r16
    29ce:	1f 93       	push	r17
    29d0:	df 93       	push	r29
    29d2:	cf 93       	push	r28
    29d4:	cd b7       	in	r28, 0x3d	; 61
    29d6:	de b7       	in	r29, 0x3e	; 62
    29d8:	28 97       	sbiw	r28, 0x08	; 8
    29da:	0f b6       	in	r0, 0x3f	; 63
    29dc:	f8 94       	cli
    29de:	de bf       	out	0x3e, r29	; 62
    29e0:	0f be       	out	0x3f, r0	; 63
    29e2:	cd bf       	out	0x3d, r28	; 61
    29e4:	9e 83       	std	Y+6, r25	; 0x06
    29e6:	8d 83       	std	Y+5, r24	; 0x05
    29e8:	78 87       	std	Y+8, r23	; 0x08
    29ea:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    29ec:	8d 81       	ldd	r24, Y+5	; 0x05
    29ee:	9e 81       	ldd	r25, Y+6	; 0x06
    29f0:	9c 83       	std	Y+4, r25	; 0x04
    29f2:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    29f4:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    29f6:	eb 81       	ldd	r30, Y+3	; 0x03
    29f8:	fc 81       	ldd	r31, Y+4	; 0x04
    29fa:	82 85       	ldd	r24, Z+10	; 0x0a
    29fc:	93 85       	ldd	r25, Z+11	; 0x0b
    29fe:	00 97       	sbiw	r24, 0x00	; 0
    2a00:	b9 f0       	breq	.+46     	; 0x2a30 <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    2a02:	eb 81       	ldd	r30, Y+3	; 0x03
    2a04:	fc 81       	ldd	r31, Y+4	; 0x04
    2a06:	82 85       	ldd	r24, Z+10	; 0x0a
    2a08:	93 85       	ldd	r25, Z+11	; 0x0b
    2a0a:	ef 81       	ldd	r30, Y+7	; 0x07
    2a0c:	f8 85       	ldd	r31, Y+8	; 0x08
    2a0e:	40 e0       	ldi	r20, 0x00	; 0
    2a10:	50 e0       	ldi	r21, 0x00	; 0
    2a12:	60 e0       	ldi	r22, 0x00	; 0
    2a14:	70 e0       	ldi	r23, 0x00	; 0
    2a16:	20 e0       	ldi	r18, 0x00	; 0
    2a18:	00 e0       	ldi	r16, 0x00	; 0
    2a1a:	10 e0       	ldi	r17, 0x00	; 0
    2a1c:	7f 01       	movw	r14, r30
    2a1e:	0e 94 3a 21 	call	0x4274	; 0x4274 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    2a22:	eb 81       	ldd	r30, Y+3	; 0x03
    2a24:	fc 81       	ldd	r31, Y+4	; 0x04
    2a26:	13 86       	std	Z+11, r1	; 0x0b
    2a28:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    2a2a:	81 e0       	ldi	r24, 0x01	; 1
    2a2c:	8a 83       	std	Y+2, r24	; 0x02
    2a2e:	01 c0       	rjmp	.+2      	; 0x2a32 <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    2a30:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2a32:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2a34:	28 96       	adiw	r28, 0x08	; 8
    2a36:	0f b6       	in	r0, 0x3f	; 63
    2a38:	f8 94       	cli
    2a3a:	de bf       	out	0x3e, r29	; 62
    2a3c:	0f be       	out	0x3f, r0	; 63
    2a3e:	cd bf       	out	0x3d, r28	; 61
    2a40:	cf 91       	pop	r28
    2a42:	df 91       	pop	r29
    2a44:	1f 91       	pop	r17
    2a46:	0f 91       	pop	r16
    2a48:	ff 90       	pop	r15
    2a4a:	ef 90       	pop	r14
    2a4c:	08 95       	ret

00002a4e <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    2a4e:	df 93       	push	r29
    2a50:	cf 93       	push	r28
    2a52:	cd b7       	in	r28, 0x3d	; 61
    2a54:	de b7       	in	r29, 0x3e	; 62
    2a56:	2e 97       	sbiw	r28, 0x0e	; 14
    2a58:	0f b6       	in	r0, 0x3f	; 63
    2a5a:	f8 94       	cli
    2a5c:	de bf       	out	0x3e, r29	; 62
    2a5e:	0f be       	out	0x3f, r0	; 63
    2a60:	cd bf       	out	0x3d, r28	; 61
    2a62:	9e 83       	std	Y+6, r25	; 0x06
    2a64:	8d 83       	std	Y+5, r24	; 0x05
    2a66:	78 87       	std	Y+8, r23	; 0x08
    2a68:	6f 83       	std	Y+7, r22	; 0x07
    2a6a:	5a 87       	std	Y+10, r21	; 0x0a
    2a6c:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    2a6e:	ed 81       	ldd	r30, Y+5	; 0x05
    2a70:	fe 81       	ldd	r31, Y+6	; 0x06
    2a72:	82 81       	ldd	r24, Z+2	; 0x02
    2a74:	93 81       	ldd	r25, Z+3	; 0x03
    2a76:	9c 83       	std	Y+4, r25	; 0x04
    2a78:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    2a7a:	ed 81       	ldd	r30, Y+5	; 0x05
    2a7c:	fe 81       	ldd	r31, Y+6	; 0x06
    2a7e:	24 81       	ldd	r18, Z+4	; 0x04
    2a80:	35 81       	ldd	r19, Z+5	; 0x05
    2a82:	8b 81       	ldd	r24, Y+3	; 0x03
    2a84:	9c 81       	ldd	r25, Y+4	; 0x04
    2a86:	a9 01       	movw	r20, r18
    2a88:	48 1b       	sub	r20, r24
    2a8a:	59 0b       	sbc	r21, r25
    2a8c:	ca 01       	movw	r24, r20
    2a8e:	29 85       	ldd	r18, Y+9	; 0x09
    2a90:	3a 85       	ldd	r19, Y+10	; 0x0a
    2a92:	3e 87       	std	Y+14, r19	; 0x0e
    2a94:	2d 87       	std	Y+13, r18	; 0x0d
    2a96:	9c 87       	std	Y+12, r25	; 0x0c
    2a98:	8b 87       	std	Y+11, r24	; 0x0b
    2a9a:	4b 85       	ldd	r20, Y+11	; 0x0b
    2a9c:	5c 85       	ldd	r21, Y+12	; 0x0c
    2a9e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2aa0:	9e 85       	ldd	r25, Y+14	; 0x0e
    2aa2:	84 17       	cp	r24, r20
    2aa4:	95 07       	cpc	r25, r21
    2aa6:	20 f4       	brcc	.+8      	; 0x2ab0 <prvWriteBytesToBuffer+0x62>
    2aa8:	2d 85       	ldd	r18, Y+13	; 0x0d
    2aaa:	3e 85       	ldd	r19, Y+14	; 0x0e
    2aac:	3c 87       	std	Y+12, r19	; 0x0c
    2aae:	2b 87       	std	Y+11, r18	; 0x0b
    2ab0:	4b 85       	ldd	r20, Y+11	; 0x0b
    2ab2:	5c 85       	ldd	r21, Y+12	; 0x0c
    2ab4:	5a 83       	std	Y+2, r21	; 0x02
    2ab6:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2ab8:	ed 81       	ldd	r30, Y+5	; 0x05
    2aba:	fe 81       	ldd	r31, Y+6	; 0x06
    2abc:	24 85       	ldd	r18, Z+12	; 0x0c
    2abe:	35 85       	ldd	r19, Z+13	; 0x0d
    2ac0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ac2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ac4:	82 0f       	add	r24, r18
    2ac6:	93 1f       	adc	r25, r19
    2ac8:	2f 81       	ldd	r18, Y+7	; 0x07
    2aca:	38 85       	ldd	r19, Y+8	; 0x08
    2acc:	49 81       	ldd	r20, Y+1	; 0x01
    2ace:	5a 81       	ldd	r21, Y+2	; 0x02
    2ad0:	b9 01       	movw	r22, r18
    2ad2:	0e 94 39 28 	call	0x5072	; 0x5072 <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    2ad6:	29 85       	ldd	r18, Y+9	; 0x09
    2ad8:	3a 85       	ldd	r19, Y+10	; 0x0a
    2ada:	89 81       	ldd	r24, Y+1	; 0x01
    2adc:	9a 81       	ldd	r25, Y+2	; 0x02
    2ade:	82 17       	cp	r24, r18
    2ae0:	93 07       	cpc	r25, r19
    2ae2:	b0 f4       	brcc	.+44     	; 0x2b10 <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2ae4:	ed 81       	ldd	r30, Y+5	; 0x05
    2ae6:	fe 81       	ldd	r31, Y+6	; 0x06
    2ae8:	64 85       	ldd	r22, Z+12	; 0x0c
    2aea:	75 85       	ldd	r23, Z+13	; 0x0d
    2aec:	2f 81       	ldd	r18, Y+7	; 0x07
    2aee:	38 85       	ldd	r19, Y+8	; 0x08
    2af0:	89 81       	ldd	r24, Y+1	; 0x01
    2af2:	9a 81       	ldd	r25, Y+2	; 0x02
    2af4:	a9 01       	movw	r20, r18
    2af6:	48 0f       	add	r20, r24
    2af8:	59 1f       	adc	r21, r25
    2afa:	29 85       	ldd	r18, Y+9	; 0x09
    2afc:	3a 85       	ldd	r19, Y+10	; 0x0a
    2afe:	89 81       	ldd	r24, Y+1	; 0x01
    2b00:	9a 81       	ldd	r25, Y+2	; 0x02
    2b02:	28 1b       	sub	r18, r24
    2b04:	39 0b       	sbc	r19, r25
    2b06:	cb 01       	movw	r24, r22
    2b08:	ba 01       	movw	r22, r20
    2b0a:	a9 01       	movw	r20, r18
    2b0c:	0e 94 39 28 	call	0x5072	; 0x5072 <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    2b10:	2b 81       	ldd	r18, Y+3	; 0x03
    2b12:	3c 81       	ldd	r19, Y+4	; 0x04
    2b14:	89 85       	ldd	r24, Y+9	; 0x09
    2b16:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b18:	82 0f       	add	r24, r18
    2b1a:	93 1f       	adc	r25, r19
    2b1c:	9c 83       	std	Y+4, r25	; 0x04
    2b1e:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    2b20:	ed 81       	ldd	r30, Y+5	; 0x05
    2b22:	fe 81       	ldd	r31, Y+6	; 0x06
    2b24:	24 81       	ldd	r18, Z+4	; 0x04
    2b26:	35 81       	ldd	r19, Z+5	; 0x05
    2b28:	8b 81       	ldd	r24, Y+3	; 0x03
    2b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b2c:	82 17       	cp	r24, r18
    2b2e:	93 07       	cpc	r25, r19
    2b30:	50 f0       	brcs	.+20     	; 0x2b46 <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    2b32:	ed 81       	ldd	r30, Y+5	; 0x05
    2b34:	fe 81       	ldd	r31, Y+6	; 0x06
    2b36:	24 81       	ldd	r18, Z+4	; 0x04
    2b38:	35 81       	ldd	r19, Z+5	; 0x05
    2b3a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b3c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b3e:	82 1b       	sub	r24, r18
    2b40:	93 0b       	sbc	r25, r19
    2b42:	9c 83       	std	Y+4, r25	; 0x04
    2b44:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    2b46:	ed 81       	ldd	r30, Y+5	; 0x05
    2b48:	fe 81       	ldd	r31, Y+6	; 0x06
    2b4a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b4c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b4e:	93 83       	std	Z+3, r25	; 0x03
    2b50:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    2b52:	89 85       	ldd	r24, Y+9	; 0x09
    2b54:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    2b56:	2e 96       	adiw	r28, 0x0e	; 14
    2b58:	0f b6       	in	r0, 0x3f	; 63
    2b5a:	f8 94       	cli
    2b5c:	de bf       	out	0x3e, r29	; 62
    2b5e:	0f be       	out	0x3f, r0	; 63
    2b60:	cd bf       	out	0x3d, r28	; 61
    2b62:	cf 91       	pop	r28
    2b64:	df 91       	pop	r29
    2b66:	08 95       	ret

00002b68 <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    2b68:	df 93       	push	r29
    2b6a:	cf 93       	push	r28
    2b6c:	cd b7       	in	r28, 0x3d	; 61
    2b6e:	de b7       	in	r29, 0x3e	; 62
    2b70:	66 97       	sbiw	r28, 0x16	; 22
    2b72:	0f b6       	in	r0, 0x3f	; 63
    2b74:	f8 94       	cli
    2b76:	de bf       	out	0x3e, r29	; 62
    2b78:	0f be       	out	0x3f, r0	; 63
    2b7a:	cd bf       	out	0x3d, r28	; 61
    2b7c:	98 87       	std	Y+8, r25	; 0x08
    2b7e:	8f 83       	std	Y+7, r24	; 0x07
    2b80:	7a 87       	std	Y+10, r23	; 0x0a
    2b82:	69 87       	std	Y+9, r22	; 0x09
    2b84:	5c 87       	std	Y+12, r21	; 0x0c
    2b86:	4b 87       	std	Y+11, r20	; 0x0b
    2b88:	3e 87       	std	Y+14, r19	; 0x0e
    2b8a:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    2b8c:	2d 85       	ldd	r18, Y+13	; 0x0d
    2b8e:	3e 85       	ldd	r19, Y+14	; 0x0e
    2b90:	3a 8b       	std	Y+18, r19	; 0x12
    2b92:	29 8b       	std	Y+17, r18	; 0x11
    2b94:	4b 85       	ldd	r20, Y+11	; 0x0b
    2b96:	5c 85       	ldd	r21, Y+12	; 0x0c
    2b98:	58 8b       	std	Y+16, r21	; 0x10
    2b9a:	4f 87       	std	Y+15, r20	; 0x0f
    2b9c:	8f 85       	ldd	r24, Y+15	; 0x0f
    2b9e:	98 89       	ldd	r25, Y+16	; 0x10
    2ba0:	29 89       	ldd	r18, Y+17	; 0x11
    2ba2:	3a 89       	ldd	r19, Y+18	; 0x12
    2ba4:	28 17       	cp	r18, r24
    2ba6:	39 07       	cpc	r19, r25
    2ba8:	20 f4       	brcc	.+8      	; 0x2bb2 <prvReadBytesFromBuffer+0x4a>
    2baa:	49 89       	ldd	r20, Y+17	; 0x11
    2bac:	5a 89       	ldd	r21, Y+18	; 0x12
    2bae:	58 8b       	std	Y+16, r21	; 0x10
    2bb0:	4f 87       	std	Y+15, r20	; 0x0f
    2bb2:	8f 85       	ldd	r24, Y+15	; 0x0f
    2bb4:	98 89       	ldd	r25, Y+16	; 0x10
    2bb6:	9e 83       	std	Y+6, r25	; 0x06
    2bb8:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    2bba:	8d 81       	ldd	r24, Y+5	; 0x05
    2bbc:	9e 81       	ldd	r25, Y+6	; 0x06
    2bbe:	00 97       	sbiw	r24, 0x00	; 0
    2bc0:	09 f4       	brne	.+2      	; 0x2bc4 <prvReadBytesFromBuffer+0x5c>
    2bc2:	74 c0       	rjmp	.+232    	; 0x2cac <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    2bc4:	ef 81       	ldd	r30, Y+7	; 0x07
    2bc6:	f8 85       	ldd	r31, Y+8	; 0x08
    2bc8:	80 81       	ld	r24, Z
    2bca:	91 81       	ldd	r25, Z+1	; 0x01
    2bcc:	9a 83       	std	Y+2, r25	; 0x02
    2bce:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    2bd0:	ef 81       	ldd	r30, Y+7	; 0x07
    2bd2:	f8 85       	ldd	r31, Y+8	; 0x08
    2bd4:	24 81       	ldd	r18, Z+4	; 0x04
    2bd6:	35 81       	ldd	r19, Z+5	; 0x05
    2bd8:	89 81       	ldd	r24, Y+1	; 0x01
    2bda:	9a 81       	ldd	r25, Y+2	; 0x02
    2bdc:	a9 01       	movw	r20, r18
    2bde:	48 1b       	sub	r20, r24
    2be0:	59 0b       	sbc	r21, r25
    2be2:	ca 01       	movw	r24, r20
    2be4:	2d 81       	ldd	r18, Y+5	; 0x05
    2be6:	3e 81       	ldd	r19, Y+6	; 0x06
    2be8:	3e 8b       	std	Y+22, r19	; 0x16
    2bea:	2d 8b       	std	Y+21, r18	; 0x15
    2bec:	9c 8b       	std	Y+20, r25	; 0x14
    2bee:	8b 8b       	std	Y+19, r24	; 0x13
    2bf0:	4b 89       	ldd	r20, Y+19	; 0x13
    2bf2:	5c 89       	ldd	r21, Y+20	; 0x14
    2bf4:	8d 89       	ldd	r24, Y+21	; 0x15
    2bf6:	9e 89       	ldd	r25, Y+22	; 0x16
    2bf8:	84 17       	cp	r24, r20
    2bfa:	95 07       	cpc	r25, r21
    2bfc:	20 f4       	brcc	.+8      	; 0x2c06 <prvReadBytesFromBuffer+0x9e>
    2bfe:	2d 89       	ldd	r18, Y+21	; 0x15
    2c00:	3e 89       	ldd	r19, Y+22	; 0x16
    2c02:	3c 8b       	std	Y+20, r19	; 0x14
    2c04:	2b 8b       	std	Y+19, r18	; 0x13
    2c06:	4b 89       	ldd	r20, Y+19	; 0x13
    2c08:	5c 89       	ldd	r21, Y+20	; 0x14
    2c0a:	5c 83       	std	Y+4, r21	; 0x04
    2c0c:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2c0e:	ef 81       	ldd	r30, Y+7	; 0x07
    2c10:	f8 85       	ldd	r31, Y+8	; 0x08
    2c12:	24 85       	ldd	r18, Z+12	; 0x0c
    2c14:	35 85       	ldd	r19, Z+13	; 0x0d
    2c16:	89 81       	ldd	r24, Y+1	; 0x01
    2c18:	9a 81       	ldd	r25, Y+2	; 0x02
    2c1a:	a9 01       	movw	r20, r18
    2c1c:	48 0f       	add	r20, r24
    2c1e:	59 1f       	adc	r21, r25
    2c20:	89 85       	ldd	r24, Y+9	; 0x09
    2c22:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c24:	2b 81       	ldd	r18, Y+3	; 0x03
    2c26:	3c 81       	ldd	r19, Y+4	; 0x04
    2c28:	ba 01       	movw	r22, r20
    2c2a:	a9 01       	movw	r20, r18
    2c2c:	0e 94 39 28 	call	0x5072	; 0x5072 <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    2c30:	2d 81       	ldd	r18, Y+5	; 0x05
    2c32:	3e 81       	ldd	r19, Y+6	; 0x06
    2c34:	8b 81       	ldd	r24, Y+3	; 0x03
    2c36:	9c 81       	ldd	r25, Y+4	; 0x04
    2c38:	82 17       	cp	r24, r18
    2c3a:	93 07       	cpc	r25, r19
    2c3c:	b0 f4       	brcc	.+44     	; 0x2c6a <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2c3e:	29 85       	ldd	r18, Y+9	; 0x09
    2c40:	3a 85       	ldd	r19, Y+10	; 0x0a
    2c42:	8b 81       	ldd	r24, Y+3	; 0x03
    2c44:	9c 81       	ldd	r25, Y+4	; 0x04
    2c46:	b9 01       	movw	r22, r18
    2c48:	68 0f       	add	r22, r24
    2c4a:	79 1f       	adc	r23, r25
    2c4c:	ef 81       	ldd	r30, Y+7	; 0x07
    2c4e:	f8 85       	ldd	r31, Y+8	; 0x08
    2c50:	44 85       	ldd	r20, Z+12	; 0x0c
    2c52:	55 85       	ldd	r21, Z+13	; 0x0d
    2c54:	2d 81       	ldd	r18, Y+5	; 0x05
    2c56:	3e 81       	ldd	r19, Y+6	; 0x06
    2c58:	8b 81       	ldd	r24, Y+3	; 0x03
    2c5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c5c:	28 1b       	sub	r18, r24
    2c5e:	39 0b       	sbc	r19, r25
    2c60:	cb 01       	movw	r24, r22
    2c62:	ba 01       	movw	r22, r20
    2c64:	a9 01       	movw	r20, r18
    2c66:	0e 94 39 28 	call	0x5072	; 0x5072 <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    2c6a:	29 81       	ldd	r18, Y+1	; 0x01
    2c6c:	3a 81       	ldd	r19, Y+2	; 0x02
    2c6e:	8d 81       	ldd	r24, Y+5	; 0x05
    2c70:	9e 81       	ldd	r25, Y+6	; 0x06
    2c72:	82 0f       	add	r24, r18
    2c74:	93 1f       	adc	r25, r19
    2c76:	9a 83       	std	Y+2, r25	; 0x02
    2c78:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    2c7a:	ef 81       	ldd	r30, Y+7	; 0x07
    2c7c:	f8 85       	ldd	r31, Y+8	; 0x08
    2c7e:	24 81       	ldd	r18, Z+4	; 0x04
    2c80:	35 81       	ldd	r19, Z+5	; 0x05
    2c82:	89 81       	ldd	r24, Y+1	; 0x01
    2c84:	9a 81       	ldd	r25, Y+2	; 0x02
    2c86:	82 17       	cp	r24, r18
    2c88:	93 07       	cpc	r25, r19
    2c8a:	50 f0       	brcs	.+20     	; 0x2ca0 <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    2c8c:	ef 81       	ldd	r30, Y+7	; 0x07
    2c8e:	f8 85       	ldd	r31, Y+8	; 0x08
    2c90:	24 81       	ldd	r18, Z+4	; 0x04
    2c92:	35 81       	ldd	r19, Z+5	; 0x05
    2c94:	89 81       	ldd	r24, Y+1	; 0x01
    2c96:	9a 81       	ldd	r25, Y+2	; 0x02
    2c98:	82 1b       	sub	r24, r18
    2c9a:	93 0b       	sbc	r25, r19
    2c9c:	9a 83       	std	Y+2, r25	; 0x02
    2c9e:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    2ca0:	ef 81       	ldd	r30, Y+7	; 0x07
    2ca2:	f8 85       	ldd	r31, Y+8	; 0x08
    2ca4:	89 81       	ldd	r24, Y+1	; 0x01
    2ca6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ca8:	91 83       	std	Z+1, r25	; 0x01
    2caa:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    2cac:	8d 81       	ldd	r24, Y+5	; 0x05
    2cae:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2cb0:	66 96       	adiw	r28, 0x16	; 22
    2cb2:	0f b6       	in	r0, 0x3f	; 63
    2cb4:	f8 94       	cli
    2cb6:	de bf       	out	0x3e, r29	; 62
    2cb8:	0f be       	out	0x3f, r0	; 63
    2cba:	cd bf       	out	0x3d, r28	; 61
    2cbc:	cf 91       	pop	r28
    2cbe:	df 91       	pop	r29
    2cc0:	08 95       	ret

00002cc2 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    2cc2:	df 93       	push	r29
    2cc4:	cf 93       	push	r28
    2cc6:	00 d0       	rcall	.+0      	; 0x2cc8 <prvBytesInBuffer+0x6>
    2cc8:	00 d0       	rcall	.+0      	; 0x2cca <prvBytesInBuffer+0x8>
    2cca:	cd b7       	in	r28, 0x3d	; 61
    2ccc:	de b7       	in	r29, 0x3e	; 62
    2cce:	9c 83       	std	Y+4, r25	; 0x04
    2cd0:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2cd2:	eb 81       	ldd	r30, Y+3	; 0x03
    2cd4:	fc 81       	ldd	r31, Y+4	; 0x04
    2cd6:	24 81       	ldd	r18, Z+4	; 0x04
    2cd8:	35 81       	ldd	r19, Z+5	; 0x05
    2cda:	eb 81       	ldd	r30, Y+3	; 0x03
    2cdc:	fc 81       	ldd	r31, Y+4	; 0x04
    2cde:	82 81       	ldd	r24, Z+2	; 0x02
    2ce0:	93 81       	ldd	r25, Z+3	; 0x03
    2ce2:	82 0f       	add	r24, r18
    2ce4:	93 1f       	adc	r25, r19
    2ce6:	9a 83       	std	Y+2, r25	; 0x02
    2ce8:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    2cea:	eb 81       	ldd	r30, Y+3	; 0x03
    2cec:	fc 81       	ldd	r31, Y+4	; 0x04
    2cee:	20 81       	ld	r18, Z
    2cf0:	31 81       	ldd	r19, Z+1	; 0x01
    2cf2:	89 81       	ldd	r24, Y+1	; 0x01
    2cf4:	9a 81       	ldd	r25, Y+2	; 0x02
    2cf6:	82 1b       	sub	r24, r18
    2cf8:	93 0b       	sbc	r25, r19
    2cfa:	9a 83       	std	Y+2, r25	; 0x02
    2cfc:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    2cfe:	eb 81       	ldd	r30, Y+3	; 0x03
    2d00:	fc 81       	ldd	r31, Y+4	; 0x04
    2d02:	24 81       	ldd	r18, Z+4	; 0x04
    2d04:	35 81       	ldd	r19, Z+5	; 0x05
    2d06:	89 81       	ldd	r24, Y+1	; 0x01
    2d08:	9a 81       	ldd	r25, Y+2	; 0x02
    2d0a:	82 17       	cp	r24, r18
    2d0c:	93 07       	cpc	r25, r19
    2d0e:	50 f0       	brcs	.+20     	; 0x2d24 <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    2d10:	eb 81       	ldd	r30, Y+3	; 0x03
    2d12:	fc 81       	ldd	r31, Y+4	; 0x04
    2d14:	24 81       	ldd	r18, Z+4	; 0x04
    2d16:	35 81       	ldd	r19, Z+5	; 0x05
    2d18:	89 81       	ldd	r24, Y+1	; 0x01
    2d1a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d1c:	82 1b       	sub	r24, r18
    2d1e:	93 0b       	sbc	r25, r19
    2d20:	9a 83       	std	Y+2, r25	; 0x02
    2d22:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    2d24:	89 81       	ldd	r24, Y+1	; 0x01
    2d26:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d28:	0f 90       	pop	r0
    2d2a:	0f 90       	pop	r0
    2d2c:	0f 90       	pop	r0
    2d2e:	0f 90       	pop	r0
    2d30:	cf 91       	pop	r28
    2d32:	df 91       	pop	r29
    2d34:	08 95       	ret

00002d36 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    2d36:	0f 93       	push	r16
    2d38:	df 93       	push	r29
    2d3a:	cf 93       	push	r28
    2d3c:	cd b7       	in	r28, 0x3d	; 61
    2d3e:	de b7       	in	r29, 0x3e	; 62
    2d40:	29 97       	sbiw	r28, 0x09	; 9
    2d42:	0f b6       	in	r0, 0x3f	; 63
    2d44:	f8 94       	cli
    2d46:	de bf       	out	0x3e, r29	; 62
    2d48:	0f be       	out	0x3f, r0	; 63
    2d4a:	cd bf       	out	0x3d, r28	; 61
    2d4c:	9a 83       	std	Y+2, r25	; 0x02
    2d4e:	89 83       	std	Y+1, r24	; 0x01
    2d50:	7c 83       	std	Y+4, r23	; 0x04
    2d52:	6b 83       	std	Y+3, r22	; 0x03
    2d54:	5e 83       	std	Y+6, r21	; 0x06
    2d56:	4d 83       	std	Y+5, r20	; 0x05
    2d58:	38 87       	std	Y+8, r19	; 0x08
    2d5a:	2f 83       	std	Y+7, r18	; 0x07
    2d5c:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    2d5e:	89 81       	ldd	r24, Y+1	; 0x01
    2d60:	9a 81       	ldd	r25, Y+2	; 0x02
    2d62:	60 e0       	ldi	r22, 0x00	; 0
    2d64:	70 e0       	ldi	r23, 0x00	; 0
    2d66:	4f e0       	ldi	r20, 0x0F	; 15
    2d68:	50 e0       	ldi	r21, 0x00	; 0
    2d6a:	0e 94 42 28 	call	0x5084	; 0x5084 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    2d6e:	e9 81       	ldd	r30, Y+1	; 0x01
    2d70:	fa 81       	ldd	r31, Y+2	; 0x02
    2d72:	8b 81       	ldd	r24, Y+3	; 0x03
    2d74:	9c 81       	ldd	r25, Y+4	; 0x04
    2d76:	95 87       	std	Z+13, r25	; 0x0d
    2d78:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    2d7a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d7c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d7e:	8d 81       	ldd	r24, Y+5	; 0x05
    2d80:	9e 81       	ldd	r25, Y+6	; 0x06
    2d82:	95 83       	std	Z+5, r25	; 0x05
    2d84:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    2d86:	e9 81       	ldd	r30, Y+1	; 0x01
    2d88:	fa 81       	ldd	r31, Y+2	; 0x02
    2d8a:	8f 81       	ldd	r24, Y+7	; 0x07
    2d8c:	98 85       	ldd	r25, Y+8	; 0x08
    2d8e:	97 83       	std	Z+7, r25	; 0x07
    2d90:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    2d92:	e9 81       	ldd	r30, Y+1	; 0x01
    2d94:	fa 81       	ldd	r31, Y+2	; 0x02
    2d96:	89 85       	ldd	r24, Y+9	; 0x09
    2d98:	86 87       	std	Z+14, r24	; 0x0e
}
    2d9a:	29 96       	adiw	r28, 0x09	; 9
    2d9c:	0f b6       	in	r0, 0x3f	; 63
    2d9e:	f8 94       	cli
    2da0:	de bf       	out	0x3e, r29	; 62
    2da2:	0f be       	out	0x3f, r0	; 63
    2da4:	cd bf       	out	0x3d, r28	; 61
    2da6:	cf 91       	pop	r28
    2da8:	df 91       	pop	r29
    2daa:	0f 91       	pop	r16
    2dac:	08 95       	ret

00002dae <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    2dae:	8f 92       	push	r8
    2db0:	9f 92       	push	r9
    2db2:	af 92       	push	r10
    2db4:	bf 92       	push	r11
    2db6:	cf 92       	push	r12
    2db8:	df 92       	push	r13
    2dba:	ef 92       	push	r14
    2dbc:	ff 92       	push	r15
    2dbe:	0f 93       	push	r16
    2dc0:	1f 93       	push	r17
    2dc2:	df 93       	push	r29
    2dc4:	cf 93       	push	r28
    2dc6:	cd b7       	in	r28, 0x3d	; 61
    2dc8:	de b7       	in	r29, 0x3e	; 62
    2dca:	60 97       	sbiw	r28, 0x10	; 16
    2dcc:	0f b6       	in	r0, 0x3f	; 63
    2dce:	f8 94       	cli
    2dd0:	de bf       	out	0x3e, r29	; 62
    2dd2:	0f be       	out	0x3f, r0	; 63
    2dd4:	cd bf       	out	0x3d, r28	; 61
    2dd6:	9f 83       	std	Y+7, r25	; 0x07
    2dd8:	8e 83       	std	Y+6, r24	; 0x06
    2dda:	79 87       	std	Y+9, r23	; 0x09
    2ddc:	68 87       	std	Y+8, r22	; 0x08
    2dde:	5b 87       	std	Y+11, r21	; 0x0b
    2de0:	4a 87       	std	Y+10, r20	; 0x0a
    2de2:	3d 87       	std	Y+13, r19	; 0x0d
    2de4:	2c 87       	std	Y+12, r18	; 0x0c
    2de6:	0e 87       	std	Y+14, r16	; 0x0e
    2de8:	f8 8a       	std	Y+16, r15	; 0x10
    2dea:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    2dec:	8a 85       	ldd	r24, Y+10	; 0x0a
    2dee:	9b 85       	ldd	r25, Y+11	; 0x0b
    2df0:	0e 94 8e 03 	call	0x71c	; 0x71c <pvPortMalloc>
    2df4:	9a 83       	std	Y+2, r25	; 0x02
    2df6:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    2df8:	89 81       	ldd	r24, Y+1	; 0x01
    2dfa:	9a 81       	ldd	r25, Y+2	; 0x02
    2dfc:	00 97       	sbiw	r24, 0x00	; 0
    2dfe:	b1 f0       	breq	.+44     	; 0x2e2c <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    2e00:	86 e2       	ldi	r24, 0x26	; 38
    2e02:	90 e0       	ldi	r25, 0x00	; 0
    2e04:	0e 94 8e 03 	call	0x71c	; 0x71c <pvPortMalloc>
    2e08:	9d 83       	std	Y+5, r25	; 0x05
    2e0a:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    2e0c:	8c 81       	ldd	r24, Y+4	; 0x04
    2e0e:	9d 81       	ldd	r25, Y+5	; 0x05
    2e10:	00 97       	sbiw	r24, 0x00	; 0
    2e12:	39 f0       	breq	.+14     	; 0x2e22 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    2e14:	ec 81       	ldd	r30, Y+4	; 0x04
    2e16:	fd 81       	ldd	r31, Y+5	; 0x05
    2e18:	89 81       	ldd	r24, Y+1	; 0x01
    2e1a:	9a 81       	ldd	r25, Y+2	; 0x02
    2e1c:	90 8f       	std	Z+24, r25	; 0x18
    2e1e:	87 8b       	std	Z+23, r24	; 0x17
    2e20:	07 c0       	rjmp	.+14     	; 0x2e30 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    2e22:	89 81       	ldd	r24, Y+1	; 0x01
    2e24:	9a 81       	ldd	r25, Y+2	; 0x02
    2e26:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <vPortFree>
    2e2a:	02 c0       	rjmp	.+4      	; 0x2e30 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    2e2c:	1d 82       	std	Y+5, r1	; 0x05
    2e2e:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    2e30:	8c 81       	ldd	r24, Y+4	; 0x04
    2e32:	9d 81       	ldd	r25, Y+5	; 0x05
    2e34:	00 97       	sbiw	r24, 0x00	; 0
    2e36:	e9 f0       	breq	.+58     	; 0x2e72 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    2e38:	8a 85       	ldd	r24, Y+10	; 0x0a
    2e3a:	9b 85       	ldd	r25, Y+11	; 0x0b
    2e3c:	9c 01       	movw	r18, r24
    2e3e:	40 e0       	ldi	r20, 0x00	; 0
    2e40:	50 e0       	ldi	r21, 0x00	; 0
    2e42:	8e 81       	ldd	r24, Y+6	; 0x06
    2e44:	9f 81       	ldd	r25, Y+7	; 0x07
    2e46:	68 85       	ldd	r22, Y+8	; 0x08
    2e48:	79 85       	ldd	r23, Y+9	; 0x09
    2e4a:	ec 85       	ldd	r30, Y+12	; 0x0c
    2e4c:	fd 85       	ldd	r31, Y+13	; 0x0d
    2e4e:	af 85       	ldd	r26, Y+15	; 0x0f
    2e50:	b8 89       	ldd	r27, Y+16	; 0x10
    2e52:	ac 80       	ldd	r10, Y+4	; 0x04
    2e54:	bd 80       	ldd	r11, Y+5	; 0x05
    2e56:	8f 01       	movw	r16, r30
    2e58:	ee 84       	ldd	r14, Y+14	; 0x0e
    2e5a:	6d 01       	movw	r12, r26
    2e5c:	88 24       	eor	r8, r8
    2e5e:	99 24       	eor	r9, r9
    2e60:	0e 94 4f 17 	call	0x2e9e	; 0x2e9e <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    2e64:	8c 81       	ldd	r24, Y+4	; 0x04
    2e66:	9d 81       	ldd	r25, Y+5	; 0x05
    2e68:	0e 94 0b 18 	call	0x3016	; 0x3016 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    2e6c:	81 e0       	ldi	r24, 0x01	; 1
    2e6e:	8b 83       	std	Y+3, r24	; 0x03
    2e70:	02 c0       	rjmp	.+4      	; 0x2e76 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2e72:	8f ef       	ldi	r24, 0xFF	; 255
    2e74:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    2e76:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    2e78:	60 96       	adiw	r28, 0x10	; 16
    2e7a:	0f b6       	in	r0, 0x3f	; 63
    2e7c:	f8 94       	cli
    2e7e:	de bf       	out	0x3e, r29	; 62
    2e80:	0f be       	out	0x3f, r0	; 63
    2e82:	cd bf       	out	0x3d, r28	; 61
    2e84:	cf 91       	pop	r28
    2e86:	df 91       	pop	r29
    2e88:	1f 91       	pop	r17
    2e8a:	0f 91       	pop	r16
    2e8c:	ff 90       	pop	r15
    2e8e:	ef 90       	pop	r14
    2e90:	df 90       	pop	r13
    2e92:	cf 90       	pop	r12
    2e94:	bf 90       	pop	r11
    2e96:	af 90       	pop	r10
    2e98:	9f 90       	pop	r9
    2e9a:	8f 90       	pop	r8
    2e9c:	08 95       	ret

00002e9e <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    2e9e:	8f 92       	push	r8
    2ea0:	9f 92       	push	r9
    2ea2:	af 92       	push	r10
    2ea4:	bf 92       	push	r11
    2ea6:	cf 92       	push	r12
    2ea8:	df 92       	push	r13
    2eaa:	ef 92       	push	r14
    2eac:	0f 93       	push	r16
    2eae:	1f 93       	push	r17
    2eb0:	df 93       	push	r29
    2eb2:	cf 93       	push	r28
    2eb4:	cd b7       	in	r28, 0x3d	; 61
    2eb6:	de b7       	in	r29, 0x3e	; 62
    2eb8:	64 97       	sbiw	r28, 0x14	; 20
    2eba:	0f b6       	in	r0, 0x3f	; 63
    2ebc:	f8 94       	cli
    2ebe:	de bf       	out	0x3e, r29	; 62
    2ec0:	0f be       	out	0x3f, r0	; 63
    2ec2:	cd bf       	out	0x3d, r28	; 61
    2ec4:	9d 83       	std	Y+5, r25	; 0x05
    2ec6:	8c 83       	std	Y+4, r24	; 0x04
    2ec8:	7f 83       	std	Y+7, r23	; 0x07
    2eca:	6e 83       	std	Y+6, r22	; 0x06
    2ecc:	28 87       	std	Y+8, r18	; 0x08
    2ece:	39 87       	std	Y+9, r19	; 0x09
    2ed0:	4a 87       	std	Y+10, r20	; 0x0a
    2ed2:	5b 87       	std	Y+11, r21	; 0x0b
    2ed4:	1d 87       	std	Y+13, r17	; 0x0d
    2ed6:	0c 87       	std	Y+12, r16	; 0x0c
    2ed8:	ee 86       	std	Y+14, r14	; 0x0e
    2eda:	d8 8a       	std	Y+16, r13	; 0x10
    2edc:	cf 86       	std	Y+15, r12	; 0x0f
    2ede:	ba 8a       	std	Y+18, r11	; 0x12
    2ee0:	a9 8a       	std	Y+17, r10	; 0x11
    2ee2:	9c 8a       	std	Y+20, r9	; 0x14
    2ee4:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    2ee6:	e9 89       	ldd	r30, Y+17	; 0x11
    2ee8:	fa 89       	ldd	r31, Y+18	; 0x12
    2eea:	27 89       	ldd	r18, Z+23	; 0x17
    2eec:	30 8d       	ldd	r19, Z+24	; 0x18
    2eee:	88 85       	ldd	r24, Y+8	; 0x08
    2ef0:	99 85       	ldd	r25, Y+9	; 0x09
    2ef2:	01 97       	sbiw	r24, 0x01	; 1
    2ef4:	82 0f       	add	r24, r18
    2ef6:	93 1f       	adc	r25, r19
    2ef8:	9b 83       	std	Y+3, r25	; 0x03
    2efa:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    2efc:	8e 81       	ldd	r24, Y+6	; 0x06
    2efe:	9f 81       	ldd	r25, Y+7	; 0x07
    2f00:	00 97       	sbiw	r24, 0x00	; 0
    2f02:	51 f1       	breq	.+84     	; 0x2f58 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2f04:	19 82       	std	Y+1, r1	; 0x01
    2f06:	21 c0       	rjmp	.+66     	; 0x2f4a <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    2f08:	89 81       	ldd	r24, Y+1	; 0x01
    2f0a:	48 2f       	mov	r20, r24
    2f0c:	50 e0       	ldi	r21, 0x00	; 0
    2f0e:	89 81       	ldd	r24, Y+1	; 0x01
    2f10:	28 2f       	mov	r18, r24
    2f12:	30 e0       	ldi	r19, 0x00	; 0
    2f14:	8e 81       	ldd	r24, Y+6	; 0x06
    2f16:	9f 81       	ldd	r25, Y+7	; 0x07
    2f18:	fc 01       	movw	r30, r24
    2f1a:	e2 0f       	add	r30, r18
    2f1c:	f3 1f       	adc	r31, r19
    2f1e:	20 81       	ld	r18, Z
    2f20:	89 89       	ldd	r24, Y+17	; 0x11
    2f22:	9a 89       	ldd	r25, Y+18	; 0x12
    2f24:	84 0f       	add	r24, r20
    2f26:	95 1f       	adc	r25, r21
    2f28:	fc 01       	movw	r30, r24
    2f2a:	79 96       	adiw	r30, 0x19	; 25
    2f2c:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    2f2e:	89 81       	ldd	r24, Y+1	; 0x01
    2f30:	28 2f       	mov	r18, r24
    2f32:	30 e0       	ldi	r19, 0x00	; 0
    2f34:	8e 81       	ldd	r24, Y+6	; 0x06
    2f36:	9f 81       	ldd	r25, Y+7	; 0x07
    2f38:	fc 01       	movw	r30, r24
    2f3a:	e2 0f       	add	r30, r18
    2f3c:	f3 1f       	adc	r31, r19
    2f3e:	80 81       	ld	r24, Z
    2f40:	88 23       	and	r24, r24
    2f42:	31 f0       	breq	.+12     	; 0x2f50 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2f44:	89 81       	ldd	r24, Y+1	; 0x01
    2f46:	8f 5f       	subi	r24, 0xFF	; 255
    2f48:	89 83       	std	Y+1, r24	; 0x01
    2f4a:	89 81       	ldd	r24, Y+1	; 0x01
    2f4c:	88 30       	cpi	r24, 0x08	; 8
    2f4e:	e0 f2       	brcs	.-72     	; 0x2f08 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    2f50:	e9 89       	ldd	r30, Y+17	; 0x11
    2f52:	fa 89       	ldd	r31, Y+18	; 0x12
    2f54:	10 a2       	std	Z+32, r1	; 0x20
    2f56:	03 c0       	rjmp	.+6      	; 0x2f5e <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    2f58:	e9 89       	ldd	r30, Y+17	; 0x11
    2f5a:	fa 89       	ldd	r31, Y+18	; 0x12
    2f5c:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2f5e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f60:	84 30       	cpi	r24, 0x04	; 4
    2f62:	10 f0       	brcs	.+4      	; 0x2f68 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    2f64:	83 e0       	ldi	r24, 0x03	; 3
    2f66:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    2f68:	e9 89       	ldd	r30, Y+17	; 0x11
    2f6a:	fa 89       	ldd	r31, Y+18	; 0x12
    2f6c:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f6e:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    2f70:	89 89       	ldd	r24, Y+17	; 0x11
    2f72:	9a 89       	ldd	r25, Y+18	; 0x12
    2f74:	02 96       	adiw	r24, 0x02	; 2
    2f76:	0e 94 34 04 	call	0x868	; 0x868 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    2f7a:	89 89       	ldd	r24, Y+17	; 0x11
    2f7c:	9a 89       	ldd	r25, Y+18	; 0x12
    2f7e:	0c 96       	adiw	r24, 0x0c	; 12
    2f80:	0e 94 34 04 	call	0x868	; 0x868 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    2f84:	e9 89       	ldd	r30, Y+17	; 0x11
    2f86:	fa 89       	ldd	r31, Y+18	; 0x12
    2f88:	89 89       	ldd	r24, Y+17	; 0x11
    2f8a:	9a 89       	ldd	r25, Y+18	; 0x12
    2f8c:	91 87       	std	Z+9, r25	; 0x09
    2f8e:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2f90:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f92:	28 2f       	mov	r18, r24
    2f94:	30 e0       	ldi	r19, 0x00	; 0
    2f96:	84 e0       	ldi	r24, 0x04	; 4
    2f98:	90 e0       	ldi	r25, 0x00	; 0
    2f9a:	82 1b       	sub	r24, r18
    2f9c:	93 0b       	sbc	r25, r19
    2f9e:	e9 89       	ldd	r30, Y+17	; 0x11
    2fa0:	fa 89       	ldd	r31, Y+18	; 0x12
    2fa2:	95 87       	std	Z+13, r25	; 0x0d
    2fa4:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    2fa6:	e9 89       	ldd	r30, Y+17	; 0x11
    2fa8:	fa 89       	ldd	r31, Y+18	; 0x12
    2faa:	89 89       	ldd	r24, Y+17	; 0x11
    2fac:	9a 89       	ldd	r25, Y+18	; 0x12
    2fae:	93 8b       	std	Z+19, r25	; 0x13
    2fb0:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    2fb2:	e9 89       	ldd	r30, Y+17	; 0x11
    2fb4:	fa 89       	ldd	r31, Y+18	; 0x12
    2fb6:	11 a2       	std	Z+33, r1	; 0x21
    2fb8:	12 a2       	std	Z+34, r1	; 0x22
    2fba:	13 a2       	std	Z+35, r1	; 0x23
    2fbc:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2fbe:	e9 89       	ldd	r30, Y+17	; 0x11
    2fc0:	fa 89       	ldd	r31, Y+18	; 0x12
    2fc2:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2fc4:	8a 81       	ldd	r24, Y+2	; 0x02
    2fc6:	9b 81       	ldd	r25, Y+3	; 0x03
    2fc8:	2c 81       	ldd	r18, Y+4	; 0x04
    2fca:	3d 81       	ldd	r19, Y+5	; 0x05
    2fcc:	4c 85       	ldd	r20, Y+12	; 0x0c
    2fce:	5d 85       	ldd	r21, Y+13	; 0x0d
    2fd0:	b9 01       	movw	r22, r18
    2fd2:	0e 94 40 05 	call	0xa80	; 0xa80 <pxPortInitialiseStack>
    2fd6:	e9 89       	ldd	r30, Y+17	; 0x11
    2fd8:	fa 89       	ldd	r31, Y+18	; 0x12
    2fda:	91 83       	std	Z+1, r25	; 0x01
    2fdc:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    2fde:	8f 85       	ldd	r24, Y+15	; 0x0f
    2fe0:	98 89       	ldd	r25, Y+16	; 0x10
    2fe2:	00 97       	sbiw	r24, 0x00	; 0
    2fe4:	31 f0       	breq	.+12     	; 0x2ff2 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    2fe6:	ef 85       	ldd	r30, Y+15	; 0x0f
    2fe8:	f8 89       	ldd	r31, Y+16	; 0x10
    2fea:	89 89       	ldd	r24, Y+17	; 0x11
    2fec:	9a 89       	ldd	r25, Y+18	; 0x12
    2fee:	91 83       	std	Z+1, r25	; 0x01
    2ff0:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    2ff2:	64 96       	adiw	r28, 0x14	; 20
    2ff4:	0f b6       	in	r0, 0x3f	; 63
    2ff6:	f8 94       	cli
    2ff8:	de bf       	out	0x3e, r29	; 62
    2ffa:	0f be       	out	0x3f, r0	; 63
    2ffc:	cd bf       	out	0x3d, r28	; 61
    2ffe:	cf 91       	pop	r28
    3000:	df 91       	pop	r29
    3002:	1f 91       	pop	r17
    3004:	0f 91       	pop	r16
    3006:	ef 90       	pop	r14
    3008:	df 90       	pop	r13
    300a:	cf 90       	pop	r12
    300c:	bf 90       	pop	r11
    300e:	af 90       	pop	r10
    3010:	9f 90       	pop	r9
    3012:	8f 90       	pop	r8
    3014:	08 95       	ret

00003016 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    3016:	df 93       	push	r29
    3018:	cf 93       	push	r28
    301a:	00 d0       	rcall	.+0      	; 0x301c <prvAddNewTaskToReadyList+0x6>
    301c:	00 d0       	rcall	.+0      	; 0x301e <prvAddNewTaskToReadyList+0x8>
    301e:	cd b7       	in	r28, 0x3d	; 61
    3020:	de b7       	in	r29, 0x3e	; 62
    3022:	9a 83       	std	Y+2, r25	; 0x02
    3024:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    3026:	0f b6       	in	r0, 0x3f	; 63
    3028:	f8 94       	cli
    302a:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    302c:	80 91 58 06 	lds	r24, 0x0658
    3030:	8f 5f       	subi	r24, 0xFF	; 255
    3032:	80 93 58 06 	sts	0x0658, r24
		if( pxCurrentTCB == NULL )
    3036:	80 91 56 06 	lds	r24, 0x0656
    303a:	90 91 57 06 	lds	r25, 0x0657
    303e:	00 97       	sbiw	r24, 0x00	; 0
    3040:	69 f4       	brne	.+26     	; 0x305c <prvAddNewTaskToReadyList+0x46>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    3042:	89 81       	ldd	r24, Y+1	; 0x01
    3044:	9a 81       	ldd	r25, Y+2	; 0x02
    3046:	90 93 57 06 	sts	0x0657, r25
    304a:	80 93 56 06 	sts	0x0656, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    304e:	80 91 58 06 	lds	r24, 0x0658
    3052:	81 30       	cpi	r24, 0x01	; 1
    3054:	b9 f4       	brne	.+46     	; 0x3084 <prvAddNewTaskToReadyList+0x6e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    3056:	0e 94 aa 1e 	call	0x3d54	; 0x3d54 <prvInitialiseTaskLists>
    305a:	14 c0       	rjmp	.+40     	; 0x3084 <prvAddNewTaskToReadyList+0x6e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    305c:	80 91 5c 06 	lds	r24, 0x065C
    3060:	88 23       	and	r24, r24
    3062:	81 f4       	brne	.+32     	; 0x3084 <prvAddNewTaskToReadyList+0x6e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3064:	e0 91 56 06 	lds	r30, 0x0656
    3068:	f0 91 57 06 	lds	r31, 0x0657
    306c:	96 89       	ldd	r25, Z+22	; 0x16
    306e:	e9 81       	ldd	r30, Y+1	; 0x01
    3070:	fa 81       	ldd	r31, Y+2	; 0x02
    3072:	86 89       	ldd	r24, Z+22	; 0x16
    3074:	89 17       	cp	r24, r25
    3076:	30 f0       	brcs	.+12     	; 0x3084 <prvAddNewTaskToReadyList+0x6e>
				{
					pxCurrentTCB = pxNewTCB;
    3078:	89 81       	ldd	r24, Y+1	; 0x01
    307a:	9a 81       	ldd	r25, Y+2	; 0x02
    307c:	90 93 57 06 	sts	0x0657, r25
    3080:	80 93 56 06 	sts	0x0656, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    3084:	80 91 60 06 	lds	r24, 0x0660
    3088:	8f 5f       	subi	r24, 0xFF	; 255
    308a:	80 93 60 06 	sts	0x0660, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    308e:	e9 81       	ldd	r30, Y+1	; 0x01
    3090:	fa 81       	ldd	r31, Y+2	; 0x02
    3092:	96 89       	ldd	r25, Z+22	; 0x16
    3094:	80 91 5b 06 	lds	r24, 0x065B
    3098:	89 17       	cp	r24, r25
    309a:	28 f4       	brcc	.+10     	; 0x30a6 <prvAddNewTaskToReadyList+0x90>
    309c:	e9 81       	ldd	r30, Y+1	; 0x01
    309e:	fa 81       	ldd	r31, Y+2	; 0x02
    30a0:	86 89       	ldd	r24, Z+22	; 0x16
    30a2:	80 93 5b 06 	sts	0x065B, r24
    30a6:	e9 81       	ldd	r30, Y+1	; 0x01
    30a8:	fa 81       	ldd	r31, Y+2	; 0x02
    30aa:	86 89       	ldd	r24, Z+22	; 0x16
    30ac:	28 2f       	mov	r18, r24
    30ae:	30 e0       	ldi	r19, 0x00	; 0
    30b0:	c9 01       	movw	r24, r18
    30b2:	88 0f       	add	r24, r24
    30b4:	99 1f       	adc	r25, r25
    30b6:	88 0f       	add	r24, r24
    30b8:	99 1f       	adc	r25, r25
    30ba:	88 0f       	add	r24, r24
    30bc:	99 1f       	adc	r25, r25
    30be:	82 0f       	add	r24, r18
    30c0:	93 1f       	adc	r25, r19
    30c2:	ac 01       	movw	r20, r24
    30c4:	4a 59       	subi	r20, 0x9A	; 154
    30c6:	59 4f       	sbci	r21, 0xF9	; 249
    30c8:	89 81       	ldd	r24, Y+1	; 0x01
    30ca:	9a 81       	ldd	r25, Y+2	; 0x02
    30cc:	9c 01       	movw	r18, r24
    30ce:	2e 5f       	subi	r18, 0xFE	; 254
    30d0:	3f 4f       	sbci	r19, 0xFF	; 255
    30d2:	ca 01       	movw	r24, r20
    30d4:	b9 01       	movw	r22, r18
    30d6:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    30da:	0f 90       	pop	r0
    30dc:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    30de:	80 91 5c 06 	lds	r24, 0x065C
    30e2:	88 23       	and	r24, r24
    30e4:	21 f0       	breq	.+8      	; 0x30ee <prvAddNewTaskToReadyList+0xd8>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    30e6:	80 91 56 06 	lds	r24, 0x0656
    30ea:	90 91 57 06 	lds	r25, 0x0657
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    30ee:	0f 90       	pop	r0
    30f0:	0f 90       	pop	r0
    30f2:	0f 90       	pop	r0
    30f4:	0f 90       	pop	r0
    30f6:	cf 91       	pop	r28
    30f8:	df 91       	pop	r29
    30fa:	08 95       	ret

000030fc <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    30fc:	df 93       	push	r29
    30fe:	cf 93       	push	r28
    3100:	cd b7       	in	r28, 0x3d	; 61
    3102:	de b7       	in	r29, 0x3e	; 62
    3104:	2a 97       	sbiw	r28, 0x0a	; 10
    3106:	0f b6       	in	r0, 0x3f	; 63
    3108:	f8 94       	cli
    310a:	de bf       	out	0x3e, r29	; 62
    310c:	0f be       	out	0x3f, r0	; 63
    310e:	cd bf       	out	0x3d, r28	; 61
    3110:	98 87       	std	Y+8, r25	; 0x08
    3112:	8f 83       	std	Y+7, r24	; 0x07
    3114:	7a 87       	std	Y+10, r23	; 0x0a
    3116:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    3118:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    311a:	0e 94 b8 1a 	call	0x3570	; 0x3570 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    311e:	80 91 59 06 	lds	r24, 0x0659
    3122:	90 91 5a 06 	lds	r25, 0x065A
    3126:	9a 83       	std	Y+2, r25	; 0x02
    3128:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    312a:	ef 81       	ldd	r30, Y+7	; 0x07
    312c:	f8 85       	ldd	r31, Y+8	; 0x08
    312e:	20 81       	ld	r18, Z
    3130:	31 81       	ldd	r19, Z+1	; 0x01
    3132:	89 85       	ldd	r24, Y+9	; 0x09
    3134:	9a 85       	ldd	r25, Y+10	; 0x0a
    3136:	82 0f       	add	r24, r18
    3138:	93 1f       	adc	r25, r19
    313a:	9e 83       	std	Y+6, r25	; 0x06
    313c:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    313e:	ef 81       	ldd	r30, Y+7	; 0x07
    3140:	f8 85       	ldd	r31, Y+8	; 0x08
    3142:	20 81       	ld	r18, Z
    3144:	31 81       	ldd	r19, Z+1	; 0x01
    3146:	89 81       	ldd	r24, Y+1	; 0x01
    3148:	9a 81       	ldd	r25, Y+2	; 0x02
    314a:	82 17       	cp	r24, r18
    314c:	93 07       	cpc	r25, r19
    314e:	98 f4       	brcc	.+38     	; 0x3176 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    3150:	ef 81       	ldd	r30, Y+7	; 0x07
    3152:	f8 85       	ldd	r31, Y+8	; 0x08
    3154:	20 81       	ld	r18, Z
    3156:	31 81       	ldd	r19, Z+1	; 0x01
    3158:	8d 81       	ldd	r24, Y+5	; 0x05
    315a:	9e 81       	ldd	r25, Y+6	; 0x06
    315c:	82 17       	cp	r24, r18
    315e:	93 07       	cpc	r25, r19
    3160:	e0 f4       	brcc	.+56     	; 0x319a <vTaskDelayUntil+0x9e>
    3162:	2d 81       	ldd	r18, Y+5	; 0x05
    3164:	3e 81       	ldd	r19, Y+6	; 0x06
    3166:	89 81       	ldd	r24, Y+1	; 0x01
    3168:	9a 81       	ldd	r25, Y+2	; 0x02
    316a:	82 17       	cp	r24, r18
    316c:	93 07       	cpc	r25, r19
    316e:	a8 f4       	brcc	.+42     	; 0x319a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3170:	81 e0       	ldi	r24, 0x01	; 1
    3172:	8b 83       	std	Y+3, r24	; 0x03
    3174:	12 c0       	rjmp	.+36     	; 0x319a <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    3176:	ef 81       	ldd	r30, Y+7	; 0x07
    3178:	f8 85       	ldd	r31, Y+8	; 0x08
    317a:	20 81       	ld	r18, Z
    317c:	31 81       	ldd	r19, Z+1	; 0x01
    317e:	8d 81       	ldd	r24, Y+5	; 0x05
    3180:	9e 81       	ldd	r25, Y+6	; 0x06
    3182:	82 17       	cp	r24, r18
    3184:	93 07       	cpc	r25, r19
    3186:	38 f0       	brcs	.+14     	; 0x3196 <vTaskDelayUntil+0x9a>
    3188:	2d 81       	ldd	r18, Y+5	; 0x05
    318a:	3e 81       	ldd	r19, Y+6	; 0x06
    318c:	89 81       	ldd	r24, Y+1	; 0x01
    318e:	9a 81       	ldd	r25, Y+2	; 0x02
    3190:	82 17       	cp	r24, r18
    3192:	93 07       	cpc	r25, r19
    3194:	10 f4       	brcc	.+4      	; 0x319a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3196:	81 e0       	ldi	r24, 0x01	; 1
    3198:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    319a:	ef 81       	ldd	r30, Y+7	; 0x07
    319c:	f8 85       	ldd	r31, Y+8	; 0x08
    319e:	8d 81       	ldd	r24, Y+5	; 0x05
    31a0:	9e 81       	ldd	r25, Y+6	; 0x06
    31a2:	91 83       	std	Z+1, r25	; 0x01
    31a4:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    31a6:	8b 81       	ldd	r24, Y+3	; 0x03
    31a8:	88 23       	and	r24, r24
    31aa:	49 f0       	breq	.+18     	; 0x31be <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    31ac:	8d 81       	ldd	r24, Y+5	; 0x05
    31ae:	9e 81       	ldd	r25, Y+6	; 0x06
    31b0:	29 81       	ldd	r18, Y+1	; 0x01
    31b2:	3a 81       	ldd	r19, Y+2	; 0x02
    31b4:	82 1b       	sub	r24, r18
    31b6:	93 0b       	sbc	r25, r19
    31b8:	60 e0       	ldi	r22, 0x00	; 0
    31ba:	0e 94 f2 22 	call	0x45e4	; 0x45e4 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    31be:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>
    31c2:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    31c4:	8c 81       	ldd	r24, Y+4	; 0x04
    31c6:	88 23       	and	r24, r24
    31c8:	11 f4       	brne	.+4      	; 0x31ce <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    31ca:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    31ce:	2a 96       	adiw	r28, 0x0a	; 10
    31d0:	0f b6       	in	r0, 0x3f	; 63
    31d2:	f8 94       	cli
    31d4:	de bf       	out	0x3e, r29	; 62
    31d6:	0f be       	out	0x3f, r0	; 63
    31d8:	cd bf       	out	0x3d, r28	; 61
    31da:	cf 91       	pop	r28
    31dc:	df 91       	pop	r29
    31de:	08 95       	ret

000031e0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    31e0:	df 93       	push	r29
    31e2:	cf 93       	push	r28
    31e4:	00 d0       	rcall	.+0      	; 0x31e6 <vTaskDelay+0x6>
    31e6:	0f 92       	push	r0
    31e8:	cd b7       	in	r28, 0x3d	; 61
    31ea:	de b7       	in	r29, 0x3e	; 62
    31ec:	9b 83       	std	Y+3, r25	; 0x03
    31ee:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    31f0:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    31f2:	8a 81       	ldd	r24, Y+2	; 0x02
    31f4:	9b 81       	ldd	r25, Y+3	; 0x03
    31f6:	00 97       	sbiw	r24, 0x00	; 0
    31f8:	51 f0       	breq	.+20     	; 0x320e <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    31fa:	0e 94 b8 1a 	call	0x3570	; 0x3570 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    31fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3200:	9b 81       	ldd	r25, Y+3	; 0x03
    3202:	60 e0       	ldi	r22, 0x00	; 0
    3204:	0e 94 f2 22 	call	0x45e4	; 0x45e4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3208:	0e 94 c4 1a 	call	0x3588	; 0x3588 <xTaskResumeAll>
    320c:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    320e:	89 81       	ldd	r24, Y+1	; 0x01
    3210:	88 23       	and	r24, r24
    3212:	11 f4       	brne	.+4      	; 0x3218 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    3214:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3218:	0f 90       	pop	r0
    321a:	0f 90       	pop	r0
    321c:	0f 90       	pop	r0
    321e:	cf 91       	pop	r28
    3220:	df 91       	pop	r29
    3222:	08 95       	ret

00003224 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    3224:	df 93       	push	r29
    3226:	cf 93       	push	r28
    3228:	00 d0       	rcall	.+0      	; 0x322a <vTaskSuspend+0x6>
    322a:	00 d0       	rcall	.+0      	; 0x322c <vTaskSuspend+0x8>
    322c:	00 d0       	rcall	.+0      	; 0x322e <vTaskSuspend+0xa>
    322e:	cd b7       	in	r28, 0x3d	; 61
    3230:	de b7       	in	r29, 0x3e	; 62
    3232:	9c 83       	std	Y+4, r25	; 0x04
    3234:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3236:	0f b6       	in	r0, 0x3f	; 63
    3238:	f8 94       	cli
    323a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    323c:	8b 81       	ldd	r24, Y+3	; 0x03
    323e:	9c 81       	ldd	r25, Y+4	; 0x04
    3240:	00 97       	sbiw	r24, 0x00	; 0
    3242:	39 f4       	brne	.+14     	; 0x3252 <vTaskSuspend+0x2e>
    3244:	80 91 56 06 	lds	r24, 0x0656
    3248:	90 91 57 06 	lds	r25, 0x0657
    324c:	9e 83       	std	Y+6, r25	; 0x06
    324e:	8d 83       	std	Y+5, r24	; 0x05
    3250:	04 c0       	rjmp	.+8      	; 0x325a <vTaskSuspend+0x36>
    3252:	8b 81       	ldd	r24, Y+3	; 0x03
    3254:	9c 81       	ldd	r25, Y+4	; 0x04
    3256:	9e 83       	std	Y+6, r25	; 0x06
    3258:	8d 83       	std	Y+5, r24	; 0x05
    325a:	8d 81       	ldd	r24, Y+5	; 0x05
    325c:	9e 81       	ldd	r25, Y+6	; 0x06
    325e:	9a 83       	std	Y+2, r25	; 0x02
    3260:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3262:	89 81       	ldd	r24, Y+1	; 0x01
    3264:	9a 81       	ldd	r25, Y+2	; 0x02
    3266:	02 96       	adiw	r24, 0x02	; 2
    3268:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    326c:	e9 81       	ldd	r30, Y+1	; 0x01
    326e:	fa 81       	ldd	r31, Y+2	; 0x02
    3270:	84 89       	ldd	r24, Z+20	; 0x14
    3272:	95 89       	ldd	r25, Z+21	; 0x15
    3274:	00 97       	sbiw	r24, 0x00	; 0
    3276:	29 f0       	breq	.+10     	; 0x3282 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3278:	89 81       	ldd	r24, Y+1	; 0x01
    327a:	9a 81       	ldd	r25, Y+2	; 0x02
    327c:	0c 96       	adiw	r24, 0x0c	; 12
    327e:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    3282:	89 81       	ldd	r24, Y+1	; 0x01
    3284:	9a 81       	ldd	r25, Y+2	; 0x02
    3286:	9c 01       	movw	r18, r24
    3288:	2e 5f       	subi	r18, 0xFE	; 254
    328a:	3f 4f       	sbci	r19, 0xFF	; 255
    328c:	89 ea       	ldi	r24, 0xA9	; 169
    328e:	96 e0       	ldi	r25, 0x06	; 6
    3290:	b9 01       	movw	r22, r18
    3292:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    3296:	e9 81       	ldd	r30, Y+1	; 0x01
    3298:	fa 81       	ldd	r31, Y+2	; 0x02
    329a:	85 a1       	ldd	r24, Z+37	; 0x25
    329c:	81 30       	cpi	r24, 0x01	; 1
    329e:	19 f4       	brne	.+6      	; 0x32a6 <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    32a0:	e9 81       	ldd	r30, Y+1	; 0x01
    32a2:	fa 81       	ldd	r31, Y+2	; 0x02
    32a4:	15 a2       	std	Z+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    32a6:	0f 90       	pop	r0
    32a8:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    32aa:	80 91 5c 06 	lds	r24, 0x065C
    32ae:	88 23       	and	r24, r24
    32b0:	39 f0       	breq	.+14     	; 0x32c0 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    32b2:	0f b6       	in	r0, 0x3f	; 63
    32b4:	f8 94       	cli
    32b6:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    32b8:	0e 94 ee 1e 	call	0x3ddc	; 0x3ddc <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    32bc:	0f 90       	pop	r0
    32be:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    32c0:	20 91 56 06 	lds	r18, 0x0656
    32c4:	30 91 57 06 	lds	r19, 0x0657
    32c8:	89 81       	ldd	r24, Y+1	; 0x01
    32ca:	9a 81       	ldd	r25, Y+2	; 0x02
    32cc:	82 17       	cp	r24, r18
    32ce:	93 07       	cpc	r25, r19
    32d0:	a1 f4       	brne	.+40     	; 0x32fa <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    32d2:	80 91 5c 06 	lds	r24, 0x065C
    32d6:	88 23       	and	r24, r24
    32d8:	19 f0       	breq	.+6      	; 0x32e0 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    32da:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    32de:	0d c0       	rjmp	.+26     	; 0x32fa <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    32e0:	90 91 a9 06 	lds	r25, 0x06A9
    32e4:	80 91 58 06 	lds	r24, 0x0658
    32e8:	98 17       	cp	r25, r24
    32ea:	29 f4       	brne	.+10     	; 0x32f6 <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    32ec:	10 92 57 06 	sts	0x0657, r1
    32f0:	10 92 56 06 	sts	0x0656, r1
    32f4:	02 c0       	rjmp	.+4      	; 0x32fa <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    32f6:	0e 94 69 1c 	call	0x38d2	; 0x38d2 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    32fa:	26 96       	adiw	r28, 0x06	; 6
    32fc:	0f b6       	in	r0, 0x3f	; 63
    32fe:	f8 94       	cli
    3300:	de bf       	out	0x3e, r29	; 62
    3302:	0f be       	out	0x3f, r0	; 63
    3304:	cd bf       	out	0x3d, r28	; 61
    3306:	cf 91       	pop	r28
    3308:	df 91       	pop	r29
    330a:	08 95       	ret

0000330c <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    330c:	df 93       	push	r29
    330e:	cf 93       	push	r28
    3310:	00 d0       	rcall	.+0      	; 0x3312 <prvTaskIsTaskSuspended+0x6>
    3312:	00 d0       	rcall	.+0      	; 0x3314 <prvTaskIsTaskSuspended+0x8>
    3314:	0f 92       	push	r0
    3316:	cd b7       	in	r28, 0x3d	; 61
    3318:	de b7       	in	r29, 0x3e	; 62
    331a:	9d 83       	std	Y+5, r25	; 0x05
    331c:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    331e:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    3320:	8c 81       	ldd	r24, Y+4	; 0x04
    3322:	9d 81       	ldd	r25, Y+5	; 0x05
    3324:	9a 83       	std	Y+2, r25	; 0x02
    3326:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    3328:	e9 81       	ldd	r30, Y+1	; 0x01
    332a:	fa 81       	ldd	r31, Y+2	; 0x02
    332c:	82 85       	ldd	r24, Z+10	; 0x0a
    332e:	93 85       	ldd	r25, Z+11	; 0x0b
    3330:	26 e0       	ldi	r18, 0x06	; 6
    3332:	89 3a       	cpi	r24, 0xA9	; 169
    3334:	92 07       	cpc	r25, r18
    3336:	81 f4       	brne	.+32     	; 0x3358 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    3338:	e9 81       	ldd	r30, Y+1	; 0x01
    333a:	fa 81       	ldd	r31, Y+2	; 0x02
    333c:	84 89       	ldd	r24, Z+20	; 0x14
    333e:	95 89       	ldd	r25, Z+21	; 0x15
    3340:	26 e0       	ldi	r18, 0x06	; 6
    3342:	80 3a       	cpi	r24, 0xA0	; 160
    3344:	92 07       	cpc	r25, r18
    3346:	41 f0       	breq	.+16     	; 0x3358 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    3348:	e9 81       	ldd	r30, Y+1	; 0x01
    334a:	fa 81       	ldd	r31, Y+2	; 0x02
    334c:	84 89       	ldd	r24, Z+20	; 0x14
    334e:	95 89       	ldd	r25, Z+21	; 0x15
    3350:	00 97       	sbiw	r24, 0x00	; 0
    3352:	11 f4       	brne	.+4      	; 0x3358 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    3354:	81 e0       	ldi	r24, 0x01	; 1
    3356:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    3358:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    335a:	0f 90       	pop	r0
    335c:	0f 90       	pop	r0
    335e:	0f 90       	pop	r0
    3360:	0f 90       	pop	r0
    3362:	0f 90       	pop	r0
    3364:	cf 91       	pop	r28
    3366:	df 91       	pop	r29
    3368:	08 95       	ret

0000336a <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    336a:	df 93       	push	r29
    336c:	cf 93       	push	r28
    336e:	00 d0       	rcall	.+0      	; 0x3370 <vTaskResume+0x6>
    3370:	00 d0       	rcall	.+0      	; 0x3372 <vTaskResume+0x8>
    3372:	00 d0       	rcall	.+0      	; 0x3374 <vTaskResume+0xa>
    3374:	cd b7       	in	r28, 0x3d	; 61
    3376:	de b7       	in	r29, 0x3e	; 62
    3378:	9c 83       	std	Y+4, r25	; 0x04
    337a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    337c:	8b 81       	ldd	r24, Y+3	; 0x03
    337e:	9c 81       	ldd	r25, Y+4	; 0x04
    3380:	9a 83       	std	Y+2, r25	; 0x02
    3382:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    3384:	20 91 56 06 	lds	r18, 0x0656
    3388:	30 91 57 06 	lds	r19, 0x0657
    338c:	89 81       	ldd	r24, Y+1	; 0x01
    338e:	9a 81       	ldd	r25, Y+2	; 0x02
    3390:	82 17       	cp	r24, r18
    3392:	93 07       	cpc	r25, r19
    3394:	09 f4       	brne	.+2      	; 0x3398 <vTaskResume+0x2e>
    3396:	3f c0       	rjmp	.+126    	; 0x3416 <vTaskResume+0xac>
    3398:	89 81       	ldd	r24, Y+1	; 0x01
    339a:	9a 81       	ldd	r25, Y+2	; 0x02
    339c:	00 97       	sbiw	r24, 0x00	; 0
    339e:	09 f4       	brne	.+2      	; 0x33a2 <vTaskResume+0x38>
    33a0:	3a c0       	rjmp	.+116    	; 0x3416 <vTaskResume+0xac>
		{
			taskENTER_CRITICAL();
    33a2:	0f b6       	in	r0, 0x3f	; 63
    33a4:	f8 94       	cli
    33a6:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    33a8:	89 81       	ldd	r24, Y+1	; 0x01
    33aa:	9a 81       	ldd	r25, Y+2	; 0x02
    33ac:	0e 94 86 19 	call	0x330c	; 0x330c <prvTaskIsTaskSuspended>
    33b0:	88 23       	and	r24, r24
    33b2:	79 f1       	breq	.+94     	; 0x3412 <vTaskResume+0xa8>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    33b4:	89 81       	ldd	r24, Y+1	; 0x01
    33b6:	9a 81       	ldd	r25, Y+2	; 0x02
    33b8:	02 96       	adiw	r24, 0x02	; 2
    33ba:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    33be:	e9 81       	ldd	r30, Y+1	; 0x01
    33c0:	fa 81       	ldd	r31, Y+2	; 0x02
    33c2:	96 89       	ldd	r25, Z+22	; 0x16
    33c4:	80 91 5b 06 	lds	r24, 0x065B
    33c8:	89 17       	cp	r24, r25
    33ca:	28 f4       	brcc	.+10     	; 0x33d6 <vTaskResume+0x6c>
    33cc:	e9 81       	ldd	r30, Y+1	; 0x01
    33ce:	fa 81       	ldd	r31, Y+2	; 0x02
    33d0:	86 89       	ldd	r24, Z+22	; 0x16
    33d2:	80 93 5b 06 	sts	0x065B, r24
    33d6:	e9 81       	ldd	r30, Y+1	; 0x01
    33d8:	fa 81       	ldd	r31, Y+2	; 0x02
    33da:	86 89       	ldd	r24, Z+22	; 0x16
    33dc:	28 2f       	mov	r18, r24
    33de:	30 e0       	ldi	r19, 0x00	; 0
    33e0:	c9 01       	movw	r24, r18
    33e2:	88 0f       	add	r24, r24
    33e4:	99 1f       	adc	r25, r25
    33e6:	88 0f       	add	r24, r24
    33e8:	99 1f       	adc	r25, r25
    33ea:	88 0f       	add	r24, r24
    33ec:	99 1f       	adc	r25, r25
    33ee:	82 0f       	add	r24, r18
    33f0:	93 1f       	adc	r25, r19
    33f2:	ac 01       	movw	r20, r24
    33f4:	4a 59       	subi	r20, 0x9A	; 154
    33f6:	59 4f       	sbci	r21, 0xF9	; 249
    33f8:	89 81       	ldd	r24, Y+1	; 0x01
    33fa:	9a 81       	ldd	r25, Y+2	; 0x02
    33fc:	9c 01       	movw	r18, r24
    33fe:	2e 5f       	subi	r18, 0xFE	; 254
    3400:	3f 4f       	sbci	r19, 0xFF	; 255
    3402:	ca 01       	movw	r24, r20
    3404:	b9 01       	movw	r22, r18
    3406:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    340a:	80 91 56 06 	lds	r24, 0x0656
    340e:	90 91 57 06 	lds	r25, 0x0657
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    3412:	0f 90       	pop	r0
    3414:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3416:	26 96       	adiw	r28, 0x06	; 6
    3418:	0f b6       	in	r0, 0x3f	; 63
    341a:	f8 94       	cli
    341c:	de bf       	out	0x3e, r29	; 62
    341e:	0f be       	out	0x3f, r0	; 63
    3420:	cd bf       	out	0x3d, r28	; 61
    3422:	cf 91       	pop	r28
    3424:	df 91       	pop	r29
    3426:	08 95       	ret

00003428 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    3428:	df 93       	push	r29
    342a:	cf 93       	push	r28
    342c:	00 d0       	rcall	.+0      	; 0x342e <xTaskResumeFromISR+0x6>
    342e:	00 d0       	rcall	.+0      	; 0x3430 <xTaskResumeFromISR+0x8>
    3430:	00 d0       	rcall	.+0      	; 0x3432 <xTaskResumeFromISR+0xa>
    3432:	cd b7       	in	r28, 0x3d	; 61
    3434:	de b7       	in	r29, 0x3e	; 62
    3436:	9e 83       	std	Y+6, r25	; 0x06
    3438:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    343a:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    343c:	8d 81       	ldd	r24, Y+5	; 0x05
    343e:	9e 81       	ldd	r25, Y+6	; 0x06
    3440:	9b 83       	std	Y+3, r25	; 0x03
    3442:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3444:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    3446:	8a 81       	ldd	r24, Y+2	; 0x02
    3448:	9b 81       	ldd	r25, Y+3	; 0x03
    344a:	0e 94 86 19 	call	0x330c	; 0x330c <prvTaskIsTaskSuspended>
    344e:	88 23       	and	r24, r24
    3450:	09 f4       	brne	.+2      	; 0x3454 <xTaskResumeFromISR+0x2c>
    3452:	46 c0       	rjmp	.+140    	; 0x34e0 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3454:	80 91 65 06 	lds	r24, 0x0665
    3458:	88 23       	and	r24, r24
    345a:	c1 f5       	brne	.+112    	; 0x34cc <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    345c:	ea 81       	ldd	r30, Y+2	; 0x02
    345e:	fb 81       	ldd	r31, Y+3	; 0x03
    3460:	96 89       	ldd	r25, Z+22	; 0x16
    3462:	e0 91 56 06 	lds	r30, 0x0656
    3466:	f0 91 57 06 	lds	r31, 0x0657
    346a:	86 89       	ldd	r24, Z+22	; 0x16
    346c:	98 17       	cp	r25, r24
    346e:	10 f0       	brcs	.+4      	; 0x3474 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    3470:	81 e0       	ldi	r24, 0x01	; 1
    3472:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3474:	8a 81       	ldd	r24, Y+2	; 0x02
    3476:	9b 81       	ldd	r25, Y+3	; 0x03
    3478:	02 96       	adiw	r24, 0x02	; 2
    347a:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    347e:	ea 81       	ldd	r30, Y+2	; 0x02
    3480:	fb 81       	ldd	r31, Y+3	; 0x03
    3482:	96 89       	ldd	r25, Z+22	; 0x16
    3484:	80 91 5b 06 	lds	r24, 0x065B
    3488:	89 17       	cp	r24, r25
    348a:	28 f4       	brcc	.+10     	; 0x3496 <xTaskResumeFromISR+0x6e>
    348c:	ea 81       	ldd	r30, Y+2	; 0x02
    348e:	fb 81       	ldd	r31, Y+3	; 0x03
    3490:	86 89       	ldd	r24, Z+22	; 0x16
    3492:	80 93 5b 06 	sts	0x065B, r24
    3496:	ea 81       	ldd	r30, Y+2	; 0x02
    3498:	fb 81       	ldd	r31, Y+3	; 0x03
    349a:	86 89       	ldd	r24, Z+22	; 0x16
    349c:	28 2f       	mov	r18, r24
    349e:	30 e0       	ldi	r19, 0x00	; 0
    34a0:	c9 01       	movw	r24, r18
    34a2:	88 0f       	add	r24, r24
    34a4:	99 1f       	adc	r25, r25
    34a6:	88 0f       	add	r24, r24
    34a8:	99 1f       	adc	r25, r25
    34aa:	88 0f       	add	r24, r24
    34ac:	99 1f       	adc	r25, r25
    34ae:	82 0f       	add	r24, r18
    34b0:	93 1f       	adc	r25, r19
    34b2:	ac 01       	movw	r20, r24
    34b4:	4a 59       	subi	r20, 0x9A	; 154
    34b6:	59 4f       	sbci	r21, 0xF9	; 249
    34b8:	8a 81       	ldd	r24, Y+2	; 0x02
    34ba:	9b 81       	ldd	r25, Y+3	; 0x03
    34bc:	9c 01       	movw	r18, r24
    34be:	2e 5f       	subi	r18, 0xFE	; 254
    34c0:	3f 4f       	sbci	r19, 0xFF	; 255
    34c2:	ca 01       	movw	r24, r20
    34c4:	b9 01       	movw	r22, r18
    34c6:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    34ca:	0a c0       	rjmp	.+20     	; 0x34e0 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    34cc:	8a 81       	ldd	r24, Y+2	; 0x02
    34ce:	9b 81       	ldd	r25, Y+3	; 0x03
    34d0:	9c 01       	movw	r18, r24
    34d2:	24 5f       	subi	r18, 0xF4	; 244
    34d4:	3f 4f       	sbci	r19, 0xFF	; 255
    34d6:	80 ea       	ldi	r24, 0xA0	; 160
    34d8:	96 e0       	ldi	r25, 0x06	; 6
    34da:	b9 01       	movw	r22, r18
    34dc:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    34e0:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    34e2:	26 96       	adiw	r28, 0x06	; 6
    34e4:	0f b6       	in	r0, 0x3f	; 63
    34e6:	f8 94       	cli
    34e8:	de bf       	out	0x3e, r29	; 62
    34ea:	0f be       	out	0x3f, r0	; 63
    34ec:	cd bf       	out	0x3d, r28	; 61
    34ee:	cf 91       	pop	r28
    34f0:	df 91       	pop	r29
    34f2:	08 95       	ret

000034f4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    34f4:	ef 92       	push	r14
    34f6:	ff 92       	push	r15
    34f8:	0f 93       	push	r16
    34fa:	df 93       	push	r29
    34fc:	cf 93       	push	r28
    34fe:	0f 92       	push	r0
    3500:	cd b7       	in	r28, 0x3d	; 61
    3502:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    3504:	8e e9       	ldi	r24, 0x9E	; 158
    3506:	9e e1       	ldi	r25, 0x1E	; 30
    3508:	20 e6       	ldi	r18, 0x60	; 96
    350a:	30 e0       	ldi	r19, 0x00	; 0
    350c:	e3 e6       	ldi	r30, 0x63	; 99
    350e:	f6 e0       	ldi	r31, 0x06	; 6
    3510:	b9 01       	movw	r22, r18
    3512:	45 e5       	ldi	r20, 0x55	; 85
    3514:	50 e0       	ldi	r21, 0x00	; 0
    3516:	20 e0       	ldi	r18, 0x00	; 0
    3518:	30 e0       	ldi	r19, 0x00	; 0
    351a:	00 e0       	ldi	r16, 0x00	; 0
    351c:	7f 01       	movw	r14, r30
    351e:	0e 94 d7 16 	call	0x2dae	; 0x2dae <xTaskCreate>
    3522:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    3524:	89 81       	ldd	r24, Y+1	; 0x01
    3526:	81 30       	cpi	r24, 0x01	; 1
    3528:	81 f4       	brne	.+32     	; 0x354a <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    352a:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    352c:	8f ef       	ldi	r24, 0xFF	; 255
    352e:	9f ef       	ldi	r25, 0xFF	; 255
    3530:	90 93 62 06 	sts	0x0662, r25
    3534:	80 93 61 06 	sts	0x0661, r24
		xSchedulerRunning = pdTRUE;
    3538:	81 e0       	ldi	r24, 0x01	; 1
    353a:	80 93 5c 06 	sts	0x065C, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    353e:	10 92 5a 06 	sts	0x065A, r1
    3542:	10 92 59 06 	sts	0x0659, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    3546:	0e 94 c3 06 	call	0xd86	; 0xd86 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    354a:	0f 90       	pop	r0
    354c:	cf 91       	pop	r28
    354e:	df 91       	pop	r29
    3550:	0f 91       	pop	r16
    3552:	ff 90       	pop	r15
    3554:	ef 90       	pop	r14
    3556:	08 95       	ret

00003558 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3558:	df 93       	push	r29
    355a:	cf 93       	push	r28
    355c:	cd b7       	in	r28, 0x3d	; 61
    355e:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    3560:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    3562:	10 92 5c 06 	sts	0x065C, r1
	vPortEndScheduler();
    3566:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vPortEndScheduler>
}
    356a:	cf 91       	pop	r28
    356c:	df 91       	pop	r29
    356e:	08 95       	ret

00003570 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3570:	df 93       	push	r29
    3572:	cf 93       	push	r28
    3574:	cd b7       	in	r28, 0x3d	; 61
    3576:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    3578:	80 91 65 06 	lds	r24, 0x0665
    357c:	8f 5f       	subi	r24, 0xFF	; 255
    357e:	80 93 65 06 	sts	0x0665, r24
}
    3582:	cf 91       	pop	r28
    3584:	df 91       	pop	r29
    3586:	08 95       	ret

00003588 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3588:	df 93       	push	r29
    358a:	cf 93       	push	r28
    358c:	00 d0       	rcall	.+0      	; 0x358e <xTaskResumeAll+0x6>
    358e:	00 d0       	rcall	.+0      	; 0x3590 <xTaskResumeAll+0x8>
    3590:	0f 92       	push	r0
    3592:	cd b7       	in	r28, 0x3d	; 61
    3594:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    3596:	1c 82       	std	Y+4, r1	; 0x04
    3598:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    359a:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    359c:	0f b6       	in	r0, 0x3f	; 63
    359e:	f8 94       	cli
    35a0:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    35a2:	80 91 65 06 	lds	r24, 0x0665
    35a6:	81 50       	subi	r24, 0x01	; 1
    35a8:	80 93 65 06 	sts	0x0665, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    35ac:	80 91 65 06 	lds	r24, 0x0665
    35b0:	88 23       	and	r24, r24
    35b2:	09 f0       	breq	.+2      	; 0x35b6 <xTaskResumeAll+0x2e>
    35b4:	6d c0       	rjmp	.+218    	; 0x3690 <xTaskResumeAll+0x108>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    35b6:	80 91 58 06 	lds	r24, 0x0658
    35ba:	88 23       	and	r24, r24
    35bc:	09 f4       	brne	.+2      	; 0x35c0 <xTaskResumeAll+0x38>
    35be:	68 c0       	rjmp	.+208    	; 0x3690 <xTaskResumeAll+0x108>
    35c0:	45 c0       	rjmp	.+138    	; 0x364c <xTaskResumeAll+0xc4>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    35c2:	e0 91 a5 06 	lds	r30, 0x06A5
    35c6:	f0 91 a6 06 	lds	r31, 0x06A6
    35ca:	86 81       	ldd	r24, Z+6	; 0x06
    35cc:	97 81       	ldd	r25, Z+7	; 0x07
    35ce:	9c 83       	std	Y+4, r25	; 0x04
    35d0:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    35d2:	8b 81       	ldd	r24, Y+3	; 0x03
    35d4:	9c 81       	ldd	r25, Y+4	; 0x04
    35d6:	0c 96       	adiw	r24, 0x0c	; 12
    35d8:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    35dc:	8b 81       	ldd	r24, Y+3	; 0x03
    35de:	9c 81       	ldd	r25, Y+4	; 0x04
    35e0:	02 96       	adiw	r24, 0x02	; 2
    35e2:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    35e6:	eb 81       	ldd	r30, Y+3	; 0x03
    35e8:	fc 81       	ldd	r31, Y+4	; 0x04
    35ea:	96 89       	ldd	r25, Z+22	; 0x16
    35ec:	80 91 5b 06 	lds	r24, 0x065B
    35f0:	89 17       	cp	r24, r25
    35f2:	28 f4       	brcc	.+10     	; 0x35fe <xTaskResumeAll+0x76>
    35f4:	eb 81       	ldd	r30, Y+3	; 0x03
    35f6:	fc 81       	ldd	r31, Y+4	; 0x04
    35f8:	86 89       	ldd	r24, Z+22	; 0x16
    35fa:	80 93 5b 06 	sts	0x065B, r24
    35fe:	eb 81       	ldd	r30, Y+3	; 0x03
    3600:	fc 81       	ldd	r31, Y+4	; 0x04
    3602:	86 89       	ldd	r24, Z+22	; 0x16
    3604:	28 2f       	mov	r18, r24
    3606:	30 e0       	ldi	r19, 0x00	; 0
    3608:	c9 01       	movw	r24, r18
    360a:	88 0f       	add	r24, r24
    360c:	99 1f       	adc	r25, r25
    360e:	88 0f       	add	r24, r24
    3610:	99 1f       	adc	r25, r25
    3612:	88 0f       	add	r24, r24
    3614:	99 1f       	adc	r25, r25
    3616:	82 0f       	add	r24, r18
    3618:	93 1f       	adc	r25, r19
    361a:	ac 01       	movw	r20, r24
    361c:	4a 59       	subi	r20, 0x9A	; 154
    361e:	59 4f       	sbci	r21, 0xF9	; 249
    3620:	8b 81       	ldd	r24, Y+3	; 0x03
    3622:	9c 81       	ldd	r25, Y+4	; 0x04
    3624:	9c 01       	movw	r18, r24
    3626:	2e 5f       	subi	r18, 0xFE	; 254
    3628:	3f 4f       	sbci	r19, 0xFF	; 255
    362a:	ca 01       	movw	r24, r20
    362c:	b9 01       	movw	r22, r18
    362e:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3632:	eb 81       	ldd	r30, Y+3	; 0x03
    3634:	fc 81       	ldd	r31, Y+4	; 0x04
    3636:	96 89       	ldd	r25, Z+22	; 0x16
    3638:	e0 91 56 06 	lds	r30, 0x0656
    363c:	f0 91 57 06 	lds	r31, 0x0657
    3640:	86 89       	ldd	r24, Z+22	; 0x16
    3642:	98 17       	cp	r25, r24
    3644:	18 f0       	brcs	.+6      	; 0x364c <xTaskResumeAll+0xc4>
					{
						xYieldPending = pdTRUE;
    3646:	81 e0       	ldi	r24, 0x01	; 1
    3648:	80 93 5e 06 	sts	0x065E, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    364c:	80 91 a0 06 	lds	r24, 0x06A0
    3650:	88 23       	and	r24, r24
    3652:	09 f0       	breq	.+2      	; 0x3656 <xTaskResumeAll+0xce>
    3654:	b6 cf       	rjmp	.-148    	; 0x35c2 <xTaskResumeAll+0x3a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    3656:	8b 81       	ldd	r24, Y+3	; 0x03
    3658:	9c 81       	ldd	r25, Y+4	; 0x04
    365a:	00 97       	sbiw	r24, 0x00	; 0
    365c:	11 f0       	breq	.+4      	; 0x3662 <xTaskResumeAll+0xda>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    365e:	0e 94 ee 1e 	call	0x3ddc	; 0x3ddc <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    3662:	80 91 5d 06 	lds	r24, 0x065D
    3666:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    3668:	89 81       	ldd	r24, Y+1	; 0x01
    366a:	88 23       	and	r24, r24
    366c:	79 f0       	breq	.+30     	; 0x368c <xTaskResumeAll+0x104>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    366e:	0e 94 b0 1b 	call	0x3760	; 0x3760 <xTaskIncrementTick>
    3672:	88 23       	and	r24, r24
    3674:	19 f0       	breq	.+6      	; 0x367c <xTaskResumeAll+0xf4>
							{
								xYieldPending = pdTRUE;
    3676:	81 e0       	ldi	r24, 0x01	; 1
    3678:	80 93 5e 06 	sts	0x065E, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    367c:	89 81       	ldd	r24, Y+1	; 0x01
    367e:	81 50       	subi	r24, 0x01	; 1
    3680:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    3682:	89 81       	ldd	r24, Y+1	; 0x01
    3684:	88 23       	and	r24, r24
    3686:	99 f7       	brne	.-26     	; 0x366e <xTaskResumeAll+0xe6>

						uxPendedTicks = 0;
    3688:	10 92 5d 06 	sts	0x065D, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    368c:	80 91 5e 06 	lds	r24, 0x065E
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    3690:	0f 90       	pop	r0
    3692:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3694:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3696:	0f 90       	pop	r0
    3698:	0f 90       	pop	r0
    369a:	0f 90       	pop	r0
    369c:	0f 90       	pop	r0
    369e:	0f 90       	pop	r0
    36a0:	cf 91       	pop	r28
    36a2:	df 91       	pop	r29
    36a4:	08 95       	ret

000036a6 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    36a6:	df 93       	push	r29
    36a8:	cf 93       	push	r28
    36aa:	00 d0       	rcall	.+0      	; 0x36ac <xTaskGetTickCount+0x6>
    36ac:	cd b7       	in	r28, 0x3d	; 61
    36ae:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    36b0:	0f b6       	in	r0, 0x3f	; 63
    36b2:	f8 94       	cli
    36b4:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    36b6:	80 91 59 06 	lds	r24, 0x0659
    36ba:	90 91 5a 06 	lds	r25, 0x065A
    36be:	9a 83       	std	Y+2, r25	; 0x02
    36c0:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    36c2:	0f 90       	pop	r0
    36c4:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    36c6:	89 81       	ldd	r24, Y+1	; 0x01
    36c8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    36ca:	0f 90       	pop	r0
    36cc:	0f 90       	pop	r0
    36ce:	cf 91       	pop	r28
    36d0:	df 91       	pop	r29
    36d2:	08 95       	ret

000036d4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    36d4:	df 93       	push	r29
    36d6:	cf 93       	push	r28
    36d8:	00 d0       	rcall	.+0      	; 0x36da <xTaskGetTickCountFromISR+0x6>
    36da:	0f 92       	push	r0
    36dc:	cd b7       	in	r28, 0x3d	; 61
    36de:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    36e0:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    36e2:	80 91 59 06 	lds	r24, 0x0659
    36e6:	90 91 5a 06 	lds	r25, 0x065A
    36ea:	9b 83       	std	Y+3, r25	; 0x03
    36ec:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    36ee:	8a 81       	ldd	r24, Y+2	; 0x02
    36f0:	9b 81       	ldd	r25, Y+3	; 0x03
}
    36f2:	0f 90       	pop	r0
    36f4:	0f 90       	pop	r0
    36f6:	0f 90       	pop	r0
    36f8:	cf 91       	pop	r28
    36fa:	df 91       	pop	r29
    36fc:	08 95       	ret

000036fe <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    36fe:	df 93       	push	r29
    3700:	cf 93       	push	r28
    3702:	cd b7       	in	r28, 0x3d	; 61
    3704:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    3706:	80 91 58 06 	lds	r24, 0x0658
}
    370a:	cf 91       	pop	r28
    370c:	df 91       	pop	r29
    370e:	08 95       	ret

00003710 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3710:	df 93       	push	r29
    3712:	cf 93       	push	r28
    3714:	00 d0       	rcall	.+0      	; 0x3716 <pcTaskGetName+0x6>
    3716:	00 d0       	rcall	.+0      	; 0x3718 <pcTaskGetName+0x8>
    3718:	00 d0       	rcall	.+0      	; 0x371a <pcTaskGetName+0xa>
    371a:	cd b7       	in	r28, 0x3d	; 61
    371c:	de b7       	in	r29, 0x3e	; 62
    371e:	9c 83       	std	Y+4, r25	; 0x04
    3720:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    3722:	8b 81       	ldd	r24, Y+3	; 0x03
    3724:	9c 81       	ldd	r25, Y+4	; 0x04
    3726:	00 97       	sbiw	r24, 0x00	; 0
    3728:	39 f4       	brne	.+14     	; 0x3738 <pcTaskGetName+0x28>
    372a:	80 91 56 06 	lds	r24, 0x0656
    372e:	90 91 57 06 	lds	r25, 0x0657
    3732:	9e 83       	std	Y+6, r25	; 0x06
    3734:	8d 83       	std	Y+5, r24	; 0x05
    3736:	04 c0       	rjmp	.+8      	; 0x3740 <pcTaskGetName+0x30>
    3738:	8b 81       	ldd	r24, Y+3	; 0x03
    373a:	9c 81       	ldd	r25, Y+4	; 0x04
    373c:	9e 83       	std	Y+6, r25	; 0x06
    373e:	8d 83       	std	Y+5, r24	; 0x05
    3740:	8d 81       	ldd	r24, Y+5	; 0x05
    3742:	9e 81       	ldd	r25, Y+6	; 0x06
    3744:	9a 83       	std	Y+2, r25	; 0x02
    3746:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    3748:	89 81       	ldd	r24, Y+1	; 0x01
    374a:	9a 81       	ldd	r25, Y+2	; 0x02
    374c:	49 96       	adiw	r24, 0x19	; 25
}
    374e:	26 96       	adiw	r28, 0x06	; 6
    3750:	0f b6       	in	r0, 0x3f	; 63
    3752:	f8 94       	cli
    3754:	de bf       	out	0x3e, r29	; 62
    3756:	0f be       	out	0x3f, r0	; 63
    3758:	cd bf       	out	0x3d, r28	; 61
    375a:	cf 91       	pop	r28
    375c:	df 91       	pop	r29
    375e:	08 95       	ret

00003760 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3760:	df 93       	push	r29
    3762:	cf 93       	push	r28
    3764:	cd b7       	in	r28, 0x3d	; 61
    3766:	de b7       	in	r29, 0x3e	; 62
    3768:	29 97       	sbiw	r28, 0x09	; 9
    376a:	0f b6       	in	r0, 0x3f	; 63
    376c:	f8 94       	cli
    376e:	de bf       	out	0x3e, r29	; 62
    3770:	0f be       	out	0x3f, r0	; 63
    3772:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    3774:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3776:	80 91 65 06 	lds	r24, 0x0665
    377a:	88 23       	and	r24, r24
    377c:	09 f0       	breq	.+2      	; 0x3780 <xTaskIncrementTick+0x20>
    377e:	9a c0       	rjmp	.+308    	; 0x38b4 <xTaskIncrementTick+0x154>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    3780:	80 91 59 06 	lds	r24, 0x0659
    3784:	90 91 5a 06 	lds	r25, 0x065A
    3788:	01 96       	adiw	r24, 0x01	; 1
    378a:	9c 83       	std	Y+4, r25	; 0x04
    378c:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    378e:	8b 81       	ldd	r24, Y+3	; 0x03
    3790:	9c 81       	ldd	r25, Y+4	; 0x04
    3792:	90 93 5a 06 	sts	0x065A, r25
    3796:	80 93 59 06 	sts	0x0659, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    379a:	8b 81       	ldd	r24, Y+3	; 0x03
    379c:	9c 81       	ldd	r25, Y+4	; 0x04
    379e:	00 97       	sbiw	r24, 0x00	; 0
    37a0:	d9 f4       	brne	.+54     	; 0x37d8 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    37a2:	80 91 9c 06 	lds	r24, 0x069C
    37a6:	90 91 9d 06 	lds	r25, 0x069D
    37aa:	9a 83       	std	Y+2, r25	; 0x02
    37ac:	89 83       	std	Y+1, r24	; 0x01
    37ae:	80 91 9e 06 	lds	r24, 0x069E
    37b2:	90 91 9f 06 	lds	r25, 0x069F
    37b6:	90 93 9d 06 	sts	0x069D, r25
    37ba:	80 93 9c 06 	sts	0x069C, r24
    37be:	89 81       	ldd	r24, Y+1	; 0x01
    37c0:	9a 81       	ldd	r25, Y+2	; 0x02
    37c2:	90 93 9f 06 	sts	0x069F, r25
    37c6:	80 93 9e 06 	sts	0x069E, r24
    37ca:	80 91 5f 06 	lds	r24, 0x065F
    37ce:	8f 5f       	subi	r24, 0xFF	; 255
    37d0:	80 93 5f 06 	sts	0x065F, r24
    37d4:	0e 94 ee 1e 	call	0x3ddc	; 0x3ddc <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    37d8:	20 91 61 06 	lds	r18, 0x0661
    37dc:	30 91 62 06 	lds	r19, 0x0662
    37e0:	8b 81       	ldd	r24, Y+3	; 0x03
    37e2:	9c 81       	ldd	r25, Y+4	; 0x04
    37e4:	82 17       	cp	r24, r18
    37e6:	93 07       	cpc	r25, r19
    37e8:	08 f4       	brcc	.+2      	; 0x37ec <xTaskIncrementTick+0x8c>
    37ea:	69 c0       	rjmp	.+210    	; 0x38be <xTaskIncrementTick+0x15e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    37ec:	e0 91 9c 06 	lds	r30, 0x069C
    37f0:	f0 91 9d 06 	lds	r31, 0x069D
    37f4:	80 81       	ld	r24, Z
    37f6:	88 23       	and	r24, r24
    37f8:	39 f4       	brne	.+14     	; 0x3808 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    37fa:	8f ef       	ldi	r24, 0xFF	; 255
    37fc:	9f ef       	ldi	r25, 0xFF	; 255
    37fe:	90 93 62 06 	sts	0x0662, r25
    3802:	80 93 61 06 	sts	0x0661, r24
    3806:	5b c0       	rjmp	.+182    	; 0x38be <xTaskIncrementTick+0x15e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3808:	e0 91 9c 06 	lds	r30, 0x069C
    380c:	f0 91 9d 06 	lds	r31, 0x069D
    3810:	05 80       	ldd	r0, Z+5	; 0x05
    3812:	f6 81       	ldd	r31, Z+6	; 0x06
    3814:	e0 2d       	mov	r30, r0
    3816:	86 81       	ldd	r24, Z+6	; 0x06
    3818:	97 81       	ldd	r25, Z+7	; 0x07
    381a:	99 87       	std	Y+9, r25	; 0x09
    381c:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    381e:	e8 85       	ldd	r30, Y+8	; 0x08
    3820:	f9 85       	ldd	r31, Y+9	; 0x09
    3822:	82 81       	ldd	r24, Z+2	; 0x02
    3824:	93 81       	ldd	r25, Z+3	; 0x03
    3826:	9f 83       	std	Y+7, r25	; 0x07
    3828:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    382a:	2b 81       	ldd	r18, Y+3	; 0x03
    382c:	3c 81       	ldd	r19, Y+4	; 0x04
    382e:	8e 81       	ldd	r24, Y+6	; 0x06
    3830:	9f 81       	ldd	r25, Y+7	; 0x07
    3832:	28 17       	cp	r18, r24
    3834:	39 07       	cpc	r19, r25
    3836:	38 f4       	brcc	.+14     	; 0x3846 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    3838:	8e 81       	ldd	r24, Y+6	; 0x06
    383a:	9f 81       	ldd	r25, Y+7	; 0x07
    383c:	90 93 62 06 	sts	0x0662, r25
    3840:	80 93 61 06 	sts	0x0661, r24
    3844:	3c c0       	rjmp	.+120    	; 0x38be <xTaskIncrementTick+0x15e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3846:	88 85       	ldd	r24, Y+8	; 0x08
    3848:	99 85       	ldd	r25, Y+9	; 0x09
    384a:	02 96       	adiw	r24, 0x02	; 2
    384c:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3850:	e8 85       	ldd	r30, Y+8	; 0x08
    3852:	f9 85       	ldd	r31, Y+9	; 0x09
    3854:	84 89       	ldd	r24, Z+20	; 0x14
    3856:	95 89       	ldd	r25, Z+21	; 0x15
    3858:	00 97       	sbiw	r24, 0x00	; 0
    385a:	29 f0       	breq	.+10     	; 0x3866 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    385c:	88 85       	ldd	r24, Y+8	; 0x08
    385e:	99 85       	ldd	r25, Y+9	; 0x09
    3860:	0c 96       	adiw	r24, 0x0c	; 12
    3862:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    3866:	e8 85       	ldd	r30, Y+8	; 0x08
    3868:	f9 85       	ldd	r31, Y+9	; 0x09
    386a:	96 89       	ldd	r25, Z+22	; 0x16
    386c:	80 91 5b 06 	lds	r24, 0x065B
    3870:	89 17       	cp	r24, r25
    3872:	28 f4       	brcc	.+10     	; 0x387e <xTaskIncrementTick+0x11e>
    3874:	e8 85       	ldd	r30, Y+8	; 0x08
    3876:	f9 85       	ldd	r31, Y+9	; 0x09
    3878:	86 89       	ldd	r24, Z+22	; 0x16
    387a:	80 93 5b 06 	sts	0x065B, r24
    387e:	e8 85       	ldd	r30, Y+8	; 0x08
    3880:	f9 85       	ldd	r31, Y+9	; 0x09
    3882:	86 89       	ldd	r24, Z+22	; 0x16
    3884:	28 2f       	mov	r18, r24
    3886:	30 e0       	ldi	r19, 0x00	; 0
    3888:	c9 01       	movw	r24, r18
    388a:	88 0f       	add	r24, r24
    388c:	99 1f       	adc	r25, r25
    388e:	88 0f       	add	r24, r24
    3890:	99 1f       	adc	r25, r25
    3892:	88 0f       	add	r24, r24
    3894:	99 1f       	adc	r25, r25
    3896:	82 0f       	add	r24, r18
    3898:	93 1f       	adc	r25, r19
    389a:	ac 01       	movw	r20, r24
    389c:	4a 59       	subi	r20, 0x9A	; 154
    389e:	59 4f       	sbci	r21, 0xF9	; 249
    38a0:	88 85       	ldd	r24, Y+8	; 0x08
    38a2:	99 85       	ldd	r25, Y+9	; 0x09
    38a4:	9c 01       	movw	r18, r24
    38a6:	2e 5f       	subi	r18, 0xFE	; 254
    38a8:	3f 4f       	sbci	r19, 0xFF	; 255
    38aa:	ca 01       	movw	r24, r20
    38ac:	b9 01       	movw	r22, r18
    38ae:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    38b2:	9c cf       	rjmp	.-200    	; 0x37ec <xTaskIncrementTick+0x8c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    38b4:	80 91 5d 06 	lds	r24, 0x065D
    38b8:	8f 5f       	subi	r24, 0xFF	; 255
    38ba:	80 93 5d 06 	sts	0x065D, r24
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    38be:	8d 81       	ldd	r24, Y+5	; 0x05
}
    38c0:	29 96       	adiw	r28, 0x09	; 9
    38c2:	0f b6       	in	r0, 0x3f	; 63
    38c4:	f8 94       	cli
    38c6:	de bf       	out	0x3e, r29	; 62
    38c8:	0f be       	out	0x3f, r0	; 63
    38ca:	cd bf       	out	0x3d, r28	; 61
    38cc:	cf 91       	pop	r28
    38ce:	df 91       	pop	r29
    38d0:	08 95       	ret

000038d2 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    38d2:	df 93       	push	r29
    38d4:	cf 93       	push	r28
    38d6:	00 d0       	rcall	.+0      	; 0x38d8 <vTaskSwitchContext+0x6>
    38d8:	0f 92       	push	r0
    38da:	cd b7       	in	r28, 0x3d	; 61
    38dc:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    38de:	80 91 65 06 	lds	r24, 0x0665
    38e2:	88 23       	and	r24, r24
    38e4:	21 f0       	breq	.+8      	; 0x38ee <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    38e6:	81 e0       	ldi	r24, 0x01	; 1
    38e8:	80 93 5e 06 	sts	0x065E, r24
    38ec:	59 c0       	rjmp	.+178    	; 0x39a0 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    38ee:	10 92 5e 06 	sts	0x065E, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    38f2:	80 91 5b 06 	lds	r24, 0x065B
    38f6:	8b 83       	std	Y+3, r24	; 0x03
    38f8:	03 c0       	rjmp	.+6      	; 0x3900 <vTaskSwitchContext+0x2e>
    38fa:	8b 81       	ldd	r24, Y+3	; 0x03
    38fc:	81 50       	subi	r24, 0x01	; 1
    38fe:	8b 83       	std	Y+3, r24	; 0x03
    3900:	8b 81       	ldd	r24, Y+3	; 0x03
    3902:	28 2f       	mov	r18, r24
    3904:	30 e0       	ldi	r19, 0x00	; 0
    3906:	c9 01       	movw	r24, r18
    3908:	88 0f       	add	r24, r24
    390a:	99 1f       	adc	r25, r25
    390c:	88 0f       	add	r24, r24
    390e:	99 1f       	adc	r25, r25
    3910:	88 0f       	add	r24, r24
    3912:	99 1f       	adc	r25, r25
    3914:	82 0f       	add	r24, r18
    3916:	93 1f       	adc	r25, r19
    3918:	fc 01       	movw	r30, r24
    391a:	ea 59       	subi	r30, 0x9A	; 154
    391c:	f9 4f       	sbci	r31, 0xF9	; 249
    391e:	80 81       	ld	r24, Z
    3920:	88 23       	and	r24, r24
    3922:	59 f3       	breq	.-42     	; 0x38fa <vTaskSwitchContext+0x28>
    3924:	8b 81       	ldd	r24, Y+3	; 0x03
    3926:	28 2f       	mov	r18, r24
    3928:	30 e0       	ldi	r19, 0x00	; 0
    392a:	c9 01       	movw	r24, r18
    392c:	88 0f       	add	r24, r24
    392e:	99 1f       	adc	r25, r25
    3930:	88 0f       	add	r24, r24
    3932:	99 1f       	adc	r25, r25
    3934:	88 0f       	add	r24, r24
    3936:	99 1f       	adc	r25, r25
    3938:	82 0f       	add	r24, r18
    393a:	93 1f       	adc	r25, r19
    393c:	8a 59       	subi	r24, 0x9A	; 154
    393e:	99 4f       	sbci	r25, 0xF9	; 249
    3940:	9a 83       	std	Y+2, r25	; 0x02
    3942:	89 83       	std	Y+1, r24	; 0x01
    3944:	e9 81       	ldd	r30, Y+1	; 0x01
    3946:	fa 81       	ldd	r31, Y+2	; 0x02
    3948:	01 80       	ldd	r0, Z+1	; 0x01
    394a:	f2 81       	ldd	r31, Z+2	; 0x02
    394c:	e0 2d       	mov	r30, r0
    394e:	82 81       	ldd	r24, Z+2	; 0x02
    3950:	93 81       	ldd	r25, Z+3	; 0x03
    3952:	e9 81       	ldd	r30, Y+1	; 0x01
    3954:	fa 81       	ldd	r31, Y+2	; 0x02
    3956:	92 83       	std	Z+2, r25	; 0x02
    3958:	81 83       	std	Z+1, r24	; 0x01
    395a:	e9 81       	ldd	r30, Y+1	; 0x01
    395c:	fa 81       	ldd	r31, Y+2	; 0x02
    395e:	21 81       	ldd	r18, Z+1	; 0x01
    3960:	32 81       	ldd	r19, Z+2	; 0x02
    3962:	89 81       	ldd	r24, Y+1	; 0x01
    3964:	9a 81       	ldd	r25, Y+2	; 0x02
    3966:	03 96       	adiw	r24, 0x03	; 3
    3968:	28 17       	cp	r18, r24
    396a:	39 07       	cpc	r19, r25
    396c:	59 f4       	brne	.+22     	; 0x3984 <vTaskSwitchContext+0xb2>
    396e:	e9 81       	ldd	r30, Y+1	; 0x01
    3970:	fa 81       	ldd	r31, Y+2	; 0x02
    3972:	01 80       	ldd	r0, Z+1	; 0x01
    3974:	f2 81       	ldd	r31, Z+2	; 0x02
    3976:	e0 2d       	mov	r30, r0
    3978:	82 81       	ldd	r24, Z+2	; 0x02
    397a:	93 81       	ldd	r25, Z+3	; 0x03
    397c:	e9 81       	ldd	r30, Y+1	; 0x01
    397e:	fa 81       	ldd	r31, Y+2	; 0x02
    3980:	92 83       	std	Z+2, r25	; 0x02
    3982:	81 83       	std	Z+1, r24	; 0x01
    3984:	e9 81       	ldd	r30, Y+1	; 0x01
    3986:	fa 81       	ldd	r31, Y+2	; 0x02
    3988:	01 80       	ldd	r0, Z+1	; 0x01
    398a:	f2 81       	ldd	r31, Z+2	; 0x02
    398c:	e0 2d       	mov	r30, r0
    398e:	86 81       	ldd	r24, Z+6	; 0x06
    3990:	97 81       	ldd	r25, Z+7	; 0x07
    3992:	90 93 57 06 	sts	0x0657, r25
    3996:	80 93 56 06 	sts	0x0656, r24
    399a:	8b 81       	ldd	r24, Y+3	; 0x03
    399c:	80 93 5b 06 	sts	0x065B, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    39a0:	0f 90       	pop	r0
    39a2:	0f 90       	pop	r0
    39a4:	0f 90       	pop	r0
    39a6:	cf 91       	pop	r28
    39a8:	df 91       	pop	r29
    39aa:	08 95       	ret

000039ac <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    39ac:	df 93       	push	r29
    39ae:	cf 93       	push	r28
    39b0:	00 d0       	rcall	.+0      	; 0x39b2 <vTaskPlaceOnEventList+0x6>
    39b2:	00 d0       	rcall	.+0      	; 0x39b4 <vTaskPlaceOnEventList+0x8>
    39b4:	cd b7       	in	r28, 0x3d	; 61
    39b6:	de b7       	in	r29, 0x3e	; 62
    39b8:	9a 83       	std	Y+2, r25	; 0x02
    39ba:	89 83       	std	Y+1, r24	; 0x01
    39bc:	7c 83       	std	Y+4, r23	; 0x04
    39be:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    39c0:	80 91 56 06 	lds	r24, 0x0656
    39c4:	90 91 57 06 	lds	r25, 0x0657
    39c8:	9c 01       	movw	r18, r24
    39ca:	24 5f       	subi	r18, 0xF4	; 244
    39cc:	3f 4f       	sbci	r19, 0xFF	; 255
    39ce:	89 81       	ldd	r24, Y+1	; 0x01
    39d0:	9a 81       	ldd	r25, Y+2	; 0x02
    39d2:	b9 01       	movw	r22, r18
    39d4:	0e 94 88 04 	call	0x910	; 0x910 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    39d8:	8b 81       	ldd	r24, Y+3	; 0x03
    39da:	9c 81       	ldd	r25, Y+4	; 0x04
    39dc:	61 e0       	ldi	r22, 0x01	; 1
    39de:	0e 94 f2 22 	call	0x45e4	; 0x45e4 <prvAddCurrentTaskToDelayedList>
}
    39e2:	0f 90       	pop	r0
    39e4:	0f 90       	pop	r0
    39e6:	0f 90       	pop	r0
    39e8:	0f 90       	pop	r0
    39ea:	cf 91       	pop	r28
    39ec:	df 91       	pop	r29
    39ee:	08 95       	ret

000039f0 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    39f0:	df 93       	push	r29
    39f2:	cf 93       	push	r28
    39f4:	00 d0       	rcall	.+0      	; 0x39f6 <vTaskPlaceOnUnorderedEventList+0x6>
    39f6:	00 d0       	rcall	.+0      	; 0x39f8 <vTaskPlaceOnUnorderedEventList+0x8>
    39f8:	00 d0       	rcall	.+0      	; 0x39fa <vTaskPlaceOnUnorderedEventList+0xa>
    39fa:	cd b7       	in	r28, 0x3d	; 61
    39fc:	de b7       	in	r29, 0x3e	; 62
    39fe:	9a 83       	std	Y+2, r25	; 0x02
    3a00:	89 83       	std	Y+1, r24	; 0x01
    3a02:	7c 83       	std	Y+4, r23	; 0x04
    3a04:	6b 83       	std	Y+3, r22	; 0x03
    3a06:	5e 83       	std	Y+6, r21	; 0x06
    3a08:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3a0a:	e0 91 56 06 	lds	r30, 0x0656
    3a0e:	f0 91 57 06 	lds	r31, 0x0657
    3a12:	8b 81       	ldd	r24, Y+3	; 0x03
    3a14:	9c 81       	ldd	r25, Y+4	; 0x04
    3a16:	90 68       	ori	r25, 0x80	; 128
    3a18:	95 87       	std	Z+13, r25	; 0x0d
    3a1a:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3a1c:	80 91 56 06 	lds	r24, 0x0656
    3a20:	90 91 57 06 	lds	r25, 0x0657
    3a24:	9c 01       	movw	r18, r24
    3a26:	24 5f       	subi	r18, 0xF4	; 244
    3a28:	3f 4f       	sbci	r19, 0xFF	; 255
    3a2a:	89 81       	ldd	r24, Y+1	; 0x01
    3a2c:	9a 81       	ldd	r25, Y+2	; 0x02
    3a2e:	b9 01       	movw	r22, r18
    3a30:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3a34:	8d 81       	ldd	r24, Y+5	; 0x05
    3a36:	9e 81       	ldd	r25, Y+6	; 0x06
    3a38:	61 e0       	ldi	r22, 0x01	; 1
    3a3a:	0e 94 f2 22 	call	0x45e4	; 0x45e4 <prvAddCurrentTaskToDelayedList>
}
    3a3e:	26 96       	adiw	r28, 0x06	; 6
    3a40:	0f b6       	in	r0, 0x3f	; 63
    3a42:	f8 94       	cli
    3a44:	de bf       	out	0x3e, r29	; 62
    3a46:	0f be       	out	0x3f, r0	; 63
    3a48:	cd bf       	out	0x3d, r28	; 61
    3a4a:	cf 91       	pop	r28
    3a4c:	df 91       	pop	r29
    3a4e:	08 95       	ret

00003a50 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3a50:	df 93       	push	r29
    3a52:	cf 93       	push	r28
    3a54:	00 d0       	rcall	.+0      	; 0x3a56 <xTaskRemoveFromEventList+0x6>
    3a56:	00 d0       	rcall	.+0      	; 0x3a58 <xTaskRemoveFromEventList+0x8>
    3a58:	0f 92       	push	r0
    3a5a:	cd b7       	in	r28, 0x3d	; 61
    3a5c:	de b7       	in	r29, 0x3e	; 62
    3a5e:	9d 83       	std	Y+5, r25	; 0x05
    3a60:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3a62:	ec 81       	ldd	r30, Y+4	; 0x04
    3a64:	fd 81       	ldd	r31, Y+5	; 0x05
    3a66:	05 80       	ldd	r0, Z+5	; 0x05
    3a68:	f6 81       	ldd	r31, Z+6	; 0x06
    3a6a:	e0 2d       	mov	r30, r0
    3a6c:	86 81       	ldd	r24, Z+6	; 0x06
    3a6e:	97 81       	ldd	r25, Z+7	; 0x07
    3a70:	9b 83       	std	Y+3, r25	; 0x03
    3a72:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3a74:	8a 81       	ldd	r24, Y+2	; 0x02
    3a76:	9b 81       	ldd	r25, Y+3	; 0x03
    3a78:	0c 96       	adiw	r24, 0x0c	; 12
    3a7a:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3a7e:	80 91 65 06 	lds	r24, 0x0665
    3a82:	88 23       	and	r24, r24
    3a84:	61 f5       	brne	.+88     	; 0x3ade <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3a86:	8a 81       	ldd	r24, Y+2	; 0x02
    3a88:	9b 81       	ldd	r25, Y+3	; 0x03
    3a8a:	02 96       	adiw	r24, 0x02	; 2
    3a8c:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    3a90:	ea 81       	ldd	r30, Y+2	; 0x02
    3a92:	fb 81       	ldd	r31, Y+3	; 0x03
    3a94:	96 89       	ldd	r25, Z+22	; 0x16
    3a96:	80 91 5b 06 	lds	r24, 0x065B
    3a9a:	89 17       	cp	r24, r25
    3a9c:	28 f4       	brcc	.+10     	; 0x3aa8 <xTaskRemoveFromEventList+0x58>
    3a9e:	ea 81       	ldd	r30, Y+2	; 0x02
    3aa0:	fb 81       	ldd	r31, Y+3	; 0x03
    3aa2:	86 89       	ldd	r24, Z+22	; 0x16
    3aa4:	80 93 5b 06 	sts	0x065B, r24
    3aa8:	ea 81       	ldd	r30, Y+2	; 0x02
    3aaa:	fb 81       	ldd	r31, Y+3	; 0x03
    3aac:	86 89       	ldd	r24, Z+22	; 0x16
    3aae:	28 2f       	mov	r18, r24
    3ab0:	30 e0       	ldi	r19, 0x00	; 0
    3ab2:	c9 01       	movw	r24, r18
    3ab4:	88 0f       	add	r24, r24
    3ab6:	99 1f       	adc	r25, r25
    3ab8:	88 0f       	add	r24, r24
    3aba:	99 1f       	adc	r25, r25
    3abc:	88 0f       	add	r24, r24
    3abe:	99 1f       	adc	r25, r25
    3ac0:	82 0f       	add	r24, r18
    3ac2:	93 1f       	adc	r25, r19
    3ac4:	ac 01       	movw	r20, r24
    3ac6:	4a 59       	subi	r20, 0x9A	; 154
    3ac8:	59 4f       	sbci	r21, 0xF9	; 249
    3aca:	8a 81       	ldd	r24, Y+2	; 0x02
    3acc:	9b 81       	ldd	r25, Y+3	; 0x03
    3ace:	9c 01       	movw	r18, r24
    3ad0:	2e 5f       	subi	r18, 0xFE	; 254
    3ad2:	3f 4f       	sbci	r19, 0xFF	; 255
    3ad4:	ca 01       	movw	r24, r20
    3ad6:	b9 01       	movw	r22, r18
    3ad8:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    3adc:	0a c0       	rjmp	.+20     	; 0x3af2 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3ade:	8a 81       	ldd	r24, Y+2	; 0x02
    3ae0:	9b 81       	ldd	r25, Y+3	; 0x03
    3ae2:	9c 01       	movw	r18, r24
    3ae4:	24 5f       	subi	r18, 0xF4	; 244
    3ae6:	3f 4f       	sbci	r19, 0xFF	; 255
    3ae8:	80 ea       	ldi	r24, 0xA0	; 160
    3aea:	96 e0       	ldi	r25, 0x06	; 6
    3aec:	b9 01       	movw	r22, r18
    3aee:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3af2:	ea 81       	ldd	r30, Y+2	; 0x02
    3af4:	fb 81       	ldd	r31, Y+3	; 0x03
    3af6:	96 89       	ldd	r25, Z+22	; 0x16
    3af8:	e0 91 56 06 	lds	r30, 0x0656
    3afc:	f0 91 57 06 	lds	r31, 0x0657
    3b00:	86 89       	ldd	r24, Z+22	; 0x16
    3b02:	89 17       	cp	r24, r25
    3b04:	30 f4       	brcc	.+12     	; 0x3b12 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    3b06:	81 e0       	ldi	r24, 0x01	; 1
    3b08:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3b0a:	81 e0       	ldi	r24, 0x01	; 1
    3b0c:	80 93 5e 06 	sts	0x065E, r24
    3b10:	01 c0       	rjmp	.+2      	; 0x3b14 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    3b12:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3b14:	89 81       	ldd	r24, Y+1	; 0x01
}
    3b16:	0f 90       	pop	r0
    3b18:	0f 90       	pop	r0
    3b1a:	0f 90       	pop	r0
    3b1c:	0f 90       	pop	r0
    3b1e:	0f 90       	pop	r0
    3b20:	cf 91       	pop	r28
    3b22:	df 91       	pop	r29
    3b24:	08 95       	ret

00003b26 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    3b26:	df 93       	push	r29
    3b28:	cf 93       	push	r28
    3b2a:	00 d0       	rcall	.+0      	; 0x3b2c <vTaskRemoveFromUnorderedEventList+0x6>
    3b2c:	00 d0       	rcall	.+0      	; 0x3b2e <vTaskRemoveFromUnorderedEventList+0x8>
    3b2e:	00 d0       	rcall	.+0      	; 0x3b30 <vTaskRemoveFromUnorderedEventList+0xa>
    3b30:	cd b7       	in	r28, 0x3d	; 61
    3b32:	de b7       	in	r29, 0x3e	; 62
    3b34:	9c 83       	std	Y+4, r25	; 0x04
    3b36:	8b 83       	std	Y+3, r24	; 0x03
    3b38:	7e 83       	std	Y+6, r23	; 0x06
    3b3a:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3b3c:	8d 81       	ldd	r24, Y+5	; 0x05
    3b3e:	9e 81       	ldd	r25, Y+6	; 0x06
    3b40:	90 68       	ori	r25, 0x80	; 128
    3b42:	eb 81       	ldd	r30, Y+3	; 0x03
    3b44:	fc 81       	ldd	r31, Y+4	; 0x04
    3b46:	91 83       	std	Z+1, r25	; 0x01
    3b48:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3b4a:	eb 81       	ldd	r30, Y+3	; 0x03
    3b4c:	fc 81       	ldd	r31, Y+4	; 0x04
    3b4e:	86 81       	ldd	r24, Z+6	; 0x06
    3b50:	97 81       	ldd	r25, Z+7	; 0x07
    3b52:	9a 83       	std	Y+2, r25	; 0x02
    3b54:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    3b56:	8b 81       	ldd	r24, Y+3	; 0x03
    3b58:	9c 81       	ldd	r25, Y+4	; 0x04
    3b5a:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3b5e:	89 81       	ldd	r24, Y+1	; 0x01
    3b60:	9a 81       	ldd	r25, Y+2	; 0x02
    3b62:	02 96       	adiw	r24, 0x02	; 2
    3b64:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    3b68:	e9 81       	ldd	r30, Y+1	; 0x01
    3b6a:	fa 81       	ldd	r31, Y+2	; 0x02
    3b6c:	96 89       	ldd	r25, Z+22	; 0x16
    3b6e:	80 91 5b 06 	lds	r24, 0x065B
    3b72:	89 17       	cp	r24, r25
    3b74:	28 f4       	brcc	.+10     	; 0x3b80 <vTaskRemoveFromUnorderedEventList+0x5a>
    3b76:	e9 81       	ldd	r30, Y+1	; 0x01
    3b78:	fa 81       	ldd	r31, Y+2	; 0x02
    3b7a:	86 89       	ldd	r24, Z+22	; 0x16
    3b7c:	80 93 5b 06 	sts	0x065B, r24
    3b80:	e9 81       	ldd	r30, Y+1	; 0x01
    3b82:	fa 81       	ldd	r31, Y+2	; 0x02
    3b84:	86 89       	ldd	r24, Z+22	; 0x16
    3b86:	28 2f       	mov	r18, r24
    3b88:	30 e0       	ldi	r19, 0x00	; 0
    3b8a:	c9 01       	movw	r24, r18
    3b8c:	88 0f       	add	r24, r24
    3b8e:	99 1f       	adc	r25, r25
    3b90:	88 0f       	add	r24, r24
    3b92:	99 1f       	adc	r25, r25
    3b94:	88 0f       	add	r24, r24
    3b96:	99 1f       	adc	r25, r25
    3b98:	82 0f       	add	r24, r18
    3b9a:	93 1f       	adc	r25, r19
    3b9c:	ac 01       	movw	r20, r24
    3b9e:	4a 59       	subi	r20, 0x9A	; 154
    3ba0:	59 4f       	sbci	r21, 0xF9	; 249
    3ba2:	89 81       	ldd	r24, Y+1	; 0x01
    3ba4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ba6:	9c 01       	movw	r18, r24
    3ba8:	2e 5f       	subi	r18, 0xFE	; 254
    3baa:	3f 4f       	sbci	r19, 0xFF	; 255
    3bac:	ca 01       	movw	r24, r20
    3bae:	b9 01       	movw	r22, r18
    3bb0:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3bb4:	e9 81       	ldd	r30, Y+1	; 0x01
    3bb6:	fa 81       	ldd	r31, Y+2	; 0x02
    3bb8:	96 89       	ldd	r25, Z+22	; 0x16
    3bba:	e0 91 56 06 	lds	r30, 0x0656
    3bbe:	f0 91 57 06 	lds	r31, 0x0657
    3bc2:	86 89       	ldd	r24, Z+22	; 0x16
    3bc4:	89 17       	cp	r24, r25
    3bc6:	18 f4       	brcc	.+6      	; 0x3bce <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    3bc8:	81 e0       	ldi	r24, 0x01	; 1
    3bca:	80 93 5e 06 	sts	0x065E, r24
	}
}
    3bce:	26 96       	adiw	r28, 0x06	; 6
    3bd0:	0f b6       	in	r0, 0x3f	; 63
    3bd2:	f8 94       	cli
    3bd4:	de bf       	out	0x3e, r29	; 62
    3bd6:	0f be       	out	0x3f, r0	; 63
    3bd8:	cd bf       	out	0x3d, r28	; 61
    3bda:	cf 91       	pop	r28
    3bdc:	df 91       	pop	r29
    3bde:	08 95       	ret

00003be0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3be0:	df 93       	push	r29
    3be2:	cf 93       	push	r28
    3be4:	00 d0       	rcall	.+0      	; 0x3be6 <vTaskSetTimeOutState+0x6>
    3be6:	cd b7       	in	r28, 0x3d	; 61
    3be8:	de b7       	in	r29, 0x3e	; 62
    3bea:	9a 83       	std	Y+2, r25	; 0x02
    3bec:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    3bee:	0f b6       	in	r0, 0x3f	; 63
    3bf0:	f8 94       	cli
    3bf2:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    3bf4:	80 91 5f 06 	lds	r24, 0x065F
    3bf8:	e9 81       	ldd	r30, Y+1	; 0x01
    3bfa:	fa 81       	ldd	r31, Y+2	; 0x02
    3bfc:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    3bfe:	80 91 59 06 	lds	r24, 0x0659
    3c02:	90 91 5a 06 	lds	r25, 0x065A
    3c06:	e9 81       	ldd	r30, Y+1	; 0x01
    3c08:	fa 81       	ldd	r31, Y+2	; 0x02
    3c0a:	92 83       	std	Z+2, r25	; 0x02
    3c0c:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3c0e:	0f 90       	pop	r0
    3c10:	0f be       	out	0x3f, r0	; 63
}
    3c12:	0f 90       	pop	r0
    3c14:	0f 90       	pop	r0
    3c16:	cf 91       	pop	r28
    3c18:	df 91       	pop	r29
    3c1a:	08 95       	ret

00003c1c <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3c1c:	df 93       	push	r29
    3c1e:	cf 93       	push	r28
    3c20:	00 d0       	rcall	.+0      	; 0x3c22 <vTaskInternalSetTimeOutState+0x6>
    3c22:	cd b7       	in	r28, 0x3d	; 61
    3c24:	de b7       	in	r29, 0x3e	; 62
    3c26:	9a 83       	std	Y+2, r25	; 0x02
    3c28:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3c2a:	80 91 5f 06 	lds	r24, 0x065F
    3c2e:	e9 81       	ldd	r30, Y+1	; 0x01
    3c30:	fa 81       	ldd	r31, Y+2	; 0x02
    3c32:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3c34:	80 91 59 06 	lds	r24, 0x0659
    3c38:	90 91 5a 06 	lds	r25, 0x065A
    3c3c:	e9 81       	ldd	r30, Y+1	; 0x01
    3c3e:	fa 81       	ldd	r31, Y+2	; 0x02
    3c40:	92 83       	std	Z+2, r25	; 0x02
    3c42:	81 83       	std	Z+1, r24	; 0x01
}
    3c44:	0f 90       	pop	r0
    3c46:	0f 90       	pop	r0
    3c48:	cf 91       	pop	r28
    3c4a:	df 91       	pop	r29
    3c4c:	08 95       	ret

00003c4e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    3c4e:	df 93       	push	r29
    3c50:	cf 93       	push	r28
    3c52:	cd b7       	in	r28, 0x3d	; 61
    3c54:	de b7       	in	r29, 0x3e	; 62
    3c56:	29 97       	sbiw	r28, 0x09	; 9
    3c58:	0f b6       	in	r0, 0x3f	; 63
    3c5a:	f8 94       	cli
    3c5c:	de bf       	out	0x3e, r29	; 62
    3c5e:	0f be       	out	0x3f, r0	; 63
    3c60:	cd bf       	out	0x3d, r28	; 61
    3c62:	9f 83       	std	Y+7, r25	; 0x07
    3c64:	8e 83       	std	Y+6, r24	; 0x06
    3c66:	79 87       	std	Y+9, r23	; 0x09
    3c68:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3c6a:	0f b6       	in	r0, 0x3f	; 63
    3c6c:	f8 94       	cli
    3c6e:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    3c70:	80 91 59 06 	lds	r24, 0x0659
    3c74:	90 91 5a 06 	lds	r25, 0x065A
    3c78:	9c 83       	std	Y+4, r25	; 0x04
    3c7a:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    3c7c:	ee 81       	ldd	r30, Y+6	; 0x06
    3c7e:	ff 81       	ldd	r31, Y+7	; 0x07
    3c80:	21 81       	ldd	r18, Z+1	; 0x01
    3c82:	32 81       	ldd	r19, Z+2	; 0x02
    3c84:	8b 81       	ldd	r24, Y+3	; 0x03
    3c86:	9c 81       	ldd	r25, Y+4	; 0x04
    3c88:	82 1b       	sub	r24, r18
    3c8a:	93 0b       	sbc	r25, r19
    3c8c:	9a 83       	std	Y+2, r25	; 0x02
    3c8e:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    3c90:	e8 85       	ldd	r30, Y+8	; 0x08
    3c92:	f9 85       	ldd	r31, Y+9	; 0x09
    3c94:	80 81       	ld	r24, Z
    3c96:	91 81       	ldd	r25, Z+1	; 0x01
    3c98:	2f ef       	ldi	r18, 0xFF	; 255
    3c9a:	8f 3f       	cpi	r24, 0xFF	; 255
    3c9c:	92 07       	cpc	r25, r18
    3c9e:	11 f4       	brne	.+4      	; 0x3ca4 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    3ca0:	1d 82       	std	Y+5, r1	; 0x05
    3ca2:	36 c0       	rjmp	.+108    	; 0x3d10 <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3ca4:	ee 81       	ldd	r30, Y+6	; 0x06
    3ca6:	ff 81       	ldd	r31, Y+7	; 0x07
    3ca8:	90 81       	ld	r25, Z
    3caa:	80 91 5f 06 	lds	r24, 0x065F
    3cae:	98 17       	cp	r25, r24
    3cb0:	61 f0       	breq	.+24     	; 0x3cca <xTaskCheckForTimeOut+0x7c>
    3cb2:	ee 81       	ldd	r30, Y+6	; 0x06
    3cb4:	ff 81       	ldd	r31, Y+7	; 0x07
    3cb6:	21 81       	ldd	r18, Z+1	; 0x01
    3cb8:	32 81       	ldd	r19, Z+2	; 0x02
    3cba:	8b 81       	ldd	r24, Y+3	; 0x03
    3cbc:	9c 81       	ldd	r25, Y+4	; 0x04
    3cbe:	82 17       	cp	r24, r18
    3cc0:	93 07       	cpc	r25, r19
    3cc2:	18 f0       	brcs	.+6      	; 0x3cca <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    3cc4:	81 e0       	ldi	r24, 0x01	; 1
    3cc6:	8d 83       	std	Y+5, r24	; 0x05
    3cc8:	23 c0       	rjmp	.+70     	; 0x3d10 <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    3cca:	e8 85       	ldd	r30, Y+8	; 0x08
    3ccc:	f9 85       	ldd	r31, Y+9	; 0x09
    3cce:	20 81       	ld	r18, Z
    3cd0:	31 81       	ldd	r19, Z+1	; 0x01
    3cd2:	89 81       	ldd	r24, Y+1	; 0x01
    3cd4:	9a 81       	ldd	r25, Y+2	; 0x02
    3cd6:	82 17       	cp	r24, r18
    3cd8:	93 07       	cpc	r25, r19
    3cda:	a0 f4       	brcc	.+40     	; 0x3d04 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    3cdc:	e8 85       	ldd	r30, Y+8	; 0x08
    3cde:	f9 85       	ldd	r31, Y+9	; 0x09
    3ce0:	20 81       	ld	r18, Z
    3ce2:	31 81       	ldd	r19, Z+1	; 0x01
    3ce4:	89 81       	ldd	r24, Y+1	; 0x01
    3ce6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ce8:	a9 01       	movw	r20, r18
    3cea:	48 1b       	sub	r20, r24
    3cec:	59 0b       	sbc	r21, r25
    3cee:	ca 01       	movw	r24, r20
    3cf0:	e8 85       	ldd	r30, Y+8	; 0x08
    3cf2:	f9 85       	ldd	r31, Y+9	; 0x09
    3cf4:	91 83       	std	Z+1, r25	; 0x01
    3cf6:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    3cf8:	8e 81       	ldd	r24, Y+6	; 0x06
    3cfa:	9f 81       	ldd	r25, Y+7	; 0x07
    3cfc:	0e 94 0e 1e 	call	0x3c1c	; 0x3c1c <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    3d00:	1d 82       	std	Y+5, r1	; 0x05
    3d02:	06 c0       	rjmp	.+12     	; 0x3d10 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    3d04:	e8 85       	ldd	r30, Y+8	; 0x08
    3d06:	f9 85       	ldd	r31, Y+9	; 0x09
    3d08:	11 82       	std	Z+1, r1	; 0x01
    3d0a:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    3d0c:	81 e0       	ldi	r24, 0x01	; 1
    3d0e:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    3d10:	0f 90       	pop	r0
    3d12:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3d14:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3d16:	29 96       	adiw	r28, 0x09	; 9
    3d18:	0f b6       	in	r0, 0x3f	; 63
    3d1a:	f8 94       	cli
    3d1c:	de bf       	out	0x3e, r29	; 62
    3d1e:	0f be       	out	0x3f, r0	; 63
    3d20:	cd bf       	out	0x3d, r28	; 61
    3d22:	cf 91       	pop	r28
    3d24:	df 91       	pop	r29
    3d26:	08 95       	ret

00003d28 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3d28:	df 93       	push	r29
    3d2a:	cf 93       	push	r28
    3d2c:	cd b7       	in	r28, 0x3d	; 61
    3d2e:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    3d30:	81 e0       	ldi	r24, 0x01	; 1
    3d32:	80 93 5e 06 	sts	0x065E, r24
}
    3d36:	cf 91       	pop	r28
    3d38:	df 91       	pop	r29
    3d3a:	08 95       	ret

00003d3c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3d3c:	df 93       	push	r29
    3d3e:	cf 93       	push	r28
    3d40:	00 d0       	rcall	.+0      	; 0x3d42 <prvIdleTask+0x6>
    3d42:	cd b7       	in	r28, 0x3d	; 61
    3d44:	de b7       	in	r29, 0x3e	; 62
    3d46:	9a 83       	std	Y+2, r25	; 0x02
    3d48:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    3d4a:	0e 94 e7 1e 	call	0x3dce	; 0x3dce <prvCheckTasksWaitingTermination>
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    3d4e:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    3d52:	fb cf       	rjmp	.-10     	; 0x3d4a <prvIdleTask+0xe>

00003d54 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    3d54:	df 93       	push	r29
    3d56:	cf 93       	push	r28
    3d58:	0f 92       	push	r0
    3d5a:	cd b7       	in	r28, 0x3d	; 61
    3d5c:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3d5e:	19 82       	std	Y+1, r1	; 0x01
    3d60:	13 c0       	rjmp	.+38     	; 0x3d88 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    3d62:	89 81       	ldd	r24, Y+1	; 0x01
    3d64:	28 2f       	mov	r18, r24
    3d66:	30 e0       	ldi	r19, 0x00	; 0
    3d68:	c9 01       	movw	r24, r18
    3d6a:	88 0f       	add	r24, r24
    3d6c:	99 1f       	adc	r25, r25
    3d6e:	88 0f       	add	r24, r24
    3d70:	99 1f       	adc	r25, r25
    3d72:	88 0f       	add	r24, r24
    3d74:	99 1f       	adc	r25, r25
    3d76:	82 0f       	add	r24, r18
    3d78:	93 1f       	adc	r25, r19
    3d7a:	8a 59       	subi	r24, 0x9A	; 154
    3d7c:	99 4f       	sbci	r25, 0xF9	; 249
    3d7e:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3d82:	89 81       	ldd	r24, Y+1	; 0x01
    3d84:	8f 5f       	subi	r24, 0xFF	; 255
    3d86:	89 83       	std	Y+1, r24	; 0x01
    3d88:	89 81       	ldd	r24, Y+1	; 0x01
    3d8a:	84 30       	cpi	r24, 0x04	; 4
    3d8c:	50 f3       	brcs	.-44     	; 0x3d62 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    3d8e:	8a e8       	ldi	r24, 0x8A	; 138
    3d90:	96 e0       	ldi	r25, 0x06	; 6
    3d92:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    3d96:	83 e9       	ldi	r24, 0x93	; 147
    3d98:	96 e0       	ldi	r25, 0x06	; 6
    3d9a:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    3d9e:	80 ea       	ldi	r24, 0xA0	; 160
    3da0:	96 e0       	ldi	r25, 0x06	; 6
    3da2:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    3da6:	89 ea       	ldi	r24, 0xA9	; 169
    3da8:	96 e0       	ldi	r25, 0x06	; 6
    3daa:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3dae:	8a e8       	ldi	r24, 0x8A	; 138
    3db0:	96 e0       	ldi	r25, 0x06	; 6
    3db2:	90 93 9d 06 	sts	0x069D, r25
    3db6:	80 93 9c 06 	sts	0x069C, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3dba:	83 e9       	ldi	r24, 0x93	; 147
    3dbc:	96 e0       	ldi	r25, 0x06	; 6
    3dbe:	90 93 9f 06 	sts	0x069F, r25
    3dc2:	80 93 9e 06 	sts	0x069E, r24
}
    3dc6:	0f 90       	pop	r0
    3dc8:	cf 91       	pop	r28
    3dca:	df 91       	pop	r29
    3dcc:	08 95       	ret

00003dce <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3dce:	df 93       	push	r29
    3dd0:	cf 93       	push	r28
    3dd2:	cd b7       	in	r28, 0x3d	; 61
    3dd4:	de b7       	in	r29, 0x3e	; 62

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    3dd6:	cf 91       	pop	r28
    3dd8:	df 91       	pop	r29
    3dda:	08 95       	ret

00003ddc <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    3ddc:	df 93       	push	r29
    3dde:	cf 93       	push	r28
    3de0:	00 d0       	rcall	.+0      	; 0x3de2 <prvResetNextTaskUnblockTime+0x6>
    3de2:	cd b7       	in	r28, 0x3d	; 61
    3de4:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3de6:	e0 91 9c 06 	lds	r30, 0x069C
    3dea:	f0 91 9d 06 	lds	r31, 0x069D
    3dee:	80 81       	ld	r24, Z
    3df0:	88 23       	and	r24, r24
    3df2:	39 f4       	brne	.+14     	; 0x3e02 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    3df4:	8f ef       	ldi	r24, 0xFF	; 255
    3df6:	9f ef       	ldi	r25, 0xFF	; 255
    3df8:	90 93 62 06 	sts	0x0662, r25
    3dfc:	80 93 61 06 	sts	0x0661, r24
    3e00:	13 c0       	rjmp	.+38     	; 0x3e28 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3e02:	e0 91 9c 06 	lds	r30, 0x069C
    3e06:	f0 91 9d 06 	lds	r31, 0x069D
    3e0a:	05 80       	ldd	r0, Z+5	; 0x05
    3e0c:	f6 81       	ldd	r31, Z+6	; 0x06
    3e0e:	e0 2d       	mov	r30, r0
    3e10:	86 81       	ldd	r24, Z+6	; 0x06
    3e12:	97 81       	ldd	r25, Z+7	; 0x07
    3e14:	9a 83       	std	Y+2, r25	; 0x02
    3e16:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    3e18:	e9 81       	ldd	r30, Y+1	; 0x01
    3e1a:	fa 81       	ldd	r31, Y+2	; 0x02
    3e1c:	82 81       	ldd	r24, Z+2	; 0x02
    3e1e:	93 81       	ldd	r25, Z+3	; 0x03
    3e20:	90 93 62 06 	sts	0x0662, r25
    3e24:	80 93 61 06 	sts	0x0661, r24
	}
}
    3e28:	0f 90       	pop	r0
    3e2a:	0f 90       	pop	r0
    3e2c:	cf 91       	pop	r28
    3e2e:	df 91       	pop	r29
    3e30:	08 95       	ret

00003e32 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    3e32:	df 93       	push	r29
    3e34:	cf 93       	push	r28
    3e36:	00 d0       	rcall	.+0      	; 0x3e38 <xTaskGetCurrentTaskHandle+0x6>
    3e38:	cd b7       	in	r28, 0x3d	; 61
    3e3a:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    3e3c:	80 91 56 06 	lds	r24, 0x0656
    3e40:	90 91 57 06 	lds	r25, 0x0657
    3e44:	9a 83       	std	Y+2, r25	; 0x02
    3e46:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    3e48:	89 81       	ldd	r24, Y+1	; 0x01
    3e4a:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    3e4c:	0f 90       	pop	r0
    3e4e:	0f 90       	pop	r0
    3e50:	cf 91       	pop	r28
    3e52:	df 91       	pop	r29
    3e54:	08 95       	ret

00003e56 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    3e56:	df 93       	push	r29
    3e58:	cf 93       	push	r28
    3e5a:	00 d0       	rcall	.+0      	; 0x3e5c <uxTaskResetEventItemValue+0x6>
    3e5c:	cd b7       	in	r28, 0x3d	; 61
    3e5e:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    3e60:	e0 91 56 06 	lds	r30, 0x0656
    3e64:	f0 91 57 06 	lds	r31, 0x0657
    3e68:	84 85       	ldd	r24, Z+12	; 0x0c
    3e6a:	95 85       	ldd	r25, Z+13	; 0x0d
    3e6c:	9a 83       	std	Y+2, r25	; 0x02
    3e6e:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3e70:	a0 91 56 06 	lds	r26, 0x0656
    3e74:	b0 91 57 06 	lds	r27, 0x0657
    3e78:	e0 91 56 06 	lds	r30, 0x0656
    3e7c:	f0 91 57 06 	lds	r31, 0x0657
    3e80:	86 89       	ldd	r24, Z+22	; 0x16
    3e82:	28 2f       	mov	r18, r24
    3e84:	30 e0       	ldi	r19, 0x00	; 0
    3e86:	84 e0       	ldi	r24, 0x04	; 4
    3e88:	90 e0       	ldi	r25, 0x00	; 0
    3e8a:	82 1b       	sub	r24, r18
    3e8c:	93 0b       	sbc	r25, r19
    3e8e:	1d 96       	adiw	r26, 0x0d	; 13
    3e90:	9c 93       	st	X, r25
    3e92:	8e 93       	st	-X, r24
    3e94:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    3e96:	89 81       	ldd	r24, Y+1	; 0x01
    3e98:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3e9a:	0f 90       	pop	r0
    3e9c:	0f 90       	pop	r0
    3e9e:	cf 91       	pop	r28
    3ea0:	df 91       	pop	r29
    3ea2:	08 95       	ret

00003ea4 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    3ea4:	df 93       	push	r29
    3ea6:	cf 93       	push	r28
    3ea8:	cd b7       	in	r28, 0x3d	; 61
    3eaa:	de b7       	in	r29, 0x3e	; 62
    3eac:	27 97       	sbiw	r28, 0x07	; 7
    3eae:	0f b6       	in	r0, 0x3f	; 63
    3eb0:	f8 94       	cli
    3eb2:	de bf       	out	0x3e, r29	; 62
    3eb4:	0f be       	out	0x3f, r0	; 63
    3eb6:	cd bf       	out	0x3d, r28	; 61
    3eb8:	8d 83       	std	Y+5, r24	; 0x05
    3eba:	7f 83       	std	Y+7, r23	; 0x07
    3ebc:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    3ebe:	0f b6       	in	r0, 0x3f	; 63
    3ec0:	f8 94       	cli
    3ec2:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    3ec4:	e0 91 56 06 	lds	r30, 0x0656
    3ec8:	f0 91 57 06 	lds	r31, 0x0657
    3ecc:	81 a1       	ldd	r24, Z+33	; 0x21
    3ece:	92 a1       	ldd	r25, Z+34	; 0x22
    3ed0:	a3 a1       	ldd	r26, Z+35	; 0x23
    3ed2:	b4 a1       	ldd	r27, Z+36	; 0x24
    3ed4:	00 97       	sbiw	r24, 0x00	; 0
    3ed6:	a1 05       	cpc	r26, r1
    3ed8:	b1 05       	cpc	r27, r1
    3eda:	89 f4       	brne	.+34     	; 0x3efe <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    3edc:	e0 91 56 06 	lds	r30, 0x0656
    3ee0:	f0 91 57 06 	lds	r31, 0x0657
    3ee4:	81 e0       	ldi	r24, 0x01	; 1
    3ee6:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    3ee8:	8e 81       	ldd	r24, Y+6	; 0x06
    3eea:	9f 81       	ldd	r25, Y+7	; 0x07
    3eec:	00 97       	sbiw	r24, 0x00	; 0
    3eee:	39 f0       	breq	.+14     	; 0x3efe <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3ef0:	8e 81       	ldd	r24, Y+6	; 0x06
    3ef2:	9f 81       	ldd	r25, Y+7	; 0x07
    3ef4:	61 e0       	ldi	r22, 0x01	; 1
    3ef6:	0e 94 f2 22 	call	0x45e4	; 0x45e4 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    3efa:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3efe:	0f 90       	pop	r0
    3f00:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    3f02:	0f b6       	in	r0, 0x3f	; 63
    3f04:	f8 94       	cli
    3f06:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    3f08:	e0 91 56 06 	lds	r30, 0x0656
    3f0c:	f0 91 57 06 	lds	r31, 0x0657
    3f10:	81 a1       	ldd	r24, Z+33	; 0x21
    3f12:	92 a1       	ldd	r25, Z+34	; 0x22
    3f14:	a3 a1       	ldd	r26, Z+35	; 0x23
    3f16:	b4 a1       	ldd	r27, Z+36	; 0x24
    3f18:	89 83       	std	Y+1, r24	; 0x01
    3f1a:	9a 83       	std	Y+2, r25	; 0x02
    3f1c:	ab 83       	std	Y+3, r26	; 0x03
    3f1e:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    3f20:	89 81       	ldd	r24, Y+1	; 0x01
    3f22:	9a 81       	ldd	r25, Y+2	; 0x02
    3f24:	ab 81       	ldd	r26, Y+3	; 0x03
    3f26:	bc 81       	ldd	r27, Y+4	; 0x04
    3f28:	00 97       	sbiw	r24, 0x00	; 0
    3f2a:	a1 05       	cpc	r26, r1
    3f2c:	b1 05       	cpc	r27, r1
    3f2e:	d9 f0       	breq	.+54     	; 0x3f66 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    3f30:	8d 81       	ldd	r24, Y+5	; 0x05
    3f32:	88 23       	and	r24, r24
    3f34:	49 f0       	breq	.+18     	; 0x3f48 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    3f36:	e0 91 56 06 	lds	r30, 0x0656
    3f3a:	f0 91 57 06 	lds	r31, 0x0657
    3f3e:	11 a2       	std	Z+33, r1	; 0x21
    3f40:	12 a2       	std	Z+34, r1	; 0x22
    3f42:	13 a2       	std	Z+35, r1	; 0x23
    3f44:	14 a2       	std	Z+36, r1	; 0x24
    3f46:	0f c0       	rjmp	.+30     	; 0x3f66 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    3f48:	e0 91 56 06 	lds	r30, 0x0656
    3f4c:	f0 91 57 06 	lds	r31, 0x0657
    3f50:	89 81       	ldd	r24, Y+1	; 0x01
    3f52:	9a 81       	ldd	r25, Y+2	; 0x02
    3f54:	ab 81       	ldd	r26, Y+3	; 0x03
    3f56:	bc 81       	ldd	r27, Y+4	; 0x04
    3f58:	01 97       	sbiw	r24, 0x01	; 1
    3f5a:	a1 09       	sbc	r26, r1
    3f5c:	b1 09       	sbc	r27, r1
    3f5e:	81 a3       	std	Z+33, r24	; 0x21
    3f60:	92 a3       	std	Z+34, r25	; 0x22
    3f62:	a3 a3       	std	Z+35, r26	; 0x23
    3f64:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3f66:	e0 91 56 06 	lds	r30, 0x0656
    3f6a:	f0 91 57 06 	lds	r31, 0x0657
    3f6e:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    3f70:	0f 90       	pop	r0
    3f72:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    3f74:	89 81       	ldd	r24, Y+1	; 0x01
    3f76:	9a 81       	ldd	r25, Y+2	; 0x02
    3f78:	ab 81       	ldd	r26, Y+3	; 0x03
    3f7a:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    3f7c:	bc 01       	movw	r22, r24
    3f7e:	cd 01       	movw	r24, r26
    3f80:	27 96       	adiw	r28, 0x07	; 7
    3f82:	0f b6       	in	r0, 0x3f	; 63
    3f84:	f8 94       	cli
    3f86:	de bf       	out	0x3e, r29	; 62
    3f88:	0f be       	out	0x3f, r0	; 63
    3f8a:	cd bf       	out	0x3d, r28	; 61
    3f8c:	cf 91       	pop	r28
    3f8e:	df 91       	pop	r29
    3f90:	08 95       	ret

00003f92 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    3f92:	ef 92       	push	r14
    3f94:	ff 92       	push	r15
    3f96:	0f 93       	push	r16
    3f98:	1f 93       	push	r17
    3f9a:	df 93       	push	r29
    3f9c:	cf 93       	push	r28
    3f9e:	cd b7       	in	r28, 0x3d	; 61
    3fa0:	de b7       	in	r29, 0x3e	; 62
    3fa2:	2d 97       	sbiw	r28, 0x0d	; 13
    3fa4:	0f b6       	in	r0, 0x3f	; 63
    3fa6:	f8 94       	cli
    3fa8:	de bf       	out	0x3e, r29	; 62
    3faa:	0f be       	out	0x3f, r0	; 63
    3fac:	cd bf       	out	0x3d, r28	; 61
    3fae:	6a 83       	std	Y+2, r22	; 0x02
    3fb0:	7b 83       	std	Y+3, r23	; 0x03
    3fb2:	8c 83       	std	Y+4, r24	; 0x04
    3fb4:	9d 83       	std	Y+5, r25	; 0x05
    3fb6:	2e 83       	std	Y+6, r18	; 0x06
    3fb8:	3f 83       	std	Y+7, r19	; 0x07
    3fba:	48 87       	std	Y+8, r20	; 0x08
    3fbc:	59 87       	std	Y+9, r21	; 0x09
    3fbe:	1b 87       	std	Y+11, r17	; 0x0b
    3fc0:	0a 87       	std	Y+10, r16	; 0x0a
    3fc2:	fd 86       	std	Y+13, r15	; 0x0d
    3fc4:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    3fc6:	0f b6       	in	r0, 0x3f	; 63
    3fc8:	f8 94       	cli
    3fca:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    3fcc:	e0 91 56 06 	lds	r30, 0x0656
    3fd0:	f0 91 57 06 	lds	r31, 0x0657
    3fd4:	85 a1       	ldd	r24, Z+37	; 0x25
    3fd6:	82 30       	cpi	r24, 0x02	; 2
    3fd8:	49 f1       	breq	.+82     	; 0x402c <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    3fda:	e0 91 56 06 	lds	r30, 0x0656
    3fde:	f0 91 57 06 	lds	r31, 0x0657
    3fe2:	21 a1       	ldd	r18, Z+33	; 0x21
    3fe4:	32 a1       	ldd	r19, Z+34	; 0x22
    3fe6:	43 a1       	ldd	r20, Z+35	; 0x23
    3fe8:	54 a1       	ldd	r21, Z+36	; 0x24
    3fea:	8a 81       	ldd	r24, Y+2	; 0x02
    3fec:	9b 81       	ldd	r25, Y+3	; 0x03
    3fee:	ac 81       	ldd	r26, Y+4	; 0x04
    3ff0:	bd 81       	ldd	r27, Y+5	; 0x05
    3ff2:	80 95       	com	r24
    3ff4:	90 95       	com	r25
    3ff6:	a0 95       	com	r26
    3ff8:	b0 95       	com	r27
    3ffa:	82 23       	and	r24, r18
    3ffc:	93 23       	and	r25, r19
    3ffe:	a4 23       	and	r26, r20
    4000:	b5 23       	and	r27, r21
    4002:	81 a3       	std	Z+33, r24	; 0x21
    4004:	92 a3       	std	Z+34, r25	; 0x22
    4006:	a3 a3       	std	Z+35, r26	; 0x23
    4008:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    400a:	e0 91 56 06 	lds	r30, 0x0656
    400e:	f0 91 57 06 	lds	r31, 0x0657
    4012:	81 e0       	ldi	r24, 0x01	; 1
    4014:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    4016:	8c 85       	ldd	r24, Y+12	; 0x0c
    4018:	9d 85       	ldd	r25, Y+13	; 0x0d
    401a:	00 97       	sbiw	r24, 0x00	; 0
    401c:	39 f0       	breq	.+14     	; 0x402c <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    401e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4020:	9d 85       	ldd	r25, Y+13	; 0x0d
    4022:	61 e0       	ldi	r22, 0x01	; 1
    4024:	0e 94 f2 22 	call	0x45e4	; 0x45e4 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4028:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    402c:	0f 90       	pop	r0
    402e:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4030:	0f b6       	in	r0, 0x3f	; 63
    4032:	f8 94       	cli
    4034:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    4036:	8a 85       	ldd	r24, Y+10	; 0x0a
    4038:	9b 85       	ldd	r25, Y+11	; 0x0b
    403a:	00 97       	sbiw	r24, 0x00	; 0
    403c:	71 f0       	breq	.+28     	; 0x405a <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    403e:	e0 91 56 06 	lds	r30, 0x0656
    4042:	f0 91 57 06 	lds	r31, 0x0657
    4046:	81 a1       	ldd	r24, Z+33	; 0x21
    4048:	92 a1       	ldd	r25, Z+34	; 0x22
    404a:	a3 a1       	ldd	r26, Z+35	; 0x23
    404c:	b4 a1       	ldd	r27, Z+36	; 0x24
    404e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4050:	fb 85       	ldd	r31, Y+11	; 0x0b
    4052:	80 83       	st	Z, r24
    4054:	91 83       	std	Z+1, r25	; 0x01
    4056:	a2 83       	std	Z+2, r26	; 0x02
    4058:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    405a:	e0 91 56 06 	lds	r30, 0x0656
    405e:	f0 91 57 06 	lds	r31, 0x0657
    4062:	85 a1       	ldd	r24, Z+37	; 0x25
    4064:	82 30       	cpi	r24, 0x02	; 2
    4066:	11 f0       	breq	.+4      	; 0x406c <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4068:	19 82       	std	Y+1, r1	; 0x01
    406a:	1a c0       	rjmp	.+52     	; 0x40a0 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    406c:	e0 91 56 06 	lds	r30, 0x0656
    4070:	f0 91 57 06 	lds	r31, 0x0657
    4074:	21 a1       	ldd	r18, Z+33	; 0x21
    4076:	32 a1       	ldd	r19, Z+34	; 0x22
    4078:	43 a1       	ldd	r20, Z+35	; 0x23
    407a:	54 a1       	ldd	r21, Z+36	; 0x24
    407c:	8e 81       	ldd	r24, Y+6	; 0x06
    407e:	9f 81       	ldd	r25, Y+7	; 0x07
    4080:	a8 85       	ldd	r26, Y+8	; 0x08
    4082:	b9 85       	ldd	r27, Y+9	; 0x09
    4084:	80 95       	com	r24
    4086:	90 95       	com	r25
    4088:	a0 95       	com	r26
    408a:	b0 95       	com	r27
    408c:	82 23       	and	r24, r18
    408e:	93 23       	and	r25, r19
    4090:	a4 23       	and	r26, r20
    4092:	b5 23       	and	r27, r21
    4094:	81 a3       	std	Z+33, r24	; 0x21
    4096:	92 a3       	std	Z+34, r25	; 0x22
    4098:	a3 a3       	std	Z+35, r26	; 0x23
    409a:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    409c:	81 e0       	ldi	r24, 0x01	; 1
    409e:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    40a0:	e0 91 56 06 	lds	r30, 0x0656
    40a4:	f0 91 57 06 	lds	r31, 0x0657
    40a8:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    40aa:	0f 90       	pop	r0
    40ac:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    40ae:	89 81       	ldd	r24, Y+1	; 0x01
	}
    40b0:	2d 96       	adiw	r28, 0x0d	; 13
    40b2:	0f b6       	in	r0, 0x3f	; 63
    40b4:	f8 94       	cli
    40b6:	de bf       	out	0x3e, r29	; 62
    40b8:	0f be       	out	0x3f, r0	; 63
    40ba:	cd bf       	out	0x3d, r28	; 61
    40bc:	cf 91       	pop	r28
    40be:	df 91       	pop	r29
    40c0:	1f 91       	pop	r17
    40c2:	0f 91       	pop	r16
    40c4:	ff 90       	pop	r15
    40c6:	ef 90       	pop	r14
    40c8:	08 95       	ret

000040ca <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    40ca:	0f 93       	push	r16
    40cc:	1f 93       	push	r17
    40ce:	df 93       	push	r29
    40d0:	cf 93       	push	r28
    40d2:	cd b7       	in	r28, 0x3d	; 61
    40d4:	de b7       	in	r29, 0x3e	; 62
    40d6:	61 97       	sbiw	r28, 0x11	; 17
    40d8:	0f b6       	in	r0, 0x3f	; 63
    40da:	f8 94       	cli
    40dc:	de bf       	out	0x3e, r29	; 62
    40de:	0f be       	out	0x3f, r0	; 63
    40e0:	cd bf       	out	0x3d, r28	; 61
    40e2:	9e 83       	std	Y+6, r25	; 0x06
    40e4:	8d 83       	std	Y+5, r24	; 0x05
    40e6:	4f 83       	std	Y+7, r20	; 0x07
    40e8:	58 87       	std	Y+8, r21	; 0x08
    40ea:	69 87       	std	Y+9, r22	; 0x09
    40ec:	7a 87       	std	Y+10, r23	; 0x0a
    40ee:	2b 87       	std	Y+11, r18	; 0x0b
    40f0:	1d 87       	std	Y+13, r17	; 0x0d
    40f2:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    40f4:	81 e0       	ldi	r24, 0x01	; 1
    40f6:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    40f8:	8d 81       	ldd	r24, Y+5	; 0x05
    40fa:	9e 81       	ldd	r25, Y+6	; 0x06
    40fc:	9c 83       	std	Y+4, r25	; 0x04
    40fe:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    4100:	0f b6       	in	r0, 0x3f	; 63
    4102:	f8 94       	cli
    4104:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    4106:	8c 85       	ldd	r24, Y+12	; 0x0c
    4108:	9d 85       	ldd	r25, Y+13	; 0x0d
    410a:	00 97       	sbiw	r24, 0x00	; 0
    410c:	61 f0       	breq	.+24     	; 0x4126 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    410e:	eb 81       	ldd	r30, Y+3	; 0x03
    4110:	fc 81       	ldd	r31, Y+4	; 0x04
    4112:	81 a1       	ldd	r24, Z+33	; 0x21
    4114:	92 a1       	ldd	r25, Z+34	; 0x22
    4116:	a3 a1       	ldd	r26, Z+35	; 0x23
    4118:	b4 a1       	ldd	r27, Z+36	; 0x24
    411a:	ec 85       	ldd	r30, Y+12	; 0x0c
    411c:	fd 85       	ldd	r31, Y+13	; 0x0d
    411e:	80 83       	st	Z, r24
    4120:	91 83       	std	Z+1, r25	; 0x01
    4122:	a2 83       	std	Z+2, r26	; 0x02
    4124:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4126:	eb 81       	ldd	r30, Y+3	; 0x03
    4128:	fc 81       	ldd	r31, Y+4	; 0x04
    412a:	85 a1       	ldd	r24, Z+37	; 0x25
    412c:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    412e:	eb 81       	ldd	r30, Y+3	; 0x03
    4130:	fc 81       	ldd	r31, Y+4	; 0x04
    4132:	82 e0       	ldi	r24, 0x02	; 2
    4134:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    4136:	8b 85       	ldd	r24, Y+11	; 0x0b
    4138:	28 2f       	mov	r18, r24
    413a:	30 e0       	ldi	r19, 0x00	; 0
    413c:	39 8b       	std	Y+17, r19	; 0x11
    413e:	28 8b       	std	Y+16, r18	; 0x10
    4140:	88 89       	ldd	r24, Y+16	; 0x10
    4142:	99 89       	ldd	r25, Y+17	; 0x11
    4144:	82 30       	cpi	r24, 0x02	; 2
    4146:	91 05       	cpc	r25, r1
    4148:	59 f1       	breq	.+86     	; 0x41a0 <xTaskGenericNotify+0xd6>
    414a:	28 89       	ldd	r18, Y+16	; 0x10
    414c:	39 89       	ldd	r19, Y+17	; 0x11
    414e:	23 30       	cpi	r18, 0x03	; 3
    4150:	31 05       	cpc	r19, r1
    4152:	34 f4       	brge	.+12     	; 0x4160 <xTaskGenericNotify+0x96>
    4154:	88 89       	ldd	r24, Y+16	; 0x10
    4156:	99 89       	ldd	r25, Y+17	; 0x11
    4158:	81 30       	cpi	r24, 0x01	; 1
    415a:	91 05       	cpc	r25, r1
    415c:	61 f0       	breq	.+24     	; 0x4176 <xTaskGenericNotify+0xac>
    415e:	4a c0       	rjmp	.+148    	; 0x41f4 <xTaskGenericNotify+0x12a>
    4160:	28 89       	ldd	r18, Y+16	; 0x10
    4162:	39 89       	ldd	r19, Y+17	; 0x11
    4164:	23 30       	cpi	r18, 0x03	; 3
    4166:	31 05       	cpc	r19, r1
    4168:	59 f1       	breq	.+86     	; 0x41c0 <xTaskGenericNotify+0xf6>
    416a:	88 89       	ldd	r24, Y+16	; 0x10
    416c:	99 89       	ldd	r25, Y+17	; 0x11
    416e:	84 30       	cpi	r24, 0x04	; 4
    4170:	91 05       	cpc	r25, r1
    4172:	89 f1       	breq	.+98     	; 0x41d6 <xTaskGenericNotify+0x10c>
    4174:	3f c0       	rjmp	.+126    	; 0x41f4 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4176:	eb 81       	ldd	r30, Y+3	; 0x03
    4178:	fc 81       	ldd	r31, Y+4	; 0x04
    417a:	21 a1       	ldd	r18, Z+33	; 0x21
    417c:	32 a1       	ldd	r19, Z+34	; 0x22
    417e:	43 a1       	ldd	r20, Z+35	; 0x23
    4180:	54 a1       	ldd	r21, Z+36	; 0x24
    4182:	8f 81       	ldd	r24, Y+7	; 0x07
    4184:	98 85       	ldd	r25, Y+8	; 0x08
    4186:	a9 85       	ldd	r26, Y+9	; 0x09
    4188:	ba 85       	ldd	r27, Y+10	; 0x0a
    418a:	82 2b       	or	r24, r18
    418c:	93 2b       	or	r25, r19
    418e:	a4 2b       	or	r26, r20
    4190:	b5 2b       	or	r27, r21
    4192:	eb 81       	ldd	r30, Y+3	; 0x03
    4194:	fc 81       	ldd	r31, Y+4	; 0x04
    4196:	81 a3       	std	Z+33, r24	; 0x21
    4198:	92 a3       	std	Z+34, r25	; 0x22
    419a:	a3 a3       	std	Z+35, r26	; 0x23
    419c:	b4 a3       	std	Z+36, r27	; 0x24
    419e:	2a c0       	rjmp	.+84     	; 0x41f4 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    41a0:	eb 81       	ldd	r30, Y+3	; 0x03
    41a2:	fc 81       	ldd	r31, Y+4	; 0x04
    41a4:	81 a1       	ldd	r24, Z+33	; 0x21
    41a6:	92 a1       	ldd	r25, Z+34	; 0x22
    41a8:	a3 a1       	ldd	r26, Z+35	; 0x23
    41aa:	b4 a1       	ldd	r27, Z+36	; 0x24
    41ac:	01 96       	adiw	r24, 0x01	; 1
    41ae:	a1 1d       	adc	r26, r1
    41b0:	b1 1d       	adc	r27, r1
    41b2:	eb 81       	ldd	r30, Y+3	; 0x03
    41b4:	fc 81       	ldd	r31, Y+4	; 0x04
    41b6:	81 a3       	std	Z+33, r24	; 0x21
    41b8:	92 a3       	std	Z+34, r25	; 0x22
    41ba:	a3 a3       	std	Z+35, r26	; 0x23
    41bc:	b4 a3       	std	Z+36, r27	; 0x24
    41be:	1a c0       	rjmp	.+52     	; 0x41f4 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    41c0:	eb 81       	ldd	r30, Y+3	; 0x03
    41c2:	fc 81       	ldd	r31, Y+4	; 0x04
    41c4:	8f 81       	ldd	r24, Y+7	; 0x07
    41c6:	98 85       	ldd	r25, Y+8	; 0x08
    41c8:	a9 85       	ldd	r26, Y+9	; 0x09
    41ca:	ba 85       	ldd	r27, Y+10	; 0x0a
    41cc:	81 a3       	std	Z+33, r24	; 0x21
    41ce:	92 a3       	std	Z+34, r25	; 0x22
    41d0:	a3 a3       	std	Z+35, r26	; 0x23
    41d2:	b4 a3       	std	Z+36, r27	; 0x24
    41d4:	0f c0       	rjmp	.+30     	; 0x41f4 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    41d6:	89 81       	ldd	r24, Y+1	; 0x01
    41d8:	82 30       	cpi	r24, 0x02	; 2
    41da:	59 f0       	breq	.+22     	; 0x41f2 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    41dc:	eb 81       	ldd	r30, Y+3	; 0x03
    41de:	fc 81       	ldd	r31, Y+4	; 0x04
    41e0:	8f 81       	ldd	r24, Y+7	; 0x07
    41e2:	98 85       	ldd	r25, Y+8	; 0x08
    41e4:	a9 85       	ldd	r26, Y+9	; 0x09
    41e6:	ba 85       	ldd	r27, Y+10	; 0x0a
    41e8:	81 a3       	std	Z+33, r24	; 0x21
    41ea:	92 a3       	std	Z+34, r25	; 0x22
    41ec:	a3 a3       	std	Z+35, r26	; 0x23
    41ee:	b4 a3       	std	Z+36, r27	; 0x24
    41f0:	01 c0       	rjmp	.+2      	; 0x41f4 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    41f2:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    41f4:	89 81       	ldd	r24, Y+1	; 0x01
    41f6:	81 30       	cpi	r24, 0x01	; 1
    41f8:	79 f5       	brne	.+94     	; 0x4258 <xTaskGenericNotify+0x18e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    41fa:	8b 81       	ldd	r24, Y+3	; 0x03
    41fc:	9c 81       	ldd	r25, Y+4	; 0x04
    41fe:	02 96       	adiw	r24, 0x02	; 2
    4200:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    4204:	eb 81       	ldd	r30, Y+3	; 0x03
    4206:	fc 81       	ldd	r31, Y+4	; 0x04
    4208:	96 89       	ldd	r25, Z+22	; 0x16
    420a:	80 91 5b 06 	lds	r24, 0x065B
    420e:	89 17       	cp	r24, r25
    4210:	28 f4       	brcc	.+10     	; 0x421c <xTaskGenericNotify+0x152>
    4212:	eb 81       	ldd	r30, Y+3	; 0x03
    4214:	fc 81       	ldd	r31, Y+4	; 0x04
    4216:	86 89       	ldd	r24, Z+22	; 0x16
    4218:	80 93 5b 06 	sts	0x065B, r24
    421c:	eb 81       	ldd	r30, Y+3	; 0x03
    421e:	fc 81       	ldd	r31, Y+4	; 0x04
    4220:	86 89       	ldd	r24, Z+22	; 0x16
    4222:	28 2f       	mov	r18, r24
    4224:	30 e0       	ldi	r19, 0x00	; 0
    4226:	c9 01       	movw	r24, r18
    4228:	88 0f       	add	r24, r24
    422a:	99 1f       	adc	r25, r25
    422c:	88 0f       	add	r24, r24
    422e:	99 1f       	adc	r25, r25
    4230:	88 0f       	add	r24, r24
    4232:	99 1f       	adc	r25, r25
    4234:	82 0f       	add	r24, r18
    4236:	93 1f       	adc	r25, r19
    4238:	ac 01       	movw	r20, r24
    423a:	4a 59       	subi	r20, 0x9A	; 154
    423c:	59 4f       	sbci	r21, 0xF9	; 249
    423e:	8b 81       	ldd	r24, Y+3	; 0x03
    4240:	9c 81       	ldd	r25, Y+4	; 0x04
    4242:	9c 01       	movw	r18, r24
    4244:	2e 5f       	subi	r18, 0xFE	; 254
    4246:	3f 4f       	sbci	r19, 0xFF	; 255
    4248:	ca 01       	movw	r24, r20
    424a:	b9 01       	movw	r22, r18
    424c:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4250:	20 91 56 06 	lds	r18, 0x0656
    4254:	30 91 57 06 	lds	r19, 0x0657
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4258:	0f 90       	pop	r0
    425a:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    425c:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    425e:	61 96       	adiw	r28, 0x11	; 17
    4260:	0f b6       	in	r0, 0x3f	; 63
    4262:	f8 94       	cli
    4264:	de bf       	out	0x3e, r29	; 62
    4266:	0f be       	out	0x3f, r0	; 63
    4268:	cd bf       	out	0x3d, r28	; 61
    426a:	cf 91       	pop	r28
    426c:	df 91       	pop	r29
    426e:	1f 91       	pop	r17
    4270:	0f 91       	pop	r16
    4272:	08 95       	ret

00004274 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4274:	ef 92       	push	r14
    4276:	ff 92       	push	r15
    4278:	0f 93       	push	r16
    427a:	1f 93       	push	r17
    427c:	df 93       	push	r29
    427e:	cf 93       	push	r28
    4280:	cd b7       	in	r28, 0x3d	; 61
    4282:	de b7       	in	r29, 0x3e	; 62
    4284:	62 97       	sbiw	r28, 0x12	; 18
    4286:	0f b6       	in	r0, 0x3f	; 63
    4288:	f8 94       	cli
    428a:	de bf       	out	0x3e, r29	; 62
    428c:	0f be       	out	0x3f, r0	; 63
    428e:	cd bf       	out	0x3d, r28	; 61
    4290:	9f 83       	std	Y+7, r25	; 0x07
    4292:	8e 83       	std	Y+6, r24	; 0x06
    4294:	48 87       	std	Y+8, r20	; 0x08
    4296:	59 87       	std	Y+9, r21	; 0x09
    4298:	6a 87       	std	Y+10, r22	; 0x0a
    429a:	7b 87       	std	Y+11, r23	; 0x0b
    429c:	2c 87       	std	Y+12, r18	; 0x0c
    429e:	1e 87       	std	Y+14, r17	; 0x0e
    42a0:	0d 87       	std	Y+13, r16	; 0x0d
    42a2:	f8 8a       	std	Y+16, r15	; 0x10
    42a4:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    42a6:	81 e0       	ldi	r24, 0x01	; 1
    42a8:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    42aa:	8e 81       	ldd	r24, Y+6	; 0x06
    42ac:	9f 81       	ldd	r25, Y+7	; 0x07
    42ae:	9d 83       	std	Y+5, r25	; 0x05
    42b0:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    42b2:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    42b4:	8d 85       	ldd	r24, Y+13	; 0x0d
    42b6:	9e 85       	ldd	r25, Y+14	; 0x0e
    42b8:	00 97       	sbiw	r24, 0x00	; 0
    42ba:	61 f0       	breq	.+24     	; 0x42d4 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    42bc:	ec 81       	ldd	r30, Y+4	; 0x04
    42be:	fd 81       	ldd	r31, Y+5	; 0x05
    42c0:	81 a1       	ldd	r24, Z+33	; 0x21
    42c2:	92 a1       	ldd	r25, Z+34	; 0x22
    42c4:	a3 a1       	ldd	r26, Z+35	; 0x23
    42c6:	b4 a1       	ldd	r27, Z+36	; 0x24
    42c8:	ed 85       	ldd	r30, Y+13	; 0x0d
    42ca:	fe 85       	ldd	r31, Y+14	; 0x0e
    42cc:	80 83       	st	Z, r24
    42ce:	91 83       	std	Z+1, r25	; 0x01
    42d0:	a2 83       	std	Z+2, r26	; 0x02
    42d2:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    42d4:	ec 81       	ldd	r30, Y+4	; 0x04
    42d6:	fd 81       	ldd	r31, Y+5	; 0x05
    42d8:	85 a1       	ldd	r24, Z+37	; 0x25
    42da:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    42dc:	ec 81       	ldd	r30, Y+4	; 0x04
    42de:	fd 81       	ldd	r31, Y+5	; 0x05
    42e0:	82 e0       	ldi	r24, 0x02	; 2
    42e2:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    42e4:	8c 85       	ldd	r24, Y+12	; 0x0c
    42e6:	28 2f       	mov	r18, r24
    42e8:	30 e0       	ldi	r19, 0x00	; 0
    42ea:	3a 8b       	std	Y+18, r19	; 0x12
    42ec:	29 8b       	std	Y+17, r18	; 0x11
    42ee:	89 89       	ldd	r24, Y+17	; 0x11
    42f0:	9a 89       	ldd	r25, Y+18	; 0x12
    42f2:	82 30       	cpi	r24, 0x02	; 2
    42f4:	91 05       	cpc	r25, r1
    42f6:	59 f1       	breq	.+86     	; 0x434e <xTaskGenericNotifyFromISR+0xda>
    42f8:	29 89       	ldd	r18, Y+17	; 0x11
    42fa:	3a 89       	ldd	r19, Y+18	; 0x12
    42fc:	23 30       	cpi	r18, 0x03	; 3
    42fe:	31 05       	cpc	r19, r1
    4300:	34 f4       	brge	.+12     	; 0x430e <xTaskGenericNotifyFromISR+0x9a>
    4302:	89 89       	ldd	r24, Y+17	; 0x11
    4304:	9a 89       	ldd	r25, Y+18	; 0x12
    4306:	81 30       	cpi	r24, 0x01	; 1
    4308:	91 05       	cpc	r25, r1
    430a:	61 f0       	breq	.+24     	; 0x4324 <xTaskGenericNotifyFromISR+0xb0>
    430c:	4a c0       	rjmp	.+148    	; 0x43a2 <xTaskGenericNotifyFromISR+0x12e>
    430e:	29 89       	ldd	r18, Y+17	; 0x11
    4310:	3a 89       	ldd	r19, Y+18	; 0x12
    4312:	23 30       	cpi	r18, 0x03	; 3
    4314:	31 05       	cpc	r19, r1
    4316:	59 f1       	breq	.+86     	; 0x436e <xTaskGenericNotifyFromISR+0xfa>
    4318:	89 89       	ldd	r24, Y+17	; 0x11
    431a:	9a 89       	ldd	r25, Y+18	; 0x12
    431c:	84 30       	cpi	r24, 0x04	; 4
    431e:	91 05       	cpc	r25, r1
    4320:	89 f1       	breq	.+98     	; 0x4384 <xTaskGenericNotifyFromISR+0x110>
    4322:	3f c0       	rjmp	.+126    	; 0x43a2 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4324:	ec 81       	ldd	r30, Y+4	; 0x04
    4326:	fd 81       	ldd	r31, Y+5	; 0x05
    4328:	21 a1       	ldd	r18, Z+33	; 0x21
    432a:	32 a1       	ldd	r19, Z+34	; 0x22
    432c:	43 a1       	ldd	r20, Z+35	; 0x23
    432e:	54 a1       	ldd	r21, Z+36	; 0x24
    4330:	88 85       	ldd	r24, Y+8	; 0x08
    4332:	99 85       	ldd	r25, Y+9	; 0x09
    4334:	aa 85       	ldd	r26, Y+10	; 0x0a
    4336:	bb 85       	ldd	r27, Y+11	; 0x0b
    4338:	82 2b       	or	r24, r18
    433a:	93 2b       	or	r25, r19
    433c:	a4 2b       	or	r26, r20
    433e:	b5 2b       	or	r27, r21
    4340:	ec 81       	ldd	r30, Y+4	; 0x04
    4342:	fd 81       	ldd	r31, Y+5	; 0x05
    4344:	81 a3       	std	Z+33, r24	; 0x21
    4346:	92 a3       	std	Z+34, r25	; 0x22
    4348:	a3 a3       	std	Z+35, r26	; 0x23
    434a:	b4 a3       	std	Z+36, r27	; 0x24
    434c:	2a c0       	rjmp	.+84     	; 0x43a2 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    434e:	ec 81       	ldd	r30, Y+4	; 0x04
    4350:	fd 81       	ldd	r31, Y+5	; 0x05
    4352:	81 a1       	ldd	r24, Z+33	; 0x21
    4354:	92 a1       	ldd	r25, Z+34	; 0x22
    4356:	a3 a1       	ldd	r26, Z+35	; 0x23
    4358:	b4 a1       	ldd	r27, Z+36	; 0x24
    435a:	01 96       	adiw	r24, 0x01	; 1
    435c:	a1 1d       	adc	r26, r1
    435e:	b1 1d       	adc	r27, r1
    4360:	ec 81       	ldd	r30, Y+4	; 0x04
    4362:	fd 81       	ldd	r31, Y+5	; 0x05
    4364:	81 a3       	std	Z+33, r24	; 0x21
    4366:	92 a3       	std	Z+34, r25	; 0x22
    4368:	a3 a3       	std	Z+35, r26	; 0x23
    436a:	b4 a3       	std	Z+36, r27	; 0x24
    436c:	1a c0       	rjmp	.+52     	; 0x43a2 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    436e:	ec 81       	ldd	r30, Y+4	; 0x04
    4370:	fd 81       	ldd	r31, Y+5	; 0x05
    4372:	88 85       	ldd	r24, Y+8	; 0x08
    4374:	99 85       	ldd	r25, Y+9	; 0x09
    4376:	aa 85       	ldd	r26, Y+10	; 0x0a
    4378:	bb 85       	ldd	r27, Y+11	; 0x0b
    437a:	81 a3       	std	Z+33, r24	; 0x21
    437c:	92 a3       	std	Z+34, r25	; 0x22
    437e:	a3 a3       	std	Z+35, r26	; 0x23
    4380:	b4 a3       	std	Z+36, r27	; 0x24
    4382:	0f c0       	rjmp	.+30     	; 0x43a2 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4384:	8b 81       	ldd	r24, Y+3	; 0x03
    4386:	82 30       	cpi	r24, 0x02	; 2
    4388:	59 f0       	breq	.+22     	; 0x43a0 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    438a:	ec 81       	ldd	r30, Y+4	; 0x04
    438c:	fd 81       	ldd	r31, Y+5	; 0x05
    438e:	88 85       	ldd	r24, Y+8	; 0x08
    4390:	99 85       	ldd	r25, Y+9	; 0x09
    4392:	aa 85       	ldd	r26, Y+10	; 0x0a
    4394:	bb 85       	ldd	r27, Y+11	; 0x0b
    4396:	81 a3       	std	Z+33, r24	; 0x21
    4398:	92 a3       	std	Z+34, r25	; 0x22
    439a:	a3 a3       	std	Z+35, r26	; 0x23
    439c:	b4 a3       	std	Z+36, r27	; 0x24
    439e:	01 c0       	rjmp	.+2      	; 0x43a2 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    43a0:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    43a2:	8b 81       	ldd	r24, Y+3	; 0x03
    43a4:	81 30       	cpi	r24, 0x01	; 1
    43a6:	09 f0       	breq	.+2      	; 0x43aa <xTaskGenericNotifyFromISR+0x136>
    43a8:	4f c0       	rjmp	.+158    	; 0x4448 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    43aa:	80 91 65 06 	lds	r24, 0x0665
    43ae:	88 23       	and	r24, r24
    43b0:	61 f5       	brne	.+88     	; 0x440a <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    43b2:	8c 81       	ldd	r24, Y+4	; 0x04
    43b4:	9d 81       	ldd	r25, Y+5	; 0x05
    43b6:	02 96       	adiw	r24, 0x02	; 2
    43b8:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    43bc:	ec 81       	ldd	r30, Y+4	; 0x04
    43be:	fd 81       	ldd	r31, Y+5	; 0x05
    43c0:	96 89       	ldd	r25, Z+22	; 0x16
    43c2:	80 91 5b 06 	lds	r24, 0x065B
    43c6:	89 17       	cp	r24, r25
    43c8:	28 f4       	brcc	.+10     	; 0x43d4 <xTaskGenericNotifyFromISR+0x160>
    43ca:	ec 81       	ldd	r30, Y+4	; 0x04
    43cc:	fd 81       	ldd	r31, Y+5	; 0x05
    43ce:	86 89       	ldd	r24, Z+22	; 0x16
    43d0:	80 93 5b 06 	sts	0x065B, r24
    43d4:	ec 81       	ldd	r30, Y+4	; 0x04
    43d6:	fd 81       	ldd	r31, Y+5	; 0x05
    43d8:	86 89       	ldd	r24, Z+22	; 0x16
    43da:	28 2f       	mov	r18, r24
    43dc:	30 e0       	ldi	r19, 0x00	; 0
    43de:	c9 01       	movw	r24, r18
    43e0:	88 0f       	add	r24, r24
    43e2:	99 1f       	adc	r25, r25
    43e4:	88 0f       	add	r24, r24
    43e6:	99 1f       	adc	r25, r25
    43e8:	88 0f       	add	r24, r24
    43ea:	99 1f       	adc	r25, r25
    43ec:	82 0f       	add	r24, r18
    43ee:	93 1f       	adc	r25, r19
    43f0:	ac 01       	movw	r20, r24
    43f2:	4a 59       	subi	r20, 0x9A	; 154
    43f4:	59 4f       	sbci	r21, 0xF9	; 249
    43f6:	8c 81       	ldd	r24, Y+4	; 0x04
    43f8:	9d 81       	ldd	r25, Y+5	; 0x05
    43fa:	9c 01       	movw	r18, r24
    43fc:	2e 5f       	subi	r18, 0xFE	; 254
    43fe:	3f 4f       	sbci	r19, 0xFF	; 255
    4400:	ca 01       	movw	r24, r20
    4402:	b9 01       	movw	r22, r18
    4404:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    4408:	0a c0       	rjmp	.+20     	; 0x441e <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    440a:	8c 81       	ldd	r24, Y+4	; 0x04
    440c:	9d 81       	ldd	r25, Y+5	; 0x05
    440e:	9c 01       	movw	r18, r24
    4410:	24 5f       	subi	r18, 0xF4	; 244
    4412:	3f 4f       	sbci	r19, 0xFF	; 255
    4414:	80 ea       	ldi	r24, 0xA0	; 160
    4416:	96 e0       	ldi	r25, 0x06	; 6
    4418:	b9 01       	movw	r22, r18
    441a:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    441e:	ec 81       	ldd	r30, Y+4	; 0x04
    4420:	fd 81       	ldd	r31, Y+5	; 0x05
    4422:	96 89       	ldd	r25, Z+22	; 0x16
    4424:	e0 91 56 06 	lds	r30, 0x0656
    4428:	f0 91 57 06 	lds	r31, 0x0657
    442c:	86 89       	ldd	r24, Z+22	; 0x16
    442e:	89 17       	cp	r24, r25
    4430:	58 f4       	brcc	.+22     	; 0x4448 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4432:	8f 85       	ldd	r24, Y+15	; 0x0f
    4434:	98 89       	ldd	r25, Y+16	; 0x10
    4436:	00 97       	sbiw	r24, 0x00	; 0
    4438:	21 f0       	breq	.+8      	; 0x4442 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    443a:	ef 85       	ldd	r30, Y+15	; 0x0f
    443c:	f8 89       	ldd	r31, Y+16	; 0x10
    443e:	81 e0       	ldi	r24, 0x01	; 1
    4440:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4442:	81 e0       	ldi	r24, 0x01	; 1
    4444:	80 93 5e 06 	sts	0x065E, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    4448:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    444a:	62 96       	adiw	r28, 0x12	; 18
    444c:	0f b6       	in	r0, 0x3f	; 63
    444e:	f8 94       	cli
    4450:	de bf       	out	0x3e, r29	; 62
    4452:	0f be       	out	0x3f, r0	; 63
    4454:	cd bf       	out	0x3d, r28	; 61
    4456:	cf 91       	pop	r28
    4458:	df 91       	pop	r29
    445a:	1f 91       	pop	r17
    445c:	0f 91       	pop	r16
    445e:	ff 90       	pop	r15
    4460:	ef 90       	pop	r14
    4462:	08 95       	ret

00004464 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4464:	df 93       	push	r29
    4466:	cf 93       	push	r28
    4468:	cd b7       	in	r28, 0x3d	; 61
    446a:	de b7       	in	r29, 0x3e	; 62
    446c:	28 97       	sbiw	r28, 0x08	; 8
    446e:	0f b6       	in	r0, 0x3f	; 63
    4470:	f8 94       	cli
    4472:	de bf       	out	0x3e, r29	; 62
    4474:	0f be       	out	0x3f, r0	; 63
    4476:	cd bf       	out	0x3d, r28	; 61
    4478:	9e 83       	std	Y+6, r25	; 0x06
    447a:	8d 83       	std	Y+5, r24	; 0x05
    447c:	78 87       	std	Y+8, r23	; 0x08
    447e:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    4480:	8d 81       	ldd	r24, Y+5	; 0x05
    4482:	9e 81       	ldd	r25, Y+6	; 0x06
    4484:	9c 83       	std	Y+4, r25	; 0x04
    4486:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4488:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    448a:	eb 81       	ldd	r30, Y+3	; 0x03
    448c:	fc 81       	ldd	r31, Y+4	; 0x04
    448e:	85 a1       	ldd	r24, Z+37	; 0x25
    4490:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4492:	eb 81       	ldd	r30, Y+3	; 0x03
    4494:	fc 81       	ldd	r31, Y+4	; 0x04
    4496:	82 e0       	ldi	r24, 0x02	; 2
    4498:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    449a:	eb 81       	ldd	r30, Y+3	; 0x03
    449c:	fc 81       	ldd	r31, Y+4	; 0x04
    449e:	81 a1       	ldd	r24, Z+33	; 0x21
    44a0:	92 a1       	ldd	r25, Z+34	; 0x22
    44a2:	a3 a1       	ldd	r26, Z+35	; 0x23
    44a4:	b4 a1       	ldd	r27, Z+36	; 0x24
    44a6:	01 96       	adiw	r24, 0x01	; 1
    44a8:	a1 1d       	adc	r26, r1
    44aa:	b1 1d       	adc	r27, r1
    44ac:	eb 81       	ldd	r30, Y+3	; 0x03
    44ae:	fc 81       	ldd	r31, Y+4	; 0x04
    44b0:	81 a3       	std	Z+33, r24	; 0x21
    44b2:	92 a3       	std	Z+34, r25	; 0x22
    44b4:	a3 a3       	std	Z+35, r26	; 0x23
    44b6:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    44b8:	8a 81       	ldd	r24, Y+2	; 0x02
    44ba:	81 30       	cpi	r24, 0x01	; 1
    44bc:	09 f0       	breq	.+2      	; 0x44c0 <vTaskNotifyGiveFromISR+0x5c>
    44be:	4f c0       	rjmp	.+158    	; 0x455e <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    44c0:	80 91 65 06 	lds	r24, 0x0665
    44c4:	88 23       	and	r24, r24
    44c6:	61 f5       	brne	.+88     	; 0x4520 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    44c8:	8b 81       	ldd	r24, Y+3	; 0x03
    44ca:	9c 81       	ldd	r25, Y+4	; 0x04
    44cc:	02 96       	adiw	r24, 0x02	; 2
    44ce:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    44d2:	eb 81       	ldd	r30, Y+3	; 0x03
    44d4:	fc 81       	ldd	r31, Y+4	; 0x04
    44d6:	96 89       	ldd	r25, Z+22	; 0x16
    44d8:	80 91 5b 06 	lds	r24, 0x065B
    44dc:	89 17       	cp	r24, r25
    44de:	28 f4       	brcc	.+10     	; 0x44ea <vTaskNotifyGiveFromISR+0x86>
    44e0:	eb 81       	ldd	r30, Y+3	; 0x03
    44e2:	fc 81       	ldd	r31, Y+4	; 0x04
    44e4:	86 89       	ldd	r24, Z+22	; 0x16
    44e6:	80 93 5b 06 	sts	0x065B, r24
    44ea:	eb 81       	ldd	r30, Y+3	; 0x03
    44ec:	fc 81       	ldd	r31, Y+4	; 0x04
    44ee:	86 89       	ldd	r24, Z+22	; 0x16
    44f0:	28 2f       	mov	r18, r24
    44f2:	30 e0       	ldi	r19, 0x00	; 0
    44f4:	c9 01       	movw	r24, r18
    44f6:	88 0f       	add	r24, r24
    44f8:	99 1f       	adc	r25, r25
    44fa:	88 0f       	add	r24, r24
    44fc:	99 1f       	adc	r25, r25
    44fe:	88 0f       	add	r24, r24
    4500:	99 1f       	adc	r25, r25
    4502:	82 0f       	add	r24, r18
    4504:	93 1f       	adc	r25, r19
    4506:	ac 01       	movw	r20, r24
    4508:	4a 59       	subi	r20, 0x9A	; 154
    450a:	59 4f       	sbci	r21, 0xF9	; 249
    450c:	8b 81       	ldd	r24, Y+3	; 0x03
    450e:	9c 81       	ldd	r25, Y+4	; 0x04
    4510:	9c 01       	movw	r18, r24
    4512:	2e 5f       	subi	r18, 0xFE	; 254
    4514:	3f 4f       	sbci	r19, 0xFF	; 255
    4516:	ca 01       	movw	r24, r20
    4518:	b9 01       	movw	r22, r18
    451a:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    451e:	0a c0       	rjmp	.+20     	; 0x4534 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4520:	8b 81       	ldd	r24, Y+3	; 0x03
    4522:	9c 81       	ldd	r25, Y+4	; 0x04
    4524:	9c 01       	movw	r18, r24
    4526:	24 5f       	subi	r18, 0xF4	; 244
    4528:	3f 4f       	sbci	r19, 0xFF	; 255
    452a:	80 ea       	ldi	r24, 0xA0	; 160
    452c:	96 e0       	ldi	r25, 0x06	; 6
    452e:	b9 01       	movw	r22, r18
    4530:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4534:	eb 81       	ldd	r30, Y+3	; 0x03
    4536:	fc 81       	ldd	r31, Y+4	; 0x04
    4538:	96 89       	ldd	r25, Z+22	; 0x16
    453a:	e0 91 56 06 	lds	r30, 0x0656
    453e:	f0 91 57 06 	lds	r31, 0x0657
    4542:	86 89       	ldd	r24, Z+22	; 0x16
    4544:	89 17       	cp	r24, r25
    4546:	58 f4       	brcc	.+22     	; 0x455e <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4548:	8f 81       	ldd	r24, Y+7	; 0x07
    454a:	98 85       	ldd	r25, Y+8	; 0x08
    454c:	00 97       	sbiw	r24, 0x00	; 0
    454e:	21 f0       	breq	.+8      	; 0x4558 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4550:	ef 81       	ldd	r30, Y+7	; 0x07
    4552:	f8 85       	ldd	r31, Y+8	; 0x08
    4554:	81 e0       	ldi	r24, 0x01	; 1
    4556:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4558:	81 e0       	ldi	r24, 0x01	; 1
    455a:	80 93 5e 06 	sts	0x065E, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    455e:	28 96       	adiw	r28, 0x08	; 8
    4560:	0f b6       	in	r0, 0x3f	; 63
    4562:	f8 94       	cli
    4564:	de bf       	out	0x3e, r29	; 62
    4566:	0f be       	out	0x3f, r0	; 63
    4568:	cd bf       	out	0x3d, r28	; 61
    456a:	cf 91       	pop	r28
    456c:	df 91       	pop	r29
    456e:	08 95       	ret

00004570 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    4570:	df 93       	push	r29
    4572:	cf 93       	push	r28
    4574:	cd b7       	in	r28, 0x3d	; 61
    4576:	de b7       	in	r29, 0x3e	; 62
    4578:	27 97       	sbiw	r28, 0x07	; 7
    457a:	0f b6       	in	r0, 0x3f	; 63
    457c:	f8 94       	cli
    457e:	de bf       	out	0x3e, r29	; 62
    4580:	0f be       	out	0x3f, r0	; 63
    4582:	cd bf       	out	0x3d, r28	; 61
    4584:	9d 83       	std	Y+5, r25	; 0x05
    4586:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    4588:	8c 81       	ldd	r24, Y+4	; 0x04
    458a:	9d 81       	ldd	r25, Y+5	; 0x05
    458c:	00 97       	sbiw	r24, 0x00	; 0
    458e:	39 f4       	brne	.+14     	; 0x459e <xTaskNotifyStateClear+0x2e>
    4590:	80 91 56 06 	lds	r24, 0x0656
    4594:	90 91 57 06 	lds	r25, 0x0657
    4598:	9f 83       	std	Y+7, r25	; 0x07
    459a:	8e 83       	std	Y+6, r24	; 0x06
    459c:	04 c0       	rjmp	.+8      	; 0x45a6 <xTaskNotifyStateClear+0x36>
    459e:	8c 81       	ldd	r24, Y+4	; 0x04
    45a0:	9d 81       	ldd	r25, Y+5	; 0x05
    45a2:	9f 83       	std	Y+7, r25	; 0x07
    45a4:	8e 83       	std	Y+6, r24	; 0x06
    45a6:	8e 81       	ldd	r24, Y+6	; 0x06
    45a8:	9f 81       	ldd	r25, Y+7	; 0x07
    45aa:	9b 83       	std	Y+3, r25	; 0x03
    45ac:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    45ae:	0f b6       	in	r0, 0x3f	; 63
    45b0:	f8 94       	cli
    45b2:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    45b4:	ea 81       	ldd	r30, Y+2	; 0x02
    45b6:	fb 81       	ldd	r31, Y+3	; 0x03
    45b8:	85 a1       	ldd	r24, Z+37	; 0x25
    45ba:	82 30       	cpi	r24, 0x02	; 2
    45bc:	31 f4       	brne	.+12     	; 0x45ca <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    45be:	ea 81       	ldd	r30, Y+2	; 0x02
    45c0:	fb 81       	ldd	r31, Y+3	; 0x03
    45c2:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    45c4:	81 e0       	ldi	r24, 0x01	; 1
    45c6:	89 83       	std	Y+1, r24	; 0x01
    45c8:	01 c0       	rjmp	.+2      	; 0x45cc <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    45ca:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    45cc:	0f 90       	pop	r0
    45ce:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    45d0:	89 81       	ldd	r24, Y+1	; 0x01
	}
    45d2:	27 96       	adiw	r28, 0x07	; 7
    45d4:	0f b6       	in	r0, 0x3f	; 63
    45d6:	f8 94       	cli
    45d8:	de bf       	out	0x3e, r29	; 62
    45da:	0f be       	out	0x3f, r0	; 63
    45dc:	cd bf       	out	0x3d, r28	; 61
    45de:	cf 91       	pop	r28
    45e0:	df 91       	pop	r29
    45e2:	08 95       	ret

000045e4 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    45e4:	df 93       	push	r29
    45e6:	cf 93       	push	r28
    45e8:	cd b7       	in	r28, 0x3d	; 61
    45ea:	de b7       	in	r29, 0x3e	; 62
    45ec:	27 97       	sbiw	r28, 0x07	; 7
    45ee:	0f b6       	in	r0, 0x3f	; 63
    45f0:	f8 94       	cli
    45f2:	de bf       	out	0x3e, r29	; 62
    45f4:	0f be       	out	0x3f, r0	; 63
    45f6:	cd bf       	out	0x3d, r28	; 61
    45f8:	9e 83       	std	Y+6, r25	; 0x06
    45fa:	8d 83       	std	Y+5, r24	; 0x05
    45fc:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    45fe:	80 91 59 06 	lds	r24, 0x0659
    4602:	90 91 5a 06 	lds	r25, 0x065A
    4606:	9a 83       	std	Y+2, r25	; 0x02
    4608:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    460a:	80 91 56 06 	lds	r24, 0x0656
    460e:	90 91 57 06 	lds	r25, 0x0657
    4612:	02 96       	adiw	r24, 0x02	; 2
    4614:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    4618:	8d 81       	ldd	r24, Y+5	; 0x05
    461a:	9e 81       	ldd	r25, Y+6	; 0x06
    461c:	2f ef       	ldi	r18, 0xFF	; 255
    461e:	8f 3f       	cpi	r24, 0xFF	; 255
    4620:	92 07       	cpc	r25, r18
    4622:	81 f4       	brne	.+32     	; 0x4644 <prvAddCurrentTaskToDelayedList+0x60>
    4624:	8f 81       	ldd	r24, Y+7	; 0x07
    4626:	88 23       	and	r24, r24
    4628:	69 f0       	breq	.+26     	; 0x4644 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    462a:	80 91 56 06 	lds	r24, 0x0656
    462e:	90 91 57 06 	lds	r25, 0x0657
    4632:	9c 01       	movw	r18, r24
    4634:	2e 5f       	subi	r18, 0xFE	; 254
    4636:	3f 4f       	sbci	r19, 0xFF	; 255
    4638:	89 ea       	ldi	r24, 0xA9	; 169
    463a:	96 e0       	ldi	r25, 0x06	; 6
    463c:	b9 01       	movw	r22, r18
    463e:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    4642:	43 c0       	rjmp	.+134    	; 0x46ca <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    4644:	29 81       	ldd	r18, Y+1	; 0x01
    4646:	3a 81       	ldd	r19, Y+2	; 0x02
    4648:	8d 81       	ldd	r24, Y+5	; 0x05
    464a:	9e 81       	ldd	r25, Y+6	; 0x06
    464c:	82 0f       	add	r24, r18
    464e:	93 1f       	adc	r25, r19
    4650:	9c 83       	std	Y+4, r25	; 0x04
    4652:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    4654:	e0 91 56 06 	lds	r30, 0x0656
    4658:	f0 91 57 06 	lds	r31, 0x0657
    465c:	8b 81       	ldd	r24, Y+3	; 0x03
    465e:	9c 81       	ldd	r25, Y+4	; 0x04
    4660:	93 83       	std	Z+3, r25	; 0x03
    4662:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    4664:	2b 81       	ldd	r18, Y+3	; 0x03
    4666:	3c 81       	ldd	r19, Y+4	; 0x04
    4668:	89 81       	ldd	r24, Y+1	; 0x01
    466a:	9a 81       	ldd	r25, Y+2	; 0x02
    466c:	28 17       	cp	r18, r24
    466e:	39 07       	cpc	r19, r25
    4670:	70 f4       	brcc	.+28     	; 0x468e <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4672:	80 91 9e 06 	lds	r24, 0x069E
    4676:	90 91 9f 06 	lds	r25, 0x069F
    467a:	20 91 56 06 	lds	r18, 0x0656
    467e:	30 91 57 06 	lds	r19, 0x0657
    4682:	2e 5f       	subi	r18, 0xFE	; 254
    4684:	3f 4f       	sbci	r19, 0xFF	; 255
    4686:	b9 01       	movw	r22, r18
    4688:	0e 94 88 04 	call	0x910	; 0x910 <vListInsert>
    468c:	1e c0       	rjmp	.+60     	; 0x46ca <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    468e:	40 91 9c 06 	lds	r20, 0x069C
    4692:	50 91 9d 06 	lds	r21, 0x069D
    4696:	80 91 56 06 	lds	r24, 0x0656
    469a:	90 91 57 06 	lds	r25, 0x0657
    469e:	9c 01       	movw	r18, r24
    46a0:	2e 5f       	subi	r18, 0xFE	; 254
    46a2:	3f 4f       	sbci	r19, 0xFF	; 255
    46a4:	ca 01       	movw	r24, r20
    46a6:	b9 01       	movw	r22, r18
    46a8:	0e 94 88 04 	call	0x910	; 0x910 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    46ac:	20 91 61 06 	lds	r18, 0x0661
    46b0:	30 91 62 06 	lds	r19, 0x0662
    46b4:	8b 81       	ldd	r24, Y+3	; 0x03
    46b6:	9c 81       	ldd	r25, Y+4	; 0x04
    46b8:	82 17       	cp	r24, r18
    46ba:	93 07       	cpc	r25, r19
    46bc:	30 f4       	brcc	.+12     	; 0x46ca <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    46be:	8b 81       	ldd	r24, Y+3	; 0x03
    46c0:	9c 81       	ldd	r25, Y+4	; 0x04
    46c2:	90 93 62 06 	sts	0x0662, r25
    46c6:	80 93 61 06 	sts	0x0661, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    46ca:	27 96       	adiw	r28, 0x07	; 7
    46cc:	0f b6       	in	r0, 0x3f	; 63
    46ce:	f8 94       	cli
    46d0:	de bf       	out	0x3e, r29	; 62
    46d2:	0f be       	out	0x3f, r0	; 63
    46d4:	cd bf       	out	0x3d, r28	; 61
    46d6:	cf 91       	pop	r28
    46d8:	df 91       	pop	r29
    46da:	08 95       	ret

000046dc <CPU_Sleep>:
* Input : E_SleepMode_t
* Output: None
* @return: void
*/
void CPU_Sleep(E_SleepMode_t e_mode)
{
    46dc:	df 93       	push	r29
    46de:	cf 93       	push	r28
    46e0:	00 d0       	rcall	.+0      	; 0x46e2 <CPU_Sleep+0x6>
    46e2:	0f 92       	push	r0
    46e4:	cd b7       	in	r28, 0x3d	; 61
    46e6:	de b7       	in	r29, 0x3e	; 62
    46e8:	89 83       	std	Y+1, r24	; 0x01
  switch (e_mode) {
    46ea:	89 81       	ldd	r24, Y+1	; 0x01
    46ec:	28 2f       	mov	r18, r24
    46ee:	30 e0       	ldi	r19, 0x00	; 0
    46f0:	3b 83       	std	Y+3, r19	; 0x03
    46f2:	2a 83       	std	Y+2, r18	; 0x02
    46f4:	8a 81       	ldd	r24, Y+2	; 0x02
    46f6:	9b 81       	ldd	r25, Y+3	; 0x03
    46f8:	82 30       	cpi	r24, 0x02	; 2
    46fa:	91 05       	cpc	r25, r1
    46fc:	09 f4       	brne	.+2      	; 0x4700 <CPU_Sleep+0x24>
    46fe:	47 c0       	rjmp	.+142    	; 0x478e <CPU_Sleep+0xb2>
    4700:	2a 81       	ldd	r18, Y+2	; 0x02
    4702:	3b 81       	ldd	r19, Y+3	; 0x03
    4704:	23 30       	cpi	r18, 0x03	; 3
    4706:	31 05       	cpc	r19, r1
    4708:	54 f4       	brge	.+20     	; 0x471e <CPU_Sleep+0x42>
    470a:	8a 81       	ldd	r24, Y+2	; 0x02
    470c:	9b 81       	ldd	r25, Y+3	; 0x03
    470e:	00 97       	sbiw	r24, 0x00	; 0
    4710:	c9 f0       	breq	.+50     	; 0x4744 <CPU_Sleep+0x68>
    4712:	2a 81       	ldd	r18, Y+2	; 0x02
    4714:	3b 81       	ldd	r19, Y+3	; 0x03
    4716:	21 30       	cpi	r18, 0x01	; 1
    4718:	31 05       	cpc	r19, r1
    471a:	19 f1       	breq	.+70     	; 0x4762 <CPU_Sleep+0x86>
    471c:	88 c0       	rjmp	.+272    	; 0x482e <CPU_Sleep+0x152>
    471e:	8a 81       	ldd	r24, Y+2	; 0x02
    4720:	9b 81       	ldd	r25, Y+3	; 0x03
    4722:	84 30       	cpi	r24, 0x04	; 4
    4724:	91 05       	cpc	r25, r1
    4726:	09 f4       	brne	.+2      	; 0x472a <CPU_Sleep+0x4e>
    4728:	5e c0       	rjmp	.+188    	; 0x47e6 <CPU_Sleep+0x10a>
    472a:	2a 81       	ldd	r18, Y+2	; 0x02
    472c:	3b 81       	ldd	r19, Y+3	; 0x03
    472e:	24 30       	cpi	r18, 0x04	; 4
    4730:	31 05       	cpc	r19, r1
    4732:	0c f4       	brge	.+2      	; 0x4736 <CPU_Sleep+0x5a>
    4734:	42 c0       	rjmp	.+132    	; 0x47ba <CPU_Sleep+0xde>
    4736:	8a 81       	ldd	r24, Y+2	; 0x02
    4738:	9b 81       	ldd	r25, Y+3	; 0x03
    473a:	85 30       	cpi	r24, 0x05	; 5
    473c:	91 05       	cpc	r25, r1
    473e:	09 f4       	brne	.+2      	; 0x4742 <CPU_Sleep+0x66>
    4740:	68 c0       	rjmp	.+208    	; 0x4812 <CPU_Sleep+0x136>
    4742:	75 c0       	rjmp	.+234    	; 0x482e <CPU_Sleep+0x152>
    case (IDLE):
      /* Set IDLE sleep mode */
      MCUCR &= ~(SM2 | SM1 | SM0);
    4744:	a5 e5       	ldi	r26, 0x55	; 85
    4746:	b0 e0       	ldi	r27, 0x00	; 0
    4748:	e5 e5       	ldi	r30, 0x55	; 85
    474a:	f0 e0       	ldi	r31, 0x00	; 0
    474c:	80 81       	ld	r24, Z
    474e:	8f 78       	andi	r24, 0x8F	; 143
    4750:	8c 93       	st	X, r24
      /* Enter sleep mode */
      MCUCR |= SE;
    4752:	a5 e5       	ldi	r26, 0x55	; 85
    4754:	b0 e0       	ldi	r27, 0x00	; 0
    4756:	e5 e5       	ldi	r30, 0x55	; 85
    4758:	f0 e0       	ldi	r31, 0x00	; 0
    475a:	80 81       	ld	r24, Z
    475c:	80 68       	ori	r24, 0x80	; 128
    475e:	8c 93       	st	X, r24
    4760:	66 c0       	rjmp	.+204    	; 0x482e <CPU_Sleep+0x152>
      break;
    case (ADC_NOISE_REDUC):
      /* Set ADC noise reduction sleep mode */
      MCUCR &= ~(SM2 | SM1);
    4762:	a5 e5       	ldi	r26, 0x55	; 85
    4764:	b0 e0       	ldi	r27, 0x00	; 0
    4766:	e5 e5       	ldi	r30, 0x55	; 85
    4768:	f0 e0       	ldi	r31, 0x00	; 0
    476a:	80 81       	ld	r24, Z
    476c:	8f 79       	andi	r24, 0x9F	; 159
    476e:	8c 93       	st	X, r24
      MCUCR |= SM0;
    4770:	a5 e5       	ldi	r26, 0x55	; 85
    4772:	b0 e0       	ldi	r27, 0x00	; 0
    4774:	e5 e5       	ldi	r30, 0x55	; 85
    4776:	f0 e0       	ldi	r31, 0x00	; 0
    4778:	80 81       	ld	r24, Z
    477a:	80 61       	ori	r24, 0x10	; 16
    477c:	8c 93       	st	X, r24
      /* Enter sleep mode */
      MCUCR |= SE;
    477e:	a5 e5       	ldi	r26, 0x55	; 85
    4780:	b0 e0       	ldi	r27, 0x00	; 0
    4782:	e5 e5       	ldi	r30, 0x55	; 85
    4784:	f0 e0       	ldi	r31, 0x00	; 0
    4786:	80 81       	ld	r24, Z
    4788:	80 68       	ori	r24, 0x80	; 128
    478a:	8c 93       	st	X, r24
    478c:	50 c0       	rjmp	.+160    	; 0x482e <CPU_Sleep+0x152>
      break;
    case (POWER_DOWN):
      /* Set Power-down sleep mode */
      MCUCR &= ~(SM2 | SM0);
    478e:	a5 e5       	ldi	r26, 0x55	; 85
    4790:	b0 e0       	ldi	r27, 0x00	; 0
    4792:	e5 e5       	ldi	r30, 0x55	; 85
    4794:	f0 e0       	ldi	r31, 0x00	; 0
    4796:	80 81       	ld	r24, Z
    4798:	8f 7a       	andi	r24, 0xAF	; 175
    479a:	8c 93       	st	X, r24
      MCUCR |= SM1;
    479c:	a5 e5       	ldi	r26, 0x55	; 85
    479e:	b0 e0       	ldi	r27, 0x00	; 0
    47a0:	e5 e5       	ldi	r30, 0x55	; 85
    47a2:	f0 e0       	ldi	r31, 0x00	; 0
    47a4:	80 81       	ld	r24, Z
    47a6:	80 62       	ori	r24, 0x20	; 32
    47a8:	8c 93       	st	X, r24
      /* Enter sleep mode */
      MCUCR |= SE;
    47aa:	a5 e5       	ldi	r26, 0x55	; 85
    47ac:	b0 e0       	ldi	r27, 0x00	; 0
    47ae:	e5 e5       	ldi	r30, 0x55	; 85
    47b0:	f0 e0       	ldi	r31, 0x00	; 0
    47b2:	80 81       	ld	r24, Z
    47b4:	80 68       	ori	r24, 0x80	; 128
    47b6:	8c 93       	st	X, r24
    47b8:	3a c0       	rjmp	.+116    	; 0x482e <CPU_Sleep+0x152>
      break;
    case (POWER_SAVE):
      /* Set Power-save sleep mode */
      MCUCR |= (SM1 | SM0);
    47ba:	a5 e5       	ldi	r26, 0x55	; 85
    47bc:	b0 e0       	ldi	r27, 0x00	; 0
    47be:	e5 e5       	ldi	r30, 0x55	; 85
    47c0:	f0 e0       	ldi	r31, 0x00	; 0
    47c2:	80 81       	ld	r24, Z
    47c4:	80 63       	ori	r24, 0x30	; 48
    47c6:	8c 93       	st	X, r24
      MCUCR &= ~SM2;
    47c8:	a5 e5       	ldi	r26, 0x55	; 85
    47ca:	b0 e0       	ldi	r27, 0x00	; 0
    47cc:	e5 e5       	ldi	r30, 0x55	; 85
    47ce:	f0 e0       	ldi	r31, 0x00	; 0
    47d0:	80 81       	ld	r24, Z
    47d2:	8f 7b       	andi	r24, 0xBF	; 191
    47d4:	8c 93       	st	X, r24
      /* Enter sleep mode */
      MCUCR |= SE;
    47d6:	a5 e5       	ldi	r26, 0x55	; 85
    47d8:	b0 e0       	ldi	r27, 0x00	; 0
    47da:	e5 e5       	ldi	r30, 0x55	; 85
    47dc:	f0 e0       	ldi	r31, 0x00	; 0
    47de:	80 81       	ld	r24, Z
    47e0:	80 68       	ori	r24, 0x80	; 128
    47e2:	8c 93       	st	X, r24
    47e4:	24 c0       	rjmp	.+72     	; 0x482e <CPU_Sleep+0x152>
      break;
    case (STANDBY):
      /* Set Standby sleep mode */
      MCUCR |= (SM2 | SM1);
    47e6:	a5 e5       	ldi	r26, 0x55	; 85
    47e8:	b0 e0       	ldi	r27, 0x00	; 0
    47ea:	e5 e5       	ldi	r30, 0x55	; 85
    47ec:	f0 e0       	ldi	r31, 0x00	; 0
    47ee:	80 81       	ld	r24, Z
    47f0:	80 66       	ori	r24, 0x60	; 96
    47f2:	8c 93       	st	X, r24
      MCUCR &= ~SM0;
    47f4:	a5 e5       	ldi	r26, 0x55	; 85
    47f6:	b0 e0       	ldi	r27, 0x00	; 0
    47f8:	e5 e5       	ldi	r30, 0x55	; 85
    47fa:	f0 e0       	ldi	r31, 0x00	; 0
    47fc:	80 81       	ld	r24, Z
    47fe:	8f 7e       	andi	r24, 0xEF	; 239
    4800:	8c 93       	st	X, r24
      /* Enter sleep mode */
      MCUCR |= SE;
    4802:	a5 e5       	ldi	r26, 0x55	; 85
    4804:	b0 e0       	ldi	r27, 0x00	; 0
    4806:	e5 e5       	ldi	r30, 0x55	; 85
    4808:	f0 e0       	ldi	r31, 0x00	; 0
    480a:	80 81       	ld	r24, Z
    480c:	80 68       	ori	r24, 0x80	; 128
    480e:	8c 93       	st	X, r24
    4810:	0e c0       	rjmp	.+28     	; 0x482e <CPU_Sleep+0x152>
      break;
    case (EXT_STANDBY):
      /* Set Extended standby sleep mode */
      MCUCR |= (SM2 | SM1 | SM0);
    4812:	a5 e5       	ldi	r26, 0x55	; 85
    4814:	b0 e0       	ldi	r27, 0x00	; 0
    4816:	e5 e5       	ldi	r30, 0x55	; 85
    4818:	f0 e0       	ldi	r31, 0x00	; 0
    481a:	80 81       	ld	r24, Z
    481c:	80 67       	ori	r24, 0x70	; 112
    481e:	8c 93       	st	X, r24
      /* Enter sleep mode */
      MCUCR |= SE;
    4820:	a5 e5       	ldi	r26, 0x55	; 85
    4822:	b0 e0       	ldi	r27, 0x00	; 0
    4824:	e5 e5       	ldi	r30, 0x55	; 85
    4826:	f0 e0       	ldi	r31, 0x00	; 0
    4828:	80 81       	ld	r24, Z
    482a:	80 68       	ori	r24, 0x80	; 128
    482c:	8c 93       	st	X, r24
      break;
    default:
      break;
  }
  /* Execute SLEEP instruction to put device in selected sleep mode */
  asm("SLEEP");
    482e:	88 95       	sleep
}
    4830:	0f 90       	pop	r0
    4832:	0f 90       	pop	r0
    4834:	0f 90       	pop	r0
    4836:	cf 91       	pop	r28
    4838:	df 91       	pop	r29
    483a:	08 95       	ret

0000483c <DIO_init>:
 *In/Out:
 *Description: This function can set the direction of a full port, a nibble
 * 			  or even one pin.
 */
ERROR_STATUS DIO_init(DIO_Cfg_s *DIO_info)
{
    483c:	df 93       	push	r29
    483e:	cf 93       	push	r28
    4840:	00 d0       	rcall	.+0      	; 0x4842 <DIO_init+0x6>
    4842:	00 d0       	rcall	.+0      	; 0x4844 <DIO_init+0x8>
    4844:	0f 92       	push	r0
    4846:	cd b7       	in	r28, 0x3d	; 61
    4848:	de b7       	in	r29, 0x3e	; 62
    484a:	9b 83       	std	Y+3, r25	; 0x03
    484c:	8a 83       	std	Y+2, r24	; 0x02
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = DIO_BASE_ERROR + ERR_SUCCESS;
    484e:	86 ef       	ldi	r24, 0xF6	; 246
    4850:	89 83       	std	Y+1, r24	; 0x01

	if (DIO_info == NULL)
    4852:	8a 81       	ldd	r24, Y+2	; 0x02
    4854:	9b 81       	ldd	r25, Y+3	; 0x03
    4856:	00 97       	sbiw	r24, 0x00	; 0
    4858:	19 f4       	brne	.+6      	; 0x4860 <DIO_init+0x24>
	{
		/*
		 * trying to access a null pointer
		 */
		s8_ErrorStatus = DIO_BASE_ERROR + ERR_NULL_PTR;
    485a:	82 ef       	ldi	r24, 0xF2	; 242
    485c:	89 83       	std	Y+1, r24	; 0x01
    485e:	8a c0       	rjmp	.+276    	; 0x4974 <DIO_init+0x138>
	}
	/*
	 * 	check Direction
	 */
	else if (DIO_info->dir == INPUT || DIO_info->dir == OUTPUT)
    4860:	ea 81       	ldd	r30, Y+2	; 0x02
    4862:	fb 81       	ldd	r31, Y+3	; 0x03
    4864:	82 81       	ldd	r24, Z+2	; 0x02
    4866:	88 23       	and	r24, r24
    4868:	31 f0       	breq	.+12     	; 0x4876 <DIO_init+0x3a>
    486a:	ea 81       	ldd	r30, Y+2	; 0x02
    486c:	fb 81       	ldd	r31, Y+3	; 0x03
    486e:	82 81       	ldd	r24, Z+2	; 0x02
    4870:	8f 3f       	cpi	r24, 0xFF	; 255
    4872:	09 f0       	breq	.+2      	; 0x4876 <DIO_init+0x3a>
    4874:	7d c0       	rjmp	.+250    	; 0x4970 <DIO_init+0x134>
	{
		/*
		 * Check on the Required PORT Number
		 */
		switch (DIO_info->GPIO)
    4876:	ea 81       	ldd	r30, Y+2	; 0x02
    4878:	fb 81       	ldd	r31, Y+3	; 0x03
    487a:	80 81       	ld	r24, Z
    487c:	28 2f       	mov	r18, r24
    487e:	30 e0       	ldi	r19, 0x00	; 0
    4880:	3d 83       	std	Y+5, r19	; 0x05
    4882:	2c 83       	std	Y+4, r18	; 0x04
    4884:	8c 81       	ldd	r24, Y+4	; 0x04
    4886:	9d 81       	ldd	r25, Y+5	; 0x05
    4888:	81 30       	cpi	r24, 0x01	; 1
    488a:	91 05       	cpc	r25, r1
    488c:	61 f1       	breq	.+88     	; 0x48e6 <DIO_init+0xaa>
    488e:	2c 81       	ldd	r18, Y+4	; 0x04
    4890:	3d 81       	ldd	r19, Y+5	; 0x05
    4892:	22 30       	cpi	r18, 0x02	; 2
    4894:	31 05       	cpc	r19, r1
    4896:	2c f4       	brge	.+10     	; 0x48a2 <DIO_init+0x66>
    4898:	8c 81       	ldd	r24, Y+4	; 0x04
    489a:	9d 81       	ldd	r25, Y+5	; 0x05
    489c:	00 97       	sbiw	r24, 0x00	; 0
    489e:	69 f0       	breq	.+26     	; 0x48ba <DIO_init+0x7e>
    48a0:	64 c0       	rjmp	.+200    	; 0x496a <DIO_init+0x12e>
    48a2:	2c 81       	ldd	r18, Y+4	; 0x04
    48a4:	3d 81       	ldd	r19, Y+5	; 0x05
    48a6:	22 30       	cpi	r18, 0x02	; 2
    48a8:	31 05       	cpc	r19, r1
    48aa:	99 f1       	breq	.+102    	; 0x4912 <DIO_init+0xd6>
    48ac:	8c 81       	ldd	r24, Y+4	; 0x04
    48ae:	9d 81       	ldd	r25, Y+5	; 0x05
    48b0:	83 30       	cpi	r24, 0x03	; 3
    48b2:	91 05       	cpc	r25, r1
    48b4:	09 f4       	brne	.+2      	; 0x48b8 <DIO_init+0x7c>
    48b6:	43 c0       	rjmp	.+134    	; 0x493e <DIO_init+0x102>
    48b8:	58 c0       	rjmp	.+176    	; 0x496a <DIO_init+0x12e>
		{
		case GPIOA:
			ASSIGN_BIT(PORTA_DIR, DIO_info->pins, DIO_info->dir);
    48ba:	aa e3       	ldi	r26, 0x3A	; 58
    48bc:	b0 e0       	ldi	r27, 0x00	; 0
    48be:	ea e3       	ldi	r30, 0x3A	; 58
    48c0:	f0 e0       	ldi	r31, 0x00	; 0
    48c2:	80 81       	ld	r24, Z
    48c4:	98 2f       	mov	r25, r24
    48c6:	ea 81       	ldd	r30, Y+2	; 0x02
    48c8:	fb 81       	ldd	r31, Y+3	; 0x03
    48ca:	81 81       	ldd	r24, Z+1	; 0x01
    48cc:	80 95       	com	r24
    48ce:	29 2f       	mov	r18, r25
    48d0:	28 23       	and	r18, r24
    48d2:	ea 81       	ldd	r30, Y+2	; 0x02
    48d4:	fb 81       	ldd	r31, Y+3	; 0x03
    48d6:	92 81       	ldd	r25, Z+2	; 0x02
    48d8:	ea 81       	ldd	r30, Y+2	; 0x02
    48da:	fb 81       	ldd	r31, Y+3	; 0x03
    48dc:	81 81       	ldd	r24, Z+1	; 0x01
    48de:	89 23       	and	r24, r25
    48e0:	82 2b       	or	r24, r18
    48e2:	8c 93       	st	X, r24
    48e4:	47 c0       	rjmp	.+142    	; 0x4974 <DIO_init+0x138>
			break;
		case GPIOB:
			ASSIGN_BIT(PORTB_DIR, DIO_info->pins, DIO_info->dir);
    48e6:	a7 e3       	ldi	r26, 0x37	; 55
    48e8:	b0 e0       	ldi	r27, 0x00	; 0
    48ea:	e7 e3       	ldi	r30, 0x37	; 55
    48ec:	f0 e0       	ldi	r31, 0x00	; 0
    48ee:	80 81       	ld	r24, Z
    48f0:	98 2f       	mov	r25, r24
    48f2:	ea 81       	ldd	r30, Y+2	; 0x02
    48f4:	fb 81       	ldd	r31, Y+3	; 0x03
    48f6:	81 81       	ldd	r24, Z+1	; 0x01
    48f8:	80 95       	com	r24
    48fa:	29 2f       	mov	r18, r25
    48fc:	28 23       	and	r18, r24
    48fe:	ea 81       	ldd	r30, Y+2	; 0x02
    4900:	fb 81       	ldd	r31, Y+3	; 0x03
    4902:	92 81       	ldd	r25, Z+2	; 0x02
    4904:	ea 81       	ldd	r30, Y+2	; 0x02
    4906:	fb 81       	ldd	r31, Y+3	; 0x03
    4908:	81 81       	ldd	r24, Z+1	; 0x01
    490a:	89 23       	and	r24, r25
    490c:	82 2b       	or	r24, r18
    490e:	8c 93       	st	X, r24
    4910:	31 c0       	rjmp	.+98     	; 0x4974 <DIO_init+0x138>
			break;
		case GPIOC:
			ASSIGN_BIT(PORTC_DIR, DIO_info->pins, DIO_info->dir);
    4912:	a4 e3       	ldi	r26, 0x34	; 52
    4914:	b0 e0       	ldi	r27, 0x00	; 0
    4916:	e4 e3       	ldi	r30, 0x34	; 52
    4918:	f0 e0       	ldi	r31, 0x00	; 0
    491a:	80 81       	ld	r24, Z
    491c:	98 2f       	mov	r25, r24
    491e:	ea 81       	ldd	r30, Y+2	; 0x02
    4920:	fb 81       	ldd	r31, Y+3	; 0x03
    4922:	81 81       	ldd	r24, Z+1	; 0x01
    4924:	80 95       	com	r24
    4926:	29 2f       	mov	r18, r25
    4928:	28 23       	and	r18, r24
    492a:	ea 81       	ldd	r30, Y+2	; 0x02
    492c:	fb 81       	ldd	r31, Y+3	; 0x03
    492e:	92 81       	ldd	r25, Z+2	; 0x02
    4930:	ea 81       	ldd	r30, Y+2	; 0x02
    4932:	fb 81       	ldd	r31, Y+3	; 0x03
    4934:	81 81       	ldd	r24, Z+1	; 0x01
    4936:	89 23       	and	r24, r25
    4938:	82 2b       	or	r24, r18
    493a:	8c 93       	st	X, r24
    493c:	1b c0       	rjmp	.+54     	; 0x4974 <DIO_init+0x138>
			break;
		case GPIOD:
			ASSIGN_BIT(PORTD_DIR, DIO_info->pins, DIO_info->dir);
    493e:	a1 e3       	ldi	r26, 0x31	; 49
    4940:	b0 e0       	ldi	r27, 0x00	; 0
    4942:	e1 e3       	ldi	r30, 0x31	; 49
    4944:	f0 e0       	ldi	r31, 0x00	; 0
    4946:	80 81       	ld	r24, Z
    4948:	98 2f       	mov	r25, r24
    494a:	ea 81       	ldd	r30, Y+2	; 0x02
    494c:	fb 81       	ldd	r31, Y+3	; 0x03
    494e:	81 81       	ldd	r24, Z+1	; 0x01
    4950:	80 95       	com	r24
    4952:	29 2f       	mov	r18, r25
    4954:	28 23       	and	r18, r24
    4956:	ea 81       	ldd	r30, Y+2	; 0x02
    4958:	fb 81       	ldd	r31, Y+3	; 0x03
    495a:	92 81       	ldd	r25, Z+2	; 0x02
    495c:	ea 81       	ldd	r30, Y+2	; 0x02
    495e:	fb 81       	ldd	r31, Y+3	; 0x03
    4960:	81 81       	ldd	r24, Z+1	; 0x01
    4962:	89 23       	and	r24, r25
    4964:	82 2b       	or	r24, r18
    4966:	8c 93       	st	X, r24
    4968:	05 c0       	rjmp	.+10     	; 0x4974 <DIO_init+0x138>
			break;
		default:
			/*
			 *  Wrong Port Number
			 */
			s8_ErrorStatus = DIO_BASE_ERROR + ERR_INVALID_ARGU;
    496a:	85 ef       	ldi	r24, 0xF5	; 245
    496c:	89 83       	std	Y+1, r24	; 0x01
    496e:	02 c0       	rjmp	.+4      	; 0x4974 <DIO_init+0x138>
	else
	{
		/*
		 *  Wrong Direction
		 */
		s8_ErrorStatus = DIO_BASE_ERROR + ERR_INVALID_ARGU;
    4970:	85 ef       	ldi	r24, 0xF5	; 245
    4972:	89 83       	std	Y+1, r24	; 0x01
	}
	/*
	 * Function shall return the Error state
	 */
	return s8_ErrorStatus;
    4974:	89 81       	ldd	r24, Y+1	; 0x01
}
    4976:	0f 90       	pop	r0
    4978:	0f 90       	pop	r0
    497a:	0f 90       	pop	r0
    497c:	0f 90       	pop	r0
    497e:	0f 90       	pop	r0
    4980:	cf 91       	pop	r28
    4982:	df 91       	pop	r29
    4984:	08 95       	ret

00004986 <DIO_Write>:
 *In/Out: No In/Out
 *Description: This function can set the value of a full port, a nibble
 * 			  or even one pin.
 */
ERROR_STATUS DIO_Write(uint8 GPIO, uint8 pins, uint8 value)
{
    4986:	df 93       	push	r29
    4988:	cf 93       	push	r28
    498a:	00 d0       	rcall	.+0      	; 0x498c <DIO_Write+0x6>
    498c:	00 d0       	rcall	.+0      	; 0x498e <DIO_Write+0x8>
    498e:	00 d0       	rcall	.+0      	; 0x4990 <DIO_Write+0xa>
    4990:	cd b7       	in	r28, 0x3d	; 61
    4992:	de b7       	in	r29, 0x3e	; 62
    4994:	8a 83       	std	Y+2, r24	; 0x02
    4996:	6b 83       	std	Y+3, r22	; 0x03
    4998:	4c 83       	std	Y+4, r20	; 0x04
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = DIO_BASE_ERROR + ERR_SUCCESS;
    499a:	86 ef       	ldi	r24, 0xF6	; 246
    499c:	89 83       	std	Y+1, r24	; 0x01
	/*
	 * 	check Value
	 */
	if (value == HIGH || value == LOW)
    499e:	8c 81       	ldd	r24, Y+4	; 0x04
    49a0:	8f 3f       	cpi	r24, 0xFF	; 255
    49a2:	21 f0       	breq	.+8      	; 0x49ac <DIO_Write+0x26>
    49a4:	8c 81       	ldd	r24, Y+4	; 0x04
    49a6:	88 23       	and	r24, r24
    49a8:	09 f0       	breq	.+2      	; 0x49ac <DIO_Write+0x26>
    49aa:	62 c0       	rjmp	.+196    	; 0x4a70 <DIO_Write+0xea>
	{
		/*
		 * Check on the Required PORT Number
		 */
		switch (GPIO)
    49ac:	8a 81       	ldd	r24, Y+2	; 0x02
    49ae:	28 2f       	mov	r18, r24
    49b0:	30 e0       	ldi	r19, 0x00	; 0
    49b2:	3e 83       	std	Y+6, r19	; 0x06
    49b4:	2d 83       	std	Y+5, r18	; 0x05
    49b6:	8d 81       	ldd	r24, Y+5	; 0x05
    49b8:	9e 81       	ldd	r25, Y+6	; 0x06
    49ba:	81 30       	cpi	r24, 0x01	; 1
    49bc:	91 05       	cpc	r25, r1
    49be:	29 f1       	breq	.+74     	; 0x4a0a <DIO_Write+0x84>
    49c0:	2d 81       	ldd	r18, Y+5	; 0x05
    49c2:	3e 81       	ldd	r19, Y+6	; 0x06
    49c4:	22 30       	cpi	r18, 0x02	; 2
    49c6:	31 05       	cpc	r19, r1
    49c8:	2c f4       	brge	.+10     	; 0x49d4 <DIO_Write+0x4e>
    49ca:	8d 81       	ldd	r24, Y+5	; 0x05
    49cc:	9e 81       	ldd	r25, Y+6	; 0x06
    49ce:	00 97       	sbiw	r24, 0x00	; 0
    49d0:	61 f0       	breq	.+24     	; 0x49ea <DIO_Write+0x64>
    49d2:	4b c0       	rjmp	.+150    	; 0x4a6a <DIO_Write+0xe4>
    49d4:	2d 81       	ldd	r18, Y+5	; 0x05
    49d6:	3e 81       	ldd	r19, Y+6	; 0x06
    49d8:	22 30       	cpi	r18, 0x02	; 2
    49da:	31 05       	cpc	r19, r1
    49dc:	31 f1       	breq	.+76     	; 0x4a2a <DIO_Write+0xa4>
    49de:	8d 81       	ldd	r24, Y+5	; 0x05
    49e0:	9e 81       	ldd	r25, Y+6	; 0x06
    49e2:	83 30       	cpi	r24, 0x03	; 3
    49e4:	91 05       	cpc	r25, r1
    49e6:	89 f1       	breq	.+98     	; 0x4a4a <DIO_Write+0xc4>
    49e8:	40 c0       	rjmp	.+128    	; 0x4a6a <DIO_Write+0xe4>
		{
		case GPIOA:
			ASSIGN_BIT(PORTA_DATA, pins, value);
    49ea:	ab e3       	ldi	r26, 0x3B	; 59
    49ec:	b0 e0       	ldi	r27, 0x00	; 0
    49ee:	eb e3       	ldi	r30, 0x3B	; 59
    49f0:	f0 e0       	ldi	r31, 0x00	; 0
    49f2:	80 81       	ld	r24, Z
    49f4:	98 2f       	mov	r25, r24
    49f6:	8b 81       	ldd	r24, Y+3	; 0x03
    49f8:	80 95       	com	r24
    49fa:	29 2f       	mov	r18, r25
    49fc:	28 23       	and	r18, r24
    49fe:	9c 81       	ldd	r25, Y+4	; 0x04
    4a00:	8b 81       	ldd	r24, Y+3	; 0x03
    4a02:	89 23       	and	r24, r25
    4a04:	82 2b       	or	r24, r18
    4a06:	8c 93       	st	X, r24
    4a08:	35 c0       	rjmp	.+106    	; 0x4a74 <DIO_Write+0xee>
			break;
		case GPIOB:
			ASSIGN_BIT(PORTB_DATA, pins, value);
    4a0a:	a8 e3       	ldi	r26, 0x38	; 56
    4a0c:	b0 e0       	ldi	r27, 0x00	; 0
    4a0e:	e8 e3       	ldi	r30, 0x38	; 56
    4a10:	f0 e0       	ldi	r31, 0x00	; 0
    4a12:	80 81       	ld	r24, Z
    4a14:	98 2f       	mov	r25, r24
    4a16:	8b 81       	ldd	r24, Y+3	; 0x03
    4a18:	80 95       	com	r24
    4a1a:	29 2f       	mov	r18, r25
    4a1c:	28 23       	and	r18, r24
    4a1e:	9c 81       	ldd	r25, Y+4	; 0x04
    4a20:	8b 81       	ldd	r24, Y+3	; 0x03
    4a22:	89 23       	and	r24, r25
    4a24:	82 2b       	or	r24, r18
    4a26:	8c 93       	st	X, r24
    4a28:	25 c0       	rjmp	.+74     	; 0x4a74 <DIO_Write+0xee>
			break;
		case GPIOC:
			ASSIGN_BIT(PORTC_DATA, pins, value);
    4a2a:	a5 e3       	ldi	r26, 0x35	; 53
    4a2c:	b0 e0       	ldi	r27, 0x00	; 0
    4a2e:	e5 e3       	ldi	r30, 0x35	; 53
    4a30:	f0 e0       	ldi	r31, 0x00	; 0
    4a32:	80 81       	ld	r24, Z
    4a34:	98 2f       	mov	r25, r24
    4a36:	8b 81       	ldd	r24, Y+3	; 0x03
    4a38:	80 95       	com	r24
    4a3a:	29 2f       	mov	r18, r25
    4a3c:	28 23       	and	r18, r24
    4a3e:	9c 81       	ldd	r25, Y+4	; 0x04
    4a40:	8b 81       	ldd	r24, Y+3	; 0x03
    4a42:	89 23       	and	r24, r25
    4a44:	82 2b       	or	r24, r18
    4a46:	8c 93       	st	X, r24
    4a48:	15 c0       	rjmp	.+42     	; 0x4a74 <DIO_Write+0xee>
			break;
		case GPIOD:
			ASSIGN_BIT(PORTD_DATA, pins, value);
    4a4a:	a2 e3       	ldi	r26, 0x32	; 50
    4a4c:	b0 e0       	ldi	r27, 0x00	; 0
    4a4e:	e2 e3       	ldi	r30, 0x32	; 50
    4a50:	f0 e0       	ldi	r31, 0x00	; 0
    4a52:	80 81       	ld	r24, Z
    4a54:	98 2f       	mov	r25, r24
    4a56:	8b 81       	ldd	r24, Y+3	; 0x03
    4a58:	80 95       	com	r24
    4a5a:	29 2f       	mov	r18, r25
    4a5c:	28 23       	and	r18, r24
    4a5e:	9c 81       	ldd	r25, Y+4	; 0x04
    4a60:	8b 81       	ldd	r24, Y+3	; 0x03
    4a62:	89 23       	and	r24, r25
    4a64:	82 2b       	or	r24, r18
    4a66:	8c 93       	st	X, r24
    4a68:	05 c0       	rjmp	.+10     	; 0x4a74 <DIO_Write+0xee>
			break;
		default:
			/*
			 *  Wrong Port Number
			 */
			s8_ErrorStatus = DIO_BASE_ERROR + ERR_INVALID_ARGU;
    4a6a:	85 ef       	ldi	r24, 0xF5	; 245
    4a6c:	89 83       	std	Y+1, r24	; 0x01
    4a6e:	02 c0       	rjmp	.+4      	; 0x4a74 <DIO_Write+0xee>
	else
	{
		/*
		 *  Wrong Direction
		 */
		s8_ErrorStatus = DIO_BASE_ERROR + ERR_INVALID_ARGU;
    4a70:	85 ef       	ldi	r24, 0xF5	; 245
    4a72:	89 83       	std	Y+1, r24	; 0x01
	}
	/*
	 * Function shall return the Error state
	 */
	return s8_ErrorStatus;
    4a74:	89 81       	ldd	r24, Y+1	; 0x01
}
    4a76:	26 96       	adiw	r28, 0x06	; 6
    4a78:	0f b6       	in	r0, 0x3f	; 63
    4a7a:	f8 94       	cli
    4a7c:	de bf       	out	0x3e, r29	; 62
    4a7e:	0f be       	out	0x3f, r0	; 63
    4a80:	cd bf       	out	0x3d, r28	; 61
    4a82:	cf 91       	pop	r28
    4a84:	df 91       	pop	r29
    4a86:	08 95       	ret

00004a88 <DIO_Read>:
 *In/Out:
 *Description: This function gets the value of a full port, a nibble
 * 			  or even one pin.
 */
ERROR_STATUS DIO_Read(uint8 GPIO, uint8 pins, uint8 *data)
{
    4a88:	df 93       	push	r29
    4a8a:	cf 93       	push	r28
    4a8c:	cd b7       	in	r28, 0x3d	; 61
    4a8e:	de b7       	in	r29, 0x3e	; 62
    4a90:	27 97       	sbiw	r28, 0x07	; 7
    4a92:	0f b6       	in	r0, 0x3f	; 63
    4a94:	f8 94       	cli
    4a96:	de bf       	out	0x3e, r29	; 62
    4a98:	0f be       	out	0x3f, r0	; 63
    4a9a:	cd bf       	out	0x3d, r28	; 61
    4a9c:	8a 83       	std	Y+2, r24	; 0x02
    4a9e:	6b 83       	std	Y+3, r22	; 0x03
    4aa0:	5d 83       	std	Y+5, r21	; 0x05
    4aa2:	4c 83       	std	Y+4, r20	; 0x04
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = DIO_BASE_ERROR + ERR_SUCCESS;
    4aa4:	86 ef       	ldi	r24, 0xF6	; 246
    4aa6:	89 83       	std	Y+1, r24	; 0x01

	if (data == NULL)
    4aa8:	8c 81       	ldd	r24, Y+4	; 0x04
    4aaa:	9d 81       	ldd	r25, Y+5	; 0x05
    4aac:	00 97       	sbiw	r24, 0x00	; 0
    4aae:	19 f4       	brne	.+6      	; 0x4ab6 <DIO_Read+0x2e>
	{
		/*
		 * trying to access a null pointer
		 */
		s8_ErrorStatus = DIO_BASE_ERROR + ERR_NULL_PTR;
    4ab0:	82 ef       	ldi	r24, 0xF2	; 242
    4ab2:	89 83       	std	Y+1, r24	; 0x01
    4ab4:	45 c0       	rjmp	.+138    	; 0x4b40 <DIO_Read+0xb8>
	else
	{
		/*
		 * Check on the Required PORT Number
		 */
		switch (GPIO)
    4ab6:	8a 81       	ldd	r24, Y+2	; 0x02
    4ab8:	28 2f       	mov	r18, r24
    4aba:	30 e0       	ldi	r19, 0x00	; 0
    4abc:	3f 83       	std	Y+7, r19	; 0x07
    4abe:	2e 83       	std	Y+6, r18	; 0x06
    4ac0:	8e 81       	ldd	r24, Y+6	; 0x06
    4ac2:	9f 81       	ldd	r25, Y+7	; 0x07
    4ac4:	81 30       	cpi	r24, 0x01	; 1
    4ac6:	91 05       	cpc	r25, r1
    4ac8:	f1 f0       	breq	.+60     	; 0x4b06 <DIO_Read+0x7e>
    4aca:	2e 81       	ldd	r18, Y+6	; 0x06
    4acc:	3f 81       	ldd	r19, Y+7	; 0x07
    4ace:	22 30       	cpi	r18, 0x02	; 2
    4ad0:	31 05       	cpc	r19, r1
    4ad2:	2c f4       	brge	.+10     	; 0x4ade <DIO_Read+0x56>
    4ad4:	8e 81       	ldd	r24, Y+6	; 0x06
    4ad6:	9f 81       	ldd	r25, Y+7	; 0x07
    4ad8:	00 97       	sbiw	r24, 0x00	; 0
    4ada:	61 f0       	breq	.+24     	; 0x4af4 <DIO_Read+0x6c>
    4adc:	2f c0       	rjmp	.+94     	; 0x4b3c <DIO_Read+0xb4>
    4ade:	2e 81       	ldd	r18, Y+6	; 0x06
    4ae0:	3f 81       	ldd	r19, Y+7	; 0x07
    4ae2:	22 30       	cpi	r18, 0x02	; 2
    4ae4:	31 05       	cpc	r19, r1
    4ae6:	c1 f0       	breq	.+48     	; 0x4b18 <DIO_Read+0x90>
    4ae8:	8e 81       	ldd	r24, Y+6	; 0x06
    4aea:	9f 81       	ldd	r25, Y+7	; 0x07
    4aec:	83 30       	cpi	r24, 0x03	; 3
    4aee:	91 05       	cpc	r25, r1
    4af0:	e1 f0       	breq	.+56     	; 0x4b2a <DIO_Read+0xa2>
    4af2:	24 c0       	rjmp	.+72     	; 0x4b3c <DIO_Read+0xb4>
		{
		case GPIOA:
			*data = (PORTA_PIN & pins);
    4af4:	e9 e3       	ldi	r30, 0x39	; 57
    4af6:	f0 e0       	ldi	r31, 0x00	; 0
    4af8:	90 81       	ld	r25, Z
    4afa:	8b 81       	ldd	r24, Y+3	; 0x03
    4afc:	89 23       	and	r24, r25
    4afe:	ec 81       	ldd	r30, Y+4	; 0x04
    4b00:	fd 81       	ldd	r31, Y+5	; 0x05
    4b02:	80 83       	st	Z, r24
    4b04:	1d c0       	rjmp	.+58     	; 0x4b40 <DIO_Read+0xb8>
			break;
		case GPIOB:
			*data = (PORTB_PIN & pins);
    4b06:	e6 e3       	ldi	r30, 0x36	; 54
    4b08:	f0 e0       	ldi	r31, 0x00	; 0
    4b0a:	90 81       	ld	r25, Z
    4b0c:	8b 81       	ldd	r24, Y+3	; 0x03
    4b0e:	89 23       	and	r24, r25
    4b10:	ec 81       	ldd	r30, Y+4	; 0x04
    4b12:	fd 81       	ldd	r31, Y+5	; 0x05
    4b14:	80 83       	st	Z, r24
    4b16:	14 c0       	rjmp	.+40     	; 0x4b40 <DIO_Read+0xb8>
			break;
		case GPIOC:
			*data = (PORTC_PIN & pins);
    4b18:	e3 e3       	ldi	r30, 0x33	; 51
    4b1a:	f0 e0       	ldi	r31, 0x00	; 0
    4b1c:	90 81       	ld	r25, Z
    4b1e:	8b 81       	ldd	r24, Y+3	; 0x03
    4b20:	89 23       	and	r24, r25
    4b22:	ec 81       	ldd	r30, Y+4	; 0x04
    4b24:	fd 81       	ldd	r31, Y+5	; 0x05
    4b26:	80 83       	st	Z, r24
    4b28:	0b c0       	rjmp	.+22     	; 0x4b40 <DIO_Read+0xb8>
			break;
		case GPIOD:
			*data = (PORTD_PIN & pins);
    4b2a:	e0 e3       	ldi	r30, 0x30	; 48
    4b2c:	f0 e0       	ldi	r31, 0x00	; 0
    4b2e:	90 81       	ld	r25, Z
    4b30:	8b 81       	ldd	r24, Y+3	; 0x03
    4b32:	89 23       	and	r24, r25
    4b34:	ec 81       	ldd	r30, Y+4	; 0x04
    4b36:	fd 81       	ldd	r31, Y+5	; 0x05
    4b38:	80 83       	st	Z, r24
    4b3a:	02 c0       	rjmp	.+4      	; 0x4b40 <DIO_Read+0xb8>
			break;
		default:
			/*
			 *  Wrong Port Number
			 */
			s8_ErrorStatus = DIO_BASE_ERROR + ERR_INVALID_ARGU;
    4b3c:	85 ef       	ldi	r24, 0xF5	; 245
    4b3e:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	/*
	 * Function shall return the Error state
	 */
	return s8_ErrorStatus;
    4b40:	89 81       	ldd	r24, Y+1	; 0x01
}
    4b42:	27 96       	adiw	r28, 0x07	; 7
    4b44:	0f b6       	in	r0, 0x3f	; 63
    4b46:	f8 94       	cli
    4b48:	de bf       	out	0x3e, r29	; 62
    4b4a:	0f be       	out	0x3f, r0	; 63
    4b4c:	cd bf       	out	0x3d, r28	; 61
    4b4e:	cf 91       	pop	r28
    4b50:	df 91       	pop	r29
    4b52:	08 95       	ret

00004b54 <DIO_Toggle>:
 *In/Out:
 *Description: This function toggles the value of a full port, a nibble
 * 			  or even one pin.
 */
ERROR_STATUS DIO_Toggle(uint8 GPIO, uint8 pins)
{
    4b54:	df 93       	push	r29
    4b56:	cf 93       	push	r28
    4b58:	00 d0       	rcall	.+0      	; 0x4b5a <DIO_Toggle+0x6>
    4b5a:	00 d0       	rcall	.+0      	; 0x4b5c <DIO_Toggle+0x8>
    4b5c:	0f 92       	push	r0
    4b5e:	cd b7       	in	r28, 0x3d	; 61
    4b60:	de b7       	in	r29, 0x3e	; 62
    4b62:	8a 83       	std	Y+2, r24	; 0x02
    4b64:	6b 83       	std	Y+3, r22	; 0x03
	/*
	 * Error state: No Error
	 */
	ERROR_STATUS s8_ErrorStatus = DIO_BASE_ERROR + ERR_SUCCESS;
    4b66:	86 ef       	ldi	r24, 0xF6	; 246
    4b68:	89 83       	std	Y+1, r24	; 0x01

	/*
	 * Check on the Required PORT Number
	 */
	switch (GPIO)
    4b6a:	8a 81       	ldd	r24, Y+2	; 0x02
    4b6c:	28 2f       	mov	r18, r24
    4b6e:	30 e0       	ldi	r19, 0x00	; 0
    4b70:	3d 83       	std	Y+5, r19	; 0x05
    4b72:	2c 83       	std	Y+4, r18	; 0x04
    4b74:	8c 81       	ldd	r24, Y+4	; 0x04
    4b76:	9d 81       	ldd	r25, Y+5	; 0x05
    4b78:	81 30       	cpi	r24, 0x01	; 1
    4b7a:	91 05       	cpc	r25, r1
    4b7c:	f1 f0       	breq	.+60     	; 0x4bba <DIO_Toggle+0x66>
    4b7e:	2c 81       	ldd	r18, Y+4	; 0x04
    4b80:	3d 81       	ldd	r19, Y+5	; 0x05
    4b82:	22 30       	cpi	r18, 0x02	; 2
    4b84:	31 05       	cpc	r19, r1
    4b86:	2c f4       	brge	.+10     	; 0x4b92 <DIO_Toggle+0x3e>
    4b88:	8c 81       	ldd	r24, Y+4	; 0x04
    4b8a:	9d 81       	ldd	r25, Y+5	; 0x05
    4b8c:	00 97       	sbiw	r24, 0x00	; 0
    4b8e:	61 f0       	breq	.+24     	; 0x4ba8 <DIO_Toggle+0x54>
    4b90:	2f c0       	rjmp	.+94     	; 0x4bf0 <DIO_Toggle+0x9c>
    4b92:	2c 81       	ldd	r18, Y+4	; 0x04
    4b94:	3d 81       	ldd	r19, Y+5	; 0x05
    4b96:	22 30       	cpi	r18, 0x02	; 2
    4b98:	31 05       	cpc	r19, r1
    4b9a:	c1 f0       	breq	.+48     	; 0x4bcc <DIO_Toggle+0x78>
    4b9c:	8c 81       	ldd	r24, Y+4	; 0x04
    4b9e:	9d 81       	ldd	r25, Y+5	; 0x05
    4ba0:	83 30       	cpi	r24, 0x03	; 3
    4ba2:	91 05       	cpc	r25, r1
    4ba4:	e1 f0       	breq	.+56     	; 0x4bde <DIO_Toggle+0x8a>
    4ba6:	24 c0       	rjmp	.+72     	; 0x4bf0 <DIO_Toggle+0x9c>
	{
	case GPIOA:
		PORTA_DATA ^= (pins);
    4ba8:	ab e3       	ldi	r26, 0x3B	; 59
    4baa:	b0 e0       	ldi	r27, 0x00	; 0
    4bac:	eb e3       	ldi	r30, 0x3B	; 59
    4bae:	f0 e0       	ldi	r31, 0x00	; 0
    4bb0:	90 81       	ld	r25, Z
    4bb2:	8b 81       	ldd	r24, Y+3	; 0x03
    4bb4:	89 27       	eor	r24, r25
    4bb6:	8c 93       	st	X, r24
    4bb8:	1d c0       	rjmp	.+58     	; 0x4bf4 <DIO_Toggle+0xa0>
		break;
	case GPIOB:
		PORTB_DATA ^= (pins);
    4bba:	a8 e3       	ldi	r26, 0x38	; 56
    4bbc:	b0 e0       	ldi	r27, 0x00	; 0
    4bbe:	e8 e3       	ldi	r30, 0x38	; 56
    4bc0:	f0 e0       	ldi	r31, 0x00	; 0
    4bc2:	90 81       	ld	r25, Z
    4bc4:	8b 81       	ldd	r24, Y+3	; 0x03
    4bc6:	89 27       	eor	r24, r25
    4bc8:	8c 93       	st	X, r24
    4bca:	14 c0       	rjmp	.+40     	; 0x4bf4 <DIO_Toggle+0xa0>
		break;
	case GPIOC:
		PORTC_DATA ^= (pins);
    4bcc:	a5 e3       	ldi	r26, 0x35	; 53
    4bce:	b0 e0       	ldi	r27, 0x00	; 0
    4bd0:	e5 e3       	ldi	r30, 0x35	; 53
    4bd2:	f0 e0       	ldi	r31, 0x00	; 0
    4bd4:	90 81       	ld	r25, Z
    4bd6:	8b 81       	ldd	r24, Y+3	; 0x03
    4bd8:	89 27       	eor	r24, r25
    4bda:	8c 93       	st	X, r24
    4bdc:	0b c0       	rjmp	.+22     	; 0x4bf4 <DIO_Toggle+0xa0>
		break;
	case GPIOD:
		PORTD_DATA ^= (pins);
    4bde:	a2 e3       	ldi	r26, 0x32	; 50
    4be0:	b0 e0       	ldi	r27, 0x00	; 0
    4be2:	e2 e3       	ldi	r30, 0x32	; 50
    4be4:	f0 e0       	ldi	r31, 0x00	; 0
    4be6:	90 81       	ld	r25, Z
    4be8:	8b 81       	ldd	r24, Y+3	; 0x03
    4bea:	89 27       	eor	r24, r25
    4bec:	8c 93       	st	X, r24
    4bee:	02 c0       	rjmp	.+4      	; 0x4bf4 <DIO_Toggle+0xa0>
		break;
	default:
		/*
		 *  Wrong Port Number
		 */
		s8_ErrorStatus = DIO_BASE_ERROR + ERR_INVALID_ARGU;
    4bf0:	85 ef       	ldi	r24, 0xF5	; 245
    4bf2:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	/*
	 * Function shall return the Error state
	 */
	return s8_ErrorStatus;
    4bf4:	89 81       	ldd	r24, Y+1	; 0x01
}
    4bf6:	0f 90       	pop	r0
    4bf8:	0f 90       	pop	r0
    4bfa:	0f 90       	pop	r0
    4bfc:	0f 90       	pop	r0
    4bfe:	0f 90       	pop	r0
    4c00:	cf 91       	pop	r28
    4c02:	df 91       	pop	r29
    4c04:	08 95       	ret

00004c06 <pushButton_Init>:
 * 				  one of the enum (En_buttonId) parameters
 *
 */

void pushButton_Init(En_buttonId btn_id)
{
    4c06:	df 93       	push	r29
    4c08:	cf 93       	push	r28
    4c0a:	00 d0       	rcall	.+0      	; 0x4c0c <pushButton_Init+0x6>
    4c0c:	00 d0       	rcall	.+0      	; 0x4c0e <pushButton_Init+0x8>
    4c0e:	00 d0       	rcall	.+0      	; 0x4c10 <pushButton_Init+0xa>
    4c10:	cd b7       	in	r28, 0x3d	; 61
    4c12:	de b7       	in	r29, 0x3e	; 62
    4c14:	8c 83       	std	Y+4, r24	; 0x04
	avrbuttons[buttonNo].buttonID = btn_id;
    4c16:	80 91 b2 06 	lds	r24, 0x06B2
    4c1a:	88 2f       	mov	r24, r24
    4c1c:	90 e0       	ldi	r25, 0x00	; 0
    4c1e:	88 0f       	add	r24, r24
    4c20:	99 1f       	adc	r25, r25
    4c22:	88 0f       	add	r24, r24
    4c24:	99 1f       	adc	r25, r25
    4c26:	fc 01       	movw	r30, r24
    4c28:	ed 54       	subi	r30, 0x4D	; 77
    4c2a:	f9 4f       	sbci	r31, 0xF9	; 249
    4c2c:	8c 81       	ldd	r24, Y+4	; 0x04
    4c2e:	80 83       	st	Z, r24
	DIO_Cfg_s DIO_Cfg;
	switch (btn_id)
    4c30:	8c 81       	ldd	r24, Y+4	; 0x04
    4c32:	28 2f       	mov	r18, r24
    4c34:	30 e0       	ldi	r19, 0x00	; 0
    4c36:	3e 83       	std	Y+6, r19	; 0x06
    4c38:	2d 83       	std	Y+5, r18	; 0x05
    4c3a:	8d 81       	ldd	r24, Y+5	; 0x05
    4c3c:	9e 81       	ldd	r25, Y+6	; 0x06
    4c3e:	00 97       	sbiw	r24, 0x00	; 0
    4c40:	31 f0       	breq	.+12     	; 0x4c4e <pushButton_Init+0x48>
    4c42:	2d 81       	ldd	r18, Y+5	; 0x05
    4c44:	3e 81       	ldd	r19, Y+6	; 0x06
    4c46:	21 30       	cpi	r18, 0x01	; 1
    4c48:	31 05       	cpc	r19, r1
    4c4a:	31 f1       	breq	.+76     	; 0x4c98 <pushButton_Init+0x92>
    4c4c:	49 c0       	rjmp	.+146    	; 0x4ce0 <pushButton_Init+0xda>
	{
	case BTN_0:
		DIO_Cfg.GPIO = BTN_0_GPIO;
    4c4e:	82 e0       	ldi	r24, 0x02	; 2
    4c50:	89 83       	std	Y+1, r24	; 0x01
		DIO_Cfg.pins = BTN_0_BIT;
    4c52:	80 e1       	ldi	r24, 0x10	; 16
    4c54:	8a 83       	std	Y+2, r24	; 0x02
		DIO_Cfg.dir = INPUT;
    4c56:	1b 82       	std	Y+3, r1	; 0x03
		DIO_init(&DIO_Cfg);
    4c58:	ce 01       	movw	r24, r28
    4c5a:	01 96       	adiw	r24, 0x01	; 1
    4c5c:	0e 94 1e 24 	call	0x483c	; 0x483c <DIO_init>
		avrbuttons[buttonNo].GPIOPort = BTN_0_GPIO;
    4c60:	80 91 b2 06 	lds	r24, 0x06B2
    4c64:	88 2f       	mov	r24, r24
    4c66:	90 e0       	ldi	r25, 0x00	; 0
    4c68:	88 0f       	add	r24, r24
    4c6a:	99 1f       	adc	r25, r25
    4c6c:	88 0f       	add	r24, r24
    4c6e:	99 1f       	adc	r25, r25
    4c70:	fc 01       	movw	r30, r24
    4c72:	ec 54       	subi	r30, 0x4C	; 76
    4c74:	f9 4f       	sbci	r31, 0xF9	; 249
    4c76:	82 e0       	ldi	r24, 0x02	; 2
    4c78:	80 83       	st	Z, r24
		avrbuttons[buttonNo].buttonBit = BTN_0_BIT;
    4c7a:	80 91 b2 06 	lds	r24, 0x06B2
    4c7e:	88 2f       	mov	r24, r24
    4c80:	90 e0       	ldi	r25, 0x00	; 0
    4c82:	88 0f       	add	r24, r24
    4c84:	99 1f       	adc	r25, r25
    4c86:	01 96       	adiw	r24, 0x01	; 1
    4c88:	88 0f       	add	r24, r24
    4c8a:	99 1f       	adc	r25, r25
    4c8c:	fc 01       	movw	r30, r24
    4c8e:	ed 54       	subi	r30, 0x4D	; 77
    4c90:	f9 4f       	sbci	r31, 0xF9	; 249
    4c92:	80 e1       	ldi	r24, 0x10	; 16
    4c94:	80 83       	st	Z, r24
    4c96:	24 c0       	rjmp	.+72     	; 0x4ce0 <pushButton_Init+0xda>
		break;
	case BTN_1:
		DIO_Cfg.GPIO = BTN_1_GPIO;
    4c98:	81 e0       	ldi	r24, 0x01	; 1
    4c9a:	89 83       	std	Y+1, r24	; 0x01
		DIO_Cfg.pins = BTN_1_BIT;
    4c9c:	84 e0       	ldi	r24, 0x04	; 4
    4c9e:	8a 83       	std	Y+2, r24	; 0x02
		DIO_Cfg.dir = INPUT;
    4ca0:	1b 82       	std	Y+3, r1	; 0x03
		DIO_init(&DIO_Cfg);
    4ca2:	ce 01       	movw	r24, r28
    4ca4:	01 96       	adiw	r24, 0x01	; 1
    4ca6:	0e 94 1e 24 	call	0x483c	; 0x483c <DIO_init>
		avrbuttons[buttonNo].GPIOPort = BTN_1_GPIO;
    4caa:	80 91 b2 06 	lds	r24, 0x06B2
    4cae:	88 2f       	mov	r24, r24
    4cb0:	90 e0       	ldi	r25, 0x00	; 0
    4cb2:	88 0f       	add	r24, r24
    4cb4:	99 1f       	adc	r25, r25
    4cb6:	88 0f       	add	r24, r24
    4cb8:	99 1f       	adc	r25, r25
    4cba:	fc 01       	movw	r30, r24
    4cbc:	ec 54       	subi	r30, 0x4C	; 76
    4cbe:	f9 4f       	sbci	r31, 0xF9	; 249
    4cc0:	81 e0       	ldi	r24, 0x01	; 1
    4cc2:	80 83       	st	Z, r24
		avrbuttons[buttonNo].buttonBit = BTN_1_BIT;
    4cc4:	80 91 b2 06 	lds	r24, 0x06B2
    4cc8:	88 2f       	mov	r24, r24
    4cca:	90 e0       	ldi	r25, 0x00	; 0
    4ccc:	88 0f       	add	r24, r24
    4cce:	99 1f       	adc	r25, r25
    4cd0:	01 96       	adiw	r24, 0x01	; 1
    4cd2:	88 0f       	add	r24, r24
    4cd4:	99 1f       	adc	r25, r25
    4cd6:	fc 01       	movw	r30, r24
    4cd8:	ed 54       	subi	r30, 0x4D	; 77
    4cda:	f9 4f       	sbci	r31, 0xF9	; 249
    4cdc:	84 e0       	ldi	r24, 0x04	; 4
    4cde:	80 83       	st	Z, r24
		break;
	default:
		break;
	}
	buttonNo++;
    4ce0:	80 91 b2 06 	lds	r24, 0x06B2
    4ce4:	8f 5f       	subi	r24, 0xFF	; 255
    4ce6:	80 93 b2 06 	sts	0x06B2, r24

}
    4cea:	26 96       	adiw	r28, 0x06	; 6
    4cec:	0f b6       	in	r0, 0x3f	; 63
    4cee:	f8 94       	cli
    4cf0:	de bf       	out	0x3e, r29	; 62
    4cf2:	0f be       	out	0x3f, r0	; 63
    4cf4:	cd bf       	out	0x3d, r28	; 61
    4cf6:	cf 91       	pop	r28
    4cf8:	df 91       	pop	r29
    4cfa:	08 95       	ret

00004cfc <pushButton_Update>:
 * Description: read all BTN_x (where x 0, 1, 2, 3) states and store it in the program
 *
 * @note : this function must be called in the system tick hundler or in the super loop hundler
 */
void pushButton_Update(void)
{
    4cfc:	df 93       	push	r29
    4cfe:	cf 93       	push	r28
    4d00:	00 d0       	rcall	.+0      	; 0x4d02 <pushButton_Update+0x6>
    4d02:	cd b7       	in	r28, 0x3d	; 61
    4d04:	de b7       	in	r29, 0x3e	; 62
	uint8 READData;
	for (uint8 i = 0; i < buttonNo; i++)
    4d06:	19 82       	std	Y+1, r1	; 0x01
    4d08:	98 c0       	rjmp	.+304    	; 0x4e3a <pushButton_Update+0x13e>
	{

		DIO_Read(avrbuttons[i].GPIOPort, avrbuttons[i].buttonBit, &READData);
    4d0a:	89 81       	ldd	r24, Y+1	; 0x01
    4d0c:	88 2f       	mov	r24, r24
    4d0e:	90 e0       	ldi	r25, 0x00	; 0
    4d10:	88 0f       	add	r24, r24
    4d12:	99 1f       	adc	r25, r25
    4d14:	88 0f       	add	r24, r24
    4d16:	99 1f       	adc	r25, r25
    4d18:	fc 01       	movw	r30, r24
    4d1a:	ec 54       	subi	r30, 0x4C	; 76
    4d1c:	f9 4f       	sbci	r31, 0xF9	; 249
    4d1e:	40 81       	ld	r20, Z
    4d20:	89 81       	ldd	r24, Y+1	; 0x01
    4d22:	88 2f       	mov	r24, r24
    4d24:	90 e0       	ldi	r25, 0x00	; 0
    4d26:	88 0f       	add	r24, r24
    4d28:	99 1f       	adc	r25, r25
    4d2a:	01 96       	adiw	r24, 0x01	; 1
    4d2c:	88 0f       	add	r24, r24
    4d2e:	99 1f       	adc	r25, r25
    4d30:	fc 01       	movw	r30, r24
    4d32:	ed 54       	subi	r30, 0x4D	; 77
    4d34:	f9 4f       	sbci	r31, 0xF9	; 249
    4d36:	90 81       	ld	r25, Z
    4d38:	9e 01       	movw	r18, r28
    4d3a:	2e 5f       	subi	r18, 0xFE	; 254
    4d3c:	3f 4f       	sbci	r19, 0xFF	; 255
    4d3e:	84 2f       	mov	r24, r20
    4d40:	69 2f       	mov	r22, r25
    4d42:	a9 01       	movw	r20, r18
    4d44:	0e 94 44 25 	call	0x4a88	; 0x4a88 <DIO_Read>
		if (READData == avrbuttons[i].buttonBit)
    4d48:	89 81       	ldd	r24, Y+1	; 0x01
    4d4a:	88 2f       	mov	r24, r24
    4d4c:	90 e0       	ldi	r25, 0x00	; 0
    4d4e:	88 0f       	add	r24, r24
    4d50:	99 1f       	adc	r25, r25
    4d52:	01 96       	adiw	r24, 0x01	; 1
    4d54:	88 0f       	add	r24, r24
    4d56:	99 1f       	adc	r25, r25
    4d58:	fc 01       	movw	r30, r24
    4d5a:	ed 54       	subi	r30, 0x4D	; 77
    4d5c:	f9 4f       	sbci	r31, 0xF9	; 249
    4d5e:	90 81       	ld	r25, Z
    4d60:	8a 81       	ldd	r24, Y+2	; 0x02
    4d62:	98 17       	cp	r25, r24
    4d64:	a9 f5       	brne	.+106    	; 0x4dd0 <pushButton_Update+0xd4>
		{
			if (avrbuttons[i].buttonStatus == Released)
    4d66:	89 81       	ldd	r24, Y+1	; 0x01
    4d68:	88 2f       	mov	r24, r24
    4d6a:	90 e0       	ldi	r25, 0x00	; 0
    4d6c:	88 0f       	add	r24, r24
    4d6e:	99 1f       	adc	r25, r25
    4d70:	88 0f       	add	r24, r24
    4d72:	99 1f       	adc	r25, r25
    4d74:	fc 01       	movw	r30, r24
    4d76:	ea 54       	subi	r30, 0x4A	; 74
    4d78:	f9 4f       	sbci	r31, 0xF9	; 249
    4d7a:	80 81       	ld	r24, Z
    4d7c:	88 23       	and	r24, r24
    4d7e:	69 f4       	brne	.+26     	; 0x4d9a <pushButton_Update+0x9e>
			{
				avrbuttons[i].buttonStatus = Prepressed;
    4d80:	89 81       	ldd	r24, Y+1	; 0x01
    4d82:	88 2f       	mov	r24, r24
    4d84:	90 e0       	ldi	r25, 0x00	; 0
    4d86:	88 0f       	add	r24, r24
    4d88:	99 1f       	adc	r25, r25
    4d8a:	88 0f       	add	r24, r24
    4d8c:	99 1f       	adc	r25, r25
    4d8e:	fc 01       	movw	r30, r24
    4d90:	ea 54       	subi	r30, 0x4A	; 74
    4d92:	f9 4f       	sbci	r31, 0xF9	; 249
    4d94:	81 e0       	ldi	r24, 0x01	; 1
    4d96:	80 83       	st	Z, r24
    4d98:	4d c0       	rjmp	.+154    	; 0x4e34 <pushButton_Update+0x138>
			}
			else if (avrbuttons[i].buttonStatus == Prepressed)
    4d9a:	89 81       	ldd	r24, Y+1	; 0x01
    4d9c:	88 2f       	mov	r24, r24
    4d9e:	90 e0       	ldi	r25, 0x00	; 0
    4da0:	88 0f       	add	r24, r24
    4da2:	99 1f       	adc	r25, r25
    4da4:	88 0f       	add	r24, r24
    4da6:	99 1f       	adc	r25, r25
    4da8:	fc 01       	movw	r30, r24
    4daa:	ea 54       	subi	r30, 0x4A	; 74
    4dac:	f9 4f       	sbci	r31, 0xF9	; 249
    4dae:	80 81       	ld	r24, Z
    4db0:	81 30       	cpi	r24, 0x01	; 1
    4db2:	09 f0       	breq	.+2      	; 0x4db6 <pushButton_Update+0xba>
    4db4:	3f c0       	rjmp	.+126    	; 0x4e34 <pushButton_Update+0x138>
			{
				avrbuttons[i].buttonStatus = Pressed;
    4db6:	89 81       	ldd	r24, Y+1	; 0x01
    4db8:	88 2f       	mov	r24, r24
    4dba:	90 e0       	ldi	r25, 0x00	; 0
    4dbc:	88 0f       	add	r24, r24
    4dbe:	99 1f       	adc	r25, r25
    4dc0:	88 0f       	add	r24, r24
    4dc2:	99 1f       	adc	r25, r25
    4dc4:	fc 01       	movw	r30, r24
    4dc6:	ea 54       	subi	r30, 0x4A	; 74
    4dc8:	f9 4f       	sbci	r31, 0xF9	; 249
    4dca:	82 e0       	ldi	r24, 0x02	; 2
    4dcc:	80 83       	st	Z, r24
    4dce:	32 c0       	rjmp	.+100    	; 0x4e34 <pushButton_Update+0x138>
			}
		}
		else
		{
			if (avrbuttons[i].buttonStatus == Pressed)
    4dd0:	89 81       	ldd	r24, Y+1	; 0x01
    4dd2:	88 2f       	mov	r24, r24
    4dd4:	90 e0       	ldi	r25, 0x00	; 0
    4dd6:	88 0f       	add	r24, r24
    4dd8:	99 1f       	adc	r25, r25
    4dda:	88 0f       	add	r24, r24
    4ddc:	99 1f       	adc	r25, r25
    4dde:	fc 01       	movw	r30, r24
    4de0:	ea 54       	subi	r30, 0x4A	; 74
    4de2:	f9 4f       	sbci	r31, 0xF9	; 249
    4de4:	80 81       	ld	r24, Z
    4de6:	82 30       	cpi	r24, 0x02	; 2
    4de8:	69 f4       	brne	.+26     	; 0x4e04 <pushButton_Update+0x108>
			{
				avrbuttons[i].buttonStatus = Prereleased;
    4dea:	89 81       	ldd	r24, Y+1	; 0x01
    4dec:	88 2f       	mov	r24, r24
    4dee:	90 e0       	ldi	r25, 0x00	; 0
    4df0:	88 0f       	add	r24, r24
    4df2:	99 1f       	adc	r25, r25
    4df4:	88 0f       	add	r24, r24
    4df6:	99 1f       	adc	r25, r25
    4df8:	fc 01       	movw	r30, r24
    4dfa:	ea 54       	subi	r30, 0x4A	; 74
    4dfc:	f9 4f       	sbci	r31, 0xF9	; 249
    4dfe:	83 e0       	ldi	r24, 0x03	; 3
    4e00:	80 83       	st	Z, r24
    4e02:	18 c0       	rjmp	.+48     	; 0x4e34 <pushButton_Update+0x138>
			}
			else if (avrbuttons[i].buttonStatus == Prereleased)
    4e04:	89 81       	ldd	r24, Y+1	; 0x01
    4e06:	88 2f       	mov	r24, r24
    4e08:	90 e0       	ldi	r25, 0x00	; 0
    4e0a:	88 0f       	add	r24, r24
    4e0c:	99 1f       	adc	r25, r25
    4e0e:	88 0f       	add	r24, r24
    4e10:	99 1f       	adc	r25, r25
    4e12:	fc 01       	movw	r30, r24
    4e14:	ea 54       	subi	r30, 0x4A	; 74
    4e16:	f9 4f       	sbci	r31, 0xF9	; 249
    4e18:	80 81       	ld	r24, Z
    4e1a:	83 30       	cpi	r24, 0x03	; 3
    4e1c:	59 f4       	brne	.+22     	; 0x4e34 <pushButton_Update+0x138>
			{
				avrbuttons[i].buttonStatus = Released;
    4e1e:	89 81       	ldd	r24, Y+1	; 0x01
    4e20:	88 2f       	mov	r24, r24
    4e22:	90 e0       	ldi	r25, 0x00	; 0
    4e24:	88 0f       	add	r24, r24
    4e26:	99 1f       	adc	r25, r25
    4e28:	88 0f       	add	r24, r24
    4e2a:	99 1f       	adc	r25, r25
    4e2c:	fc 01       	movw	r30, r24
    4e2e:	ea 54       	subi	r30, 0x4A	; 74
    4e30:	f9 4f       	sbci	r31, 0xF9	; 249
    4e32:	10 82       	st	Z, r1
 * @note : this function must be called in the system tick hundler or in the super loop hundler
 */
void pushButton_Update(void)
{
	uint8 READData;
	for (uint8 i = 0; i < buttonNo; i++)
    4e34:	89 81       	ldd	r24, Y+1	; 0x01
    4e36:	8f 5f       	subi	r24, 0xFF	; 255
    4e38:	89 83       	std	Y+1, r24	; 0x01
    4e3a:	90 91 b2 06 	lds	r25, 0x06B2
    4e3e:	89 81       	ldd	r24, Y+1	; 0x01
    4e40:	89 17       	cp	r24, r25
    4e42:	08 f4       	brcc	.+2      	; 0x4e46 <pushButton_Update+0x14a>
    4e44:	62 cf       	rjmp	.-316    	; 0x4d0a <pushButton_Update+0xe>
			{
				avrbuttons[i].buttonStatus = Released;
			}
		}
	}
}
    4e46:	0f 90       	pop	r0
    4e48:	0f 90       	pop	r0
    4e4a:	cf 91       	pop	r28
    4e4c:	df 91       	pop	r29
    4e4e:	08 95       	ret

00004e50 <pushButton_GetStatus>:
 * Description: read BTN_x (where x 0, 1, 2, 3) state which is stored in the program
 * 				in the update function
 *
 */
En_buttonStatus_t pushButton_GetStatus(En_buttonId btn_id)
{
    4e50:	df 93       	push	r29
    4e52:	cf 93       	push	r28
    4e54:	00 d0       	rcall	.+0      	; 0x4e56 <pushButton_GetStatus+0x6>
    4e56:	0f 92       	push	r0
    4e58:	cd b7       	in	r28, 0x3d	; 61
    4e5a:	de b7       	in	r29, 0x3e	; 62
    4e5c:	8b 83       	std	Y+3, r24	; 0x03
	En_buttonStatus_t outStatus;
	for (uint8 i = 0; i < buttonNo; i++)
    4e5e:	19 82       	std	Y+1, r1	; 0x01
    4e60:	1d c0       	rjmp	.+58     	; 0x4e9c <pushButton_GetStatus+0x4c>
	{
		if (btn_id == avrbuttons[i].buttonID)
    4e62:	89 81       	ldd	r24, Y+1	; 0x01
    4e64:	88 2f       	mov	r24, r24
    4e66:	90 e0       	ldi	r25, 0x00	; 0
    4e68:	88 0f       	add	r24, r24
    4e6a:	99 1f       	adc	r25, r25
    4e6c:	88 0f       	add	r24, r24
    4e6e:	99 1f       	adc	r25, r25
    4e70:	fc 01       	movw	r30, r24
    4e72:	ed 54       	subi	r30, 0x4D	; 77
    4e74:	f9 4f       	sbci	r31, 0xF9	; 249
    4e76:	90 81       	ld	r25, Z
    4e78:	8b 81       	ldd	r24, Y+3	; 0x03
    4e7a:	98 17       	cp	r25, r24
    4e7c:	61 f4       	brne	.+24     	; 0x4e96 <pushButton_GetStatus+0x46>
		{
			outStatus = avrbuttons[i].buttonStatus;
    4e7e:	89 81       	ldd	r24, Y+1	; 0x01
    4e80:	88 2f       	mov	r24, r24
    4e82:	90 e0       	ldi	r25, 0x00	; 0
    4e84:	88 0f       	add	r24, r24
    4e86:	99 1f       	adc	r25, r25
    4e88:	88 0f       	add	r24, r24
    4e8a:	99 1f       	adc	r25, r25
    4e8c:	fc 01       	movw	r30, r24
    4e8e:	ea 54       	subi	r30, 0x4A	; 74
    4e90:	f9 4f       	sbci	r31, 0xF9	; 249
    4e92:	80 81       	ld	r24, Z
    4e94:	8a 83       	std	Y+2, r24	; 0x02
 *
 */
En_buttonStatus_t pushButton_GetStatus(En_buttonId btn_id)
{
	En_buttonStatus_t outStatus;
	for (uint8 i = 0; i < buttonNo; i++)
    4e96:	89 81       	ldd	r24, Y+1	; 0x01
    4e98:	8f 5f       	subi	r24, 0xFF	; 255
    4e9a:	89 83       	std	Y+1, r24	; 0x01
    4e9c:	90 91 b2 06 	lds	r25, 0x06B2
    4ea0:	89 81       	ldd	r24, Y+1	; 0x01
    4ea2:	89 17       	cp	r24, r25
    4ea4:	f0 f2       	brcs	.-68     	; 0x4e62 <pushButton_GetStatus+0x12>
		{
			outStatus = avrbuttons[i].buttonStatus;
		}
	}

	return outStatus;
    4ea6:	8a 81       	ldd	r24, Y+2	; 0x02

}
    4ea8:	0f 90       	pop	r0
    4eaa:	0f 90       	pop	r0
    4eac:	0f 90       	pop	r0
    4eae:	cf 91       	pop	r28
    4eb0:	df 91       	pop	r29
    4eb2:	08 95       	ret

00004eb4 <vDIO_Init>:
MessageBufferHandle_t xMessageBuffer;
uint8 gu8_buff;
uint8 gu8_Error_State;

void vDIO_Init(void * pvParameters)
{
    4eb4:	df 93       	push	r29
    4eb6:	cf 93       	push	r28
    4eb8:	cd b7       	in	r28, 0x3d	; 61
    4eba:	de b7       	in	r29, 0x3e	; 62
    4ebc:	2a 97       	sbiw	r28, 0x0a	; 10
    4ebe:	0f b6       	in	r0, 0x3f	; 63
    4ec0:	f8 94       	cli
    4ec2:	de bf       	out	0x3e, r29	; 62
    4ec4:	0f be       	out	0x3f, r0	; 63
    4ec6:	cd bf       	out	0x3d, r28	; 61
    4ec8:	9d 83       	std	Y+5, r25	; 0x05
    4eca:	8c 83       	std	Y+4, r24	; 0x04

	for (;;)
	{
		/* Task code goes here. */
		DIO_Cfg_s DIO_test =
		{ GPIOB, UPPER_NIBBLE, OUTPUT };
    4ecc:	ce 01       	movw	r24, r28
    4ece:	01 96       	adiw	r24, 0x01	; 1
    4ed0:	9f 83       	std	Y+7, r25	; 0x07
    4ed2:	8e 83       	std	Y+6, r24	; 0x06
    4ed4:	e3 e7       	ldi	r30, 0x73	; 115
    4ed6:	f0 e0       	ldi	r31, 0x00	; 0
    4ed8:	f9 87       	std	Y+9, r31	; 0x09
    4eda:	e8 87       	std	Y+8, r30	; 0x08
    4edc:	f3 e0       	ldi	r31, 0x03	; 3
    4ede:	fa 87       	std	Y+10, r31	; 0x0a
    4ee0:	e8 85       	ldd	r30, Y+8	; 0x08
    4ee2:	f9 85       	ldd	r31, Y+9	; 0x09
    4ee4:	00 80       	ld	r0, Z
    4ee6:	88 85       	ldd	r24, Y+8	; 0x08
    4ee8:	99 85       	ldd	r25, Y+9	; 0x09
    4eea:	01 96       	adiw	r24, 0x01	; 1
    4eec:	99 87       	std	Y+9, r25	; 0x09
    4eee:	88 87       	std	Y+8, r24	; 0x08
    4ef0:	ee 81       	ldd	r30, Y+6	; 0x06
    4ef2:	ff 81       	ldd	r31, Y+7	; 0x07
    4ef4:	00 82       	st	Z, r0
    4ef6:	8e 81       	ldd	r24, Y+6	; 0x06
    4ef8:	9f 81       	ldd	r25, Y+7	; 0x07
    4efa:	01 96       	adiw	r24, 0x01	; 1
    4efc:	9f 83       	std	Y+7, r25	; 0x07
    4efe:	8e 83       	std	Y+6, r24	; 0x06
    4f00:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f02:	91 50       	subi	r25, 0x01	; 1
    4f04:	9a 87       	std	Y+10, r25	; 0x0a
    4f06:	ea 85       	ldd	r30, Y+10	; 0x0a
    4f08:	ee 23       	and	r30, r30
    4f0a:	51 f7       	brne	.-44     	; 0x4ee0 <vDIO_Init+0x2c>
		DIO_init(&DIO_test);
    4f0c:	ce 01       	movw	r24, r28
    4f0e:	01 96       	adiw	r24, 0x01	; 1
    4f10:	0e 94 1e 24 	call	0x483c	; 0x483c <DIO_init>
		vTaskSuspend(NULL);
    4f14:	80 e0       	ldi	r24, 0x00	; 0
    4f16:	90 e0       	ldi	r25, 0x00	; 0
    4f18:	0e 94 12 19 	call	0x3224	; 0x3224 <vTaskSuspend>
    4f1c:	d7 cf       	rjmp	.-82     	; 0x4ecc <vDIO_Init+0x18>

00004f1e <vToggleLED1>:
	}
}

void vToggleLED1(void * pvParameters)
{
    4f1e:	df 93       	push	r29
    4f20:	cf 93       	push	r28
    4f22:	00 d0       	rcall	.+0      	; 0x4f24 <vToggleLED1+0x6>
    4f24:	00 d0       	rcall	.+0      	; 0x4f26 <vToggleLED1+0x8>
    4f26:	0f 92       	push	r0
    4f28:	cd b7       	in	r28, 0x3d	; 61
    4f2a:	de b7       	in	r29, 0x3e	; 62
    4f2c:	9d 83       	std	Y+5, r25	; 0x05
    4f2e:	8c 83       	std	Y+4, r24	; 0x04
	/* The parameter value is expected to be 1 as 1 is passed in the
	 pvParameters value in the call to xTaskCreate() below. */
	configASSERT( ( ( uint32_t ) pvParameters ) == 1 );

	uint16 u16_delVar = 1000;
    4f30:	88 ee       	ldi	r24, 0xE8	; 232
    4f32:	93 e0       	ldi	r25, 0x03	; 3
    4f34:	9a 83       	std	Y+2, r25	; 0x02
    4f36:	89 83       	std	Y+1, r24	; 0x01
	uint8 u8_send = 7;
    4f38:	87 e0       	ldi	r24, 0x07	; 7
    4f3a:	8b 83       	std	Y+3, r24	; 0x03
	for (;;)
	{
		/* Task code goes here. */
		DIO_Toggle(GPIOB, PIN5);
    4f3c:	81 e0       	ldi	r24, 0x01	; 1
    4f3e:	60 e2       	ldi	r22, 0x20	; 32
    4f40:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <DIO_Toggle>
		xMessageBufferSend(xMessageBuffer, &u8_send, 1, 0);
    4f44:	80 91 bb 06 	lds	r24, 0x06BB
    4f48:	90 91 bc 06 	lds	r25, 0x06BC
    4f4c:	9e 01       	movw	r18, r28
    4f4e:	2d 5f       	subi	r18, 0xFD	; 253
    4f50:	3f 4f       	sbci	r19, 0xFF	; 255
    4f52:	b9 01       	movw	r22, r18
    4f54:	41 e0       	ldi	r20, 0x01	; 1
    4f56:	50 e0       	ldi	r21, 0x00	; 0
    4f58:	20 e0       	ldi	r18, 0x00	; 0
    4f5a:	30 e0       	ldi	r19, 0x00	; 0
    4f5c:	0e 94 95 10 	call	0x212a	; 0x212a <xStreamBufferSend>

		vTaskDelay(u16_delVar);
    4f60:	89 81       	ldd	r24, Y+1	; 0x01
    4f62:	9a 81       	ldd	r25, Y+2	; 0x02
    4f64:	0e 94 f0 18 	call	0x31e0	; 0x31e0 <vTaskDelay>
    4f68:	e9 cf       	rjmp	.-46     	; 0x4f3c <vToggleLED1+0x1e>

00004f6a <vToggleLED2>:
	}
}

void vToggleLED2(void * pvParameters)
{
    4f6a:	df 93       	push	r29
    4f6c:	cf 93       	push	r28
    4f6e:	00 d0       	rcall	.+0      	; 0x4f70 <vToggleLED2+0x6>
    4f70:	00 d0       	rcall	.+0      	; 0x4f72 <vToggleLED2+0x8>
    4f72:	00 d0       	rcall	.+0      	; 0x4f74 <vToggleLED2+0xa>
    4f74:	cd b7       	in	r28, 0x3d	; 61
    4f76:	de b7       	in	r29, 0x3e	; 62
    4f78:	9e 83       	std	Y+6, r25	; 0x06
    4f7a:	8d 83       	std	Y+5, r24	; 0x05
	/* The parameter value is expected to be 1 as 1 is passed in the
	 pvParameters value in the call to xTaskCreate() below. */
	configASSERT( ( ( uint32_t ) pvParameters ) == 1 );

	uint16 u16_delVar = 500;
    4f7c:	84 ef       	ldi	r24, 0xF4	; 244
    4f7e:	91 e0       	ldi	r25, 0x01	; 1
    4f80:	9c 83       	std	Y+4, r25	; 0x04
    4f82:	8b 83       	std	Y+3, r24	; 0x03
	size_t xReceivedBytes;
	for (;;)
	{
		/* Task code goes here. */
		DIO_Toggle(GPIOB, PIN6);
    4f84:	81 e0       	ldi	r24, 0x01	; 1
    4f86:	60 e4       	ldi	r22, 0x40	; 64
    4f88:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <DIO_Toggle>
		xReceivedBytes = xMessageBufferReceive(xMessageBuffer, &gu8_buff, 1, 5);
    4f8c:	80 91 bb 06 	lds	r24, 0x06BB
    4f90:	90 91 bc 06 	lds	r25, 0x06BC
    4f94:	2e eb       	ldi	r18, 0xBE	; 190
    4f96:	36 e0       	ldi	r19, 0x06	; 6
    4f98:	b9 01       	movw	r22, r18
    4f9a:	41 e0       	ldi	r20, 0x01	; 1
    4f9c:	50 e0       	ldi	r21, 0x00	; 0
    4f9e:	25 e0       	ldi	r18, 0x05	; 5
    4fa0:	30 e0       	ldi	r19, 0x00	; 0
    4fa2:	0e 94 4c 12 	call	0x2498	; 0x2498 <xStreamBufferReceive>
    4fa6:	9a 83       	std	Y+2, r25	; 0x02
    4fa8:	89 83       	std	Y+1, r24	; 0x01
		if(xReceivedBytes > 0)
    4faa:	89 81       	ldd	r24, Y+1	; 0x01
    4fac:	9a 81       	ldd	r25, Y+2	; 0x02
    4fae:	00 97       	sbiw	r24, 0x00	; 0
    4fb0:	21 f0       	breq	.+8      	; 0x4fba <vToggleLED2+0x50>
		{
			/* xMessageBuffer contains data */
			//if(u16_delVar == 1000)
			//{
				DIO_Toggle(GPIOB, PIN4);
    4fb2:	81 e0       	ldi	r24, 0x01	; 1
    4fb4:	60 e1       	ldi	r22, 0x10	; 16
    4fb6:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <DIO_Toggle>
		}
		else
		{
			/* Do nothing */
		}
		vTaskDelay(u16_delVar);
    4fba:	8b 81       	ldd	r24, Y+3	; 0x03
    4fbc:	9c 81       	ldd	r25, Y+4	; 0x04
    4fbe:	0e 94 f0 18 	call	0x31e0	; 0x31e0 <vTaskDelay>
    4fc2:	e0 cf       	rjmp	.-64     	; 0x4f84 <vToggleLED2+0x1a>

00004fc4 <main>:
	}
}

int main(void)
{
    4fc4:	ef 92       	push	r14
    4fc6:	ff 92       	push	r15
    4fc8:	0f 93       	push	r16
    4fca:	df 93       	push	r29
    4fcc:	cf 93       	push	r28
    4fce:	00 d0       	rcall	.+0      	; 0x4fd0 <main+0xc>
    4fd0:	00 d0       	rcall	.+0      	; 0x4fd2 <main+0xe>
    4fd2:	00 d0       	rcall	.+0      	; 0x4fd4 <main+0x10>
    4fd4:	cd b7       	in	r28, 0x3d	; 61
    4fd6:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xToggleLED1_Handle = NULL;
    4fd8:	1a 82       	std	Y+2, r1	; 0x02
    4fda:	19 82       	std	Y+1, r1	; 0x01
	TaskHandle_t xToggleLED2_Handle = NULL;
    4fdc:	1c 82       	std	Y+4, r1	; 0x04
    4fde:	1b 82       	std	Y+3, r1	; 0x03
	TaskHandle_t xDio_Init_Handle = NULL;
    4fe0:	1e 82       	std	Y+6, r1	; 0x06
    4fe2:	1d 82       	std	Y+5, r1	; 0x05

	xMessageBuffer = xMessageBufferCreate(1);
    4fe4:	81 e0       	ldi	r24, 0x01	; 1
    4fe6:	90 e0       	ldi	r25, 0x00	; 0
    4fe8:	60 e0       	ldi	r22, 0x00	; 0
    4fea:	70 e0       	ldi	r23, 0x00	; 0
    4fec:	41 e0       	ldi	r20, 0x01	; 1
    4fee:	0e 94 43 0f 	call	0x1e86	; 0x1e86 <xStreamBufferGenericCreate>
    4ff2:	90 93 bc 06 	sts	0x06BC, r25
    4ff6:	80 93 bb 06 	sts	0x06BB, r24
	if( xMessageBuffer == NULL )
    4ffa:	80 91 bb 06 	lds	r24, 0x06BB
    4ffe:	90 91 bc 06 	lds	r25, 0x06BC
    5002:	00 97       	sbiw	r24, 0x00	; 0
    5004:	21 f4       	brne	.+8      	; 0x500e <main+0x4a>
	{
		/* There was not enough heap memory space available to create the
		message buffer. */
		gu8_Error_State = 0xFF;
    5006:	8f ef       	ldi	r24, 0xFF	; 255
    5008:	80 93 bd 06 	sts	0x06BD, r24
    500c:	02 c0       	rjmp	.+4      	; 0x5012 <main+0x4e>
	}
	else
	{
		/* The message buffer was created successfully and can now be used. */
		gu8_Error_State = 0;
    500e:	10 92 bd 06 	sts	0x06BD, r1
	}

	xTaskCreate(vDIO_Init, "DIO", 100, (void *) 1, 1, &xDio_Init_Handle);
    5012:	8a e5       	ldi	r24, 0x5A	; 90
    5014:	97 e2       	ldi	r25, 0x27	; 39
    5016:	25 e6       	ldi	r18, 0x65	; 101
    5018:	30 e0       	ldi	r19, 0x00	; 0
    501a:	fe 01       	movw	r30, r28
    501c:	35 96       	adiw	r30, 0x05	; 5
    501e:	b9 01       	movw	r22, r18
    5020:	44 e6       	ldi	r20, 0x64	; 100
    5022:	50 e0       	ldi	r21, 0x00	; 0
    5024:	21 e0       	ldi	r18, 0x01	; 1
    5026:	30 e0       	ldi	r19, 0x00	; 0
    5028:	01 e0       	ldi	r16, 0x01	; 1
    502a:	7f 01       	movw	r14, r30
    502c:	0e 94 d7 16 	call	0x2dae	; 0x2dae <xTaskCreate>
	xTaskCreate(vToggleLED1, "LED1", 100, (void *) 1, 1, &xToggleLED1_Handle);
    5030:	8f e8       	ldi	r24, 0x8F	; 143
    5032:	97 e2       	ldi	r25, 0x27	; 39
    5034:	29 e6       	ldi	r18, 0x69	; 105
    5036:	30 e0       	ldi	r19, 0x00	; 0
    5038:	b9 01       	movw	r22, r18
    503a:	44 e6       	ldi	r20, 0x64	; 100
    503c:	50 e0       	ldi	r21, 0x00	; 0
    503e:	21 e0       	ldi	r18, 0x01	; 1
    5040:	30 e0       	ldi	r19, 0x00	; 0
    5042:	01 e0       	ldi	r16, 0x01	; 1
    5044:	fe 01       	movw	r30, r28
    5046:	31 96       	adiw	r30, 0x01	; 1
    5048:	7f 01       	movw	r14, r30
    504a:	0e 94 d7 16 	call	0x2dae	; 0x2dae <xTaskCreate>
	xTaskCreate(vToggleLED2, "LED2", 100, (void *) 1, 1, &xToggleLED2_Handle);
    504e:	85 eb       	ldi	r24, 0xB5	; 181
    5050:	97 e2       	ldi	r25, 0x27	; 39
    5052:	2e e6       	ldi	r18, 0x6E	; 110
    5054:	30 e0       	ldi	r19, 0x00	; 0
    5056:	fe 01       	movw	r30, r28
    5058:	33 96       	adiw	r30, 0x03	; 3
    505a:	b9 01       	movw	r22, r18
    505c:	44 e6       	ldi	r20, 0x64	; 100
    505e:	50 e0       	ldi	r21, 0x00	; 0
    5060:	21 e0       	ldi	r18, 0x01	; 1
    5062:	30 e0       	ldi	r19, 0x00	; 0
    5064:	01 e0       	ldi	r16, 0x01	; 1
    5066:	7f 01       	movw	r14, r30
    5068:	0e 94 d7 16 	call	0x2dae	; 0x2dae <xTaskCreate>

	/* Start Scheduler */
	vTaskStartScheduler();
    506c:	0e 94 7a 1a 	call	0x34f4	; 0x34f4 <vTaskStartScheduler>
    5070:	ff cf       	rjmp	.-2      	; 0x5070 <main+0xac>

00005072 <memcpy>:
    5072:	fb 01       	movw	r30, r22
    5074:	dc 01       	movw	r26, r24
    5076:	02 c0       	rjmp	.+4      	; 0x507c <memcpy+0xa>
    5078:	01 90       	ld	r0, Z+
    507a:	0d 92       	st	X+, r0
    507c:	41 50       	subi	r20, 0x01	; 1
    507e:	50 40       	sbci	r21, 0x00	; 0
    5080:	d8 f7       	brcc	.-10     	; 0x5078 <memcpy+0x6>
    5082:	08 95       	ret

00005084 <memset>:
    5084:	dc 01       	movw	r26, r24
    5086:	01 c0       	rjmp	.+2      	; 0x508a <memset+0x6>
    5088:	6d 93       	st	X+, r22
    508a:	41 50       	subi	r20, 0x01	; 1
    508c:	50 40       	sbci	r21, 0x00	; 0
    508e:	e0 f7       	brcc	.-8      	; 0x5088 <memset+0x4>
    5090:	08 95       	ret

00005092 <_exit>:
    5092:	f8 94       	cli

00005094 <__stop_program>:
    5094:	ff cf       	rjmp	.-2      	; 0x5094 <__stop_program>
